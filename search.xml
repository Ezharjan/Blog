<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CG In Practice</title>
    <url>/Blog/2022/03/18/CG-In-Practice/</url>
    <content><![CDATA[<!-- <h1 align="center">Computer Graphics In Practice<h1>  -->
<h6 align="center">Alexander Ezharjan<h6>


<br>
<br>



<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This reference book is mainly to discuss the detailed knowledge of basic computer graphics based on the soft renderer project called <em>Render Engine</em>, which is a tiny graphical rendering engine developed via pure C++ without any third-party-libraries included.</p>
<br>

<p>The content of this book is separated into many parts so that we are able to to have a deeper view into each section.</p>
<p>The first section is this Introduction it self.</p>
<p>The second section is to discuss the mathematical basis for computer graphics. The advanced part as well as those part that have tight relation with the physics is not included, as we are just learning the basic knowledge of computer graphics, not the advanced ones.</p>
<p>The third section is to discuss the inside of render pipeline, which is a significant aspect in the study of computer graphics.</p>
<p>The forth section is to discuss the basic unit used in render engine — Vertex. A vertex stores lots of information including position, tex-coord, normal etc,.</p>
<br>

<br>


<p>In order to relate the CG knowledge into the application, we have to apply the theory into reality by programing, With this notes, however, the co-related project demands the basics for C++ programming. But if you take a look at the project code, you will notice that the application of the programming language is really in basic way, as too many properties of C++ is not utilized at all. Only some of the basic data structures and methods of the STL is used to make the code more accessible as well as to facilitate the project. Note that any other programing languages are OK to apply the theory I clarified in this book.</p>
<hr>
<br>
<br>
<br>
<br>
<br>



<h2 id="Math-Basis"><a href="#Math-Basis" class="headerlink" title="Math Basis"></a>Math Basis</h2><p>Math is needed as the basic tool for every field of science. As the base of the computer science, I myself also regard it as the base of computer graphics, for many algorithms can not escape from the use of math. I separated it as a single chapter so as to mention its importance as well as to show you the utility of math in computer graphics.</p>
<p>In math, we have vectors, matrices, coordinates and more. These are all used in computer graphics. If you have ever used OpenGL or any other libraries, you’ll notice that the math is actually provided as basic APIs and using them is quite simple. But if you are writing the CPU based renderer like I have done in this project, you ought to know the inner activities that these APIs are conducting. Here I am going to show you some of the APIs that I wrote:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="type">float</span> <span class="title">RadToDegree</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; rad)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (rad * <span class="number">180.f</span> / MATH_PI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">DegreeToRad</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; degree)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (degree * MATH_PI / <span class="number">180.f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">LinearInerpolate</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; x1, <span class="type">const</span> <span class="type">float</span>&amp; x2, <span class="type">const</span> <span class="type">float</span>&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x1 + (x2 - x1) * t; <span class="comment">// formula of linear interpolation</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Lerp</span><span class="params">(<span class="type">const</span> <span class="type">float</span> a, <span class="type">const</span> <span class="type">float</span> b, <span class="type">const</span> <span class="type">float</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t &lt;= <span class="number">0.f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (t &gt;= <span class="number">1.f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> b * t + (<span class="number">1.f</span> - t) * a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Vector4 <span class="title">Lerp</span><span class="params">(<span class="type">const</span> Vector4&amp; a, <span class="type">const</span> Vector4&amp; b, <span class="type">float</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Vector4 <span class="title">result</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		Lerp(a.getX(), b.getX(), t),</span></span></span><br><span class="line"><span class="params"><span class="function">		Lerp(a.getY(), b.getY(), t),</span></span></span><br><span class="line"><span class="params"><span class="function">		Lerp(a.getZ(), b.getZ(), t),</span></span></span><br><span class="line"><span class="params"><span class="function">		Lerp(a.getW(), b.getW(), t)</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Colour <span class="title">Lerp</span><span class="params">(<span class="type">const</span> Colour&amp; a, <span class="type">const</span> Colour&amp; b, <span class="type">float</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Colour result;</span><br><span class="line">	result.r = <span class="built_in">Lerp</span>(a.r, b.r, t);</span><br><span class="line">	result.g = <span class="built_in">Lerp</span>(a.g, b.g, t);</span><br><span class="line">	result.b = <span class="built_in">Lerp</span>(a.b, b.b, t);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Clamp</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; param, <span class="type">const</span> <span class="type">float</span>&amp; min, <span class="type">const</span> <span class="type">float</span>&amp; max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (param &lt;= min)</span><br><span class="line">		<span class="keyword">return</span> min;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (param &gt;= max)</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> param;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// optimized way below</span></span><br><span class="line">	<span class="comment">//return ((param &lt; min) ? min : ((param &gt; max) ? max : param));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CLAMP</span><span class="params">(<span class="type">float</span>&amp; param, <span class="type">const</span> <span class="type">float</span>&amp; min, <span class="type">const</span> <span class="type">float</span>&amp; max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (param &lt;= min)</span><br><span class="line">		param = min;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (param &gt;= max)</span><br><span class="line">		param = max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ColorInterpolation</span><span class="params">(Vertex &amp; s1, Vertex &amp; s3, Vertex &amp; s4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s4.color.r = (s4.pos.<span class="built_in">getY</span>() - s1.pos.<span class="built_in">getY</span>()) *(s3.color.r - s1.color.r) / (s3.pos.<span class="built_in">getY</span>() - s1.pos.<span class="built_in">getY</span>()) + s1.color.r;</span><br><span class="line">	s4.color.g = (s4.pos.<span class="built_in">getY</span>() - s1.pos.<span class="built_in">getY</span>()) *(s3.color.g - s1.color.g) / (s3.pos.<span class="built_in">getY</span>() - s1.pos.<span class="built_in">getY</span>()) + s1.color.g;</span><br><span class="line">	s4.color.b = (s4.pos.<span class="built_in">getY</span>() - s1.pos.<span class="built_in">getY</span>()) *(s3.color.b - s1.color.b) / (s3.pos.<span class="built_in">getY</span>() - s1.pos.<span class="built_in">getY</span>()) + s1.color.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrimeNumber</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">2</span>; i &lt; num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (num % i == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">StringToNum</span><span class="params">(<span class="type">const</span> std::string &amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::istringstream <span class="title">iss</span><span class="params">(str)</span></span>;</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	iss &gt;&gt; num;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">float</span>)num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CharToNum</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">atoi</span>(&amp;c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Sigmoid</span><span class="params">(<span class="type">const</span> <span class="type">float</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1</span> / <span class="number">1</span> + <span class="built_in">exp</span>(-x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">FloatToByte</span><span class="params">(<span class="type">const</span> <span class="type">float</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">unsigned</span> <span class="built_in">char</span>((<span class="type">int</span>)(x * <span class="number">255.f</span>) % <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">MapTo0_255f</span><span class="params">(<span class="type">const</span> <span class="type">float</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> result = <span class="built_in">Clamp</span>(x, <span class="number">0.f</span>, <span class="number">0.999999f</span>) * <span class="number">255.f</span>; <span class="comment">// never dropping value ranging 0~1</span></span><br><span class="line">	<span class="keyword">if</span> (result - EPSILON &gt;= <span class="number">1.f</span>)</span><br><span class="line">		result = <span class="built_in">floorf</span>(<span class="built_in">Clamp</span>(x, <span class="number">0.f</span>, <span class="number">0.999999f</span>) * <span class="number">256.f</span>);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GetGrayScaleViaGamaCorrection</span><span class="params">(<span class="type">const</span> Colour&amp; valueToBeCorrected)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> numerator = <span class="built_in">powf</span>(<span class="built_in">MapTo0_255f</span>(valueToBeCorrected.r), <span class="number">2.2f</span>) + <span class="built_in">powf</span>((<span class="number">1.5f</span>*<span class="built_in">MapTo0_255f</span>(valueToBeCorrected.g)), <span class="number">2.2f</span>) + <span class="built_in">powf</span>((<span class="number">0.6f</span>*<span class="built_in">MapTo0_255f</span>(valueToBeCorrected.b)), <span class="number">2.2f</span>);</span><br><span class="line">	<span class="type">float</span> denominator = <span class="number">1.f</span> + <span class="built_in">powf</span>(<span class="number">1.5f</span>, <span class="number">2.2f</span>) + <span class="built_in">powf</span>(<span class="number">0.6f</span>, <span class="number">2.2f</span>);</span><br><span class="line">	<span class="type">float</span> result = <span class="built_in">powf</span>((numerator / denominator), <span class="number">1.f</span> / <span class="number">2.2f</span>);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Colour <span class="title">GetGrayScaleViaGamaCorrection</span><span class="params">(<span class="type">const</span> <span class="type">float</span> sameRGBValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> numerator = <span class="built_in">powf</span>(<span class="built_in">MapTo0_255f</span>(sameRGBValue), <span class="number">2.2f</span>) + <span class="built_in">powf</span>((<span class="number">1.5f</span>*<span class="built_in">MapTo0_255f</span>(sameRGBValue)), <span class="number">2.2f</span>) + <span class="built_in">powf</span>((<span class="number">0.6f</span>*<span class="built_in">MapTo0_255f</span>(sameRGBValue)), <span class="number">2.2f</span>);</span><br><span class="line">	<span class="type">float</span> denominator = <span class="number">1.f</span> + <span class="built_in">powf</span>(<span class="number">1.5f</span>, <span class="number">2.2f</span>) + <span class="built_in">powf</span>(<span class="number">0.6f</span>, <span class="number">2.2f</span>);</span><br><span class="line">	<span class="type">float</span> result = <span class="built_in">powf</span>((numerator / denominator), <span class="number">1.f</span> / <span class="number">2.2f</span>);</span><br><span class="line">	<span class="keyword">return</span>  <span class="built_in">Colour</span>(result, result, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GetBrightnessViaGamaCorrection</span><span class="params">(<span class="type">const</span> Colour &amp; valueToBeCorrected)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> numerator = <span class="built_in">powf</span>(valueToBeCorrected.r, <span class="number">2.2f</span>) + <span class="built_in">powf</span>((<span class="number">1.5f</span>*valueToBeCorrected.g), <span class="number">2.2f</span>) + <span class="built_in">powf</span>((<span class="number">0.6f</span>*valueToBeCorrected.b), <span class="number">2.2f</span>);</span><br><span class="line">	<span class="type">float</span> denominator = <span class="number">1.f</span> + <span class="built_in">powf</span>(<span class="number">1.5f</span>, <span class="number">2.2f</span>) + <span class="built_in">powf</span>(<span class="number">0.6f</span>, <span class="number">2.2f</span>);</span><br><span class="line">	<span class="type">float</span> result = <span class="built_in">powf</span>((numerator / denominator), <span class="number">1.f</span> / <span class="number">2.2f</span>);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Colour <span class="title">GetBrightnessViaGamaCorrection</span><span class="params">(<span class="type">const</span> <span class="type">float</span> sameRGBValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> numerator = <span class="built_in">powf</span>(sameRGBValue, <span class="number">2.2f</span>) + <span class="built_in">powf</span>((<span class="number">1.5f</span>*sameRGBValue), <span class="number">2.2f</span>) + <span class="built_in">powf</span>((<span class="number">0.6f</span>*sameRGBValue), <span class="number">2.2f</span>);</span><br><span class="line">	<span class="type">float</span> denominator = <span class="number">1.f</span> + <span class="built_in">powf</span>(<span class="number">1.5f</span>, <span class="number">2.2f</span>) + <span class="built_in">powf</span>(<span class="number">0.6f</span>, <span class="number">2.2f</span>);</span><br><span class="line">	<span class="type">float</span> result = <span class="built_in">powf</span>((numerator / denominator), <span class="number">1.f</span> / <span class="number">2.2f</span>);</span><br><span class="line">	<span class="keyword">return</span>  <span class="built_in">Colour</span>(result, result, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Vector4 <span class="title">Vector4DotMatrix4f</span><span class="params">(<span class="type">const</span> Vector4 &amp; vec4, <span class="type">const</span> Matrix4f &amp; m4f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Vector4 result;</span><br><span class="line">	result.<span class="built_in">setX</span>(vec4.<span class="built_in">getX</span>() * m4f.matrix[<span class="number">0</span>][<span class="number">0</span>] + vec4.<span class="built_in">getY</span>() * m4f.matrix[<span class="number">1</span>][<span class="number">0</span>] + vec4.<span class="built_in">getZ</span>() * m4f.matrix[<span class="number">2</span>][<span class="number">0</span>] + vec4.<span class="built_in">getW</span>() * m4f.matrix[<span class="number">3</span>][<span class="number">0</span>]);</span><br><span class="line">	result.<span class="built_in">setY</span>(vec4.<span class="built_in">getX</span>() * m4f.matrix[<span class="number">0</span>][<span class="number">1</span>] + vec4.<span class="built_in">getY</span>() * m4f.matrix[<span class="number">1</span>][<span class="number">1</span>] + vec4.<span class="built_in">getZ</span>() * m4f.matrix[<span class="number">2</span>][<span class="number">1</span>] + vec4.<span class="built_in">getW</span>() * m4f.matrix[<span class="number">3</span>][<span class="number">1</span>]);</span><br><span class="line">	result.<span class="built_in">setZ</span>(vec4.<span class="built_in">getX</span>() * m4f.matrix[<span class="number">0</span>][<span class="number">2</span>] + vec4.<span class="built_in">getY</span>() * m4f.matrix[<span class="number">1</span>][<span class="number">2</span>] + vec4.<span class="built_in">getZ</span>() * m4f.matrix[<span class="number">2</span>][<span class="number">2</span>] + vec4.<span class="built_in">getW</span>() * m4f.matrix[<span class="number">3</span>][<span class="number">2</span>]);</span><br><span class="line">	result.<span class="built_in">setW</span>(vec4.<span class="built_in">getX</span>() * m4f.matrix[<span class="number">0</span>][<span class="number">3</span>] + vec4.<span class="built_in">getY</span>() * m4f.matrix[<span class="number">1</span>][<span class="number">3</span>] + vec4.<span class="built_in">getZ</span>() * m4f.matrix[<span class="number">2</span>][<span class="number">3</span>] + vec4.<span class="built_in">getW</span>() * m4f.matrix[<span class="number">3</span>][<span class="number">3</span>]);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<br>

<p>Actually, some of the APIs can be directly gain from STL or ‘math.h’ while you’re using C++, such as the function ‘RadToDegree’ above can also be found in Lua’s inner math library, but writing them done is a way to apply what you have learnt into practice. Hope you can directly use the ones that the inner libraries provide rather than writing them by yourself so as to avoid mistakes and prevent the performance of your application from being lowered.</p>
<p>Here are some of the APIs when defining <code>Vectors</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/* Vector2                                                              */</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="type">void</span> Vector2::<span class="keyword">operator</span>=(<span class="type">const</span> Vector2 &amp; right)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">setX</span>(right.<span class="built_in">getX</span>());</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">setY</span>(right.<span class="built_in">getY</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector2 Vector2::<span class="keyword">operator</span>+(<span class="type">const</span> Vector2&amp; right) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Vector2 <span class="title">result</span><span class="params">(<span class="keyword">this</span>-&gt;getX() + right.getX(), <span class="keyword">this</span>-&gt;getY() + right.getY())</span></span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector2 Vector2::<span class="keyword">operator</span>-(<span class="type">const</span> Vector2&amp; right) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Vector2 <span class="title">result</span><span class="params">(<span class="keyword">this</span>-&gt;getX() - right.getX(), <span class="keyword">this</span>-&gt;getY() - right.getY())</span></span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Vector2 Vector2::<span class="keyword">operator</span>*(<span class="type">const</span> T&amp; k) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Vector2 <span class="title">result</span><span class="params">(<span class="keyword">this</span>-&gt;getX() * k, <span class="keyword">this</span>-&gt;getY() * k)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector2 Vector2::<span class="keyword">operator</span> /(<span class="type">const</span> <span class="type">float</span>&amp; k) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0.f</span> || <span class="built_in">abs</span>(k - <span class="number">0.f</span>) &lt; EPSILON) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Vector2</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">float</span> reciprocalK = <span class="number">1</span> / k;</span><br><span class="line">	<span class="function">Vector2 <span class="title">result</span><span class="params">(<span class="keyword">this</span>-&gt;getX()*reciprocalK, <span class="keyword">this</span>-&gt;getY()*reciprocalK)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Vector2::<span class="keyword">operator</span>*(<span class="type">const</span> Vector2&amp; right) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span>-&gt;<span class="built_in">getX</span>() * right.<span class="built_in">getX</span>() + <span class="keyword">this</span>-&gt;<span class="built_in">getY</span>() * right.<span class="built_in">getY</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Vector2::swap</span><span class="params">(Vector2 &amp; vecA, Vector2 &amp; vecB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vecA == vecB)<span class="keyword">return</span>;</span><br><span class="line">	<span class="function">Vector2 <span class="title">tmp</span><span class="params">(vecA.getX(), vecA.getY())</span></span>;</span><br><span class="line">	vecA = vecB;</span><br><span class="line">	vecB = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Vector2::getLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrtf</span>(<span class="built_in">powf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getX</span>(), <span class="number">2</span>) + <span class="built_in">powf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getY</span>(), <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/* Vector3                                                              */</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="type">bool</span> Vector3::<span class="keyword">operator</span>==(<span class="type">const</span> <span class="type">float</span> right) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> xIsEqual = <span class="built_in">fabsf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getX</span>() - right) &lt;= EPSILON;</span><br><span class="line">	<span class="type">bool</span> yIsEqual = <span class="built_in">fabsf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getY</span>() - right) &lt;= EPSILON;</span><br><span class="line">	<span class="type">bool</span> zIsEqual = <span class="built_in">fabsf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getZ</span>() - right) &lt;= EPSILON;</span><br><span class="line">	<span class="keyword">return</span> (xIsEqual &amp;&amp; yIsEqual &amp;&amp; zIsEqual);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Vector3::<span class="keyword">operator</span>==(<span class="type">const</span> Vector3 &amp; right) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> xIsEqual = <span class="built_in">fabsf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getX</span>() - right.<span class="built_in">getX</span>()) &lt;= EPSILON;</span><br><span class="line">	<span class="type">bool</span> yIsEqual = <span class="built_in">fabsf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getY</span>() - right.<span class="built_in">getY</span>()) &lt;= EPSILON;</span><br><span class="line">	<span class="type">bool</span> zIsEqual = <span class="built_in">fabsf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getZ</span>() - right.<span class="built_in">getZ</span>()) &lt;= EPSILON;</span><br><span class="line">	<span class="keyword">return</span> (xIsEqual &amp;&amp; yIsEqual &amp;&amp; zIsEqual);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector3 Vector3::<span class="keyword">operator</span>+(<span class="type">const</span> Vector3 &amp; right) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Vector3 <span class="title">result</span><span class="params">(<span class="keyword">this</span>-&gt;getX() + right.getX(), <span class="keyword">this</span>-&gt;getY() + right.getY(), <span class="keyword">this</span>-&gt;getZ() + right.getZ())</span></span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector3 Vector3::<span class="keyword">operator</span>-(<span class="type">const</span> Vector3 &amp; right) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Vector3 <span class="title">result</span><span class="params">(<span class="keyword">this</span>-&gt;getX() - right.getX(), <span class="keyword">this</span>-&gt;getY() - right.getY(), <span class="keyword">this</span>-&gt;getZ() - right.getZ())</span></span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector3 Vector3::<span class="keyword">operator</span>*(<span class="type">const</span> <span class="type">float</span> k) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Vector3 <span class="title">result</span><span class="params">(<span class="keyword">this</span>-&gt;getX() * k, <span class="keyword">this</span>-&gt;getY() * k, <span class="keyword">this</span>-&gt;getZ() * k)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Vector3::<span class="keyword">operator</span>*(<span class="type">const</span> Vector3 &amp; right) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span>-&gt;<span class="built_in">getX</span>()*right.<span class="built_in">getX</span>() + <span class="keyword">this</span>-&gt;<span class="built_in">getY</span>()*right.<span class="built_in">getY</span>() + <span class="keyword">this</span>-&gt;<span class="built_in">getZ</span>()*right.<span class="built_in">getZ</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Vector3 Vector3::<span class="keyword">operator</span>*(<span class="type">const</span> T&amp; right) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Vector3 <span class="title">result</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">this</span>-&gt;getX()*right.matrix[<span class="number">0</span>][<span class="number">0</span>] + <span class="keyword">this</span>-&gt;getY()*right.matrix[<span class="number">0</span>][<span class="number">1</span>] + <span class="keyword">this</span>-&gt;getZ() * right.matrix[<span class="number">0</span>][<span class="number">2</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">this</span>-&gt;getY()*right.matrix[<span class="number">1</span>][<span class="number">0</span>] + <span class="keyword">this</span>-&gt;getY()*right.matrix[<span class="number">1</span>][<span class="number">1</span>] + <span class="keyword">this</span>-&gt;getZ() * right.matrix[<span class="number">1</span>][<span class="number">2</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">this</span>-&gt;getZ()*right.matrix[<span class="number">2</span>][<span class="number">0</span>] + <span class="keyword">this</span>-&gt;getY()*right.matrix[<span class="number">2</span>][<span class="number">1</span>] + <span class="keyword">this</span>-&gt;getZ() * right.matrix[<span class="number">2</span>][<span class="number">2</span>])</span></span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector3 Vector3::<span class="keyword">operator</span>^(<span class="type">const</span> Vector3 &amp; right) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	Vector3 result;</span><br><span class="line">	result.<span class="built_in">setX</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getY</span>() * right.<span class="built_in">getZ</span>() - <span class="keyword">this</span>-&gt;<span class="built_in">getZ</span>() * right.<span class="built_in">getY</span>());</span><br><span class="line">	result.<span class="built_in">setY</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getZ</span>() * right.<span class="built_in">getX</span>() - <span class="keyword">this</span>-&gt;<span class="built_in">getX</span>() * right.<span class="built_in">getZ</span>());</span><br><span class="line">	result.<span class="built_in">setZ</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getX</span>() * right.<span class="built_in">getY</span>() - <span class="keyword">this</span>-&gt;<span class="built_in">getY</span>() * right.<span class="built_in">getX</span>());</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Vector3::Normalize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> length = <span class="built_in">sqrtf</span>(<span class="built_in">powf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getX</span>(), <span class="number">2</span>) + <span class="built_in">powf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getY</span>(), <span class="number">2</span>) + <span class="built_in">powf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getZ</span>(), <span class="number">2</span>));</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">setX</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getX</span>() / length);</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">setY</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getY</span>() / length);</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">setZ</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getZ</span>() / length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Vector3 <span class="title">Vector3::Normalize</span><span class="params">(<span class="type">const</span> Vector3&amp; vecToBeNormalized)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Vector3 result;</span><br><span class="line">	<span class="type">float</span> length = <span class="built_in">sqrtf</span>(<span class="built_in">powf</span>(vecToBeNormalized.<span class="built_in">getX</span>(), <span class="number">2</span>) + <span class="built_in">powf</span>(vecToBeNormalized.<span class="built_in">getY</span>(), <span class="number">2</span>) + <span class="built_in">powf</span>(vecToBeNormalized.<span class="built_in">getZ</span>(), <span class="number">2</span>));</span><br><span class="line">	result.<span class="built_in">setX</span>(vecToBeNormalized.<span class="built_in">getX</span>() / length);</span><br><span class="line">	result.<span class="built_in">setY</span>(vecToBeNormalized.<span class="built_in">getY</span>() / length);</span><br><span class="line">	result.<span class="built_in">setZ</span>(vecToBeNormalized.<span class="built_in">getZ</span>() / length);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Vector3::getLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrtf</span>(<span class="built_in">powf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getX</span>(), <span class="number">2</span>) + <span class="built_in">powf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getY</span>(), <span class="number">2</span>) + <span class="built_in">powf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getZ</span>(), <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/* Vector4                                                              */</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="type">bool</span> Vector4::<span class="keyword">operator</span>==(<span class="type">float</span> right) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> xIsEqual = <span class="built_in">fabsf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getX</span>() - right) &lt;= EPSILON;</span><br><span class="line">	<span class="type">bool</span> yIsEqual = <span class="built_in">fabsf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getY</span>() - right) &lt;= EPSILON;</span><br><span class="line">	<span class="type">bool</span> zIsEqual = <span class="built_in">fabsf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getZ</span>() - right) &lt;= EPSILON;</span><br><span class="line">	<span class="type">bool</span> wIsEqual = <span class="built_in">fabsf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getW</span>() - right) &lt;= EPSILON;</span><br><span class="line">	<span class="keyword">return</span> (xIsEqual &amp;&amp; yIsEqual &amp;&amp; zIsEqual &amp;&amp; wIsEqual);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Vector4::<span class="keyword">operator</span>==(<span class="type">const</span> Vector4 &amp; right) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> xIsEqual = <span class="built_in">fabsf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getX</span>() - right.<span class="built_in">getX</span>()) &lt;= EPSILON;</span><br><span class="line">	<span class="type">bool</span> yIsEqual = <span class="built_in">fabsf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getY</span>() - right.<span class="built_in">getY</span>()) &lt;= EPSILON;</span><br><span class="line">	<span class="type">bool</span> zIsEqual = <span class="built_in">fabsf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getZ</span>() - right.<span class="built_in">getZ</span>()) &lt;= EPSILON;</span><br><span class="line">	<span class="type">bool</span> wIsEqual = <span class="built_in">fabsf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getW</span>() - right.<span class="built_in">getW</span>()) &lt;= EPSILON;</span><br><span class="line">	<span class="keyword">return</span> (xIsEqual &amp;&amp; yIsEqual &amp;&amp; zIsEqual &amp;&amp; wIsEqual);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Vector4::<span class="keyword">operator</span>!=(<span class="type">const</span> Vector4 &amp; right) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> xIsInequal = <span class="built_in">fabsf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getX</span>() - right.<span class="built_in">getX</span>()) &gt; EPSILON;</span><br><span class="line">	<span class="type">bool</span> yIsInequal = <span class="built_in">fabsf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getY</span>() - right.<span class="built_in">getY</span>()) &gt; EPSILON;</span><br><span class="line">	<span class="type">bool</span> zIsInequal = <span class="built_in">fabsf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getZ</span>() - right.<span class="built_in">getZ</span>()) &gt; EPSILON;</span><br><span class="line">	<span class="type">bool</span> wIsInequal = <span class="built_in">fabsf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getW</span>() - right.<span class="built_in">getW</span>()) &gt; EPSILON;</span><br><span class="line">	<span class="keyword">return</span> (xIsInequal || yIsInequal || zIsInequal || wIsInequal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector4 Vector4::<span class="keyword">operator</span> +(<span class="type">const</span> Vector4 &amp; right) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Vector4 <span class="title">result</span><span class="params">(<span class="keyword">this</span>-&gt;getX() + right.getX(), <span class="keyword">this</span>-&gt;getY() + right.getY(), <span class="keyword">this</span>-&gt;getZ() + right.getZ(), <span class="keyword">this</span>-&gt;getW() + right.getW())</span></span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector4 Vector4::<span class="keyword">operator</span>-(<span class="type">const</span> Vector4 &amp; right) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Vector4 <span class="title">result</span><span class="params">(<span class="keyword">this</span>-&gt;getX() - right.getX(), <span class="keyword">this</span>-&gt;getY() - right.getY(), <span class="keyword">this</span>-&gt;getZ() - right.getZ(), <span class="keyword">this</span>-&gt;getW() - right.getW())</span></span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector4 Vector4::<span class="keyword">operator</span>*(<span class="type">const</span> <span class="type">float</span> k) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Vector4 <span class="title">result</span><span class="params">(<span class="keyword">this</span>-&gt;getX()*k, <span class="keyword">this</span>-&gt;getY()*k, <span class="keyword">this</span>-&gt;getZ() *k, <span class="keyword">this</span>-&gt;getW() *k)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector4 Vector4::<span class="keyword">operator</span>/(<span class="type">const</span> <span class="type">float</span> k) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> reciprocalK = <span class="number">1</span> / k;</span><br><span class="line">	<span class="function">Vector4 <span class="title">result</span><span class="params">(<span class="keyword">this</span>-&gt;getX()*reciprocalK, <span class="keyword">this</span>-&gt;getY()*reciprocalK, <span class="keyword">this</span>-&gt;getZ() *reciprocalK, <span class="keyword">this</span>-&gt;getW() *reciprocalK)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Vector4::<span class="keyword">operator</span> *(<span class="type">const</span> Vector4 &amp; right) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">getX</span>()*right.<span class="built_in">getX</span>() + <span class="keyword">this</span>-&gt;<span class="built_in">getY</span>()*right.<span class="built_in">getY</span>() + <span class="keyword">this</span>-&gt;<span class="built_in">getZ</span>()*right.<span class="built_in">getZ</span>() + <span class="keyword">this</span>-&gt;<span class="built_in">getW</span>()*right.<span class="built_in">getW</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector4 Vector4::<span class="keyword">operator</span> ^(<span class="type">const</span> Vector4&amp; right) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Vector4 <span class="title">result</span><span class="params">(<span class="keyword">this</span>-&gt;getY()*right.getZ() - <span class="keyword">this</span>-&gt;getZ()*right.getY(),</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">this</span>-&gt;getZ()*right.getX() - <span class="keyword">this</span>-&gt;getX()*right.getZ(),</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">this</span>-&gt;getX()* right.getY() - <span class="keyword">this</span>-&gt;getY()*right.getX())</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Vector4 <span class="title">Vector4::getInterpolateVector</span><span class="params">(<span class="type">const</span> Vector4 &amp; vecA, <span class="type">const</span> Vector4 &amp; vecB, <span class="type">float</span> factor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Vector4 <span class="title">result</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		LinearInerpolate(vecA.getX(), vecB.getX(), factor),</span></span></span><br><span class="line"><span class="params"><span class="function">		LinearInerpolate(vecA.getY(), vecB.getY(), factor),</span></span></span><br><span class="line"><span class="params"><span class="function">		LinearInerpolate(vecA.getZ(), vecB.getZ(), factor),</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="number">1.f</span></span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Vector4 <span class="title">Vector4::getQuaternion</span><span class="params">(<span class="type">const</span> Vector3 &amp; lastPoint, <span class="type">const</span> Vector3 &amp; currentPoint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Vector4 result;</span><br><span class="line"></span><br><span class="line">	Vector3 perp = lastPoint ^ currentPoint;</span><br><span class="line">	<span class="keyword">if</span> (perp.<span class="built_in">getLength</span>() &gt; EPSILON)</span><br><span class="line">	&#123;</span><br><span class="line">		result.<span class="built_in">setX</span>(perp.<span class="built_in">getX</span>());</span><br><span class="line">		result.<span class="built_in">setY</span>(perp.<span class="built_in">getY</span>());</span><br><span class="line">		result.<span class="built_in">setZ</span>(perp.<span class="built_in">getZ</span>());</span><br><span class="line">		<span class="comment">// w=cos(rotationAngle/2) ---&gt; formula</span></span><br><span class="line">		result.<span class="built_in">setW</span>(lastPoint * currentPoint);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		result.<span class="built_in">setX</span>(<span class="number">.0</span>f);</span><br><span class="line">		result.<span class="built_in">setY</span>(<span class="number">.0</span>f);</span><br><span class="line">		result.<span class="built_in">setZ</span>(<span class="number">.0</span>f);</span><br><span class="line">		result.<span class="built_in">setW</span>(<span class="number">.0</span>f);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Vector4::Normalize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> length = <span class="built_in">sqrtf</span>(<span class="built_in">powf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getX</span>(), <span class="number">2</span>) + <span class="built_in">powf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getY</span>(), <span class="number">2</span>) + <span class="built_in">powf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getZ</span>(), <span class="number">2</span>));</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">setX</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getX</span>() / length);</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">setY</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getY</span>() / length);</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">setZ</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getZ</span>() / length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Vector4 <span class="title">Vector4::GetNormalizedVector</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Vector4 result;</span><br><span class="line">	<span class="type">float</span> length = <span class="built_in">sqrtf</span>(<span class="built_in">powf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getX</span>(), <span class="number">2</span>) + <span class="built_in">powf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getY</span>(), <span class="number">2</span>) + <span class="built_in">powf</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getZ</span>(), <span class="number">2</span>));</span><br><span class="line">	result.<span class="built_in">setX</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getX</span>() / length);</span><br><span class="line">	result.<span class="built_in">setY</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getY</span>() / length);</span><br><span class="line">	result.<span class="built_in">setZ</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getZ</span>() / length);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Vector4::swap</span><span class="params">(Vector4 &amp; v1, Vector4 &amp; v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v1 != v2)</span><br><span class="line">	&#123;</span><br><span class="line">		std::<span class="built_in">swap</span>(v1.m_x, v2.m_x);</span><br><span class="line">		std::<span class="built_in">swap</span>(v1.m_y, v2.m_y);</span><br><span class="line">		std::<span class="built_in">swap</span>(v1.m_z, v2.m_z);</span><br><span class="line">		std::<span class="built_in">swap</span>(v1.m_w, v2.m_w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<br>
<br>
<br>
<br>
<br>



<h2 id="Rendering-pipeline"><a href="#Rendering-pipeline" class="headerlink" title="Rendering pipeline"></a>Rendering pipeline</h2><p>Learning the rendering pipeline is crucial for the study of computer graphics.</p>
<br>

<p>Here are three major stages in the rendering pipeline:</p>
<ol>
<li><code>Application Stage</code></li>
<li><code>Geometry Conduction Stage</code></li>
<li><code>Rasterization Stage</code></li>
</ol>
<br>
<br>

<h3 id="1-Application-Stage"><a href="#1-Application-Stage" class="headerlink" title="1. Application Stage"></a>1. Application Stage</h3><p>In this stage, all of the elements you got is in its original state. For example, if you’re going to read the positions of an OBJ formatted model in to the computer buffer so as to construct each of the position into a vertex and then calculate them later, you should have a formatted OBJ model first and then read those positions into a vector orderly. Whatever your model’s format is, FBX, MTL or any other formats, reading into the position information to a vector is the first step. </p>
<p>Besides the positions information, there are still lots of information such as the <strong>texture coordinates</strong>, the <strong>normal vector</strong>, the <strong>blend weights</strong> and <strong>blend shapes</strong>, the <strong>bone weights</strong> to read from a file(OBJ, FBX, MTL, etc,.) that holds the models information. These information builds up the attributes of a vertex. Just take the texture coordinate (in the project it is name “Texcoord”) for example. The texture coordinate, as a basic attribute of a vertex, it includes the information about a vertex’s U axis and V axis, which informs us the way to put texture on the model. </p>
<p>Finally, as these information(the <strong>texture coordinates</strong>, the <strong>normal vector</strong>, the <strong>blend weights</strong> and <strong>blend shapes</strong>, the <strong>bone weights</strong>) are stored in a vertex orderly and correctly, a simple but formal vertex is born. Its structure should be like the structure shown below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SimpleVertex</span></span><br><span class="line">&#123;</span><br><span class="line">	Vector4 pos;</span><br><span class="line">	Colour color;</span><br><span class="line">	Texcoord tex;</span><br><span class="line">	Vector4 normal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>You might see that the Vertex struct is simple compared with the ones you might ever seen in other materials, as I have excluded many of the attributes for this vertex struct like the blend weight, the blend shapes and the bone weights that I have described in the paragraph above. Also, the attributes like “rhw”, which represents the reciprocal of homogenous W, is not shown directly in this chapter just for the convenience of clarifying the process of the Application Stage, but they will later be added in.</p>
<br>

<p>Let’s take a closer look at the inside of this simple vertex.</p>
<p>You may realize that the position attribute in our vertex is a four-dimensional vector rather than a 3D one. So what does the fourth dimension represents for? Why we use a four-dimensional vector to store a position in a three-dimensional scene? Actually the W, which is the forth dimension, represents for the homogeneous coordinate. Now tha question lingers that why we use homogeneous coordinate while 3D coordinate is enough?<br>The answer of the questions above lays on the three factors below:</p>
<p>(1) It plays an important role when conducting homogeneous transformation. The Homogeneous Transformation Matrix For 3D Bodies is shown below. You will notice that it will be easier for multiple matrices’ multiplication if you use have N+1 dimensions than directly calculating N dimensional matrices. Especially the rotation will be more convenient for the quaternion itself demands 4 dimensional vector.</p>
<p><img src="https://ezharjan.github.io/Blog/2022/03/18/CG-In-Practice/Homogeneous%20Transformation%20Matrix%20For%203D%20Bodies.png" alt="CG"></p>
<!-- <p align='center'>
<img src="./Homogeneous%20Transformation%20Matrix%20For%203D%20Bodies.png">
</p> -->


<p>(2) In real world, two parallel lines will never meet with one another mathematically, but in perspective(human-eye) projection it will. In Euclidean space(geometry), two parallel line on the same plane cannot interest, or cannot cannot meet each other forever. Euclidean space describe our 2D or 3D space so well, but they are not sufficient to handle the projective space. What if this point goes far away to infinity? The point at infinity would be (∞, ∞) and it becomes meaningless in Euclidean space. The parallel lines should meet at infinity in projective space, but cannot do in Euclidean space. Mathematicians have discovered a way to solve this issue: Homogeneous Coordinate. Adding the W as the forth dimension can transform a vertex from Euclidean space to projective space while dividing to W can transform it back.<br>For example:</p>
<ul>
<li>A &#x3D; (x1, y1, z1)</li>
<li>B &#x3D; (x2, y2, z2)</li>
<li>A &#x2F;&#x2F; B</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">αx1 + βy1 + θz1 + d = 0</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">αx2 + βy2 + θz2 + d = 0</span><br></pre></td></tr></table></figure>

<p>In perspective projection, even though these two lines are parallel, they still intersect in some point. But how to get that intersected point? Just add the homogeneous coordinate like I did below:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(αx1/w)*w + (βy1/w)*w + (θz1/w)*w + dw = 0</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(αx2/w)*w + (βy2/w)*w + (θz2/w)*w + dw = 0</span><br></pre></td></tr></table></figure>

<p>Then we will find out a point that intersects the two parallel lines in projective space.</p>
<p>(3) It’s easy to find out a vector from a point. The point, or the position is described as (x, y, z, 1) while a vector is described as (x, y, z, 0).</p>
<p>(4) It will be easier to describe the intersection points of lines with lines and planes with planes.</p>
<br>

<p>Here is the structure of a four-dimensional vector. You’ll notice that the struct Vector4 actually has 4 dimensions: X, Y, Z and W, and all of them are defined in ‘float’ type rather than double or integer. Because either using an ‘integer’ type or a ‘double’ type is inappropriate in this circumstance. Using an ‘integer’ may lose the detail of a position while using a ‘double’ type may be space-consuming.  </p>
<p>Now here is a significant question that why we choose to use 4 dimensional vector to describe a position in 3 dimensional space while the 3 dimensional vector is enough? What is the forth dimension ‘w’ actually? Answer to these questions have actually been answered above.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector4</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> X;</span><br><span class="line">	<span class="type">float</span> Y;</span><br><span class="line">	<span class="type">float</span> Z;</span><br><span class="line">	<span class="type">float</span> W;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>In order to make the four-dimensional vector available and convenient to use in a real project, we have to make some APIs for it. The class below shows a more mature structure of a four-dimensional vector, including <code>initialization constructor</code>, <code>copy constructor</code>, <code>overridden operators</code>,  and ‘get()s’ and ‘set()s’ for needed private members.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector4</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Vector4</span>() :</span><br><span class="line">			<span class="built_in">m_x</span>(<span class="number">0</span>), <span class="built_in">m_y</span>(<span class="number">0</span>), <span class="built_in">m_z</span>(<span class="number">0</span>), <span class="built_in">m_w</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">		<span class="built_in">Vector4</span>(<span class="type">const</span> Vector4&amp; vecToBeCopied) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">setX</span>(vecToBeCopied.<span class="built_in">getX</span>());</span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">setY</span>(vecToBeCopied.<span class="built_in">getY</span>());</span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">setZ</span>(vecToBeCopied.<span class="built_in">getZ</span>());</span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">setW</span>(vecToBeCopied.<span class="built_in">getW</span>());</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="built_in">Vector4</span>(<span class="type">const</span> Vector3&amp; vecToBeCopied, <span class="type">bool</span> isPoint = <span class="literal">false</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">setX</span>(vecToBeCopied.<span class="built_in">getX</span>());</span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">setY</span>(vecToBeCopied.<span class="built_in">getY</span>());</span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">setZ</span>(vecToBeCopied.<span class="built_in">getZ</span>());</span><br><span class="line">			<span class="keyword">if</span> (isPoint)<span class="keyword">this</span>-&gt;<span class="built_in">setW</span>(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">this</span>-&gt;<span class="built_in">setW</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="built_in">Vector4</span>(<span class="type">const</span> <span class="type">float</span>&amp; a0, <span class="type">const</span> <span class="type">float</span>&amp; a1, <span class="type">const</span> <span class="type">float</span>&amp; a2, <span class="type">const</span> <span class="type">float</span>&amp; a3 = <span class="number">0</span>) :</span><br><span class="line">			<span class="built_in">m_x</span>(a0), <span class="built_in">m_y</span>(a1), <span class="built_in">m_z</span>(a2), <span class="built_in">m_w</span>(a3) &#123;&#125;;</span><br><span class="line">		~<span class="built_in">Vector4</span>() &#123;&#125;;</span><br><span class="line">		<span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">float</span> right)<span class="type">const</span>;</span><br><span class="line">		<span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> Vector4&amp; right)<span class="type">const</span>;</span><br><span class="line">		<span class="type">bool</span> <span class="keyword">operator</span> !=(<span class="type">const</span> Vector4&amp; right)<span class="type">const</span>;</span><br><span class="line">		Vector4 <span class="keyword">operator</span> +(<span class="type">const</span> Vector4&amp; right)<span class="type">const</span>;</span><br><span class="line">		Vector4 <span class="keyword">operator</span> -(<span class="type">const</span> Vector4&amp; right)<span class="type">const</span>;</span><br><span class="line">		Vector4 <span class="keyword">operator</span> *(<span class="type">const</span> <span class="type">float</span> k)<span class="type">const</span>;</span><br><span class="line">		Vector4 <span class="keyword">operator</span> /(<span class="type">const</span> <span class="type">float</span> k)<span class="type">const</span>;</span><br><span class="line">        <span class="type">float</span> <span class="keyword">operator</span> *(<span class="type">const</span> Vector4&amp; right)<span class="type">const</span>;</span><br><span class="line">		Vector4 <span class="keyword">operator</span> ^(<span class="type">const</span> Vector4&amp; right)<span class="type">const</span>; <span class="comment">// vector cross product</span></span><br><span class="line">		<span class="function">Vector4 <span class="title">getInterpolateVector</span><span class="params">(<span class="type">const</span> Vector4&amp; vecA, <span class="type">const</span> Vector4&amp; vecB, <span class="type">float</span> factor)</span></span>;</span><br><span class="line">		<span class="function">Vector4 <span class="title">getQuaternion</span><span class="params">(<span class="type">const</span> Vector3 &amp; lastPoint, <span class="type">const</span> Vector3 &amp; currentPoint)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">Normalize</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function">Vector4 <span class="title">GetNormalizedVector</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">swap</span><span class="params">(Vector4&amp; v1, Vector4&amp; v2)</span></span>;</span><br><span class="line">        </span><br><span class="line">		<span class="function"><span class="type">float</span> <span class="title">getX</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_x; &#125;</span><br><span class="line">		<span class="function"><span class="type">float</span> <span class="title">getY</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_y; &#125;</span><br><span class="line">		<span class="function"><span class="type">float</span> <span class="title">getZ</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_z; &#125;</span><br><span class="line">		<span class="function"><span class="type">float</span> <span class="title">getW</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_w; &#125;</span><br><span class="line">		<span class="function"><span class="type">float</span> <span class="title">getR</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_x; &#125;</span><br><span class="line">		<span class="function"><span class="type">float</span> <span class="title">getG</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_y; &#125;</span><br><span class="line">		<span class="function"><span class="type">float</span> <span class="title">getB</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_z; &#125;</span><br><span class="line">		<span class="function"><span class="type">float</span> <span class="title">getA</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_w; &#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; x)</span> </span>&#123; m_x = x; &#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; y)</span> </span>&#123; m_y = y; &#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setZ</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; z)</span> </span>&#123; m_z = z; &#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setW</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; w)</span> </span>&#123; m_w = w; &#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setR</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; r)</span> </span>&#123; m_x = r; &#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setG</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; g)</span> </span>&#123; m_y = g; &#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setB</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; b)</span> </span>&#123; m_z = b; &#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setA</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; a)</span> </span>&#123; m_w = a; &#125;</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">float</span> m_x;</span><br><span class="line">		<span class="type">float</span> m_y;</span><br><span class="line">		<span class="type">float</span> m_z;</span><br><span class="line">		<span class="type">float</span> m_w;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Among <code>initialization constructor</code>, <code>copy constructor</code>, <code>overridden operators</code>, the overridden of the vector is closely related to the mathematics. No need to mention that the operators ‘plus’ and ‘minus’ are easy to understand, but the overridden operators of ‘*&#39; and ‘^&#39; are a little bit hard to understand. I use the overridden operator for ‘*&#39; to represent the inner product of two vectors, while using ‘^&#39; to represent the cross product(namely: outer product) of the two vectors.</p>
<p>We need to know the differences between the inner product and the cross product. </p>
<p>The inner product of the 2 vectors is just to make the two vector multiply in mathematical way, the detail of the inner product of 2 vectors is shown below.</p>
<p>An inner product is a generalization of the dot product. In a vector space, it is a way to multiply vectors together, with the result of this multiplication being a scalar. A simple inner product of the two vectors is shown below</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A*B = ||A||*||B||*cos(θ)</span><br></pre></td></tr></table></figure>


<p>The cross product of the 2 vectors is totally different for just multiplying the vectors and it has distinct meaning from the inner product. The detail of the cross product of 2 vectors is shown below.  </p>
<p>The Cross Product a × b of two vectors is another vector that is at right angles to both:</p>
<p><img src="https://ezharjan.github.io/Blog/2022/03/18/CG-In-Practice/AcrossB.png" alt="CG"></p>
<!-- <p align='center'>
<img src="./AcrossB.png">
</p> -->

<p>The cross product could point in the completely opposite direction and still be at right angles to the two other vectors, so we have the: <code>Right Hand Rule</code>.</p>
<p><img src="https://ezharjan.github.io/Blog/2022/03/18/CG-In-Practice/rightHandRule.png" alt="CG"></p>
<!-- <p align='center'>
<img src="./rightHandRule.png">
</p> -->



<p>The magnitude (length) of the cross product equals the area of a parallelogram with vectors a and b for sides:</p>
<p><img src="https://ezharjan.github.io/Blog/2022/03/18/CG-In-Practice/lengthACrossB.png" alt="CG"></p>
<!-- <p align='center'>
<img src="./lengthACrossB.png">
</p> -->

<p>See how it changes for different angles:</p>
<p><img src="https://ezharjan.github.io/Blog/2022/03/18/CG-In-Practice/crossProduct.gif" alt="CG"></p>
<!-- <p align='center'>
<img src="./crossProduct.gif">
</p> -->

<p>The cross product (blue) is:</p>
<ul>
<li>zero in length when vectors a and b point in the same, or opposite, direction</li>
<li>reaches maximum length when vectors a and b are at right angles</li>
</ul>
<p>And it can point one way or the other!</p>
<p>So how do we calculate it?</p>
<p>We can calculate the Cross Product this way:</p>
<p><img src="https://ezharjan.github.io/Blog/2022/03/18/CG-In-Practice/crossProduct.png" alt="CG"></p>
<!-- <p align='center'>
<img src="./crossProduct.png">
</p> -->


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a × b = |a|*|b|*sin(θ)*n</span><br></pre></td></tr></table></figure>


<ul>
<li>|a| is the magnitude (length) of vector a</li>
<li>|b| is the magnitude (length) of vector b</li>
<li>θ is the angle between a and b</li>
<li>n is the unit vector at right angles to both a and b</li>
</ul>
<p>OR we can calculate it this way:<br>When a and b start at the origin point (0,0,0), the Cross Product will end at:</p>
<ul>
<li>cx &#x3D; aybz − azby</li>
<li>cy &#x3D; azbx − axbz</li>
<li>cz &#x3D; axby − aybx</li>
</ul>
<p><img src="https://ezharjan.github.io/Blog/2022/03/18/CG-In-Practice/calculateCrossProduct.png" alt="CG"></p>
<!-- <p align='center'>
<img src="./calculateCrossProduct.png">
</p> -->


<br>
<br>

<p>Next, there is a color attribute in our vertex called ‘SimpleVertex’. The color attribute is defined as a <code>Colour</code> type, which is also a self-defined type like ‘Vector4’. The color attribute stores a position’s color information, so that we can achieve lighting based on it. The inside of the ‘Colour’ type can also be regarded as a C++ struct, its structure is shown as below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Colour</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> Red;</span><br><span class="line">	<span class="type">float</span> Green;</span><br><span class="line">	<span class="type">float</span> Blue;</span><br><span class="line">	<span class="type">float</span> Alpha; <span class="comment">// (In my final project, alpha is not used.)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Its outlined structure is so simple that only contains three float members to represent three primary colors of the light, including a number to represent the alpha.</p>
<p>Also, in order to use it in the real project more conveniently, basic APIs should be added into the ‘Colour’ structure above, as well as some more color-related APIs. The final structure of the color will be like the one below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Colour</span> </span><br><span class="line">&#123;</span><br><span class="line">		<span class="built_in">Colour</span>() = <span class="keyword">default</span>;</span><br><span class="line">		<span class="built_in">Colour</span>(<span class="type">const</span> <span class="type">float</span> red, <span class="type">const</span> <span class="type">float</span> green, <span class="type">const</span> <span class="type">float</span> blue) :</span><br><span class="line">			<span class="built_in">r</span>(red), <span class="built_in">g</span>(green), <span class="built_in">b</span>(blue)&#123;&#125;</span><br><span class="line">		<span class="built_in">Colour</span>(<span class="type">const</span> Colour&amp; right)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;r = right.r;</span><br><span class="line">			<span class="keyword">this</span>-&gt;g = right.g;</span><br><span class="line">			<span class="keyword">this</span>-&gt;b = right.b;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> Colour&amp; right)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - right.r &lt;= EPSILON</span><br><span class="line">				&amp;&amp; <span class="keyword">this</span>-&gt;g - right.g &lt;= EPSILON</span><br><span class="line">				&amp;&amp; <span class="keyword">this</span>-&gt;b - right.b &lt;= EPSILON)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Colour&amp; <span class="keyword">operator</span> =(<span class="type">const</span> Colour&amp; right)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;right) </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>-&gt;r = right.r;</span><br><span class="line">			<span class="keyword">this</span>-&gt;g = right.g;</span><br><span class="line">			<span class="keyword">this</span>-&gt;b = right.b;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">Colour <span class="title">ClampColor</span><span class="params">(Colour&amp; color)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="built_in">Clamp</span>(color.r, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">			<span class="built_in">Clamp</span>(color.g, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">			<span class="built_in">Clamp</span>(color.b, <span class="number">0.f</span>, <span class="number">1.f</span>);</span><br><span class="line">			<span class="keyword">return</span> color;</span><br><span class="line">		&#125;</span><br><span class="line">		Colour <span class="keyword">operator</span> /(<span class="type">const</span> <span class="type">float</span> right) &#123;</span><br><span class="line">			Colour result;</span><br><span class="line">			result.r = <span class="keyword">this</span>-&gt;r / right;</span><br><span class="line">			result.g = <span class="keyword">this</span>-&gt;g / right;</span><br><span class="line">			result.b = <span class="keyword">this</span>-&gt;b / right;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		Colour <span class="keyword">operator</span> *(<span class="type">const</span> Colour&amp; right) <span class="type">const</span></span><br><span class="line">		&#123;</span><br><span class="line">			Colour result;</span><br><span class="line">			result.r = <span class="keyword">this</span>-&gt;r * right.r;</span><br><span class="line">			result.g = <span class="keyword">this</span>-&gt;g * right.g;</span><br><span class="line">			result.b = <span class="keyword">this</span>-&gt;b * right.b;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		Colour <span class="keyword">operator</span> *(<span class="type">const</span> <span class="type">float</span>&amp; right) <span class="type">const</span></span><br><span class="line">		&#123;</span><br><span class="line">			Colour result;</span><br><span class="line">			result.r = <span class="keyword">this</span>-&gt;r * right;</span><br><span class="line">			result.g = <span class="keyword">this</span>-&gt;g * right;</span><br><span class="line">			result.b = <span class="keyword">this</span>-&gt;b * right;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		Colour <span class="keyword">operator</span> +(<span class="type">const</span> Colour&amp; right)</span><br><span class="line">		&#123;</span><br><span class="line">			Colour result;</span><br><span class="line">			result.r = <span class="keyword">this</span>-&gt;r + right.r;</span><br><span class="line">			result.g = <span class="keyword">this</span>-&gt;g + right.g;</span><br><span class="line">			result.b = <span class="keyword">this</span>-&gt;b + right.b;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		Colour <span class="keyword">operator</span> -(<span class="type">const</span> Colour&amp; right)</span><br><span class="line">		&#123;</span><br><span class="line">			Colour result;</span><br><span class="line">			result.r = <span class="keyword">this</span>-&gt;r - right.r;</span><br><span class="line">			result.g = <span class="keyword">this</span>-&gt;g - right.g;</span><br><span class="line">			result.b = <span class="keyword">this</span>-&gt;b - right.b;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		Colour&amp; <span class="keyword">operator</span> *=(<span class="type">const</span> Colour&amp; right) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">return</span> (*<span class="keyword">this</span>) = (*<span class="keyword">this</span> * right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">float</span> r, g, b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>One important thing to mention in the code above is <code>the comparison of the two float-typed numbers</code>. <strong>In computer, a float-type number may well not be the exact number we saw on log, it may hide subtle bias behind its decimal point, especially those float-type numbers after having mathematical operations</strong>. Remember that 1.0 - 1.0 in computer may not be 0 at all. To avoid this, <strong>we have to use subtraction and epsilon when comparing 2 float-type(or double-type) numbers</strong>. For example, <code>if you want to know whether two float-type numbers are equal, subtraction of these two numbers is the first step, then just compare the subtracted result with the epsilon---a pretty tiny number that we have previously defined before. If the result is smaller than the epsilon, it means that the two float-type numbers are equal, vice versa.</code></p>
<br>

<p>Besides the basic APIs and operators we have mentioned above when talking about the ‘Vector4’, here we can see a different API called ‘ClampColor(Colour&amp; color)’. As the word’s own meaning goes, the <code>Clamp</code> is a way to clamp some number in or der to make it into the range previously set, let’s just call that range ‘valid range’. So it is a simple conduction just to avoid the number being outside the bounds of range. For example, if you only want to ensure the digits you get are within the range of x and y, mathematically written as [x, y], you can just take y — which is the roof of the range — if some number is bigger than y, vice versa. The code below shows how does the clamping works:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">Clamp</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; param, <span class="type">const</span> <span class="type">float</span>&amp; min, <span class="type">const</span> <span class="type">float</span>&amp; max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (param &lt;= min)</span><br><span class="line">		<span class="keyword">return</span> min;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (param &gt;= max)</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	<span class="keyword">return</span> param;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>An optimization is just shown below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">Clamp</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; param, <span class="type">const</span> <span class="type">float</span>&amp; min, <span class="type">const</span> <span class="type">float</span>&amp; max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((param &lt; min) ? min : ((param &gt; max) ? max : param));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>But why we clamp colors? </p>
<p>As a common sense that we can use 0<del>1 or 0</del>255 to represent a color’s attribute(R, G, B, A). In this case, we use 0~1. So this demands each of the color lies within the range of [0, 1]. In calculating float-type-based colors, because of the complex algorithm we use, it is almost possible that we gain a number outside the range we want. So clamping is always necessary.</p>
<br>


<p>The third member in our vertex is ‘Texcoord’, which represents texture coordinate, and its structure is very simple that only has two float-typed member, one is ‘U’ and the other is ‘V’. Just see the struct below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Texcoord</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> U;</span><br><span class="line">	<span class="type">float</span> V;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Texture coordinates, also called UVs, are pairs of numbers stored in the vertices of a mesh.</p>
<p>These numbers are often used to stretch a 2D texture onto a 3D mesh, but they can be used for other things like coloring the mesh, controlling the flow across the surface , etc.</p>
<p>Game engines commonly use two texture coordinates, U and V, for mapping the width and height of a texture. A third axis W can also be used for depth if you are using a 3D volume texture, but usually this coordinate is removed for efficiency.</p>
<p>Texture coordinates are measured in a scale of 0.0 to 1.0, with 0.0 and 1.0 at opposite sides of the texture. When a model has a UV distance greater than 1 (for example, UV goes from -1 to 2) then the texture will tile across the model.</p>
<p>These numbers are usually hidden from the artist, replaced by helpful visual representations of how the textures are projected. Planes, cylinders and spheres help the artist align the textures in a visual way, but it helps to know that games only see the UV numbers that these shapes create.</p>
<p>Texture coordinates define how an image (or portion of an image) gets mapped to a geometry. A texture coordinate is associated with each vertex on the geometry, and it indicates what point within the texture image should be mapped to that vertex.<br>Each texture coordinate is, at a minimum, a (u,v) pair, which is the horizontal and vertical location in texture space, respectively. The values are typically in the range of [0,1]. The (0,0) origin is at the lower left of the texture.<br>For (u,v) values outside the range of [0,1], the Texture Wrap Style property describes how this is handled.<br>Texture coordinates may also have optional values “w” and “q”. This is often represented as (u,v,w,q). These coordinates are both optional, so you may have, for example, (u,v,w) or (u,v,q).<br>The ‘w’ is used for more complex texture mapping in 3D space and is seen relatively infrequently in most workflows. This mapping in 3D may be in relation to 3D textures or 2D texture variations in 3D such as shadows. It can also be used with 2D textures that are intended to represent complex irregular surfaces in 3D.<br>The ‘w’ is used when rendering, in conjunction with the texture’s transformation values such as rotation, shearing, scaling, and offset. w is an extra value against which to multiply the texture transformation values, and may be used when you want to take perspective into account (such as in shadow mapping). It works the same as when you transform a location in object-space to 3D (solid) screen-space via a world-view-projection matrix. By multiplying the uvw with projection transformation values, you end up with two coordinates (often called s and t) which are then mapped onto a 2D texture.<br>The ‘q’ is used to scale texture coordinates when employing techniques such as projective interpolation. For most use cases, if a system can only handle (u,v) texture coordinates and is instead offered (u,v,q) values, a location of (u&#x2F;q,v&#x2F;q) may be used.</p>
<br>
<br>

<p>As we have took so much time on introducing the basic elements called ‘vertex’, we are sure that we have appropriate data structures to store the basic information of a 3D model. Let’s go on to the next step: <code>Reading the model into the memory</code>, which means that we are going to use our vertex-typed container to store each of the vertex from a 3D model. In C++, its convenient that we can use ‘vector’ in STL as a list to store all of the information we read from the model. Using ‘vector&lt;SimpleVertex&gt;‘ to represent a list of ‘SimpleVertex’ that we have just constructed above. Then comes the reading of a 3D model file. In this case we use OBJ format as it’s file structure is easier understand and visible in file format rather than a binary format like other model files. Lets take a simple look at the content of an file with OBJ format:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># File Created: 25.02.2021 17:35:16</span><br><span class="line"># object Teapot001</span><br><span class="line"></span><br><span class="line">v  0.279771417379 0.523323953152 0.361592650414</span><br><span class="line">v  0.256112784147 0.523323953152 0.481412023306</span><br><span class="line">v  0.252184033394 0.539422273636 0.479740440845</span><br><span class="line">... ... ... ## details ignored</span><br><span class="line">v  0.207081869245 0.542744159698 0.262634694576</span><br><span class="line">v  0.235997557640 0.523323953152 0.250331819057</span><br><span class="line"># 529 vertices</span><br><span class="line"></span><br><span class="line">vn -0.966742336750 -0.255752444267 -0.000000119668</span><br><span class="line">vn -0.893014192581 -0.256344825029 -0.369882434607</span><br><span class="line">vn -0.893437385559 0.255995273590 -0.369101703167</span><br><span class="line">vn -0.966824233532 0.255442529917 -0.000000077787</span><br><span class="line">... ... ... ## details ignored</span><br><span class="line">vn 0.350497841835 0.925311684608 -0.144739553332</span><br><span class="line">vn 0.485588967800 0.850653529167 -0.201474279165</span><br><span class="line"># 530 vertex normals</span><br><span class="line"></span><br><span class="line">vt 2.000000000000 2.000000000000 0.000000000000</span><br><span class="line">vt 1.750000000000 2.000000000000 0.000000000000</span><br><span class="line">... ... ... ## details ignored</span><br><span class="line">vt 0.375000000000 0.999999880791 0.000000000000</span><br><span class="line"># 323 texture coords</span><br><span class="line"></span><br><span class="line">o Teapot001</span><br><span class="line">g Teapot001</span><br><span class="line">f 1/1/1 2/2/2 3/3/3 </span><br><span class="line">f 3/3/3 4/4/4 1/1/1 </span><br><span class="line">... ... ... ## details ignored</span><br><span class="line">f 528/250/529 471/254/472 473/256/474 </span><br><span class="line">f 473/256/474 529/252/530 528/250/529 </span><br><span class="line"># 1024 faces</span><br></pre></td></tr></table></figure>

<p>The content of the OBJ file above is a pretty simple once, with many details ignored but the whole structure is entirely considered. The ‘#’ can be regarded as comments, there is no headers or tails in any OBJ files. Beginning with the vertex data, the ‘v’ represents the geometric vertices, ‘vt’ means ‘texture vertices’, ‘vn’ is ‘vertex normals’, and in some of the OBJ files there is ‘vp’, which means the parameter space vertices. Then comes the groups, ‘o’ is for the name of the object, ‘g’ is for the name of the group. The ‘f’ is crucial for it means ‘face’, the vertex indexes are split by ‘&#x2F;‘, and always remember that the structure is mainly controlled by geometric vertices and the faces. We just stop deepening into the content of the file format as the detailed introduction about the OBJ file can be found online if you’re interested. Besides, you can even use FBX in your project rather than this kind of simple OBJ files. </p>
<p>Next, just I’m gonna show you the way to read OBJ file into our vertex container, namely, the computer memory we have constructed before. You can see that I divides the OBJ model data into the types(‘v’, ‘vt’, ‘vn’, ‘f’) before reading into the container just in accordance with the content of the files mentioned above.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReadOBJFileIntoOBJModel</span><span class="params">(<span class="type">const</span> std::string&amp; path, ModelInfo* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::ifstream in;</span><br><span class="line">	in.<span class="built_in">open</span>(path, std::ifstream::in);</span><br><span class="line">	<span class="keyword">if</span> (in.<span class="built_in">fail</span>()) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (in)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> vertexIndex = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> vertexCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		std::vector&lt;Vector4&gt; verts;</span><br><span class="line">		std::vector&lt;Vector3&gt; texs;</span><br><span class="line">		std::vector&lt;Vector4&gt; norms;</span><br><span class="line">		std::string line;</span><br><span class="line">		<span class="type">float</span> maxVx = -FLT_MAX, maxVy = -FLT_MAX, maxVz = -FLT_MAX;</span><br><span class="line">		<span class="type">float</span> minVx = FLT_MAX, minVy = FLT_MAX, minVz = FLT_MAX;</span><br><span class="line">		<span class="keyword">while</span> (!in.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">			std::<span class="built_in">getline</span>(in, line);</span><br><span class="line">			<span class="function">std::istringstream <span class="title">iss</span><span class="params">(line.c_str())</span></span>;</span><br><span class="line">			<span class="type">char</span> trash;</span><br><span class="line">			<span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;v &quot;</span>)) &#123;</span><br><span class="line">				iss &gt;&gt; trash;</span><br><span class="line">				<span class="type">float</span> x, y, z;</span><br><span class="line">				iss &gt;&gt; x;</span><br><span class="line">				iss &gt;&gt; y;</span><br><span class="line">				iss &gt;&gt; z;</span><br><span class="line">				<span class="function">Vector4 <span class="title">v</span><span class="params">(x, y, z, <span class="number">1.f</span>)</span></span>;</span><br><span class="line">				Vertex newVertex;</span><br><span class="line">				newVertex.pos = v;</span><br><span class="line">				obj-&gt;vertexVec.<span class="built_in">push_back</span>(newVertex);</span><br><span class="line">				vertexCount++;</span><br><span class="line">				maxVx = std::<span class="built_in">fmaxf</span>(maxVx, v.<span class="built_in">getX</span>());</span><br><span class="line">				maxVy = std::<span class="built_in">fmaxf</span>(maxVy, v.<span class="built_in">getY</span>());</span><br><span class="line">				maxVz = std::<span class="built_in">fmaxf</span>(maxVz, v.<span class="built_in">getZ</span>());</span><br><span class="line">				minVx = std::<span class="built_in">fminf</span>(minVx, v.<span class="built_in">getX</span>());</span><br><span class="line">				minVy = std::<span class="built_in">fminf</span>(minVy, v.<span class="built_in">getY</span>());</span><br><span class="line">				minVz = std::<span class="built_in">fminf</span>(minVz, v.<span class="built_in">getZ</span>());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;vt &quot;</span>)) &#123;</span><br><span class="line">				iss &gt;&gt; trash;</span><br><span class="line">				iss &gt;&gt; trash;</span><br><span class="line">				<span class="type">float</span> u, v;</span><br><span class="line">				iss &gt;&gt; u;</span><br><span class="line">				iss &gt;&gt; v;</span><br><span class="line">				<span class="keyword">if</span> (u &gt; <span class="number">1.0f</span>) u -= std::<span class="built_in">floor</span>(u);</span><br><span class="line">				<span class="keyword">if</span> (v &gt; <span class="number">1.0f</span>) v -= std::<span class="built_in">floor</span>(v);</span><br><span class="line">				obj-&gt;vertexVec[vertexIndex].tex = &#123; u, v &#125;;</span><br><span class="line">				obj-&gt;vertexVec[vertexIndex].rhw = <span class="number">1.0f</span>;</span><br><span class="line">				vertexIndex++;</span><br><span class="line">				<span class="keyword">if</span> (vertexIndex == vertexCount)</span><br><span class="line">				&#123;</span><br><span class="line">					vertexIndex = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;vn &quot;</span>)) &#123;</span><br><span class="line">				iss &gt;&gt; trash;</span><br><span class="line">				iss &gt;&gt; trash;</span><br><span class="line">				<span class="type">float</span> x, y, z;</span><br><span class="line">				iss &gt;&gt; x;</span><br><span class="line">				iss &gt;&gt; y;</span><br><span class="line">				iss &gt;&gt; z;</span><br><span class="line">				obj-&gt;vertexVec[vertexIndex].normal = <span class="built_in">Vector4</span>(x, y, z, <span class="number">0.f</span>);</span><br><span class="line">				vertexIndex++;</span><br><span class="line">				<span class="keyword">if</span> (vertexIndex == vertexCount)</span><br><span class="line">				&#123;</span><br><span class="line">					vertexIndex = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;f &quot;</span>)) &#123;</span><br><span class="line">				std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">				std::vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">				std::vector&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">				<span class="type">int</span> vx, vy, vz;</span><br><span class="line">				<span class="type">int</span> tx, ty, tz;</span><br><span class="line">				<span class="type">int</span> nx, ny, nz;</span><br><span class="line"></span><br><span class="line">				iss &gt;&gt; trash;</span><br><span class="line">				iss &gt;&gt; vx &gt;&gt; trash &gt;&gt; tx &gt;&gt; trash &gt;&gt; nx &gt;&gt;</span><br><span class="line">					vy &gt;&gt; trash &gt;&gt; ty &gt;&gt; trash &gt;&gt; ny &gt;&gt;</span><br><span class="line">					vz &gt;&gt; trash &gt;&gt; tz &gt;&gt; trash &gt;&gt; nz;</span><br><span class="line"></span><br><span class="line">				VerticeIndex indexes;</span><br><span class="line">				<span class="keyword">if</span> (MODEL_PATH == <span class="string">&quot;assets/Tonny.obj&quot;</span>) &#123;</span><br><span class="line">					indexes = &#123; vx , vy, vz &#125;;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					indexes = &#123; vz , vy, vx &#125;;  <span class="comment">// some obj files&#x27;s vertex order is different (For Back Culling Correctly) </span></span><br><span class="line">				&#125;</span><br><span class="line">				obj-&gt;verteciesIndexVec.<span class="built_in">push_back</span>(indexes);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Vector4 center = <span class="built_in">Vector4</span>((maxVx + minVx) / <span class="number">2</span>, (maxVy + minVy) / <span class="number">2</span>, (maxVz + minVz) / <span class="number">2</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">		in.<span class="built_in">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;No such file or path named \&#x27;&quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;\&#x27; !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>By now, we have prepared a model data well. As you can see that the application stage is conducted in CPU, the programmer has the full control on every step and operation happened in this stage. You can try to reduce the count of the triangle during this stage in order to render it fast in the next stage, but the cost is obvious that the detail may lose. The CPU will send the data(model data which combined with vertices, vertices which includes positions, normals and texture coordinates) we stored into the hardware for the stage.</p>
<br>
<br>
<br>
<br>
<br>

<br>
<br>

<h3 id="2-Geometry-Stage"><a href="#2-Geometry-Stage" class="headerlink" title="2. Geometry Stage"></a>2. Geometry Stage</h3><p>The model data prepared and sent from the application stage will be used as the input content for geometry stage. <strong>The main tasks of the geometry stage is to tranfer the vertices, do the clippings, shad lights, make projections and conduct screen mappings.</strong></p>
<p>First and foremost, in order to make the mathematical calculations more unified, I have to mention that I use radiant(0~Π→0~180°) while describing an Euler angle, and use 0~1 rather than 0~255 while describing a color value, and use ‘vector • matrix’(vector-on-the-right-side) rule. The matrix are in ‘row-first’ order. Left-hand coordinate is used while doing geometric transforms.</p>
<p>In this stage there is a very important process called ‘MVP Transformation’, which is actually the combination of the ‘Model Transform’(the process during which we transform the model into its own space to the world space), ‘View Transform’(the process during which we transform the model from the world space into the view space) and the ‘Projection Transform’(the process during which we make the projection to the models in view space and transform it into the projection space). Let’s take a look at the detailed process of the geometry stage step by step.</p>
<p>Firstly, we have to transfer the model from its own space into the world space, but what is a ‘world space’? The world space is actually a space that holds all of the models, formally: objects. It should be able to hold all the objects with universal rules. The rule is originated from the world coordinates, which means that the world coordinate itself is a universal rule to all of the objects that are being rendered in the world space. Once we have learnt the origin of the universal rules, we are able to describe it in math, and you will find that describing a coordinate is simple in mathematics. It is a common sense that the coordinates can be easily described via matrix. <strong>As we can use a unit vector to form the base of a vector space, every vector in the space can be expressed as the linear combination of unit vectors, we can use a unit matrix to form the base of a matrix space. This means that the world space coordinate should be a unit matrix, so as to hold all the other objects. Thus the world space is created. Generally, we regard a unit matrix as a world space matrix, a world space, a world coordinate.</strong> A unit matrix is shown below, which can represent the world matrix. We can use a 3x3 matrix to represent a 3D space, but we choose 4x4 matrix, why? Because the position of our vertex is constructed in 4 dimension, with ‘w’ which represents the homogeneous coordinate. And we know that the mathematical rule does not allow us make arithmetic operations between a 3x3 matrix and a vector4. Also, the homogeneous coordinate W is crucial in the next steps that we can not lose it, we have to store it so as to use it later. As we use 2 dimentional array to define a matrix, we have to be clear about the inner side of it. In computing, row-major order and column-major order are methods for storing multidimensional arrays in linear storage such as random access memory. The difference between the orders lies in which elements of an array are contiguous in memory. In row-major order, the consecutive elements of a row reside next to each other, whereas the same holds true for consecutive elements of a column in column-major order. While the terms allude to the rows and columns of a two-dimensional array, i.e. a matrix, the orders can be generalized to arrays of any dimension by noting that the terms row-major and column-major are equivalent to lexicographic and co-lexicographic orders, respectively. Data layout is critical for correctly passing arrays between programs written in different programming languages. It is also important for performance when traversing an array because modern CPUs process sequential data more efficiently than non-sequential data. This is primarily due to CPU caching which exploits spatial locality of reference. In addition, contiguous access makes it possible to use SIMD instructions that operate on vectors of data. In some media such as tape or NAND flash memory, accessing sequentially is orders of magnitude faster than non-sequential access. We cannot clearly see whether the world matrix shown below is in row-major order or in column-major order for it is a unit matrix and the transpose of a unit matrix is actually itself, but I have to mention that all the matrices defined in this book and used in the relevant final project is in row-major order.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WorldMatrix = &#123;</span><br><span class="line">                 &#123;1, 0, 0, 0&#125;</span><br><span class="line">                 &#123;0, 1, 0, 0&#125;</span><br><span class="line">                 &#123;0, 0, 1, 0&#125;</span><br><span class="line">                 &#123;0, 0, 0, 1&#125;</span><br><span class="line">              &#125;;</span><br></pre></td></tr></table></figure>


<p>Then we have to place our models into the world space. As we have stored the model in a vertex which contains the attribute of position in 4 dimentional vector type, we can just multiply each of the position vectors with the world space matrix, thus transforming the positions of the model from its own space into the world space.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(type:matrix4f)ModelInWorldSpace = (type:vector4)ModelVertices[n].position * (type:matrix4f)WorldMatrix</span><br></pre></td></tr></table></figure>


<p>Notice that all of the interactions on the object&#x2F;models come from user side is applied on the models&#x2F;objects in world space. This means that the rotation transform, scale transform and translation transform are conducted directly after we placed the models&#x2F;objects in the world space through world matrix. First we have to map the user interaction from screen to 3D space if needed, for example, it’s needed that we map the rotation angle from 2D screen into 3D virtual world space if we want the user interact directly through the 2D screen when changing the rotation of the models&#x2F;objects. Just multiplying the world matrix with the transform matrices will make the objects&#x2F;models transform in the way we want. But how to describe our transform for the objects&#x2F;models? Here are the details of the rotation matrix, scale matrix and transformation matrix that we should bear in mind:</p>
<p><em>Rotate by X-axis</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RotationXMatrix = &#123;</span><br><span class="line">                 &#123;1, 0,       0,      0&#125;</span><br><span class="line">                 &#123;0, cos(θ),  sin(θ), 0&#125;</span><br><span class="line">                 &#123;0, -sin(θ), cos(θ), 0&#125;</span><br><span class="line">                 &#123;0, 0,       0,      1&#125;</span><br><span class="line">              &#125;;</span><br></pre></td></tr></table></figure>

<p><em>Rotate by Y-axis</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RotationYMatrix = &#123;</span><br><span class="line">                 &#123;cos(θ),  0, -sin(θ), 0&#125;</span><br><span class="line">                 &#123;0,       1,  0,      0&#125;</span><br><span class="line">                 &#123;sin(θ),  0,  cos(θ), 0&#125;</span><br><span class="line">                 &#123;0,       0,  0,      1&#125;</span><br><span class="line">              &#125;;</span><br></pre></td></tr></table></figure>

<p><em>Rotate by Z-axis</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RotationZMatrix = &#123;</span><br><span class="line">                 &#123;cos(θ),  sin(θ), 0, 0&#125;</span><br><span class="line">                 &#123;-sin(θ), cos(θ), 0, 0&#125;</span><br><span class="line">                 &#123;sin(θ),  0,      1, 0&#125;</span><br><span class="line">                 &#123;0,       0,      0, 1&#125;</span><br><span class="line">              &#125;;</span><br></pre></td></tr></table></figure>

<p>The way to build out these matrices in C++ goes like the codes below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="function">Matrix4f <span class="title">Matrix4f::getRotateXMatrix</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; thetaX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Matrix4f rotateXMatrix;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> angle = <span class="built_in">RadToDegree</span>(thetaX);</span><br><span class="line"></span><br><span class="line">	rotateXMatrix.matrix[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0f</span>;</span><br><span class="line">	rotateXMatrix.matrix[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> cosine = (<span class="type">float</span>)<span class="built_in">cos</span>(angle);</span><br><span class="line">	<span class="type">float</span> sine = (<span class="type">float</span>)<span class="built_in">sin</span>(angle);</span><br><span class="line">	rotateXMatrix.matrix[<span class="number">1</span>][<span class="number">1</span>] = cosine;</span><br><span class="line">	rotateXMatrix.matrix[<span class="number">2</span>][<span class="number">2</span>] = cosine;</span><br><span class="line">	rotateXMatrix.matrix[<span class="number">1</span>][<span class="number">2</span>] = sine;</span><br><span class="line">	rotateXMatrix.matrix[<span class="number">2</span>][<span class="number">1</span>] = -sine;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rotateXMatrix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix4f <span class="title">Matrix4f::getRotateYMatrix</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; thetaY)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Matrix4f rotateYMatrix;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> angle = <span class="built_in">RadToDegree</span>(thetaY);</span><br><span class="line"></span><br><span class="line">	rotateYMatrix.matrix[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1.0f</span>;</span><br><span class="line">	rotateYMatrix.matrix[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> cosine = (<span class="type">float</span>)<span class="built_in">cos</span>(angle);</span><br><span class="line">	<span class="type">float</span> sine = (<span class="type">float</span>)<span class="built_in">sin</span>(angle);</span><br><span class="line">	rotateYMatrix.matrix[<span class="number">0</span>][<span class="number">0</span>] = cosine;</span><br><span class="line">	rotateYMatrix.matrix[<span class="number">2</span>][<span class="number">2</span>] = cosine;</span><br><span class="line">	rotateYMatrix.matrix[<span class="number">0</span>][<span class="number">2</span>] = -sine;</span><br><span class="line">	rotateYMatrix.matrix[<span class="number">2</span>][<span class="number">0</span>] = sine;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rotateYMatrix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix4f <span class="title">Matrix4f::getRotateZMatrix</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; thetaZ)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Matrix4f rotateZMatrix;</span><br><span class="line"></span><br><span class="line">	rotateZMatrix.matrix[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1.0f</span>;</span><br><span class="line">	rotateZMatrix.matrix[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> angle = <span class="built_in">RadToDegree</span>(thetaZ);</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> cosine = (<span class="type">float</span>)<span class="built_in">cos</span>(angle);</span><br><span class="line">	<span class="type">float</span> sine = (<span class="type">float</span>)<span class="built_in">sin</span>(angle);</span><br><span class="line">	rotateZMatrix.matrix[<span class="number">0</span>][<span class="number">0</span>] = cosine;</span><br><span class="line">	rotateZMatrix.matrix[<span class="number">1</span>][<span class="number">1</span>] = cosine;</span><br><span class="line">	rotateZMatrix.matrix[<span class="number">0</span>][<span class="number">1</span>] = sine;</span><br><span class="line">	rotateZMatrix.matrix[<span class="number">1</span>][<span class="number">0</span>] = -sine;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rotateZMatrix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>But notice that the direct rotation via Euler angles on any objects&#x2F;models will cause <code>Gimbal Lock</code>. <strong>Gimbal lock is the loss of one degree of freedom in a three-dimensional, three-gimbal mechanism that occurs when the axes of two of the three gimbals are driven into a parallel configuration, “locking” the system into rotation in a degenerate two-dimensional space.</strong><br>The word lock is misleading: no gimbal is restrained. All three gimbals can still rotate freely about their respective axes of suspension. Nevertheless, because of the parallel orientation of two of the gimbals’ axes there is no gimbal available to accommodate rotation about one axis.</p>
<p><img src="https://ezharjan.github.io/Blog/2022/03/18/CG-In-Practice/GimbalLockOccasions.png" alt="CG"></p>
<p align="center">
All together there are 6 parenting combinations to choose from. In each case gimbal lock occurs on the parent when the middle axis is rotated too far.
<!-- <img src="./GimbalLockOccasions.png"> -->
</p>


<p>The cause of gimbal lock is the representation of orientation in calculations as three axial rotations based on Euler angles. A potential solution therefore is to represent the orientation in some other way. This could be as a rotation matrix, a quaternion , or a similar orientation representation that treats the orientation as a value rather than three separate and related values. Given such a representation, the user stores the orientation as a value. To quantify angular changes produced by a transformation, the orientation change is expressed as a delta angle&#x2F;axis rotation. The resulting orientation must be re-normalized to prevent the accumulation of floating-point error in successive transformations. For matrices, re-normalizing the result requires converting the matrix into its nearest orthonormal representation. For quaternions, re-normalization requires performing quaternion normalization.</p>
<p>To avoid gimbal lock, we can use quaternion. <code>Quaternion is</code> a complex system in math.<br>In mathematics, the quaternion number system extends the complex numbers. Quaternions were first applied to mechanics in three-dimensional space. Hamilton defined a quaternion as the quotient of two directed lines in a three-dimensional space, or, equivalently, as the quotient of two vectors. Multiplication of quaternions is noncommunicative. Quaternions are used in pure mathematics, but also have practical uses in applied mathematics, particularly for calculations involving three-dimensional rotations, such as in three-dimensional computer graphics, computer vision, and crystallographic texture analysis. They can be used alongside other methods of rotation, such as Euler angles and rotation matrices, or as an alternative to them, depending on the application. It can avoid Gimbal Lock.</p>
<p>The detail of an angle’s quaternion is a matrix shown below:<br><em>Quaternion matrix to describe the rotation</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StartPoint(x1, y1, z1, 1)</span><br><span class="line">EndPoint(x1, y1, z1, 1)</span><br><span class="line">EulerAngle&lt;StartPoint, EndPoint&gt; = θ</span><br><span class="line">Quaternion  </span><br><span class="line">    = (</span><br><span class="line">        (StartPoint ⊗ EndPoint).x,</span><br><span class="line">        (StartPoint ⊗ EndPoint).y,</span><br><span class="line">        (StartPoint ⊗ EndPoint).z,</span><br><span class="line">        (StartPoint • EndPoint), // ==&gt; cos(θ / 2)</span><br><span class="line">      )</span><br></pre></td></tr></table></figure>

<p>The Euler angle between start point and the end point: θ, can be inversely calculated out through a quaternion for test, and it is equal to 2*arccos(Quaternion.w) when being inverted.</p>
<p>Here is the detailed method to get quaternion in real code:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vector4 <span class="title">GetQuaternion</span><span class="params">(<span class="type">const</span> Vector2 &amp; lastPointV2, <span class="type">const</span> Vector2 &amp; curPointV2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Vector4 result;</span><br><span class="line"></span><br><span class="line">	Vector3 lastPointV3;</span><br><span class="line">	Vector3 curPointV3;</span><br><span class="line">	<span class="built_in">ArcBallTransform</span>(lastPointV2, lastPointV3);</span><br><span class="line">	<span class="built_in">ArcBallTransform</span>(curPointV2, curPointV3);</span><br><span class="line"></span><br><span class="line">	Vector3 perp;</span><br><span class="line">	perp = lastPointV3 ^ curPointV3;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (perp.<span class="built_in">getLength</span>() &gt; EPSILON)</span><br><span class="line">	&#123;</span><br><span class="line">		result.<span class="built_in">setX</span>(perp.<span class="built_in">getX</span>());</span><br><span class="line">		result.<span class="built_in">setY</span>(perp.<span class="built_in">getY</span>());</span><br><span class="line">		result.<span class="built_in">setZ</span>(perp.<span class="built_in">getZ</span>());</span><br><span class="line">		<span class="comment">// w=cos(rotationAngle/2) ---&gt; formula</span></span><br><span class="line">		result.<span class="built_in">setW</span>(lastPointV3 * curPointV3);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		result.<span class="built_in">setX</span>(<span class="number">.0</span>f);</span><br><span class="line">		result.<span class="built_in">setY</span>(<span class="number">.0</span>f);</span><br><span class="line">		result.<span class="built_in">setZ</span>(<span class="number">.0</span>f);</span><br><span class="line">		result.<span class="built_in">setW</span>(<span class="number">.0</span>f);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">///std::cout &lt;&lt; &quot;rotated (in degree)&quot; &lt;&lt; RadToDegree(2 * acosf(result.getW())) &lt;&lt; std::endl;</span></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can see that the function above includes a function called <code>ArcBallTransform, which is a mathematical way to map the 2D point onto a 3D sphere, thus making it possible to describe the user&#39;s interaction from 2D screen to 3D virtual world space.</code> The detail of the arc ball transform goes like the code shown below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="type">float</span> <span class="title">GetKFactorForArcBall</span><span class="params">(<span class="type">const</span> <span class="type">float</span> para)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// mouse point ranges from [0, window_width - 1]</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1.f</span> / ((para - <span class="number">1.f</span>) * <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ArcBallTransform</span><span class="params">(<span class="type">const</span> Vector2&amp; pointOnScreen, Vector3&amp; pointOnSphere)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// convert width&amp;height to [-1,1], left-hand coordinate</span></span><br><span class="line">	<span class="function">Vector2 <span class="title">tempVec2</span><span class="params">((pointOnScreen.getX() * GetKFactorForArcBall(WINDOW_WIDTH)) - <span class="number">1.f</span>, (pointOnScreen.getY() * GetKFactorForArcBall(WINDOW_HEIGHT)) - <span class="number">1.f</span>)</span></span>;</span><br><span class="line">	<span class="comment">//Vector2 tempVec2((pointOnScreen.getX() * GetKFactorForArcBall(WINDOW_WIDTH)) - 1.f,1.f - (pointOnScreen.getY() * GetKFactorForArcBall(WINDOW_HEIGHT))); // left-hand coordinate</span></span><br><span class="line">	<span class="type">float</span> length = <span class="built_in">pow</span>(tempVec2.<span class="built_in">getX</span>(), <span class="number">2</span>) + <span class="built_in">pow</span>(tempVec2.<span class="built_in">getY</span>(), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if it&#x27;s outside the ball</span></span><br><span class="line">	<span class="keyword">if</span> (length &gt; <span class="number">1.f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// scale to sphere</span></span><br><span class="line">		<span class="type">float</span> norm = <span class="number">-1.f</span> / <span class="built_in">sqrtf</span>(length);</span><br><span class="line"></span><br><span class="line">		pointOnSphere.<span class="built_in">setX</span>(tempVec2.<span class="built_in">getX</span>() * norm);</span><br><span class="line">		pointOnSphere.<span class="built_in">setY</span>(tempVec2.<span class="built_in">getY</span>() * norm);</span><br><span class="line">		pointOnSphere.<span class="built_in">setZ</span>(<span class="number">0.f</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// if it&#x27;s inside the ball</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		pointOnSphere.<span class="built_in">setX</span>(tempVec2.<span class="built_in">getX</span>());</span><br><span class="line">		pointOnSphere.<span class="built_in">setY</span>(tempVec2.<span class="built_in">getY</span>());</span><br><span class="line">		pointOnSphere.<span class="built_in">setZ</span>(<span class="built_in">sqrtf</span>(<span class="number">1.f</span> - length));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">float</span> <span class="title">GetArcAngleCosineValue</span><span class="params">(<span class="type">const</span> Vector3&amp; position, <span class="type">const</span> Vector3&amp; startPosition, <span class="type">const</span> Vector3&amp; endPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> r = position.<span class="built_in">getZ</span>();</span><br><span class="line">	<span class="type">float</span> pointDistance = </span><br><span class="line">                           <span class="built_in">sqrtf</span>(</span><br><span class="line">                                 <span class="built_in">pow</span>((endPosition.<span class="built_in">getX</span>() - startPosition.<span class="built_in">getX</span>()), <span class="number">2</span>)</span><br><span class="line">                               + <span class="built_in">pow</span>((endPosition.<span class="built_in">getY</span>() - startPosition.<span class="built_in">getY</span>()), <span class="number">2</span>)</span><br><span class="line">                               + <span class="built_in">pow</span>((endPosition.<span class="built_in">getZ</span>() - startPosition.<span class="built_in">getZ</span>()), <span class="number">2</span>));</span><br><span class="line">	<span class="type">float</span> consAngle = (<span class="built_in">pow</span>(r, <span class="number">2</span>) + <span class="built_in">pow</span>(r, <span class="number">2</span>) - <span class="built_in">pow</span>(pointDistance, <span class="number">2</span>)) / (<span class="number">2</span> * r * r); <span class="comment">// cosine formula</span></span><br><span class="line">	<span class="keyword">return</span> consAngle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Changing the location(Translating the objects&#x2F;models) directly from the screen-side(eg: the user clicked to select an object and moved the mouse from one point on screen to the other just to make the selected object move as the mouse’s track) is also in the same way I have mentioned above, but is much easier than doing rotation via arc ball transform plus quaternion. Only the subtraction of the 2 points is needed without any complicated calculations. However, the selection of the object&#x2F;model in virtual 3D world space from 2D screen is a little bit hard for most of the fresh-hands for it demands some more bounding-box related algorithms and knowledge basis to achieve this.</p>
<p>Now here is the details of the translation transform matrix, through which we are able to translate an object from one place to another in a 3D world space:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TranslationMatrix = &#123;</span><br><span class="line">                 &#123;1, 0, 0, 0&#125;</span><br><span class="line">                 &#123;0, 1, 0, 0&#125;</span><br><span class="line">                 &#123;0, 0, 1, 0&#125;</span><br><span class="line">                 &#123;x, y, z, 1&#125;</span><br><span class="line">              &#125;;</span><br></pre></td></tr></table></figure>

<p>And here is the way to get the translation matrix in C++:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Matrix4f <span class="title">Matrix4f::getTranslateMatrix</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; x, <span class="type">const</span> <span class="type">float</span>&amp; y, <span class="type">const</span> <span class="type">float</span>&amp; z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Matrix4f translationMatrix;</span><br><span class="line"></span><br><span class="line">	translationMatrix.matrix[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0f</span>;</span><br><span class="line">	translationMatrix.matrix[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1.0f</span>;</span><br><span class="line">	translationMatrix.matrix[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1.0f</span>;</span><br><span class="line">	translationMatrix.matrix[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">	translationMatrix.matrix[<span class="number">3</span>][<span class="number">0</span>] = x;</span><br><span class="line">	translationMatrix.matrix[<span class="number">3</span>][<span class="number">1</span>] = y;</span><br><span class="line">	translationMatrix.matrix[<span class="number">3</span>][<span class="number">2</span>] = z;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> translationMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After the translation, we might need some ways to scale the models&#x2F;objects in 3D world space so that the things can be in the size we expected. Here is the detail of the scale matrix:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ScaleMatrix = &#123;</span><br><span class="line">                 &#123;x, 0, 0, 0&#125;</span><br><span class="line">                 &#123;0, y, 0, 0&#125;</span><br><span class="line">                 &#123;0, 0, z, 0&#125;</span><br><span class="line">                 &#123;0, 0, 0, 1&#125;</span><br><span class="line">              &#125;;</span><br></pre></td></tr></table></figure>

<p>Here are 2 ways to get the scale matrix in C++:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Matrix4f <span class="title">Matrix4f::getScaleMatrix</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; x, <span class="type">const</span> <span class="type">float</span>&amp; y, <span class="type">const</span> <span class="type">float</span>&amp; z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Matrix4f scaleMatrix;</span><br><span class="line"></span><br><span class="line">	scaleMatrix.matrix[<span class="number">0</span>][<span class="number">0</span>] = x;</span><br><span class="line">	scaleMatrix.matrix[<span class="number">1</span>][<span class="number">1</span>] = y;</span><br><span class="line">	scaleMatrix.matrix[<span class="number">2</span>][<span class="number">2</span>] = z;</span><br><span class="line">	scaleMatrix.matrix[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>  scaleMatrix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix4f <span class="title">Matrix4f::getScaleMatrix</span><span class="params">(<span class="type">const</span> Matrix4f &amp; matrixToScale, <span class="type">const</span> <span class="type">float</span> scaleFactor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Matrix4f result;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">			result.matrix[i][j] = matrixToScale.matrix[i][j] * scaleFactor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>All the transforms in world space from either the user interaction or the preset automation is conducted through matrices. The vertices multiplies the world space matrix, translation matrix, scale matrix as well as rotation matrix, the order of multiplying with the scale matrix, translation matrix and rotation matrix can be various be they should always be on the right side of the multiplication when using the ‘vector • matrix’(vector-on-the-right-side) rule. Otherwise, the transpose of them is needed to carry out the transformations correctly.</p>
<p>The formula goes like this:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ModelInWorldSpaceAfterScaling = ModelInWorldSpace * ScaleMatrix</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ModelInWorldSpaceAfterRotation = ModelInWorldSpace * RotationMatrix</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ModelInWorldSpaceAfterTranslation = ModelInWorldSpace * TranslationMatrix</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ModelInWorldSpaceAfterTransform = ModelInWorldSpace * ScaleMatrix * RotationMatrix * TranslationMatrix</span><br></pre></td></tr></table></figure>


<br>

<p>The second step is to transform the model from the world space into the view space. In order to create a view space, we have to construct a camera first. The main functions of this camera is to shot the models in scene and send the rendering data onto screen so that we can see what’s happening in the virtual 3D world. You can either separate the camera out as a single class or just inject it into the one of the class you think injectable and appropriate.</p>
<p>Before constructing a camera, we should learn the main function that the camera has to do for us while rendering. To make it more specific, the camera can be regarded as our eyes in the virtual 3D world, and in this way you’re going to realize the first thing the camera have to solve: seeing the models. How to see those models in the scene? There should be some rules so that the view is in correct and non-distorted state. Here are some rules we have to consider: </p>
<ol>
<li>The up-axis of the camera <em>[In order to view the models&#x2F;objects correctly]</em>;</li>
<li>The position we are viewing the models from <em>[We have to keep a distance from the models we want to see so that we can see them]</em>; </li>
<li>The target of the camera that is shooting <em>[In oder to specify the shooting position]</em>;</li>
</ol>
<p>These three aspects are crucial for a camera to shoot the models or objects in a 3D space correctly, so we are going to build up a way to describe the way a camera shoots the scene. In computer graphics, we still use a matrix to describe the way, but there are 2 types of rule that the one is in left-hand coordinate while the other is in right-hand coordinate. Just use the one that you will not change in the future. In this book I use the left hand coordinate system in building up my camera matrix, which is called “LookAtMatrix” formally in the project. Let’s just take a look at the details of the view matrix we are going to use:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Matrix4f <span class="title">getLookAtMatrixForLeftHandCoordinate</span><span class="params">(Vector3 * eyePos, <span class="type">const</span> Vector3 * lookAt, <span class="type">const</span> Vector3 * up, Vector3 &amp; newCameraUpAxis)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Vector3 zAxis = *lookAt - *eyePos;</span><br><span class="line">		zAxis.<span class="built_in">Normalize</span>();</span><br><span class="line">		Vector3 xAxis = *up ^ zAxis; <span class="comment">// cross product</span></span><br><span class="line">		xAxis.<span class="built_in">Normalize</span>();</span><br><span class="line">		Vector3 yAxis = zAxis ^ xAxis; <span class="comment">// cross product</span></span><br><span class="line">		newCameraUpAxis = yAxis; <span class="comment">// store the last up-axis for updating camera position</span></span><br><span class="line"></span><br><span class="line">		Matrix4f result;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/// when(major==raw) =&gt; do: below</span></span><br><span class="line">		result.matrix[<span class="number">0</span>][<span class="number">0</span>] = xAxis.<span class="built_in">getX</span>();</span><br><span class="line">		result.matrix[<span class="number">0</span>][<span class="number">1</span>] = yAxis.<span class="built_in">getX</span>();</span><br><span class="line">		result.matrix[<span class="number">0</span>][<span class="number">2</span>] = zAxis.<span class="built_in">getX</span>();</span><br><span class="line">		result.matrix[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">		result.matrix[<span class="number">1</span>][<span class="number">0</span>] = xAxis.<span class="built_in">getY</span>();</span><br><span class="line">		result.matrix[<span class="number">1</span>][<span class="number">1</span>] = yAxis.<span class="built_in">getY</span>();</span><br><span class="line">		result.matrix[<span class="number">1</span>][<span class="number">2</span>] = zAxis.<span class="built_in">getY</span>();</span><br><span class="line">		result.matrix[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">		result.matrix[<span class="number">2</span>][<span class="number">0</span>] = xAxis.<span class="built_in">getZ</span>();</span><br><span class="line">		result.matrix[<span class="number">2</span>][<span class="number">1</span>] = yAxis.<span class="built_in">getZ</span>();</span><br><span class="line">		result.matrix[<span class="number">2</span>][<span class="number">2</span>] = zAxis.<span class="built_in">getZ</span>();</span><br><span class="line">		result.matrix[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">		result.matrix[<span class="number">3</span>][<span class="number">0</span>] = -(xAxis * (*eyePos));</span><br><span class="line">		result.matrix[<span class="number">3</span>][<span class="number">1</span>] = -(yAxis * (*eyePos));</span><br><span class="line">		result.matrix[<span class="number">3</span>][<span class="number">2</span>] = -(zAxis * (*eyePos));</span><br><span class="line">		result.matrix[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		Matrix-Structure(</span></span><br><span class="line"><span class="comment">				xaxis.x,			yaxis.x,			zaxis.x,			0,</span></span><br><span class="line"><span class="comment">				xaxis.y,			yaxis.y,			zaxis.y,			0,</span></span><br><span class="line"><span class="comment">				xaxis.z,			yaxis.z,			zaxis.z,			0,</span></span><br><span class="line"><span class="comment">			   -xaxis.Dot(eyePos), -yaxis.Dot(eyePos), -zaxis.Dot(eyePos),  1</span></span><br><span class="line"><span class="comment">		);*/</span></span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>It’s just creating a virtual camera for shooting the virtual 3D world using matrix. Ones all the significant information is stored in the matrices, it will be so easy for us to apply them onto the models in the 3D world be rendered. The result of the matrix we gain via the function above is the origin of our view matrix. So we apply the matrix we gain by using the function above to an empty matrix to store our view matrix. Now you will realize that you can directly regard the view matrix as the ‘camera matrix’ or ‘eye matrix’, any transforms conducted onto the camera shall directly be conducted on the view matrix.</p>
<p>Now that we gained the view matrix singly by configuring the camera we are using in the virtual 3D world, we can transform the vertices from the world space into the view space just by updating the vertices in the world space through: <code>multiplying the vertex positions already in the world space with the view matrix</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ModelInViewSpace = ModelInWorldSpace * ViewMatrix;</span><br></pre></td></tr></table></figure>

<p>Till now, we have successfully transformed the models from the world space into the view space, next step after this is the transform of the model from the view space into the projection space. In order to make the transform, we have to gain projection matrix first.</p>
<p>There are 2 kinds of projections in our life, the one is orthographic while the other is perspective.</p>
<p><strong>In the orthographic projection, the things we see will be shown in the shape based on its original geometric shape, non-distorted surfaces with all of the lines and points mathematically-ordered.</strong> For this reason, we use a cube to project the objects&#x2F;models in the view space, all the shapes are projected mathematically through a cube.</p>
<p><strong>In the perspective projection, the things we see will be shown in the shape based on its realistic shape we see in our real life. It seems ‘realistic’ just because of the fact that the human eyes see things in perspective view, the shapes of the objects in real life is distorted when it is being projected into our brains from our eyes: mastering the rule that “Everything looks small in the distance and big on the contrary”.</strong> For this reason, we use cone to project the objects&#x2F;models in the view space rather than a cube, all the shapes are projected from a point, also, the furthest objects will disappear and become as a point after the projection.</p>
<p>Since we have noticed the main difference of 2 types of projection, the question lingers: What elements are needed when acquiring the projection matrix?</p>
<p>As we use a geometry to make the projection process(using a cube to make the orthographic projection while using a cone to make the perspective projection), the properties of the geometry selected shall be the attributes we have to consider when making the projection. We store the projection space in a 4x4 matrix as we did for the world space and view space before. </p>
<p>A cube has its width, height and length. When projecting, it’s enough for us to build out an orthographic projection matrix using these 3 attributes. We use its length to represent the distance from <code>the nearest z-position</code>(zNear) to <code>the furthest z-position</code>(zFar). Any objects&#x2F;models outside this range will not be seen and should be clipped away so that they will not be rendered on screen. We usually set a small number, for example 0.2 as the nearest z-position while a bigger like 500 as the furthest z-position. Conus left can be 0 while the conus right should be the width of the cube, conus bottom can be 0 while the conus top should be the height of the cube. Here is the details of the orthographic matrix:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Matrix4f <span class="title">Matrix4f::getOrthographicMatrix</span><span class="params">(<span class="type">const</span> <span class="type">float</span> conusLeft, <span class="type">const</span> <span class="type">float</span> conusRight, <span class="type">const</span> <span class="type">float</span> conusBottom, <span class="type">const</span> <span class="type">float</span> conusTop, <span class="type">float</span> zNear, <span class="type">float</span> zFar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Matrix4f orthographicMatrix;</span><br><span class="line">	<span class="comment">/// make z range : [0,1], left hand coordinate</span></span><br><span class="line">	orthographicMatrix.matrix[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2.f</span> / (conusRight - conusLeft);</span><br><span class="line">	orthographicMatrix.matrix[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2.f</span> / (conusTop - conusBottom);</span><br><span class="line">	orthographicMatrix.matrix[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1.f</span> / (zFar - zNear); <span class="comment">// in left hand coordinate</span></span><br><span class="line">	orthographicMatrix.matrix[<span class="number">3</span>][<span class="number">0</span>] = -(conusRight + conusLeft) / (conusRight - conusLeft);</span><br><span class="line">	orthographicMatrix.matrix[<span class="number">3</span>][<span class="number">1</span>] = -(conusTop + conusBottom) / (conusTop - conusBottom);</span><br><span class="line">	orthographicMatrix.matrix[<span class="number">3</span>][<span class="number">2</span>] = -zNear / (zFar - zNear);</span><br><span class="line">	orthographicMatrix.matrix[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1.f</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> orthographicMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>A cone, however, is different from a cube, and it has not width or height. Apart form using its length to represent the distance from <code>the nearest z-position</code>(zNear) to <code>the furthest z-position</code>(zFar), we use its angle on roof to represent the viewing field, which is formally called: <code>field of view</code>. And there is another element we have to consider when building the perspective matrix, that is: <code>aspect ratio</code>, <strong>which is the ratio of the rendering view’s(or the image’s) width to its height, and is expressed with 2 numbers separated by a colon</strong>, such as 16:9. Its simple to gain the aspect ratio once we configured the target rendering height and width. In the final project accompanied with this book, I used 720 as window width and 576 as window height, which means the aspect ratio is 720:576. By now, we have all the important information gained from a cone to build out a perspective projection matrix, which represents the perspective projection space itself. Let’s take a look at the details of the perspective matrix below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Matrix4f <span class="title">Matrix4f::getPerspectiveMatrix</span><span class="params">(<span class="type">float</span> fovYOZ, <span class="type">float</span> aspectRatio, <span class="type">float</span> zNear, <span class="type">float</span> zFar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fovYOZ = <span class="built_in">DegreeToRad</span>(fovYOZ);</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> focalLength = <span class="number">1.f</span> / <span class="built_in">tanf</span>(fovYOZ / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	Matrix4f perspectiveMatrix;</span><br><span class="line"></span><br><span class="line">	perspectiveMatrix.matrix[<span class="number">0</span>][<span class="number">0</span>] = focalLength / aspectRatio;</span><br><span class="line">	perspectiveMatrix.matrix[<span class="number">1</span>][<span class="number">1</span>] = focalLength;</span><br><span class="line">	perspectiveMatrix.matrix[<span class="number">2</span>][<span class="number">2</span>] = zFar / (zFar - zNear); <span class="comment">// in left hand coordinate</span></span><br><span class="line">	perspectiveMatrix.matrix[<span class="number">3</span>][<span class="number">2</span>] = -(zFar * zNear) / (zFar - zNear);</span><br><span class="line">	perspectiveMatrix.matrix[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">1.f</span>; <span class="comment">// in left hand coordinate</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> perspectiveMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then the way to transform the vertices from the view space into the projection space is as easy as what we have done when transforming the vertices form the world space into the view space: multiplying the model information matrix in view space with one of the projection matrix we calculated above. The formula goes like this:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ModelInProjectionSpace = ModelInViewSpace * ProjectionMatrix;</span><br></pre></td></tr></table></figure>

<p>Notice that we should choose one type of projection at a time so that we can view in relevant projection mode, so the exact formula in a frame goes like this:<br><em>When using perspective mode</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ModelInPerspectiveProjectionSpace = ModelInViewSpace * PerspectiveProjectionMatrix;</span><br></pre></td></tr></table></figure>

<p><em>When using orthographic mode</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ModelInOrthographicProjectionSpace = ModelInViewSpace * OrthographicProjectionMatrix;</span><br></pre></td></tr></table></figure>

<p>Till now we have successfully processed the MVP transform, here is the recitation of the <code>MVP transform in a nut shell</code>:</p>
<p><em>(matrices are all with type:matrix4f)</em><br><em>(positions are all with type:vector4)</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ModelInWorldSpace = ModelVertices[n].position * WorldMatrix;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ModelInViewSpace = ModelInWorldSpace * ViewMatrix;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ModelInProjectionSpace = ModelInViewSpace * ProjectionMatrix;</span><br></pre></td></tr></table></figure>

<p>After we have transformed the vertices into the relevant projection space(perspective or orthographic), we have to make clippings. Clipping is a way to ignore the vertices that need not to be rendered in our visible area. In formula, <code>when a vertex is inside the frustum, its position in X-axis and Y-axis will lay among the range of [-w, w] while its position in Z-axis will be in the range of [0, w]</code>. So we can use this formula to check whether a vertex is inside the frustum. Here is the detail of the way to check whether a vertex is inside the CVV:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">IsOutsideCVV</span><span class="params">(<span class="type">const</span> Vector4&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> x = v.<span class="built_in">getX</span>();</span><br><span class="line">	<span class="type">float</span> y = v.<span class="built_in">getY</span>();</span><br><span class="line">	<span class="type">float</span> z = v.<span class="built_in">getZ</span>();</span><br><span class="line">	<span class="type">float</span> w = v.<span class="built_in">getW</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (x &lt;= w &amp;&amp; x &gt;= -w &amp;&amp; y &lt;= w &amp;&amp; y &gt;= -w &amp;&amp; z &lt;= w &amp;&amp; z &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A similar step with clippings is <code>back culling</code>, which <code>is a way to ignore the back side of the model being rendered so that the rendering efficiency may be accelerated.</code> When culling the backside of the model being rendered in virtual 3D world space, the important thing is to figure out its normal. The normal is decided upon the rule of drawing triangle: if you draw a triangle by connecting the vertices clockwise, the back side of the model is pointed to the inner side to the screen, vice versa. We can easily figure out the normal based on the Right-hand Screw Rule, but in programming, we have to know the way to express the Right-hand Screw Rule: we make subtractions twice to take all the three points into consideration as well as pretending to screw from one point to the other, then we calculate the cross product of the first point with the second point(or the second with the third, as is shown using ‘way 2’ below, but the points must be in continuity so as to pretend the screwing correctly). This normalized cross-product result best describes the normal of three points — the triangle. The back side of a primitive is easily figured out in this way. Here is the detail of CVV-Clipping and back-culling in my simple project:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Vector4 <span class="title">GetNormalVectorForBackCulling</span><span class="params">(<span class="type">const</span> Vector4&amp; p1, <span class="type">const</span> Vector4&amp; p2, <span class="type">const</span> Vector4&amp; p3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Vector4 s1, s2, pn;</span><br><span class="line">	s1 = p3 - p2;</span><br><span class="line">	s2 = p2 - p1;</span><br><span class="line">	pn = s1 ^ s2; <span class="comment">//way 1</span></span><br><span class="line">	<span class="comment">//Vector4 s3;  s3 = p1 - p3; pn = s2 ^ s3; //way 2</span></span><br><span class="line">	pn.<span class="built_in">Normalize</span>();</span><br><span class="line">	<span class="keyword">return</span> pn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">ShouldCullBack</span><span class="params">(<span class="type">const</span> Vector4&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// anti-clock wise culling</span></span><br><span class="line">	<span class="function">Vector4 <span class="title">v</span><span class="params">(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (v * vec &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">DrawTriangle</span><span class="params">(Vertex&amp; v1, Vertex&amp; v2, Vertex&amp; v3, <span class="type">const</span> Colour** texture)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Vector4 pos1AfterMVP, pos2AfterMVP, pos3AfterMVP;</span><br><span class="line"></span><br><span class="line">	Vector4 pos1TransformedToWorld, pos2TransformedToWorld, pos3TransformedToWorld;</span><br><span class="line">	m_transform-&gt;<span class="built_in">ModelToWorld</span>(pos1TransformedToWorld, v1.pos);</span><br><span class="line">	m_transform-&gt;<span class="built_in">ModelToWorld</span>(pos2TransformedToWorld, v2.pos);</span><br><span class="line">	m_transform-&gt;<span class="built_in">ModelToWorld</span>(pos3TransformedToWorld, v3.pos);</span><br><span class="line"></span><br><span class="line">	v1.posInWorldSpace = pos1TransformedToWorld;</span><br><span class="line">	v2.posInWorldSpace = pos2TransformedToWorld;</span><br><span class="line">	v3.posInWorldSpace = pos3TransformedToWorld;</span><br><span class="line"></span><br><span class="line">	Vector4 pos1InView, pos2InView, pos3InView;</span><br><span class="line">	<span class="built_in">Vector4DotMatrix4f</span>(pos1InView, pos1TransformedToWorld, m_transform-&gt;viewMatrix);</span><br><span class="line">	<span class="built_in">Vector4DotMatrix4f</span>(pos2InView, pos2TransformedToWorld, m_transform-&gt;viewMatrix);</span><br><span class="line">	<span class="built_in">Vector4DotMatrix4f</span>(pos3InView, pos3TransformedToWorld, m_transform-&gt;viewMatrix);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Vector4DotMatrix4f</span>(pos1AfterMVP, pos1InView, m_transform-&gt;projectionMatrix);</span><br><span class="line">	<span class="built_in">Vector4DotMatrix4f</span>(pos2AfterMVP, pos2InView, m_transform-&gt;projectionMatrix);</span><br><span class="line">	<span class="built_in">Vector4DotMatrix4f</span>(pos3AfterMVP, pos3InView, m_transform-&gt;projectionMatrix);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Vector4 transformedVertNormal1, transformedVertNormal2, transformedVertNormal3;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// CVV Clip here</span></span><br><span class="line">	<span class="keyword">if</span> (m_transform-&gt;<span class="built_in">IsOutsideCVV</span>(pos1AfterMVP)</span><br><span class="line">		&amp;&amp; m_transform-&gt;<span class="built_in">IsOutsideCVV</span>(pos2AfterMVP)</span><br><span class="line">		&amp;&amp; m_transform-&gt;<span class="built_in">IsOutsideCVV</span>(pos3AfterMVP)) <span class="keyword">return</span>; <span class="comment">//The clipping happens here! Just stop here to prevent points from next steps.</span></span><br><span class="line"></span><br><span class="line">	m_transform-&gt;<span class="built_in">ModelToWorld</span>(transformedVertNormal1, v1.normal);</span><br><span class="line">	m_transform-&gt;<span class="built_in">ModelToWorld</span>(transformedVertNormal2, v2.normal);</span><br><span class="line">	m_transform-&gt;<span class="built_in">ModelToWorld</span>(transformedVertNormal3, v3.normal);</span><br><span class="line"></span><br><span class="line">	Vector4 homogenizedVertPos1, homogenizedVertPos2, homogenizedVertPos3;</span><br><span class="line">	<span class="comment">/// Set projection transform ---&gt; To NDC</span></span><br><span class="line">	m_transform-&gt;<span class="built_in">Homogenize</span>(homogenizedVertPos1, pos1AfterMVP);</span><br><span class="line">	m_transform-&gt;<span class="built_in">Homogenize</span>(homogenizedVertPos2, pos2AfterMVP);</span><br><span class="line">	m_transform-&gt;<span class="built_in">Homogenize</span>(homogenizedVertPos3, pos3AfterMVP);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	Vector4 pn = <span class="built_in">GetNormalVectorForBackCulling</span>(homogenizedVertPos1, homogenizedVertPos2, homogenizedVertPos3);</span><br><span class="line">	<span class="keyword">if</span> (m_transform-&gt;<span class="built_in">ShouldCullBack</span>(pn)) <span class="keyword">return</span>; <span class="comment">//The culling happens here! Just stop here to prevent the points from rasterization stage.</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">       <span class="built_in">ScanLineDraw</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>You can see that the points are just prevented from being sent to the rasterization stage when we are culling the back. The points are prevented from going to the next steps when clipping also.</p>
<p>There is a step not mentioned above that we may do before making the projection(inside the MVP, before ‘P’): shading lights. <code>Shading lights is an operation conducted on textures of the models</code>. When shading the light, lots of algorithms is used. In the final project asides this book, I showed the way of computing light and shading the light in Lambert mode. Main formula of Lambert Lighting is :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I = Ia * Ka + Ip * Kd * (N·L)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I = Ia * Ka + Ip * Kd * cosTheta;</span><br></pre></td></tr></table></figure>


<p>The details of lighting are shown below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Light</span></span><br><span class="line">	&#123;</span><br><span class="line">		Vector3 direction;</span><br><span class="line">		Colour color;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">Light</span>(<span class="type">const</span> Vector3&amp; direction, <span class="type">const</span> Colour&amp; color) :<span class="built_in">direction</span>(direction), <span class="built_in">color</span>(color) &#123;&#125;</span><br><span class="line">		<span class="built_in">Light</span>(<span class="type">const</span> Colour&amp; color) : <span class="built_in">color</span>(color) &#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">DirectionalLight</span> : <span class="keyword">public</span> Light &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// important to know that the initializer should be initiated from parent</span></span><br><span class="line">		<span class="built_in">DirectionalLight</span>(<span class="type">const</span> Colour&amp; c, <span class="type">const</span> Vector3&amp; position, <span class="type">const</span> Vector3&amp; target, <span class="type">float</span> intensity)</span><br><span class="line">			:<span class="built_in">Light</span>(c), <span class="built_in">position</span>(position), <span class="built_in">targetPosition</span>(target), <span class="built_in">intensity</span>(intensity) &#123;&#125;</span><br><span class="line">		<span class="built_in">DirectionalLight</span>(<span class="type">const</span> Colour&amp; c, <span class="type">const</span> Vector3&amp; direction, <span class="type">float</span> intensity)</span><br><span class="line">			:<span class="built_in">Light</span>(Vector3::<span class="built_in">Normalize</span>(direction), c), <span class="built_in">intensity</span>(<span class="built_in">Clamp</span>(intensity, <span class="number">0.f</span>, <span class="number">1.f</span>)) &#123;&#125;</span><br><span class="line">		~<span class="built_in">DirectionalLight</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Global directional light using Lambert Shading </span></span><br><span class="line">		<span class="comment">// I = Ia * Ka + Ip * Kd * (N·L)</span></span><br><span class="line">		<span class="comment">// Ia * Ka --&gt; ambient light</span></span><br><span class="line">		<span class="comment">// back side will be totally black in the case of removing the ambient light</span></span><br><span class="line">		<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">LambertLightOn</span><span class="params">(Colour&amp; ambientColour, DirectionalLight* light, Vector3&amp; normalInWorldSpace, Colour&amp; vertexColor)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="comment">//float I, Ia, Ip, Kd, cosTheta;</span></span><br><span class="line">			<span class="type">float</span> Ia, Ip, Kd, cosTheta;</span><br><span class="line">			Ia = <span class="number">0.2f</span>; <span class="comment">//ambient light intensity</span></span><br><span class="line">			Ip = light-&gt;intensity; <span class="comment">//directional light intensity</span></span><br><span class="line">			Kd = <span class="number">1.f</span>; <span class="comment">//coefficients of directional light</span></span><br><span class="line">			light-&gt;direction.<span class="built_in">Normalize</span>();</span><br><span class="line">			normalInWorldSpace.<span class="built_in">Normalize</span>(); <span class="comment">// must be normalized!!!</span></span><br><span class="line">			cosTheta = light-&gt;direction * normalInWorldSpace; <span class="comment">// incident angel</span></span><br><span class="line">			cosTheta &gt; <span class="number">1.f</span> ? (cosTheta = <span class="number">1.f</span>) : (cosTheta &lt; <span class="number">0.f</span> ? cosTheta = <span class="number">0.f</span> : cosTheta = cosTheta);</span><br><span class="line">			<span class="comment">////Formula: I = Ia * Ka + Ip * Kd * cosTheta;</span></span><br><span class="line">			Colour result = ambientColour * (Ia * Kd) + light-&gt;color * (Ip * Kd * cosTheta);</span><br><span class="line">			<span class="comment">// clamp the colors&#x27; rgb value into valid range in case of bounding outside</span></span><br><span class="line">			<span class="keyword">if</span> (result.r &gt; <span class="number">1.f</span> || result.g &gt; <span class="number">1.f</span> || result.b &gt; <span class="number">1.f</span>)</span><br><span class="line">				result.r = result.g = result.b = <span class="number">1.f</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (result.r &lt; <span class="number">0.f</span> || result.g &lt; <span class="number">0.f</span> || result.b &lt; <span class="number">0.f</span>)</span><br><span class="line">				result.r = result.g = result.b = <span class="number">0.f</span>;</span><br><span class="line">			vertexColor = result;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">ComputeLighting</span><span class="params">(<span class="type">const</span> DirectionalLight&amp; light, <span class="type">const</span> Vector3&amp; P, <span class="type">const</span> Vector3&amp; N,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="type">const</span> Vector3&amp; eyePosition, <span class="type">const</span> <span class="type">float</span> shininess,</span></span></span><br><span class="line"><span class="params"><span class="function">			Colour&amp; diffuseResult, Colour&amp; specularResult, <span class="type">const</span> <span class="type">float</span> attenuate)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="comment">// calculate diffuse</span></span><br><span class="line">			Vector3 L = (light.position - P);</span><br><span class="line">			L.<span class="built_in">Normalize</span>();</span><br><span class="line">			<span class="type">float</span> diffuseLight = <span class="built_in">max</span>(N * L, <span class="number">0</span>); <span class="comment">// always get the bigger value to ignore the error case such as shading from the back side</span></span><br><span class="line">			diffuseResult = light.color * diffuseLight * attenuate;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// calculate reflection</span></span><br><span class="line">			Vector3 V = eyePosition - P;</span><br><span class="line">			V.<span class="built_in">Normalize</span>();</span><br><span class="line">			Vector3 H = L + V;</span><br><span class="line">			H.<span class="built_in">Normalize</span>();</span><br><span class="line">			<span class="type">float</span> specularLight = <span class="built_in">pow</span>(<span class="built_in">max</span>((N*H), <span class="number">0</span>), shininess);</span><br><span class="line">			<span class="keyword">if</span> (diffuseLight &lt;= <span class="number">0</span>) specularLight = <span class="number">0</span>;</span><br><span class="line">			specularResult = light.color * specularLight * attenuate;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		Vector3 targetPosition;</span><br><span class="line">		Vector3 position;</span><br><span class="line">		<span class="type">float</span> intensity;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// calculate the normal vector of the light in world space coordinate</span></span><br><span class="line">		<span class="function"><span class="keyword">inline</span> Vector3 <span class="title">DirectionInWorldSpace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			Vector3 direction;</span><br><span class="line">			direction = position - targetPosition;</span><br><span class="line">			direction.<span class="built_in">Normalize</span>();</span><br><span class="line">			<span class="keyword">return</span> direction;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>


<p>After the MVP transform and clippings, we know that the models state does not change at all, they are still in 3D state, but we have to see it on a 2D screen, so the screen mapping comes to help us transform the 3D vertices into the 2D screen. <code>Screen mapping is a technic that maps the 3D vertices to the 2D screen</code>. As is the codes shown above in function ‘DrawTriangle’, we simply call it <code>Homogenize: the way to transform the vertices from the projection space into the screen space</code>. Here is the detail of homogenizing a vertex: </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Homogenize</span><span class="params">(Vector4&amp; result, <span class="type">const</span> Vector4&amp; posInProjectionSpace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (posInProjectionSpace.W == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Vector4</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">float</span> rhw = <span class="number">1</span> / posInProjectionSpace.W;</span><br><span class="line">	result.X = (<span class="number">1</span> + posInProjectionSpace.X * rhw) * canvasWidth * <span class="number">0.5</span>; <span class="comment">// screen coordinate</span></span><br><span class="line">	result.Y = (<span class="number">1</span> - posInProjectionSpace.Y * rhw) * canvasHeight * <span class="number">0.5</span>; <span class="comment">//screen coordinate ---&gt; top down</span></span><br><span class="line">	result.Z = posInProjectionSpace.Z * rhw;</span><br><span class="line">	result.W = rhw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>After such a long process, with the pixels we have just gain, we are entering into the next stage: rasterization stage, where we conduct multiple operations on each pixel so that each of the frame — namely an image, formed of many pixels — rendered on screen is in ideal state.</p>
<br>
<br>
<br>

<h3 id="3-Rasterization-Stage"><a href="#3-Rasterization-Stage" class="headerlink" title="3. Rasterization Stage"></a>3. Rasterization Stage</h3><p>The vertices we gain in screen space during the geometry stage will be used for drawing the final image, formally: single frame, that we are able to see directly. </p>
<p>After the screen mapping, through which we transformed the vertices from projection space to the screen space, some of the processes is still needed to make out a single frame to be rendered, and these processes are conducted in rasterization stage. Actually, it is the rasterization stage that converts vector information (composed of shapes or primitives) into a raster image (composed of pixels) for the purpose of displaying real-time 3D graphics.</p>
<p>During rasterization, each primitive is converted into pixels, while interpolating per-vertex values across each primitive. Rasterization includes clipping vertices to the view frustum, performing a divide by z to provide perspective, mapping primitives to a 2D viewport, and determining how to invoke the pixel shader. While using a pixel shader is optional, the rasterizer stage always performs clipping, a perspective divide to transform the points into homogeneous space, and maps the vertices to the viewport.</p>
<p>The positions[type:Vector4(x,y,z,w)] in each vertices, coming into the rasterizer stage are assumed to be in homogeneous clip-space. In this coordinate space the X axis points right, Y points up and Z points away from camera.</p>
<p>You may disable rasterization by telling the pipeline there is no pixel shader, and disabling depth and stencil testing. While disabled, rasterization-related pipeline counters will not update. There is also a complete description of the rasterization rules. Rasterization rules define how vector data is mapped into raster data. The raster data is snapped to integer locations that are then culled and clipped (to draw the minimum number of pixels), and per-pixel attributes are interpolated (from per-vertex attributes) before being passed to a pixel shader. There are several types of rules, which depend on the type of primitive that is being mapped, as well as whether or not the data uses multi-sampling to reduce aliasing. More related topics is available <a href="https://docs.microsoft.com/en-us/windows/win32/direct3d11/d3d10-graphics-programming-guide-rasterizer-stage-rules">online</a> and in this book we are just talking about the simple steps to create the usable pixels for rendering.</p>
<p>The vertices are placed in screen space after being clipped in projection space, but not formally, they are still in projection space de facto. Because we only clipped away the vertices outside the projected area, there are still vertices inside the projected area but outside the screen area. Different from the back culling, the vertices outside the screen area&#x2F;space, which is also called: the view frustum, need to be clipped away not only for the reason that they are useless for rendering, but the consideration of those vertices may explode our frame buffer. <code>Frame buffer is a container that stores all of the pixels going to be rendered on screen.</code> Its volume is screenHeight*screenWidth large, so by now you will realize the importance of clipping of the vertices outside the screen space. </p>
<p>The RHW is the reciprocal of the homogeneous (clip space) w coordinate of a vertex (e.g., 1&#x2F;w).<br>Recall that we must expand our 3D vectors to 4D vectors in order to be able to multiply them with 4x4 matrices (which we do because 4x4 matrices allow us to completely encode both rotational, translational, and scaling terms). In doing so we often set (or assume) the expanded fourth (w) component is 1 for model vertices, and the nature of the transforms we use to bring model-space vertices into world or view space doesn’t include any terms that alter the w component.<br>However, the typical perspective projection transformation often takes the follow general form which, when multiplied with a general view-space vertex vector (x,y,z,1), gives you a vector like (Ax, By, Cz + E, zD) — note that the resulting vertex has a w component that is proportional to the original input’s z component. Also note that the space you’re in after multiplication by this matrix is called clip space, because the nature of the transform has distorted the viewing frustum into a cuboid, the edges of which are much easier to perform clipping against.<br>After clipping, the graphics pipeline divided by the w component to scale things based on distance to give you the perspective effect. This division cannot be encoded in a matrix transform.<br>Now, division by w is the same as multiplication by the reciprocal of w, and the reason that you are required to give the reciprocal of the clip space w coordinate is probably a throwback to the time when division was significantly slower than multiplication. When you use pre-transformed vertices, the transformation from model to world to view to clip space is skipped, but the rest of the pipeline (division by w, conversion to window coordinates, and rasterization, obviously) must still happen. Since the projection transform was skipped, there is no basis for the pipeline to determine the w coordinate to divide by, so it asks you for it.</p>
<p>There are some interesting uses for the value, but for the most part people use pre-transformed vertices when doing 2D rendering, and in that case its most useful to set the RHW value to 1, which effectively causes the divide to be a no-op.</p>
<p>The detail of initiating the RHW is shown below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VertexRHWInit</span><span class="params">(Vertex&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	v.rhw = <span class="number">1</span> / v.pos.W;</span><br><span class="line">	v.tex.u *= v.rhw;</span><br><span class="line">	v.tex.v *= v.rhw;</span><br><span class="line">	v.normal.X = v.normal.X * v.rhw;</span><br><span class="line">	v.normal.Y = v.normal.Y * v.rhw;</span><br><span class="line">	v.normal.Z = v.normal.Z * v.rhw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There are lots of ways to draw triangles when we have pixels in hand. Each of the way has its pros and cons and we have to choose the correct one to use. BUt in the final project, I provided multiple choices for learning. For example, you can use <code>Point-by-Point Comparison Method</code> to draw a line, it has its costs on performance but also has it advantage on some tiny models which ought to be rendered precisely. And, we can easily put some effects on each of the vertices when drawing the points. Here is the detail of the ‘Point-by-Point Comparison Method’:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="type">void</span> <span class="title">DrawPoint</span><span class="params">(<span class="type">const</span> Vector4&amp; p, <span class="type">const</span> Colour&amp; color, <span class="type">const</span> Texcoord&amp; tc, <span class="type">const</span> Vector3&amp; normal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> y = (<span class="type">int</span>)p.<span class="built_in">getY</span>();</span><br><span class="line">	<span class="type">int</span> x = (<span class="type">int</span>)p.<span class="built_in">getX</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (y &lt; <span class="number">0</span> || y &gt;= m_height) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m_width) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span>&amp; z = m_zbuffer[y * m_width + x];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (z &lt; p.<span class="built_in">getZ</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> fcolor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> s = <span class="built_in">GetState</span>(m_state);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s &amp; STATE_DRAW_COLOR)</span><br><span class="line">	&#123;</span><br><span class="line">		fcolor = <span class="built_in">GetHEXColor</span>(color);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Colour textureColor;</span><br><span class="line">		<span class="keyword">if</span> (s &amp; STATE_DRAW_TEX) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (m_interp == INTERP_NONE) &#123;</span><br><span class="line">				<span class="type">int</span> tx = (<span class="type">int</span>)<span class="built_in">roundf</span>((tc.u * (textureWidth - <span class="number">1</span>)));</span><br><span class="line">				<span class="type">int</span> ty = (<span class="type">int</span>)<span class="built_in">roundf</span>((tc.v * (textureHeight - <span class="number">1</span>)));</span><br><span class="line">				textureColor = pixelColorData[ty][tx];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				textureColor = <span class="built_in">BilinearInterp</span>(pixelColorData, textureWidth, textureHeight, tc.u, tc.v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// default ambient light</span></span><br><span class="line">		<span class="function">Colour <span class="title">ambient</span><span class="params">(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>)</span></span>;</span><br><span class="line">		<span class="type">float</span> ambientIntensity = AMBIENT_INTENSITY;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// influence of ambient</span></span><br><span class="line">		ambient.r *= ambientIntensity * textureColor.r;</span><br><span class="line">		ambient.g *= ambientIntensity * textureColor.g;</span><br><span class="line">		ambient.b *= ambientIntensity * textureColor.b;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//fcolor = (int(ambient.r * 255) &lt;&lt; 16 | int(ambient.g * 255) &lt;&lt; 8 | int(ambient.b * 255));</span></span><br><span class="line">		fcolor = <span class="built_in">GetHEXColor</span>(<span class="built_in">Colour</span>(ambient.r, ambient.g, ambient.b)); <span class="comment">// simple functions of the code above</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_framebuffer[y][x] = fcolor;</span><br><span class="line">	z = p.<span class="built_in">getZ</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here is the detail of the ‘Point-by-Point Comparison Method To Draw A Line’:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">// Draw line via Point-by-Point Comparison Method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawLine</span><span class="params">(<span class="type">const</span> Vector4&amp; p1, <span class="type">const</span> Vector4&amp; p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Colour color = <span class="built_in">GetColorFromHEX</span>(m_foregroundColour);</span><br><span class="line"></span><br><span class="line">	Texcoord tex = &#123; <span class="number">0.f</span>, <span class="number">0.f</span> &#125;;</span><br><span class="line">	<span class="function">Vector3 <span class="title">normal</span><span class="params">(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">	x1 = (<span class="type">int</span>)p1.<span class="built_in">getX</span>();</span><br><span class="line">	y1 = (<span class="type">int</span>)p1.<span class="built_in">getY</span>();</span><br><span class="line">	x2 = (<span class="type">int</span>)p2.<span class="built_in">getX</span>();</span><br><span class="line">	y2 = (<span class="type">int</span>)p2.<span class="built_in">getY</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> y, x;</span><br><span class="line">	y = p1.<span class="built_in">getY</span>();</span><br><span class="line">	x = p1.<span class="built_in">getX</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2) &#123;</span><br><span class="line">		<span class="built_in">DrawPoint</span>(p1, color, tex, normal);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x1 == x2) &#123;</span><br><span class="line">		<span class="built_in">DrawPoint</span>(p1, color, tex, normal);</span><br><span class="line">		<span class="type">int</span> increment = (y1 &lt; y2) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			y += increment;</span><br><span class="line">			<span class="keyword">if</span> (increment == <span class="number">1</span> &amp;&amp; y &gt;= y2) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (increment == <span class="number">-1</span> &amp;&amp; y &lt;= y2) <span class="keyword">break</span>;</span><br><span class="line">			<span class="function">Vector4 <span class="title">p</span><span class="params">(x, y, <span class="number">0.f</span>, <span class="number">1.f</span>)</span></span>;</span><br><span class="line">			<span class="built_in">DrawPoint</span>(p, color, tex, normal);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">DrawPoint</span>(p2, color, tex, normal);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (y1 == y2) &#123;</span><br><span class="line">		<span class="built_in">DrawPoint</span>(p1, color, tex, normal);</span><br><span class="line">		<span class="type">int</span> increment = (x1 &lt; x2) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			x += increment;</span><br><span class="line">			<span class="keyword">if</span> (increment == <span class="number">1</span> &amp;&amp; x &gt;= x2) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (increment == <span class="number">-1</span> &amp;&amp; x &lt;= x2) <span class="keyword">break</span>;</span><br><span class="line">			<span class="function">Vector4 <span class="title">p</span><span class="params">(x, y, <span class="number">0.f</span>, <span class="number">1.f</span>)</span></span>;</span><br><span class="line">			<span class="built_in">DrawPoint</span>(p, color, tex, normal);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">DrawPoint</span>(p2, color, tex, normal);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">DrawPoint</span>(p1, color, tex, normal);</span><br><span class="line">		<span class="type">float</span> t = (<span class="type">float</span>)<span class="built_in">abs</span>(x2 - x1) / <span class="built_in">abs</span>(y2 - y1);</span><br><span class="line">		<span class="type">int</span> xIncrement = (p1.<span class="built_in">getX</span>() &lt; p2.<span class="built_in">getX</span>()) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">		<span class="type">int</span> yIncrement = (p1.<span class="built_in">getY</span>() &lt; p2.<span class="built_in">getY</span>()) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			y += yIncrement;</span><br><span class="line">			<span class="keyword">if</span> (yIncrement == <span class="number">1</span> &amp;&amp; y &gt;= y2) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (yIncrement == <span class="number">-1</span> &amp;&amp; y &lt;= y2) <span class="keyword">break</span>;</span><br><span class="line">			x += t * xIncrement;</span><br><span class="line">			<span class="function">Vector4 <span class="title">p</span><span class="params">(x, y, <span class="number">0.f</span>, <span class="number">1.f</span>)</span></span>;</span><br><span class="line">			<span class="built_in">DrawPoint</span>(p, color, tex, normal);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">DrawPoint</span>(p2, color, tex, normal);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>You can also choose another ways to draw line. In the final project, I separated the conduction on the pixel in the way below: </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="type">void</span> <span class="title">DrawPixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> hexColor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((x &lt; m_width) &amp;&amp; ((y &lt; m_height)) &amp;&amp; ((x &gt;= <span class="number">0</span>)) &amp;&amp; ((y &gt;= <span class="number">0</span>)))</span><br><span class="line">	&#123;</span><br><span class="line">		m_framebuffer[y][x] = hexColor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawPixel</span><span class="params">(<span class="type">const</span> Vector2 &amp; point, <span class="type">unsigned</span> <span class="type">int</span> hexColor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = (<span class="type">int</span>)point.<span class="built_in">getX</span>();</span><br><span class="line">	<span class="type">int</span> y = (<span class="type">int</span>)point.<span class="built_in">getY</span>();</span><br><span class="line">	<span class="built_in">DrawPixel</span>(x, y, hexColor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawPixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Colour &amp; color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((x &lt; m_width) &amp;&amp; ((y &lt; m_height))</span><br><span class="line">		&amp;&amp; ((x &gt;= <span class="number">0</span>)) &amp;&amp; ((y &gt;= <span class="number">0</span>)))</span><br><span class="line">	&#123;</span><br><span class="line">		m_framebuffer[y][x] = <span class="built_in">GetHEXColor</span>(color);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawPixel</span><span class="params">(<span class="type">const</span> Vector2 &amp; point, <span class="type">const</span> Colour &amp; color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = (<span class="type">int</span>)point.<span class="built_in">getX</span>();</span><br><span class="line">	<span class="type">int</span> y = (<span class="type">int</span>)point.<span class="built_in">getY</span>();</span><br><span class="line">	<span class="built_in">DrawPixel</span>(x, y, color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Besides this way, you can use <code>Bresenhem Way</code> to draw the line, here are the details:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="type">void</span> <span class="title">DrawBresenhemLine</span><span class="params">(<span class="type">const</span> Vector4 &amp; startPoint, <span class="type">const</span> Vector4 &amp; endPoint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (startPoint == endPoint)	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> x0 = (<span class="type">int</span>)startPoint.<span class="built_in">getX</span>();</span><br><span class="line">	<span class="type">int</span> y0 = (<span class="type">int</span>)startPoint.<span class="built_in">getY</span>();</span><br><span class="line">	<span class="type">int</span> x1 = (<span class="type">int</span>)endPoint.<span class="built_in">getX</span>();</span><br><span class="line">	<span class="type">int</span> y1 = (<span class="type">int</span>)endPoint.<span class="built_in">getY</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> steep = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (std::<span class="built_in">abs</span>(x0 - x1) &lt; std::<span class="built_in">abs</span>(y0 - y1))</span><br><span class="line">	&#123;</span><br><span class="line">		std::<span class="built_in">swap</span>(x0, y0);</span><br><span class="line">		std::<span class="built_in">swap</span>(x1, y1);</span><br><span class="line">		steep = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (x0 &gt; x1)</span><br><span class="line">	&#123;</span><br><span class="line">		std::<span class="built_in">swap</span>(x0, x1);</span><br><span class="line">		std::<span class="built_in">swap</span>(y0, y1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> dx = x1 - x0;</span><br><span class="line">	<span class="type">int</span> dy = y1 - y0;</span><br><span class="line">	<span class="type">int</span> derror2 = std::<span class="built_in">abs</span>(dy) * <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> error2 = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> y = y0;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x = x0; x &lt;= x1; ++x) &#123;</span><br><span class="line">		<span class="keyword">if</span> (steep) &#123;</span><br><span class="line">			<span class="function">Colour <span class="title">co</span><span class="params">(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>)</span></span>;</span><br><span class="line">			<span class="comment">//DrawPixel(y, x, GetColorIntensity(co)); // way 1</span></span><br><span class="line">			<span class="function">Vector4 <span class="title">p</span><span class="params">((<span class="type">float</span>)y, (<span class="type">float</span>)x, <span class="number">0.f</span>, <span class="number">0.f</span>)</span></span>;</span><br><span class="line">			<span class="built_in">DrawPoint</span>(p, co); <span class="comment">// way 2</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Colour <span class="built_in">co</span>(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>);</span><br><span class="line">			<span class="comment">//DrawPixel(x, y, GetColorIntensity(co)); // way 1</span></span><br><span class="line">			<span class="function">Vector4 <span class="title">p</span><span class="params">((<span class="type">float</span>)x, (<span class="type">float</span>)y, <span class="number">0.f</span>, <span class="number">0.f</span>)</span></span>;</span><br><span class="line">			<span class="built_in">DrawPoint</span>(p, co); <span class="comment">// way 2</span></span><br><span class="line">		&#125;</span><br><span class="line">		error2 += derror2;</span><br><span class="line">		<span class="keyword">if</span> (error2 &gt; dx) &#123;</span><br><span class="line">			y += (y1 &gt; y0 ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">			error2 -= dx * <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The way to draw line in Bresenhem way shown above can even be optimized to the codes below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawBresenhemLineInUnoptimizedWay</span><span class="params">(<span class="type">const</span> Vector4 &amp; startPoint, <span class="type">const</span> Vector4 &amp; endPoint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (startPoint == endPoint)	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> x1 = startPoint.<span class="built_in">getX</span>();</span><br><span class="line">	<span class="type">float</span> y1 = startPoint.<span class="built_in">getY</span>();</span><br><span class="line">	<span class="type">float</span> x2 = endPoint.<span class="built_in">getX</span>();</span><br><span class="line">	<span class="type">float</span> y2 = endPoint.<span class="built_in">getY</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> xTemp, yTemp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*1：Draw the line segment with no slope.*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (x1 == x2)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// avoid oversteping the boundary of visual plane</span></span><br><span class="line">		<span class="keyword">if</span> (x1 &gt; m_width || x1 &lt; <span class="number">0</span>)	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (y1 &gt; y2)</span><br><span class="line">		&#123;</span><br><span class="line">			yTemp = y1;</span><br><span class="line">			y1 = y2;</span><br><span class="line">			y2 = yTemp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">float</span> y = y1; y &lt; y2&amp;&amp;y &lt; m_height&amp;&amp; y &gt;= <span class="number">0</span>; ++y)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">DrawPixel</span>(<span class="built_in">Vector2</span>(x1, y), <span class="built_in">Colour</span>(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*2：Draw the line segment with no slope.*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// stipulate X1&lt;X2, otherwise, swap them</span></span><br><span class="line">	<span class="keyword">if</span> (x1 &gt; x2)</span><br><span class="line">	&#123;</span><br><span class="line">		xTemp = x1;</span><br><span class="line">		x1 = x2;</span><br><span class="line">		x2 = xTemp;</span><br><span class="line"></span><br><span class="line">		yTemp = y1;</span><br><span class="line">		y1 = y2;</span><br><span class="line">		y2 = yTemp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> k = (y2 - y1) / (x2 - x1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1：as the gradient factor is less than 1 or bigger than 0</span></span><br><span class="line">	<span class="keyword">if</span> (k &gt;= <span class="number">0.0f</span>&amp;&amp;k &lt;= <span class="number">1.f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// draw pixel crosswise from x1 to x2 with attention of limiting inside window width</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">float</span> x = x1, y = y1; x &lt;= x2 &amp;&amp; x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m_width; ++x)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">float</span> dis = (x - x1) * k + y1 - y;</span><br><span class="line">			<span class="keyword">if</span> (dis &gt;= <span class="number">0.5</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				++y;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">DrawPixel</span>(<span class="built_in">Vector2</span>(x, y), <span class="built_in">Colour</span>(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2：as the gradient factor is less than 0 or bigger than -1</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (k &lt; <span class="number">0.0f</span>&amp;&amp;k &gt;= <span class="number">-1.f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">float</span> x = x1, y = y1; x &lt;= x2 &amp;&amp; x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m_width; ++x)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">float</span> dis = (x - x1)*k + y1 - y;</span><br><span class="line">			<span class="keyword">if</span> (dis &lt; <span class="number">-0.5</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				--y;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">DrawPixel</span>(<span class="built_in">Vector2</span>(x, y), <span class="built_in">Colour</span>(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3：as the gradient factor is bigger than -1</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (k &gt; <span class="number">1.f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">float</span> k1 = <span class="number">1.f</span> / k;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">float</span> y = y1, x = x1; y &lt;= y2 &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m_height; ++y)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">float</span> dis = (y - y1)*k1 + x1 - x;</span><br><span class="line">			<span class="keyword">if</span> (dis &gt;= <span class="number">0.5</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				++x;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">DrawPixel</span>(<span class="built_in">Vector2</span>(x, y), <span class="built_in">Colour</span>(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4：as the gradient factor is less than -1</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (k &lt; <span class="number">-1.f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">float</span> k1 = <span class="number">1.f</span> / k;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">float</span> y = y2, x = x2; y &lt;= y1 &amp;&amp; y &lt; m_height &amp;&amp; y &gt;= <span class="number">0</span>; ++y)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">float</span> dis = (y - y2)*k1 + x2 - x;</span><br><span class="line">			<span class="keyword">if</span> (dis &lt;= <span class="number">-0.5</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				--x;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">DrawPixel</span>(<span class="built_in">Vector2</span>(x, y), <span class="built_in">Colour</span>(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Once we are able to draw lines, we are able to draw triangles, too. By calling the method of drawing lines three times can we build out a triangle we want:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//           startPoint,            endPoint</span></span><br><span class="line">   <span class="built_in">DrawLine</span>(homogenizedVertPos1, homogenizedVertPos2);</span><br><span class="line"><span class="built_in">DrawLine</span>(homogenizedVertPos1, homogenizedVertPos3);</span><br><span class="line"><span class="built_in">DrawLine</span>(homogenizedVertPos2, homogenizedVertPos3);</span><br></pre></td></tr></table></figure>

<br>

<p>Apart from this, we can use <code>Scan-line Way</code> to <strong>rasterize triangles on screen</strong>, which is <strong>the core of our rendering</strong>. The detail of the scan-line way is shown below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanlineFill</span><span class="params">(<span class="type">const</span> Vertex &amp; leftPoint, <span class="type">const</span>  Vertex &amp; rightPoint, <span class="type">const</span> <span class="type">int</span> yIndex, <span class="type">const</span> Colour** texture)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> lineWidth = rightPoint.pos.<span class="built_in">getX</span>() - leftPoint.pos.<span class="built_in">getX</span>();</span><br><span class="line">	<span class="type">float</span> step = <span class="number">1.f</span>;</span><br><span class="line">	<span class="keyword">if</span> (lineWidth &gt; <span class="number">0.f</span>) step = <span class="number">1.f</span> / lineWidth;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">float</span> x = leftPoint.pos.<span class="built_in">getX</span>(); x &lt;= rightPoint.pos.<span class="built_in">getX</span>(); x++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> xIndex = (<span class="type">int</span>)(x + <span class="number">0.5f</span>);</span><br><span class="line">		<span class="type">float</span> lerpFactor = (x - leftPoint.pos.<span class="built_in">getX</span>()) / lineWidth;</span><br><span class="line">		<span class="type">float</span> zValue = <span class="built_in">Lerp</span>(leftPoint.pos.<span class="built_in">getZ</span>(), rightPoint.pos.<span class="built_in">getZ</span>(), lerpFactor);</span><br><span class="line">		<span class="keyword">if</span> (xIndex &gt;= <span class="number">0</span> &amp;&amp; xIndex &lt; m_width &amp;&amp; zValue &gt; <span class="number">0.f</span> &amp;&amp; zValue &lt; <span class="number">1.f</span>) <span class="comment">// clip again</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">float</span> rhwTemp = <span class="built_in">Lerp</span>(leftPoint.rhw, rightPoint.rhw, lerpFactor);</span><br><span class="line"></span><br><span class="line">			<span class="type">float</span>&amp; zInBuffer = m_zbuffer[yIndex * m_width + xIndex];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (zValue &lt; zInBuffer)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// Perpective correction! ---&gt; useless in orthographic mode</span></span><br><span class="line">				<span class="type">float</span> w = <span class="number">1.f</span> / rhwTemp;</span><br><span class="line"></span><br><span class="line">				zInBuffer = zValue; <span class="comment">// write into z-buffer</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// uv interpolation to get the texture color (multiplies w to gain perspective correction of uv-texcture)</span></span><br><span class="line">				<span class="type">float</span> u = <span class="built_in">Lerp</span>(leftPoint.tex.u, rightPoint.tex.u, lerpFactor) * w * (textureWidth - <span class="number">1</span>);</span><br><span class="line">				<span class="type">float</span> v = <span class="built_in">Lerp</span>(leftPoint.tex.v, rightPoint.tex.v, lerpFactor) * w * (textureHeight - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">				<span class="type">int</span> uIndex = (<span class="type">int</span>)(u + <span class="number">0.5f</span>); <span class="comment">// maybe this is more effective than (int)roundf(fNum) </span></span><br><span class="line">				<span class="type">int</span> vIndex = (<span class="type">int</span>)(v + <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">				<span class="function">Colour <span class="title">vertexColor</span><span class="params">(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (uIndex &lt;= textureWidth - <span class="number">1</span> &amp;&amp; uIndex &gt;= <span class="number">0</span></span><br><span class="line">					&amp;&amp; vIndex &lt;= textureHeight - <span class="number">1</span> &amp;&amp; vIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (mLightOn)</span><br><span class="line">						vertexColor = <span class="built_in">Lerp</span>(leftPoint.color, rightPoint.color, lerpFactor);</span><br><span class="line"></span><br><span class="line">					Colour texColor;</span><br><span class="line">					<span class="keyword">if</span> (m_interp == INTERP_BILINEAR) &#123;</span><br><span class="line">						Colour** m_texture = (Colour**)texture;</span><br><span class="line">						texColor = <span class="built_in">BilinearInterp</span>(m_texture, textureWidth, textureHeight, u, v);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						texColor = texture[uIndex][vIndex];</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="type">float</span> xHere = <span class="built_in">Lerp</span>(leftPoint.posInWorldSpace.<span class="built_in">getX</span>(), rightPoint.posInWorldSpace.<span class="built_in">getX</span>(), lerpFactor);</span><br><span class="line">					<span class="type">float</span> yHere = <span class="built_in">Lerp</span>(leftPoint.posInWorldSpace.<span class="built_in">getY</span>(), rightPoint.posInWorldSpace.<span class="built_in">getY</span>(), lerpFactor);</span><br><span class="line">					<span class="type">float</span> zHere = <span class="built_in">Lerp</span>(leftPoint.posInWorldSpace.<span class="built_in">getZ</span>(), rightPoint.posInWorldSpace.<span class="built_in">getZ</span>(), lerpFactor);</span><br><span class="line">					posInWorldSpace = <span class="built_in">Vector4</span>(xHere, yHere, zHere, <span class="number">1.f</span>); <span class="comment">// For showing shadow of the models on the floor</span></span><br><span class="line"></span><br><span class="line">					<span class="built_in">Vector4DotMatrix4f</span>(lightScreenPosBeforsHomogenized, posInWorldSpace, lightSpaceMatrix);</span><br><span class="line">					m_transform-&gt;<span class="built_in">Homogenize</span>(posInLightScreen, lightScreenPosBeforsHomogenized);</span><br><span class="line"></span><br><span class="line">					<span class="type">int</span> hX = (<span class="type">int</span>)(posInLightScreen.<span class="built_in">getX</span>() + <span class="number">0.5f</span>);</span><br><span class="line">					<span class="type">int</span> hY = (<span class="type">int</span>)(posInLightScreen.<span class="built_in">getY</span>() + <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">					<span class="type">float</span> bias = <span class="built_in">GetBiasDynamically</span>(biasDelta, rightPoint.normal, leftPoint.normal, lerpFactor);</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (hX &gt; <span class="number">0</span> &amp;&amp; hY &gt; <span class="number">0</span> &amp;&amp; hX &lt; m_width &amp;&amp; hY &lt; m_height) &#123;</span><br><span class="line">						<span class="keyword">if</span> (posInLightScreen.<span class="built_in">getZ</span>() - bias &gt; depthBufferFromLightPos[hY * m_width + hX])</span><br><span class="line">							texColor *= <span class="built_in">Colour</span>(<span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					m_framebuffer[yIndex][xIndex] = <span class="built_in">GetHEXColor</span>(vertexColor * texColor);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>You can see that we conduct <code>Bilinear Interpolcation</code> in rasterization stage, its a way of avoiding the edges of the texture mapped on the models&#x2F;pbjects. The details of ‘Bilinear Interpolcation’ is shown below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Colour <span class="title">BilinearInterp</span><span class="params">(Colour** textureColorData, <span class="type">const</span> <span class="type">int</span> textureWidth, <span class="type">const</span> <span class="type">int</span> textureHeight, <span class="type">const</span> <span class="type">float</span> u, <span class="type">const</span> <span class="type">float</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//float y = u * textureHeight, x = v * textureWidth;</span></span><br><span class="line">	<span class="type">float</span> y = v, x = u;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> x0 = (<span class="type">int</span>)<span class="built_in">floorf</span>(x);</span><br><span class="line">	<span class="type">int</span> y0 = (<span class="type">int</span>)<span class="built_in">floorf</span>(y);</span><br><span class="line">	<span class="type">int</span> x1 = x0 + <span class="number">1</span>, y1 = y0 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// border correction</span></span><br><span class="line">	<span class="keyword">if</span> (x0 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		x0 = <span class="number">0</span>;</span><br><span class="line">		x1 = <span class="number">1</span>;</span><br><span class="line">		x = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (y0 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		y0 = <span class="number">0</span>;</span><br><span class="line">		y1 = <span class="number">1</span>;</span><br><span class="line">		y = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (x1 &gt; textureWidth - <span class="number">1</span>) &#123;</span><br><span class="line">		x1 = textureWidth - <span class="number">1</span>;</span><br><span class="line">		x0 = textureWidth - <span class="number">2</span>;</span><br><span class="line">		x = (<span class="type">float</span>)textureWidth - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (y1 &gt; textureHeight - <span class="number">1</span>) &#123;</span><br><span class="line">		y1 = textureHeight - <span class="number">1</span>;</span><br><span class="line">		y0 = textureHeight - <span class="number">2</span>;</span><br><span class="line">		y = (<span class="type">float</span>)textureHeight - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> w00 = (<span class="type">float</span>)((y1 - y) * (x1 - x));</span><br><span class="line">	<span class="type">float</span> w01 = (<span class="type">float</span>)((y1 - y) * (x - x0));</span><br><span class="line">	<span class="type">float</span> w11 = (<span class="type">float</span>)((y - y0) * (x - x0));</span><br><span class="line">	<span class="type">float</span> w10 = (<span class="type">float</span>)((y - y0) * (x1 - x));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Colour c00 = textureColorData[x0][y0];</span><br><span class="line">	Colour c01 = textureColorData[x1][y0];</span><br><span class="line">	Colour c10 = textureColorData[x0][y1];</span><br><span class="line">	Colour c11 = textureColorData[x1][y1];</span><br><span class="line"></span><br><span class="line">	Colour interpedResult00 = c00 * w00;</span><br><span class="line">	Colour interpedResult01 = c01 * w01;</span><br><span class="line">	Colour interpedResult10 = c10 * w10;</span><br><span class="line">	Colour interpedResult11 = c11 * w11;</span><br><span class="line"></span><br><span class="line">	Colour c = interpedResult00 + interpedResult01 + interpedResult10 + interpedResult11;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>When rasterizing, notice that the lerping is also needed in screen space for acquiring a correct pixel position on screen. More details of Lerping and resterizing triangles are shown below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="type">float</span> <span class="title">Lerp</span><span class="params">(<span class="type">const</span> <span class="type">float</span> a, <span class="type">const</span> <span class="type">float</span> b, <span class="type">const</span> <span class="type">float</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t &lt;= <span class="number">0.f</span>) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (t &gt;= <span class="number">1.f</span>) <span class="keyword">return</span> b;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">return</span> (b - a) * t + a; <span class="comment">// optimized</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Vector4 <span class="title">Lerp</span><span class="params">(<span class="type">const</span> Vector4 vecA, <span class="type">const</span> Vector4 vecB, <span class="type">const</span> <span class="type">float</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Vector4 <span class="title">result</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		Lerp(vecA.getX(), vecB.getX(), t),</span></span></span><br><span class="line"><span class="params"><span class="function">		Lerp(vecA.getY(), vecB.getY(), t),</span></span></span><br><span class="line"><span class="params"><span class="function">		Lerp(vecA.getZ(), vecB.getZ(), t),</span></span></span><br><span class="line"><span class="params"><span class="function">		Lerp(vecA.getW(), vecB.getW(), t)</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">Vertex <span class="title">Lerp</span><span class="params">(<span class="type">const</span> Vertex vecA, <span class="type">const</span> Vertex  vecB, <span class="type">const</span> <span class="type">float</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Vertex result&#123;</span><br><span class="line">		<span class="built_in">Lerp</span>(vecA.pos, vecB.pos, t),</span><br><span class="line">		<span class="built_in">Lerp</span>(vecA.color, vecB.color, t),</span><br><span class="line">		<span class="built_in">Lerp</span>(vecA.tex.u, vecB.tex.u, t),</span><br><span class="line">		<span class="built_in">Lerp</span>(vecA.tex.v, vecB.tex.v, t),</span><br><span class="line">		<span class="built_in">Lerp</span>(vecA.normal, vecB.normal, t),</span><br><span class="line">		<span class="built_in">Lerp</span>(vecA.rhw, vecB.rhw, t),</span><br><span class="line">		<span class="built_in">Lerp</span>(vecA.posInWorldSpace, vecB.posInWorldSpace, t)</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function">Colour <span class="title">Lerp</span><span class="params">(<span class="type">const</span> Colour&amp; a, <span class="type">const</span> Colour&amp; b, <span class="type">float</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Colour result;</span><br><span class="line">	result.r = <span class="built_in">Lerp</span>(a.r, b.r, t);</span><br><span class="line">	result.g = <span class="built_in">Lerp</span>(a.g, b.g, t);</span><br><span class="line">	result.b = <span class="built_in">Lerp</span>(a.b, b.b, t);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LerpVertexInScreenSpace</span><span class="params">(Vertex &amp; v, <span class="type">const</span> Vertex &amp; v1, <span class="type">const</span> Vertex &amp; v2, <span class="type">float</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//optimized below ---&gt; using the inline Lerp functions rather than the one from Math.h</span></span><br><span class="line">	v.rhw = <span class="built_in">Lerp</span>(v1.rhw, v2.rhw, t);</span><br><span class="line">	v.tex.u = <span class="built_in">Lerp</span>(v1.tex.u, v2.tex.u, t);</span><br><span class="line">	v.tex.v = <span class="built_in">Lerp</span>(v1.tex.v, v2.tex.v, t);</span><br><span class="line">	v.color = <span class="built_in">Lerp</span>(v1.color, v2.color, t);</span><br><span class="line">	v.pos = <span class="built_in">Lerp</span>(v1.pos, v2.pos, t);</span><br><span class="line">	v.normal = <span class="built_in">Lerp</span>(v1.normal, v2.normal, t); <span class="comment">// comment this line to stay normal unchanged(in world space)</span></span><br><span class="line">	v.posInWorldSpace = <span class="built_in">Lerp</span>(v1.posInWorldSpace, v2.posInWorldSpace, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">DrawTopTriangle</span><span class="params">(<span class="type">const</span> Vertex &amp; p1, <span class="type">const</span> Vertex &amp; p2, <span class="type">const</span> Vertex &amp; p3, <span class="type">const</span> Colour** texture)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">float</span> y = p1.pos.<span class="built_in">getY</span>(); y &lt;= p3.pos.<span class="built_in">getY</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m_height; y += <span class="number">0.5f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> yIndex = (<span class="type">int</span>)<span class="built_in">roundf</span>(y);</span><br><span class="line">		<span class="keyword">if</span> (yIndex &gt;= <span class="number">0</span> &amp;&amp; yIndex &lt; m_height)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">float</span> xl = (y - p1.pos.<span class="built_in">getY</span>()) * (p3.pos.<span class="built_in">getX</span>() - p1.pos.<span class="built_in">getX</span>()) / (p3.pos.<span class="built_in">getY</span>() - p1.pos.<span class="built_in">getY</span>()) + p1.pos.<span class="built_in">getX</span>();</span><br><span class="line">			<span class="type">float</span> x2 = (y - p2.pos.<span class="built_in">getY</span>()) * (p3.pos.<span class="built_in">getX</span>() - p2.pos.<span class="built_in">getX</span>()) / (p3.pos.<span class="built_in">getY</span>() - p2.pos.<span class="built_in">getY</span>()) + p2.pos.<span class="built_in">getX</span>();</span><br><span class="line"></span><br><span class="line">			<span class="type">float</span> dy = y - p1.pos.<span class="built_in">getY</span>();</span><br><span class="line">			<span class="type">float</span> t = dy / (p3.pos.<span class="built_in">getY</span>() - p1.pos.<span class="built_in">getY</span>());</span><br><span class="line"></span><br><span class="line">			<span class="comment">// get the right and left point via interpolation</span></span><br><span class="line">			Vertex new1;</span><br><span class="line">			new1.pos.<span class="built_in">setX</span>(xl);</span><br><span class="line">			new1.pos.<span class="built_in">setY</span>(y);</span><br><span class="line">			<span class="built_in">LerpVertexInScreenSpace</span>(new1, p1, p3, t);</span><br><span class="line"></span><br><span class="line">			Vertex new2;</span><br><span class="line">			new2.pos.<span class="built_in">setX</span>(x2);</span><br><span class="line">			new2.pos.<span class="built_in">setY</span>(y);</span><br><span class="line">			<span class="built_in">LerpVertexInScreenSpace</span>(new2, p2, p3, t);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (new1.pos.<span class="built_in">getX</span>() &lt; new2.pos.<span class="built_in">getX</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">ScanlineFill</span>(new1, new2, yIndex, texture);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">ScanlineFill</span>(new2, new1, yIndex, texture);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawBottomTriangle</span><span class="params">(<span class="type">const</span> Vertex &amp; p1, <span class="type">const</span> Vertex &amp; p2, <span class="type">const</span> Vertex &amp; p3, <span class="type">const</span> Colour** texture)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">float</span> y = p1.pos.<span class="built_in">getY</span>(); y &lt;= p2.pos.<span class="built_in">getY</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m_height; y += <span class="number">0.5f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> yIndex = (<span class="type">int</span>)<span class="built_in">roundf</span>(y);</span><br><span class="line">		<span class="keyword">if</span> (yIndex &gt;= <span class="number">0</span> &amp;&amp; yIndex &lt; m_height)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">float</span> xl = (y - p1.pos.<span class="built_in">getY</span>()) * (p2.pos.<span class="built_in">getX</span>() - p1.pos.<span class="built_in">getX</span>()) / (p2.pos.<span class="built_in">getY</span>() - p1.pos.<span class="built_in">getY</span>()) + p1.pos.<span class="built_in">getX</span>();</span><br><span class="line">			<span class="type">float</span> x2 = (y - p1.pos.<span class="built_in">getY</span>()) * (p3.pos.<span class="built_in">getX</span>() - p1.pos.<span class="built_in">getX</span>()) / (p3.pos.<span class="built_in">getY</span>() - p1.pos.<span class="built_in">getY</span>()) + p1.pos.<span class="built_in">getX</span>();</span><br><span class="line"></span><br><span class="line">			<span class="type">float</span> dy = y - p1.pos.<span class="built_in">getY</span>();</span><br><span class="line">			<span class="type">float</span> t = dy / (p2.pos.<span class="built_in">getY</span>() - p1.pos.<span class="built_in">getY</span>());</span><br><span class="line"></span><br><span class="line">			<span class="comment">// get the right and left point via interpolation</span></span><br><span class="line">			Vertex new1;</span><br><span class="line">			new1.pos.<span class="built_in">setX</span>(xl);</span><br><span class="line">			new1.pos.<span class="built_in">setY</span>(y);</span><br><span class="line">			<span class="built_in">LerpVertexInScreenSpace</span>(new1, p1, p2, t);</span><br><span class="line"></span><br><span class="line">			Vertex new2;</span><br><span class="line">			new2.pos.<span class="built_in">setX</span>(x2);</span><br><span class="line">			new2.pos.<span class="built_in">setY</span>(y);</span><br><span class="line">			<span class="built_in">LerpVertexInScreenSpace</span>(new2, p1, p3, t);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (new1.pos.<span class="built_in">getX</span>() &lt; new2.pos.<span class="built_in">getX</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">ScanlineFill</span>(new1, new2, yIndex, texture);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">ScanlineFill</span>(new2, new1, yIndex, texture);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TriangleRasterization</span><span class="params">(<span class="type">const</span> Vertex &amp; p1, <span class="type">const</span> Vertex &amp; p2, <span class="type">const</span> Vertex &amp; p3, <span class="type">const</span> Colour** texture)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p1.pos.<span class="built_in">getY</span>() == p2.pos.<span class="built_in">getY</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p1.pos.<span class="built_in">getY</span>() &lt; p3.pos.<span class="built_in">getY</span>())</span><br><span class="line">		&#123;<span class="comment">// Flat top</span></span><br><span class="line">			<span class="built_in">DrawTopTriangle</span>(p1, p2, p3, texture);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;<span class="comment">// Flat bottom</span></span><br><span class="line">			<span class="built_in">DrawBottomTriangle</span>(p3, p1, p2, texture);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (p1.pos.<span class="built_in">getY</span>() == p3.pos.<span class="built_in">getY</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p1.pos.<span class="built_in">getY</span>() &lt; p2.pos.<span class="built_in">getY</span>())</span><br><span class="line">		&#123;<span class="comment">// Flat top</span></span><br><span class="line">			<span class="built_in">DrawTopTriangle</span>(p1, p3, p2, texture);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;<span class="comment">// Flat bottom</span></span><br><span class="line">			<span class="built_in">DrawBottomTriangle</span>(p2, p1, p3, texture);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (p2.pos.<span class="built_in">getY</span>() == p3.pos.<span class="built_in">getY</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p2.pos.<span class="built_in">getY</span>() &lt; p1.pos.<span class="built_in">getY</span>())</span><br><span class="line">		&#123;<span class="comment">// Flat top</span></span><br><span class="line">			<span class="built_in">DrawTopTriangle</span>(p2, p3, p1, texture);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;<span class="comment">// Flat bottom</span></span><br><span class="line">			<span class="built_in">DrawBottomTriangle</span>(p1, p2, p3, texture);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;<span class="comment">// Segment the triangle </span></span><br><span class="line">		Vertex top;</span><br><span class="line"></span><br><span class="line">		Vertex bottom;</span><br><span class="line">		Vertex middle;</span><br><span class="line">		<span class="keyword">if</span> (p1.pos.<span class="built_in">getY</span>() &gt; p2.pos.<span class="built_in">getY</span>() &amp;&amp; p2.pos.<span class="built_in">getY</span>() &gt; p3.pos.<span class="built_in">getY</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			top = p3;</span><br><span class="line">			middle = p2;</span><br><span class="line">			bottom = p1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p3.pos.<span class="built_in">getY</span>() &gt; p2.pos.<span class="built_in">getY</span>() &amp;&amp; p2.pos.<span class="built_in">getY</span>() &gt; p1.pos.<span class="built_in">getY</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			top = p1;</span><br><span class="line">			middle = p2;</span><br><span class="line">			bottom = p3;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p2.pos.<span class="built_in">getY</span>() &gt; p1.pos.<span class="built_in">getY</span>() &amp;&amp; p1.pos.<span class="built_in">getY</span>() &gt; p3.pos.<span class="built_in">getY</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			top = p3;</span><br><span class="line">			middle = p1;</span><br><span class="line">			bottom = p2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p3.pos.<span class="built_in">getY</span>() &gt; p1.pos.<span class="built_in">getY</span>() &amp;&amp; p1.pos.<span class="built_in">getY</span>() &gt; p2.pos.<span class="built_in">getY</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			top = p2;</span><br><span class="line">			middle = p1;</span><br><span class="line">			bottom = p3;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p1.pos.<span class="built_in">getY</span>() &gt; p3.pos.<span class="built_in">getY</span>() &amp;&amp; p3.pos.<span class="built_in">getY</span>() &gt; p2.pos.<span class="built_in">getY</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			top = p2;</span><br><span class="line">			middle = p3;</span><br><span class="line">			bottom = p1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p2.pos.<span class="built_in">getY</span>() &gt; p3.pos.<span class="built_in">getY</span>() &amp;&amp; p3.pos.<span class="built_in">getY</span>() &gt; p1.pos.<span class="built_in">getY</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			top = p1;</span><br><span class="line">			middle = p3;</span><br><span class="line">			bottom = p2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 3 points colinear</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// get middle X by interpolation, get coeffiecient-t first</span></span><br><span class="line">		<span class="type">float</span> middleX = (middle.pos.<span class="built_in">getY</span>() - top.pos.<span class="built_in">getY</span>()) * (bottom.pos.<span class="built_in">getX</span>() - top.pos.<span class="built_in">getX</span>()) / (bottom.pos.<span class="built_in">getY</span>() - top.pos.<span class="built_in">getY</span>()) + top.pos.<span class="built_in">getX</span>();</span><br><span class="line">		<span class="type">float</span> dy = middle.pos.<span class="built_in">getY</span>() - top.pos.<span class="built_in">getY</span>();</span><br><span class="line">		<span class="type">float</span> t = dy / (bottom.pos.<span class="built_in">getY</span>() - top.pos.<span class="built_in">getY</span>());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// get the right and left point via interpolation</span></span><br><span class="line">		Vertex newMiddle;</span><br><span class="line">		newMiddle.pos.<span class="built_in">setX</span>(middleX);</span><br><span class="line">		newMiddle.pos.<span class="built_in">setY</span>(middle.pos.<span class="built_in">getY</span>());</span><br><span class="line">		newMiddle.normal = middle.normal;</span><br><span class="line">		<span class="built_in">LerpVertexInScreenSpace</span>(newMiddle, top, bottom, t);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DrawBottomTriangle</span>(top, newMiddle, middle, texture);</span><br><span class="line">		<span class="built_in">DrawTopTriangle</span>(newMiddle, middle, bottom, texture);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>


<p>The final process of the rasterization stage is kind of like image processing, its main difference with the image processing is that the rasterization stage process vertices gain in geomotry stage, which means that the pixels are created and converted manually by the real vertices, while the image processing is to process an image from an pure pixel container: image itself. But there is no doubt that many conductions of image processing can be integrated from rasterization stage.</p>
<br>
<br>
<br>
<br>
<br>
<br>



<p align="right">© Alexander Ezharjan</p>
<p align="right">31st, March, 2022</p>




<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></h6></h6>]]></content>
      <categories>
        <category>Computer Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>Ways to Reduce Similarity of Papers Submitted via Turnitin</title>
    <url>/Blog/2023/03/13/Ways-to-Reduce-Similarity-of-Papers-Submitted-via-Turnitin/</url>
    <content><![CDATA[<h6 align="center">Editor: Alexander Ezharjan<h6>


<p>Using this method, the similarity index will be reduced enormously:</p>
<p><strong>Experimental Use Only</strong></p>
<ol>
<li>Write using Word;</li>
<li>Export as PDF in Word;</li>
<li>Open exported PDF;</li>
<li>Export all the pages into multiple JPEG files;</li>
<li>Create a new Word document and set its style of all borders to 0cm;</li>
<li>Integrate all the JPEG files into the the Word document at once;</li>
<li>Save the Word document created in step-6 as a PDF file;</li>
<li>Combine the PDF file created in step-2 with the files created in step-7 to reduce the similarity rate of the paper.</li>
<li>Eg. In my tested case, ‘final-opt-v1.pdf’ used only Page 7~11 as the image, the similarity index droped from 44% to 43%; while ‘final-opt-v2.pdf’ added Page 19~21 based on it, the similarity index dropped from 43% to 27%.</li>
</ol>
<br>

<p><img src="https://img2023.cnblogs.com/blog/1991547/202303/1991547-20230313115609390-30665254.png"></p>
<br>


<p><strong>Note</strong> that the <strong>FILE SIZE MATTERS</strong>!<br>Reduce the file size as much as possible while keeping the resolution as high as possible!</p>
<p><em>Be kindly reminded that this is only an experiment for testing the qualification of using Turnitin as a formal way for submitting assignment RATHER THAN an approach for submitting the papers directly via the methods mentioned above.</em></p>
<br>
<br>
<br>

<p><a href="https://guides.lib.monash.edu/turnitin/increasing-originality">Here</a> are <a href="https://guides.lib.monash.edu/ld.php?content_id=8482075">other formal ways</a> to reduce similarity index better.</p>
</h6></h6>]]></content>
      <categories>
        <category>Notes</category>
      </categories>
  </entry>
  <entry>
    <title>Video List</title>
    <url>/Blog/2023/02/24/Video-List/</url>
    <content><![CDATA[<h1 id="My-Lectures-amp-Micro-films-amp-Videos"><a href="#My-Lectures-amp-Micro-films-amp-Videos" class="headerlink" title="My Lectures &amp; Micro-films &amp; Videos"></a>My Lectures &amp; Micro-films &amp; Videos</h1><h6 align="center">Editor: Alexander Ezharjan<h6>

<b>
<b>
<b>


<ol>
<li>[PREFIX]&#x2F;VpN2uhHLG_M</li>
<li>[PREFIX]&#x2F;jBY1V1uklxs</li>
<li>[PREFIX]&#x2F;MtCl0HI2JJE</li>
<li>[PREFIX]&#x2F;B59-yAfN-5c</li>
<li>[PREFIX]&#x2F;UfdyJO3H5mo</li>
<li>[PREFIX]&#x2F;uGPFPjTT2hE</li>
<li>[PREFIX]&#x2F;eh2bNNBGggU</li>
</ol>
<b>
<b>
<b>
<b>


<hr>
<p>I&#x3D;utu<br>.<br>EF&#x3D;&#x2F;&#x2F;yo<br>PR&#x3D;https:<br>X&#x3D;be</p>
</b></b></b></b></b></b></b></h6></h6>]]></content>
      <categories>
        <category>Notes</category>
      </categories>
  </entry>
  <entry>
    <title>FFmpeg常用指令合集</title>
    <url>/Blog/2023/02/23/FFmpeg%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h6 align="center">Editor: Alexander Ezharjan<h6>



<ol>
<li><strong>切割MP3，按时间准确切割</strong></li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i F:\源.mp3 -ss 00:20:00 -to 02:30:05 F:\目标文件.mp3</span><br></pre></td></tr></table></figure>


<ol>
<li><strong>MTS到MP4</strong></li>
</ol>
<p><em>说明：（-b 4m：码率是4M；-s 1280*720：这个是设定视频大小。这2个参数其实可以删掉）</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i F:\源.mts -b 4M -s 1280*720 F:\结果.mp4</span><br></pre></td></tr></table></figure>


<ol start="3">
<li><strong>MP4到WMV</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i f:\视频.mp4 -b 4M f:\out.wmv</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>MP4图像旋转</strong></li>
</ol>
<p><em>说明：主要参数： -vf “transpose&#x3D;1” ，这里等于1是顺时针90度旋转；如果用手机录制的时候录反了，则执行2次这个操作就正过来了</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i f:\o.mp4 -vf &quot;transpose=1&quot; f:\o2.mp4</span><br></pre></td></tr></table></figure>


<ol start="5">
<li><strong>MP4到MP4改尺寸</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i G:\源.mp4 -b 4M -s 640*340 g:\OUT.mp4</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>MP4到MP4改尺寸加水印</strong></li>
</ol>
<p><em>说明：1: -vf “movie&#x3D;logo.png [logo];[in][logo] overlay&#x3D;10:20 [out]” 这里面的是加水印的参数，logo.png是我自己做的PNG水印，大小</em><br><em>300<em>100,10:20是水印的位置，为了方便，就把logo.png拷贝到FFMPEg的bin目录下(必须放，加路径就失败)，这样不用再加路径了 ;2: -b 2M 是用2M压缩率; 3: -s 640</em>340 意思是图像分辨率改为640*340。</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i G:\源.mp4 -vf &quot;movie=logo.png [logo];[in][logo] overlay=10:20 [out]&quot; -b 2M -s 640*340 g:\OUT.mp4</span><br></pre></td></tr></table></figure>


<ol start="7">
<li><strong>快速剪切某段视频作为输出</strong></li>
</ol>
<p><em>说明：上面截取 H:\源.mpg 这个视频，从第0秒开始，到23分20秒，这样一段，保存到G:\out.mp4，注意参数必须是 -c copy ，这样执行起来特别快，也就不到半分钟就搞定。</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i H:\源.mpg -ss 0:0:0 -to 0:23:20 -c copy G:\OUT.MP4</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><strong>该编码为H265,让MP4瘦身2&#x2F;3，1G的MP4可以压缩到300M</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 源.MP4 -vcodec libx265 -acodec copy F:\OUT.MP4</span><br></pre></td></tr></table></figure>


<ol start="9">
<li><strong>WAV转换格式到amr</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i test.wav -acodec libamr_nb -ab 12.2k -ar 8000 -ac 1 wav2amr.amr</span><br></pre></td></tr></table></figure>

<ol start="10">
<li><strong>提取视频中的声音保存成一个mp3</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 源.mp4 输出.mp3</span><br></pre></td></tr></table></figure>


<ol start="11">
<li><strong>要实现批量转换，可以直接用这个批处理文件</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for %%i in (*.mkv) do ffmpeg.exe -i &quot;%%i&quot; -vcodec copy -acodec copy &quot;%%~ni.mp4&quot;</span><br></pre></td></tr></table></figure>

<ol start="12">
<li><strong>合并多个MP4为一个</strong></li>
</ol>
<p><em>方法一</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i INPUT1.MP4 -i INPUT2.MP4 -f FORMAT -acodec AUDIOCODEC -vcodec VIDEOCODEC -sameq OUTPUT.MP4</span><br></pre></td></tr></table></figure>


<p><em>方法二</em></p>
<p>（1） 先创建一个文本文件 <code>filelist.txt</code>， 内容如下:(注意input1、2、3是你的文件的名字，都在该目录下)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file &#x27;input1.mp4&#x27;</span><br><span class="line">file &#x27;input2.mp4&#x27;</span><br><span class="line">file &#x27;input3.mp4&#x27;</span><br></pre></td></tr></table></figure>


<p>（2） 以上是这个文本文件的内容，保存后，在命令行执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -f concat -i filelist.txt -c copy output.mp4</span><br></pre></td></tr></table></figure>


<ol start="13">
<li><strong>下载直播流</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FFmpeg -i xxxxxxxxx.m3u8 -c copy out.mp4</span><br></pre></td></tr></table></figure>

<ol start="14">
<li><strong>FFmpeg将MP4转换为M3U8</strong></li>
</ol>
<p>（1）  直接将MP4文件转成m3u8：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i demo.mp4 -hls_time 10 -hls_list_size 0 -hls_segment_filename ene_%05d.ts ene.m3u8</span><br></pre></td></tr></table></figure>



<p>（2） 如果已经是ts文件了,则只需要执行下方命令即可:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i demo.ts -c copy -map 0 -f segment -segment_list playlist.m3u8 -segment_time 10 output%03d.ts</span><br></pre></td></tr></table></figure>


<p>（3） 将大量分割成ts文件的视频片段全部转换成mp4视频片段 — 直接上批处理脚本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> %%a <span class="keyword">in</span> (<span class="string">&quot;D:\VideoProjects\NewDemo\*.ts&quot;</span>) <span class="keyword">do</span> ffmpeg -i <span class="string">&quot;%%a&quot;</span>   -vcodec copy -vcodec copy -f mp4 <span class="string">&quot;D:\VideoProjects\NewDemo\NewMP4\%%~na.mp4&quot;</span></span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<p>（4） 上面的  ffmpeg -i test.ts -acodec copy -vcodec copy -f mp4 test.mp4  是将ts文件转换为mp4文件的意思，再在其之上套了一层for循环，%%a就是每个文件，转换命令最末尾的%%~na是将文件保持原来的文件名的情况下进行输出，存放到指定文件夹的意思。</p>
<ol start="15">
<li><strong>mp4视频转flv</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -acodec copy -vcodec copy -f flv test.flv </span><br></pre></td></tr></table></figure>

<ol start="16">
<li><strong>将本地指定的demo.ts文件进行推流</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -re  -i demo.ts  -c copy -f mpegts   udp://127.0.0.1:1997</span><br></pre></td></tr></table></figure>

<ol start="17">
<li><strong>强制把输出视频文件帧率改为 24 fps</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.avi -r 24 output.avi</span><br></pre></td></tr></table></figure>


<ol start="18">
<li><strong>对视频每个一秒截一个图并存在本地</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -f image2 -vf fps=fps=1 out%d.png</span><br></pre></td></tr></table></figure>


<ol start="19">
<li><strong>每隔20秒截一个图</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -f image2 -vf fps=fps=1/20 out%d.png</span><br></pre></td></tr></table></figure>


<ol start="20">
<li><strong>将视频转换为图片，一帧一图</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i out.mp4 out%4d.png</span><br></pre></td></tr></table></figure>

<br>
<br>



<p><br> <a href="https://www.jianshu.com/p/91727ab25227" target="_blank">参考</a><br><br> <a href="https://ffmpeg.org/ffmpeg.html" target="_blank">官网</a></p>
</h6></h6>]]></content>
      <categories>
        <category>Notes</category>
      </categories>
  </entry>
  <entry>
    <title>49天效应</title>
    <url>/Blog/2023/02/13/49%E5%A4%A9%E6%95%88%E5%BA%94/</url>
    <content><![CDATA[<h6 align="center">作者: 艾孜尔江·艾尔斯兰<h6>


<p><strong>49天效应</strong>旨在说明<br><code>全球西方的一些发达、最为先进的科学技术在国内普罗大众之间的广泛传播、达到国内一定程度上众所周知的地步所需要花费的时间约为49天</code></p>
<p>这种规律的掌握有利于对各类技术领域提前研究，甚至在商业领域进行推广和营销。</p>
<p>提出该效应的人是艾孜尔江·艾尔斯兰。</p>
<br>

<br>

<p>拿ChatGPT为例，首先报道此新闻的是西方技术相关媒体，而后在一周到两周的时间内，针对国内而言对此消息获悉最早的是一批以诸如微信公众号、抖音等为载体的小型科技类自媒体（非官方媒体），最后经过一系列传播，不断扩大，更多的非科技类媒体也便参与其中，使消息不断在更多人群中扩散，在49天的时间里形成了以大型媒体以及技术大厂为主体的新型传播样态。学界也涌入其中。</p>
<p>如下图显示的是ChatGPT的全球搜索趋势</p>
<p><img src="https://ezharjan.github.io/Blog/2023/02/13/49%E5%A4%A9%E6%95%88%E5%BA%94/49Effect.png" alt="49Effect"></p>
</h6></h6>]]></content>
      <categories>
        <category>Notes</category>
      </categories>
  </entry>
  <entry>
    <title>解决conda装虚拟Python环境联网失败问题</title>
    <url>/Blog/2022/10/17/%E8%A7%A3%E5%86%B3conda%E8%A3%85%E8%99%9A%E6%8B%9FPython%E7%8E%AF%E5%A2%83%E8%81%94%E7%BD%91%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h6 align="center">Editor: Alexander Ezharjan<h6>

<ol>
<li><p>使用 <code>conda create -n carla python=3.7</code> 命令安装虚拟环境出错，说网络连接异常，经久查询未果：<br><img src="https://img-blog.csdnimg.cn/0af662487e2c48f7baaf3f323d1dbc73.png" alt="在这里插入图片描述"></p>
</li>
<li><p>在终端输入下面这些：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>走进 <code>C:/Users/USER_NAME/.condarc</code>，删除内部的 <code>-defaults</code> 选项，保存退出；<br><img src="https://img-blog.csdnimg.cn/3d4a61eddb84466586e14749939fd41c.png" alt="在这里插入图片描述"></p>
</li>
<li><p>重新运行 <code>conda create -n carla python=3.7</code> 指令即可。</p>
</li>
</ol>
<br>

<br>
<br>


<p>作者：艾孜尔江·艾尔斯兰</p>
</h6></h6>]]></content>
      <categories>
        <category>答疑</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo Hello World</title>
    <url>/Blog/2022/10/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>]]></content>
      <categories>
        <category>Hexo Intro</category>
      </categories>
  </entry>
  <entry>
    <title>MOSES入门</title>
    <url>/Blog/2022/10/16/MOSES%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h6 align="center">编者：艾孜尔江<h6>


<hr>
<p>摩西是统计（或称基于数据的）机器翻译（MT）的一个实现方法。这是该领域目前的主要方法，并被谷歌和微软等公司部署的在线翻译系统所采用。在统计机器翻译（SMT）中，翻译系统接受大量并行数据的训练（系统从中学习如何翻译小段），以及更大量的单语数据（系统从中学习目标语言应该怎么组织）。平行数据是两种不同语言的句子集合，它们是句子对齐的，因为一种语言的每个句子都与另一种语言中相应的翻译句子相匹配，它也被称为bitext。</p>
<p>摩西的训练过程接收平行数据，并使用单词和语言片段（即为短语）的同时出现来推断两种语言之间的对应关系。在基于短语的机器翻译中，这些对应关系仅在连续的单词序列之间，而在基于分层短语的机器翻译或基于语法的翻译中，更多关于句子的结构被添加到对应关系中。例如，一个分层的机器翻译系统可以知道德国hat<br>X gegessen 对应于英语中的ate<br>X，其中Xs能被任何德语-英语单词对所替换。在这些类型的系统中使用的额外结构可能或并不能从并行语料的语言分析得到。摩西还实现了基于短语的机器翻译的扩展，称为因式翻译，可以将额外的语言信息添加到基于短语的翻译系统中。</p>
<p>有关摩西翻译模型的更多信息，请参见摩西网站上关于<a href="http://www.statmt.org/moses/?n=Moses.Tutorial">基于短语的机器翻译系统</a>，基于<a href="http://www.statmt.org/moses/?n=Moses.SyntaxTutorial">句法的翻译系统</a>或基于因子的翻译系统。</p>
<p>无论您使用哪种类型的机器翻译模型，创建一个表现良好的翻译系统的关键都是大量优质数据（语料）。您可以使用许多<a href="http://www.statmt.org/moses/?n=Moses.LinksToCorpora">免费的并行数据源</a>来训练样本系统，比如：<a href="http://www.statmt.org/moses/?n=Moses.LinksToCorpora">http://www.statmt.org/moses/?n=Moses.LinksToCorpora</a>。但（通常）您使用的数据越接近您要翻译的语言类型，得到的结果就越好。这是使用像Moses这样的开源工具的优势之一，如果您拥有自己的数据，那么您可以根据需要定制自己的翻译系统，并且可能比通用翻译系统获得更好的性能。摩西用来训练翻译系统的过程中需要句子对齐的数据，但如果语料在文档级别对齐，则通常可以使用像<a href="http://mokk.bme.hu/resources/hunalign/">hunalign</a>这样的工具将其转换为句子对齐的数据。</p>
<h2 id="Moses系统的组成部分"><a href="#Moses系统的组成部分" class="headerlink" title="Moses系统的组成部分"></a><strong>Moses系统的组成部分</strong></h2><p>摩西系统的两个主要组成部分是训练管道和解码器。还有各种开源社区贡献的工具和实用程序。训练管道实际上是一组工具（主要用perl编写，有些用C<br>++编写），它们采用原始数据（并行语料和单语言）并将其转换为机器翻译模型。解码器是一个单独的C<br>++应用程序，给定一个训练有素的机器翻译模型和源句子，将源语句翻译成目标语言。</p>
<p>1.培训管道：</p>
<p>从培训数据生成翻译系统涉及各个阶段，这些阶段在培训文档和基线系统指南中有更详细的描述。这些作为管道被完成，并且可由摩西实验管理系统所控制，而Moses通常可以轻松地将不同类型的外部工具插入到培训管道中</p>
<p>数据在被用于训练之前需要做一些准备工作，标记文本并且将标记转换为标准案例。启发式用于删除看起来未对齐的句子对，并删除长句子。然后，并行的句子需要词对齐，通常使用<br>GIZA<br>++来完成，它实现了80年代在IBM开发的一组统计模型。这些词对齐被用于根据需要提取短语-短语翻译或分层规则，并且使用这些规则的语料库范围统计来估计概率。</p>
<p>翻译系统的一个重要部分是语言模型，一种使用目标语言中的单语言数据构建的统计模型，并由解码器用来尝试确保输出的流畅性。摩西依靠<a href="http://www.statmt.org/moses/?n=FactoredTraining.BuildingLanguageModel">外部工具</a>（<a href="http://www.statmt.org/moses/?n=FactoredTraining.BuildingLanguageModel%EF%BC%89%E8%BF%9B%E8%A1%8C%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E6%9E%84%E5%BB%BA%E3%80%82">http://www.statmt.org/moses/?n=FactoredTraining.BuildingLanguageModel）进行语言模型构建。</a></p>
<p>创建机器翻译系统的最后一步是<em>调优</em>，其中不同的统计模型相互加权以产生最佳可能的翻译。摩西系统包含了最流行的调优算法的实现。</p>
<p>2.解码器</p>
<p>摩西解码器的工作是找到与给定源句子相对应的目标语言（根据翻译模型）的最高评分句子。解码器还可以输出候选的翻译的从好到坏的排序列表，并且还提供关于其如何做出决策的各种类型的信息（例如，它使用的短语-短语对应关系）。</p>
<p>解码器以模块化方式编写，并允许用户以各种方式改变解码过程，例如：</p>
<ul>
<li><p>输入：这可以是一个简单的句子，或者它可以用类似xml的元素的注释来指导翻译过程，或者它可以是更复杂的结构，如格子或混淆网络（例如，从语音识别的输出）</p>
</li>
<li><p>翻译模型：这可以使用短语-短语规则或分层（也可能是句法）规则。它可以编译成二进制形式，以加快加载速度。它可以通过将额外的信息添加到翻译过程中来补充一些特性，例如阐明短语对的来源以控制他们的可靠性的特性。</p>
</li>
<li><p>解码算法：解码问题是一个巨型的搜索问题，通常对于精确搜索来说太大了，而且Moses为这种搜索实现了几种不同的策略，例如基于堆栈，立方体修剪，图表解析等。</p>
</li>
<li><p>语言模型：<br>Moses支持几种不同的语言模型工具包（SRILM，KenLM，IRSTLM，RandLM），每种工具包都有自己的优点和缺点，添加一个新的LM工具包很简单。</p>
</li>
</ul>
<p>Moses解码器还支持多线程解码（因为翻译具有<a href="https://en.wikipedia.org/wiki/Embarrassingly_parallel">很高的的并行性</a>），并且如果您有权访问群集服务器，摩西提供启用多进程解码的脚本。</p>
<h2 id="贡献工具"><a href="#贡献工具" class="headerlink" title="贡献工具"></a>贡献工具</h2><p>摩西有许多贡献工具，它们提供额外的功能和超越标准训练和解码管道的附加功能。这些包括：</p>
<ul>
<li><p>Moses服务器：为解码器提供xml-rpc接口，需要安装xmlrpc-c。</p>
</li>
<li><p>Web翻译：一组脚本，使Moses可用于翻译网页</p>
</li>
<li><p>分析工具：与参考文献相比，是一个可以对摩西输出进行分析和可视化的脚本。</p>
</li>
</ul>
<p>还有用于评估翻译的工具，替代短语评分方法，用于加权短语表的技术的实现，用于减小短语表的规模的工具以及其他贡献工具。</p>
<h2 id="一-安装相关依赖项："><a href="#一-安装相关依赖项：" class="headerlink" title="一 安装相关依赖项："></a>一 安装相关依赖项：</h2><p>在本教程中，我用来搭建Moses系统的服务器环境如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root\@VM-0-15-ubuntu:/home/ubuntu/mosesdecoder\<span class="comment"># lsb_release -a</span></span><br><span class="line"></span><br><span class="line">No LSB modules are available.</span><br><span class="line"></span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line"></span><br><span class="line">Description: Ubuntu 16.04.4 LTS</span><br><span class="line"></span><br><span class="line">Release: 16.04</span><br><span class="line"></span><br><span class="line">Codename: xenial</span><br></pre></td></tr></table></figure>

<p>安装如下依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential git-core pkg-config automake libtool wget</span><br><span class="line">zlib1g-dev python-dev libbz2-dev</span><br></pre></td></tr></table></figure>
<p>从Github克隆Moses：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;https://github.com/moses-smt/mosesdecoder.git&gt;</span><br><span class="line"><span class="built_in">cd</span> mosesdecoder</span><br></pre></td></tr></table></figure>

<p>运行以下命令安装最新的boost库，cmph (for<br>CompactPT，即C Minimal Perfect Hashing Library), irstlm (language model from<br>FBK, required to pass the regression tests),和 xmlrpc-c (for moses<br>server)。这些都会默认安装在你的当前工作目录的.&#x2F;opt路径。其中xmlrpc不是必须，但是如果将moses作为服务提供必须安装xmlrpc。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -f contrib/Makefiles/install-dependencies.gmake</span><br></pre></td></tr></table></figure>

<p>编译Moses：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">./compile.sh [additional options]</span><br><span class="line"></span><br><span class="line">\--prefix=/destination/path --install-scripts 安装到其他目录</span><br><span class="line"></span><br><span class="line">\--with-mm 使用基于后缀数组的短语表</span><br></pre></td></tr></table></figure>

<p>其中，MOSES<br>SERVER使你可以把MOSES解码器作为一个服务器进程来运行，发送给其的句子将通过XMLRPC来翻译。这意味着无论客户使用java,python,perl,php还是其它别的XMLRPC集合里有的语言来编码，MOSES进程都可以服务客户且分布式地服务客户。</p>
<p>XMLRPC是Userland<br>Software公司设计的一种格式：是一种使用HTTP协议传输XML格式文件来获取远程程序调用（Remote<br>Procedure<br>Call）的传输方式。远程程序调用简单地讲是指，一台机器通过网络调用另一台机器里的应用程序，同时将执行结果返回。一般一台机器作为服务器端，另一台作为客户端。服务器端需要轮询是否有客户端进行RPC请求。一个简单的例子。一台服务器提供查询当前时间的RPC服务。其他任何一台机器通过网络，使用客户端，都可以到该服务器查询当前的时间。</p>
<p>MLRPC是RPC机制的实现方式之一。采用XML语言作为服务器与客户端的数据交互格式，方便使用者阅读。XMLRPC可以用很多种语言实现，包括perl，phyon，c等。使用c与c++实现的库，就是XMLRPC-c。</p>
<p>Boost<br>1.48版本在编译Moses时会出现一个严重的bug。在有些Linux的分发版本中，比如Ubuntu<br>12.04，Boost库存在着这种版本的Boost库。在这种情况下，你必须要手动下载和编译Boost。</p>
<p>下载编译boost：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">wget &lt;https://dl.bintray.com/boostorg/release/1.64.0/source/boost_1_64_0.tar.gz&gt;</span><br><span class="line"></span><br><span class="line">tar zxvf boost_1_64_0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> boost_1_64_0/</span><br><span class="line"></span><br><span class="line">./bootstrap.sh</span><br><span class="line"></span><br><span class="line">./b2 -j4 --prefix=\<span class="variable">$PWD</span> --libdir=\<span class="variable">$PWD</span>/lib64 --layout=system <span class="built_in">link</span>=static install</span><br><span class="line">\|\| <span class="built_in">echo</span> FAILURE \<span class="comment">#或者执行./b2安装在当前目录下</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述命令在文件夹lib64中创建文件夹，并不是在系统目录下。因此，你不必使用系统root权限来执行上述命令。然而，你需要告诉Moses如何找到boost。当boost被暗账好以后，你可以开始编译Moses，你需要用 –with-boost标记告诉Moses系统<br>boost安装在哪里。</p>
<p>下载安装cmph:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget</span><br><span class="line">http://www.mirrorservice.org/sites/download.sourceforge.net/pub/sourceforge/c/cm/cmph/cmph/cmph-2.0.tar.gz</span><br><span class="line"></span><br><span class="line">tar zxvf cmph-2.0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">cd</span> cmph-2.0/</span><br><span class="line"></span><br><span class="line">./configure --prefix= /usr/local/cmph</span><br><span class="line">\<span class="comment">#指定安装路径，这里我选择了/usr/local/cmph</span></span><br><span class="line"></span><br><span class="line">Make</span><br><span class="line"></span><br><span class="line">Make install</span><br></pre></td></tr></table></figure>

<p>下载安装xmlrpc-c：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">wget</span><br><span class="line">https://launchpad.net/ubuntu/+archive/primary/+sourcefiles/xmlrpc-c/1.33.14-8build1/xmlrpc-c_1.33.14.orig.tar.gz</span><br><span class="line"></span><br><span class="line">tar zxvf xmlrpc-c_1.33.14.orig.tar.gz</span><br><span class="line"></span><br><span class="line">cd xmlrpc-c-1.33.14/</span><br><span class="line"></span><br><span class="line">./configure --prefix= /usr/local/xmlrpc-c</span><br><span class="line">\#指定安装路径，这里我选择了/usr/local/xmlrpc-c</span><br><span class="line"></span><br><span class="line">Make</span><br><span class="line"></span><br><span class="line">Make install</span><br></pre></td></tr></table></figure>

<p>接下来，用bjam编译Moses：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bjam --with-boost=/home/ubuntu/boost_1_64_0 --with-cmph=/usr/local/cmph</span><br><span class="line">--with-xmlrpc-c=/usr/local/xmlrpc-c -j4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意： –with-boost<br>后的路径为你自己安装时指定的路径，-j4 用于指定核心数。Moses可选的语言模型有IRSTLM，SRILM，KenLM.其中，KenLM已经默认包含在Moses工具包中。我们在这里使用Moses自带的语言模型工具KenLM，不再安装irstlm。</p>
<h2 id="二-安装词对齐工具GIZA"><a href="#二-安装词对齐工具GIZA" class="headerlink" title="二 安装词对齐工具GIZA++"></a>二 安装词对齐工具GIZA++</h2><p>接下来，安装词对齐工具GIZA++：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> &lt;https://github.com/moses-smt/giza-pp.git&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> giza-pp</span><br><span class="line"></span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>编译完成后，将生成三个二进制文件：</p>
<p>· giza-pp&#x2F;GIZA++-v2&#x2F;GIZA++</p>
<p>· giza-pp&#x2F;GIZA++-v2&#x2F;snt2cooc.out</p>
<p>· giza-pp&#x2F;mkcls-v2&#x2F;mkcls</p>
<p>记得在编译完之后将上面的三个文件拷到一个目录下，便于访问使用。如下面的命令所示，我是直接将其放在tools文件夹下的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cd \~/mosesdecoder</span><br><span class="line"></span><br><span class="line">mkdir tools</span><br><span class="line"></span><br><span class="line">cp \~/giza-pp/GIZA++-v2/GIZA++ \~/giza-pp/GIZA++-v2/snt2cooc.out \\</span><br><span class="line"></span><br><span class="line">\~/giza-pp/mkcls-v2/mkcls tools</span><br></pre></td></tr></table></figure>

<p>编译创建好GIZA++后，有两种方式来使用它，一是在编译Moses时将GIZA++的地址作为选项参数。如果在编译Moses时没有指定GIZA++的地址，可以采用另外一个方法，那就是在训练语言模型时指明GIZA++三个可执行文件的路径，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">train-model.perl -external-bin-dir \<span class="variable">$HOME</span>/external-bin-dir</span><br><span class="line"></span><br><span class="line">我在实际操作中，采用的是第二种方法，即在使用Moses时，给一个参数指明GIZA++路径。</span><br></pre></td></tr></table></figure>

<h2 id="三-语料准备"><a href="#三-语料准备" class="headerlink" title="三 语料准备"></a>三 语料准备</h2><p>接下来，准备平行语料：</p>
<p>我的英汉平行语料来自联合国的网站提供的英汉平行语料，（<a href="https://conferences.unite.un.org/uncorpus/zh%EF%BC%89%EF%BC%8C%E5%A4%A7%E7%BA%A61600%E4%B8%87%E5%AF%B9%E3%80%82%E5%9B%A0%E6%88%91%E4%BD%BF%E7%94%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E5%AD%98%E5%8F%AA%E6%9C%894G%EF%BC%8C%E6%89%80%E4%BB%A5%E5%B0%86%E5%8E%9F%E6%96%87%E4%BB%B6%E5%88%86%E6%88%9030%E4%BB%BD%EF%BC%8C%E4%BB%8E%E4%B8%AD%E6%88%AA%E5%8F%96%E4%BA%86%E7%BA%A660%E4%B8%87%E5%AF%B9%E7%94%A8%E6%9D%A5%E5%81%9A%E6%AD%A4%E6%AC%A1%E5%AE%9E%E9%AA%8C%E3%80%82">https://conferences.unite.un.org/uncorpus/zh），大约1600万对。因我使用的服务器内存只有4G，所以将原文件分成30份，从中截取了约60万对用来做此次实验。</a></p>
<p>我们的英文语料为：un_en-zh23.en，汉语语料为：un_en-zh23.cn。</p>
<p>在准备训练翻译系统之前，我们需要对语料做如下的处理：</p>
<ol>
<li><strong>tokenisation：</strong>这一步主要是在单词和单词之间或者单词和标点之间插入空白，以便于后续识别和其他操作。</li>
</ol>
<p>对于英文语料，我们运行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\~/mosesdecoder/scripts/tokenizer/tokenizer.perl -l en \\</span><br><span class="line"></span><br><span class="line">\&lt; \~/corpus/training/un_en-zh23.en \\</span><br><span class="line"></span><br><span class="line">\&gt; \~/corpus/un_en-zh23.tok.en</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  注：命令当中的~为Mosesdecoder的安装路径和语料所在的具体路径，下同</p>
</blockquote>
<p>对于汉语语料。我们需要进行分词。在这里，我们使用清华大学自然语言处理与社会人文计算实验室研制推出的中文词法分析工具包（<a href="http://thulac.thunlp.org），具有中文分词和词性标注功能。具有能力强，准确率高，速度快的特点。具体使用方法请参照网页。在这里，我们使用Python版本来对中文语料进行分词，具体代码如下：">http://thulac.thunlp.org），具有中文分词和词性标注功能。具有能力强，准确率高，速度快的特点。具体使用方法请参照网页。在这里，我们使用Python版本来对中文语料进行分词，具体代码如下：</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> thulac</span><br><span class="line"></span><br><span class="line">thu1=thulac.thulac(user_dict=<span class="string">&quot;/home/ubuntu/corpus/un_en-zh_23/dict.txt&quot;</span>,seg_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">\<span class="comment">#只进行分词，不进行词性标注</span></span><br><span class="line"></span><br><span class="line">thu1.cut_f(<span class="string">&quot;/home/ubuntu/corpus/un_en-zh_23/un_en-zh23.cn&quot;</span>,</span><br><span class="line"><span class="string">&quot;/home/ubuntu/corpus/un_en-zh_23/un_en-zh23.fc&quot;</span>)</span><br><span class="line">\<span class="comment">#对un_en-zh23.cn文件内容进行分词，输出到un_en-zh23.fc</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  经过tokenisation，我们得到un_en-zh23.fc和un_en-zh23.tok.en两个文件。</p>
</blockquote>
<ol>
<li>truecase：初始每句话的字和词组都被转换为没有格式的形式(例如统一为小写）。这有助于减少数据稀疏性问题。</li>
</ol>
<blockquote>
<p>  Truecase首先需要训练，以便提取关于文本的一些统计信息</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\~/mosesdecoder/scripts/recaser/train-truecaser.perl \\</span><br><span class="line"></span><br><span class="line">\--model \~/corpus/truecase-model.en --corpus \\</span><br><span class="line"></span><br><span class="line">\~/corpus/ un_en-zh23.tok.en</span><br><span class="line"></span><br><span class="line">\~/mosesdecoder/scripts/recaser/train-truecaser.perl \\</span><br><span class="line"></span><br><span class="line">\--model \~/corpus/truecase-model.cn --corpus \\</span><br><span class="line"></span><br><span class="line">\~/corpus/ un_en-zh23.fc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  经过此步，我们得到truecase-model.en和truecase-model.cn两个文件。</p>
</blockquote>
<blockquote>
<p>  接下来，我们对tokenisation后的文件进行truecase：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\~/mosesdecoder/scripts/recaser/truecase.perl \\</span><br><span class="line"></span><br><span class="line">\--model \~/corpus/truecase-model.en \\</span><br><span class="line"></span><br><span class="line">\&lt; \~/corpus/ un_en-zh23.tok.en \\</span><br><span class="line"></span><br><span class="line">\&gt; \~/corpus/ un_en-zh23.true.en</span><br><span class="line"></span><br><span class="line">\~/mosesdecoder/scripts/recaser/truecase.perl \\</span><br><span class="line"></span><br><span class="line">\--model \~/corpus/truecase-model.cn \\</span><br><span class="line"></span><br><span class="line">\&lt; \~/corpus/ un_en-zh23.fc \\</span><br><span class="line"></span><br><span class="line">\&gt; \~/corpus/un_en-zh23.true.cn</span><br></pre></td></tr></table></figure>

<p>经过truecase，我们得到un_en-zh23.true.cn和un_en-zh23.true.en两个文件。</p>
<ol start="3">
<li>cleaning：长句和空语句可引起训练过程中的问题，因此将其删除，同时删除明显不对齐的句子。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\~/mosesdecoder/scripts/training/clean-corpus-n.perl \\</span><br><span class="line"></span><br><span class="line">\~/corpus/ un_en-zh23.true cn en \\</span><br><span class="line"></span><br><span class="line">\~/corpus/ un_en-zh23.clean 1 80</span><br><span class="line"></span><br></pre></td></tr></table></figure>
需要注意的是，这句命令会对truecase-model.en和truecase-model.cn两个文件同时进行清洗。经过clean，我们得到un_en-zh23.clean.en和un_en-zh23.clean.cn两个文件。</li>
</ol>
<h2 id="四-语言模型训练（Language-Model-Training）"><a href="#四-语言模型训练（Language-Model-Training）" class="headerlink" title="四 语言模型训练（Language Model Training）"></a>四 语言模型训练（Language Model Training）</h2><p>语言模型的训练是为了保证能够产生流利的输出，所以要用目标语言来建立。本例的目标语言是汉语。在这里，我们使用Moses系统中内置的语言语言模型工具KenLM，当然，你也可以使用其他一些开源的语言模型工具，比如，IRSTLM，BerkeleyLM，SRILM等。接下来，我们建立一个合适的3元文语言模型。</p>
<p>建立文件夹lm，然后运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> \~/lm</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> \~/lm</span><br><span class="line"></span><br><span class="line">\~/mosesdecoder/bin/lmplz -o 3 \&lt;\~/corpus/ un_en-zh23.true.cn \&gt;</span><br><span class="line">un_en-zh23.arpa.cn</span><br></pre></td></tr></table></figure>

<p>你会看到建立语言模型的五个步骤：</p>
<p>1&#x2F;5 Counting and sorting n-grams</p>
<p>2&#x2F;5 Calculating and sorting adjusted counts</p>
<p>3&#x2F;5 Calculating and sorting initial probabilities</p>
<p>4&#x2F;5 Calculating and writing order- interpolated probabilities</p>
<p>5&#x2F;5 Writing ARPA model &#x3D;FE Name</p>
<p>此步我们生成un_en-zh23.arpa.cn<br>文件，接下来我们为了加载的更快一些，我们使用KenLm来对*.arpa.en文件二进制化。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\~/mosesdecoder/bin/build_binary \\</span><br><span class="line"></span><br><span class="line">un_en-zh23.arpa.cn \\</span><br><span class="line"></span><br><span class="line">un_en-zh23.blm.cn</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当你看到绿色的SUCCESS字样时说明二进制化已经成功了。我们可以在这一步之后通过查询测试来判断训练的模型是否正确，运行如下的linux命令你会看到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\$ <span class="built_in">echo</span> <span class="string">&quot;我 爱 我的 好姑娘&quot;</span> \\</span><br><span class="line"></span><br><span class="line">\| \~/mosesdecoder/bin/query un_en-zh23.blm.cn</span><br><span class="line"></span><br><span class="line">Loading statistics:</span><br><span class="line"></span><br><span class="line">我=8872 2 -2.282969 爱=18074 1 -6.466906 我的=9416 1 -4.8714185</span><br><span class="line"></span><br><span class="line">好姑娘=0 1 -6.4878592 \&lt;/s\&gt;=2 1 -2.288369 Total: -22.397522 OOV: 1</span><br><span class="line"></span><br><span class="line">Perplexity including OOVs: 30165.07396388977</span><br><span class="line"></span><br><span class="line">Perplexity excluding OOVs: 9493.266676976866</span><br><span class="line"></span><br><span class="line">OOVs: 1</span><br><span class="line"></span><br><span class="line">Tokens: 5</span><br><span class="line"></span><br><span class="line">Name:query VmPeak:151680 kB VmRSS:4088 kB RSSMax:136452 kB</span><br><span class="line"></span><br><span class="line">user:0.008 sys:0 CPU:0.008 real:0.00995472</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="五-训练翻译模型（Training-the-Translation-System）"><a href="#五-训练翻译模型（Training-the-Translation-System）" class="headerlink" title="五 训练翻译模型（Training the Translation System）"></a>五 训练翻译模型（Training the Translation System）</h2><p>接下来，我们进行到最主要的一步，训练翻译模型。在这一步，我们进行词对齐（用GIZA++），短语抽取，打分，创建词汇化重新排序表，并且创建属于我们自己的摩西配置文件(moses.ini)。我们运行如下的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> \~/working</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> \~/working</span><br><span class="line"></span><br><span class="line"><span class="built_in">nohup</span> <span class="built_in">nice</span> \~/mosesdecoder/scripts/training/train-model.perl -root-dir train \\</span><br><span class="line"></span><br><span class="line">\-corpus \~/corpus/ un_en-zh23.clean \\</span><br><span class="line"></span><br><span class="line">\-f en -e cn -alignment grow-diag-final-and -reordering msd-bidirectional-fe \\</span><br><span class="line"></span><br><span class="line">\-lm 0:3:\<span class="variable">$HOME</span>/lm/un_en-zh23.blm.cn:8 \\</span><br><span class="line"></span><br><span class="line">\-external-bin-dir \~/mosesdecoder/tools \&gt;&amp; training.out &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你的CPU是多核的，建议你加上-cores<br>参数来加快词对齐的过程。注意，如果在训练翻译系统的过程中遇到了 Exit<br>code:137错误，一般是因为内存不足，需要增大服务器的内存配置。上述过程完成后，你可以在~&#x2F;working&#x2F;train&#x2F;model<br>文件夹下找到一个moses.ini配置文件，这是需要在moses解码时使用到的。但这里有几个问题，首先是它的加载速度很慢，这个问题我们可以通过二值化(binarising)短语表和短语重排序表来解决，即编译成一个可以很快地加载的格式。第二个问题是，该配置文件中moses解码系统用来权衡不同的模型之间重要程度的权重信息都是刚初始化的，即非最优的，如果你用VIM打开moses.ini文件看看的话，你会看到各种权重都被设置为默认值，如0.2，0.3等。要寻找更好的权重，我们需要调整(tuning)翻译系统，即下一步。</p>
<h2 id="六-调优-Tuning"><a href="#六-调优-Tuning" class="headerlink" title="六 调优(Tuning)"></a>六 调优(Tuning)</h2><p>这是整个过程中最慢的一步，Tuning需要一小部分的平行语料，与训练数据相分离开。这里，我们再次从联合国的平行语料中截取一部分。我们用来调优的语料文件名称为un_dev.cn和un_dev.en。我们将用这两个文件来完成调优的过程，所以我们在之前必须对着两个文件进行  tokenise<br>和 truecase。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cd \~/corpus</span><br><span class="line"></span><br><span class="line">\~/mosesdecoder/scripts/tokenizer/tokenizer.perl -l en \\</span><br><span class="line"></span><br><span class="line">\&lt; dev/un_dev.en \&gt; un_dev.tok.en</span><br></pre></td></tr></table></figure>

<p>同样的，对un_dev.cn进行中文分词，得到un_dev.fc。</p>
<p>然后进行truecase：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\~/mosesdecoder/scripts/recaser/truecase.perl --model truecase-model.en \\</span><br><span class="line"></span><br><span class="line">\&lt; un_dev.tok.en \&gt; un_dev.true.en</span><br><span class="line"></span><br><span class="line">\~/mosesdecoder/scripts/recaser/truecase.perl --model truecase-model.fr \\</span><br><span class="line"></span><br><span class="line">\&lt; un_dev.fc \&gt; un_dev.true.cn</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后回到我们用来训练的目录，开始调优的过程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cd \~/working</span><br><span class="line"></span><br><span class="line">nohup nice \~/mosesdecoder/scripts/training/mert-moses.pl \\</span><br><span class="line"></span><br><span class="line">\~/corpus/ un_dev.true.en \~/corpus/ un_dev.true.cn \\</span><br><span class="line"></span><br><span class="line">\~/mosesdecoder/bin/moses train/model/moses.ini --mertdir \~/mosesdecoder/bin/</span><br><span class="line">\\</span><br><span class="line"></span><br><span class="line">&amp;\&gt; mert.out &amp;</span><br></pre></td></tr></table></figure>

<p>如果你的CPU是多核的，那么用多线程来运行摩西会明显加快速度。在上面的最后一行加上–decoder-flags&#x3D;”-threads<br>4”可以用四线程来运行解码器。</p>
<p>最后的调优结果是一个包含训练权重的ini文件，如果你用的跟我一样的目录结构的话，应该存在于~&#x2F;working&#x2F;mert-<br>work&#x2F;moses.ini文件夹中。</p>
<h2 id="七-测试"><a href="#七-测试" class="headerlink" title="七 测试"></a>七 测试</h2><p>接下来你可以运行下面的命令来翻译句子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\~/mosesdecoder/bin/moses -f \~/working/mert-work/moses.ini</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行命令后，会得到下面的提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Defined parameters (per moses.ini or switch):</span><br><span class="line"></span><br><span class="line">config: /home/ubuntu/corpus/un_en-zh_23/working/mert-work/moses.ini</span><br><span class="line"></span><br><span class="line">distortion-limit: 6</span><br><span class="line"></span><br><span class="line">feature: UnknownWordPenalty WordPenalty PhrasePenalty PhraseDictionaryMemory</span><br><span class="line">name=TranslationMode l0 num-features=4</span><br><span class="line">path=/home/ubuntu/corpus/un_en-zh_23/working/train/model/phrase-table.gz</span><br><span class="line">input-factor=0 output-factor=0 LexicalReordering name=LexicalReordering0</span><br><span class="line">num-features=6 <span class="built_in">type</span>=wbe-msd-bidirectional-fe-a llff input-factor=0</span><br><span class="line">output-factor=0</span><br><span class="line">path=/home/ubuntu/corpus/un_enzh_23/working/train/model/reordering-t</span><br><span class="line">able.wbe-msd-bidirectional-fe.gz Distortion KENLM name=LM0 <span class="built_in">factor</span>=0</span><br><span class="line">path=/home/ubuntu/corpus/un_en-zh_23/ lm/un_en-zh23.blm.cn order=3</span><br><span class="line"></span><br><span class="line">input-factors: 0</span><br><span class="line"></span><br><span class="line">mapping: 0 T 0</span><br><span class="line"></span><br><span class="line">weight: LexicalReordering0= 0.0614344 0.0245557 0.242242 0.0725016 0.0539617</span><br><span class="line">0.0566553 Distortion 0= 0.00534453 LM0= 0.0696027 WordPenalty0= -0.166007</span><br><span class="line">PhrasePenalty0= 0.0688629 TranslationModel0= 0.03900 17 0.0457273 0.0730895</span><br><span class="line">0.0210141 UnknownWordPenalty0= 1</span><br><span class="line"></span><br><span class="line">line=UnknownWordPenalty</span><br><span class="line"></span><br><span class="line">FeatureFunction: UnknownWordPenalty0 start: 0 end: 0</span><br><span class="line"></span><br><span class="line">line=WordPenalty</span><br><span class="line"></span><br><span class="line">FeatureFunction: WordPenalty0 start: 1 end: 1</span><br><span class="line"></span><br><span class="line">line=PhrasePenalty</span><br><span class="line"></span><br><span class="line">FeatureFunction: PhrasePenalty0 start: 2 end: 2</span><br><span class="line"></span><br><span class="line">line=PhraseDictionaryMemory name=TranslationModel0 num-features=4</span><br><span class="line">path=/home/ubuntu/corpus/un_en-zh_23/wo rking/train/model/phrase-table.gz</span><br><span class="line">input-factor=0 output-factor=0</span><br><span class="line"></span><br><span class="line">FeatureFunction: TranslationModel0 start: 3 end: 6</span><br><span class="line"></span><br><span class="line">line=LexicalReordering name=LexicalReordering0 num-features=6</span><br><span class="line"><span class="built_in">type</span>=wbe-msd-bidirectional-fe-allff input-f actor=0 output-factor=0</span><br><span class="line">path=/home/ubuntu/corpus/un_en-zh_23/working/train/model/reordering-table.wbe-msd</span><br><span class="line">-bidirectional-fe.gz</span><br><span class="line"></span><br><span class="line">Initializing Lexical Reordering Feature..</span><br><span class="line"></span><br><span class="line">FeatureFunction: LexicalReordering0 start: 7 end: 12</span><br><span class="line"></span><br><span class="line">line=Distortion</span><br><span class="line"></span><br><span class="line">FeatureFunction: Distortion0 start: 13 end: 13</span><br><span class="line"></span><br><span class="line">line=KENLM name=LM0 <span class="built_in">factor</span>=0</span><br><span class="line">path=/home/ubuntu/corpus/un_en-zh_23/lm/un_en-zh23.blm.cn order=3</span><br><span class="line"></span><br><span class="line">FeatureFunction: LM0 start: 14 end: 14</span><br><span class="line"></span><br><span class="line">Loading UnknownWordPenalty0</span><br><span class="line"></span><br><span class="line">Loading WordPenalty0</span><br><span class="line"></span><br><span class="line">Loading PhrasePenalty0</span><br><span class="line"></span><br><span class="line">Loading LexicalReordering0</span><br><span class="line"></span><br><span class="line">Loading table into memory...done.</span><br><span class="line"></span><br><span class="line">Loading Distortion0</span><br><span class="line"></span><br><span class="line">Loading LM0</span><br><span class="line"></span><br><span class="line">Loading TranslationModel0</span><br><span class="line"></span><br><span class="line">Start loading text phrase table. Moses format : [133.871] seconds</span><br><span class="line"></span><br><span class="line">Reading /home/ubuntu/corpus/un_en-zh_23/working/train/model/phrase-table.gz</span><br><span class="line"></span><br><span class="line">\----5---10---15---20---25---30---35---40---45---50---55---60---65---70---75---80---85---90---95--100</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输入你喜欢的英语句子，然后查看结果。你会注意到，解码器会话费很长一段时间来启动。如上所示，我们此次启动花费了133.871秒，并且CPU和内存一直处于满载状态。为了让解码器启动的更快一些，我们可以将短语表和词汇化再排序模型二进制化。注意，binarise操作需要使用cmph，如果没有按照本文档事先安装cmph，在此时才安装cmph，那么必须进入mosesdecoder安装文件夹重新执行.&#x2F;bjam，并补全编译参数重新编译moses。否则执行moses.ini时会报错。</p>
<p>我们要创建一个合适的目录并且按如下的命令来二进制化模型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> \~/working/binarised-model</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> \~/working</span><br><span class="line"></span><br><span class="line">\~/mosesdecoder/bin/processPhraseTableMin \\</span><br><span class="line"></span><br><span class="line">\-<span class="keyword">in</span> train/model/phrase-table.gz -nscores 4 \\</span><br><span class="line"></span><br><span class="line">\-out binarised-model/phrase-table</span><br><span class="line"></span><br><span class="line">\~/mosesdecoder/bin/processLexicalTableMin \\</span><br><span class="line"></span><br><span class="line">\-<span class="keyword">in</span> train/model/reordering-table.wbe-msd-bidirectional-fe.gz \\</span><br><span class="line"></span><br><span class="line">\-out binarised-model/reordering-table</span><br></pre></td></tr></table></figure>

<p>输入命令，你会看到如下的信息，分别是将短语表和重排序表二值化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Used options:</span><br><span class="line"></span><br><span class="line">Text phrase table will be <span class="built_in">read</span> from: train/model/phrase-table.gz</span><br><span class="line"></span><br><span class="line">Output phrase table will be written to: binarised-model/phrase-table.minphr</span><br><span class="line"></span><br><span class="line">Step size <span class="keyword">for</span> <span class="built_in">source</span> landmark phrases: 2\^10=1024</span><br><span class="line"></span><br><span class="line">Source phrase fingerprint size: 16 bits / P(fp)=1.52588e-05</span><br><span class="line"></span><br><span class="line">Selected target phrase encoding: Huffman + PREnc</span><br><span class="line"></span><br><span class="line">Maxiumum allowed rank <span class="keyword">for</span> PREnc: 100</span><br><span class="line"></span><br><span class="line">Number of score components <span class="keyword">in</span> phrase table: 4</span><br><span class="line"></span><br><span class="line">Single Huffman code <span class="built_in">set</span> <span class="keyword">for</span> score components: no</span><br><span class="line"></span><br><span class="line">Using score quantization: no</span><br><span class="line"></span><br><span class="line">Explicitly included alignment information: <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">Running with 1 threads</span><br><span class="line"></span><br><span class="line">Pass 1/3: Creating <span class="built_in">hash</span> <span class="keyword">function</span> <span class="keyword">for</span> rank assignment</span><br><span class="line"></span><br><span class="line">..................................................[5000000]</span><br><span class="line"></span><br><span class="line">..................................................[10000000]</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Pass 2/3: Creating <span class="built_in">source</span> phrase index + Encoding target phrases</span><br><span class="line"></span><br><span class="line">..................................................[5000000]</span><br><span class="line"></span><br><span class="line">..................................................[10000000]</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Intermezzo: Calculating Huffman code sets</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 90037 target phrase symbols</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 69575 scores</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 5814858 scores</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 58305 scores</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 5407479 scores</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 50 alignment points</span><br><span class="line"></span><br><span class="line">Pass 3/3: Compressing target phrases</span><br><span class="line"></span><br><span class="line">..................................................[5000000]</span><br><span class="line"></span><br><span class="line">..................................................[10000000]</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Saving to binarised-model/phrase-table.minphr</span><br><span class="line"></span><br><span class="line">Done</span><br><span class="line"></span><br><span class="line">Used options:</span><br><span class="line"></span><br><span class="line">Text reordering table will be <span class="built_in">read</span> from:</span><br><span class="line">train/model/reordering-table.wbe-msd-bidirectional-fe.gz</span><br><span class="line"></span><br><span class="line">Output reordering table will be written to:</span><br><span class="line">binarised-model/reordering-table.minlexr</span><br><span class="line"></span><br><span class="line">Step size <span class="keyword">for</span> <span class="built_in">source</span> landmark phrases: 2\^10=1024</span><br><span class="line"></span><br><span class="line">Phrase fingerprint size: 16 bits / P(fp)=1.52588e-05</span><br><span class="line"></span><br><span class="line">Single Huffman code <span class="built_in">set</span> <span class="keyword">for</span> score components: no</span><br><span class="line"></span><br><span class="line">Using score quantization: no</span><br><span class="line"></span><br><span class="line">Running with 1 threads</span><br><span class="line"></span><br><span class="line">Pass 1/2: Creating phrase index + Counting scores</span><br><span class="line"></span><br><span class="line">..................................................[5000000]</span><br><span class="line"></span><br><span class="line">..................................................[10000000]</span><br><span class="line"></span><br><span class="line">..................................................[15000000]</span><br><span class="line"></span><br><span class="line">........................</span><br><span class="line"></span><br><span class="line">Intermezzo: Calculating Huffman code sets</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 16117 scores</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 8771 scores</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 16117 scores</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 15936 scores</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 8975 scores</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 16122 scores</span><br><span class="line"></span><br><span class="line">Pass 2/2: Compressing scores</span><br><span class="line"></span><br><span class="line">..................................................[5000000]</span><br><span class="line"></span><br><span class="line">..................................................[10000000]</span><br><span class="line"></span><br><span class="line">..................................................[15000000]</span><br><span class="line"></span><br><span class="line">........................</span><br><span class="line"></span><br><span class="line">Saving to binarised-model/reordering-table.minlexr</span><br><span class="line"></span><br><span class="line">Done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：如果你遇到了如下的错误，请确保你在刚开始用CMPH来编译摩西。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> ...\~/mosesdecoder/bin/processPhraseTableMin: No such file or directory</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将 ~&#x2F;working&#x2F;mert-work&#x2F;moses.ini复制到binarised-model<br>目录中，并且改变短语和重排序表以让他们指向二进制版本，你可以按如下的命令运行：</p>
<ol>
<li><p>将 binarised-model目录下的Moses.ini文件中的# feature<br>functions一栏中的PhraseDictionaryMemory 改为 PhraseDictionaryCompact</p>
</li>
<li><p>将 binarised-model目录下的Moses.ini文件中的# feature<br>functions一栏中的PhraseDictionary 的路径设置为如下：</p>
</li>
</ol>
<p>$HOME&#x2F;working&#x2F;binarised-model&#x2F;phrase-table.minphr</p>
<ol>
<li>将 binarised-model目录下的Moses.ini文件中# feature<br>functions一栏中的LexicalReordering 的路径设置为如下：</li>
</ol>
<p>$HOME&#x2F;working&#x2F;binarised-model&#x2F;reordering-table</p>
<p>修改后的Moses.ini中的feature function部分如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\# feature functions</span><br><span class="line"></span><br><span class="line">[feature]</span><br><span class="line"></span><br><span class="line">UnknownWordPenalty</span><br><span class="line"></span><br><span class="line">WordPenalty</span><br><span class="line"></span><br><span class="line">PhrasePenalty</span><br><span class="line"></span><br><span class="line">PhraseDictionaryCompact name=TranslationModel0 num-features=4</span><br><span class="line">path=/home/ubuntu/corpus/un_en-zh_23/working/binarised-model/phrase-table.minphr</span><br><span class="line">input-factor=0 output-factor=0</span><br><span class="line"></span><br><span class="line">LexicalReordering name=LexicalReordering0 num-features=6</span><br><span class="line">type=wbe-msd-bidirectional-fe-allff input-factor=0 output-factor=0</span><br><span class="line">path=/home/ubuntu/corpus/un_en-zh_23/working/binarised-model/reordering-table</span><br><span class="line"></span><br><span class="line">Distortion</span><br><span class="line"></span><br><span class="line">KENLM name=LM0 factor=0</span><br><span class="line">path=/home/ubuntu/corpus/un_en-zh_23/lm/un_en-zh23.blm.cn order=3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再次运行Moses:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\~/mosesdecoder/bin/moses -f \~/working/binarised-model/moses.ini</span><br></pre></td></tr></table></figure>

<p>接下来你会发现加载和运行一次翻译将会变得非常迅速。这里我们输入英语句子“however ,<br>there are good reasons for supporting the government .”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Defined parameters (per moses.ini or switch):</span><br><span class="line"></span><br><span class="line">config: /home/ubuntu/corpus/un_en-zh_23/working/binarised-model/moses.ini</span><br><span class="line"></span><br><span class="line">distortion-limit: 6</span><br><span class="line"></span><br><span class="line">feature: UnknownWordPenalty WordPenalty PhrasePenalty PhraseDictionaryCompact</span><br><span class="line">name=TranslationModel0 num -features=4</span><br><span class="line">path=/home/ubuntu/corpus/un_en-zh_23/working/binarised-model/phrase-table.minphr</span><br><span class="line">input-factor=0 outp ut-factor=0 LexicalReordering name=LexicalReordering0</span><br><span class="line">num-features=6 <span class="built_in">type</span>=wbe-msd-bidirectional-fe-allff input-f actor=0</span><br><span class="line">output-factor=0</span><br><span class="line">path=/home/ubuntu/corpus/un_en-zh_23/working/binarised-model/reordering-table</span><br><span class="line">Distortion KENLM name=LM0 <span class="built_in">factor</span>=0</span><br><span class="line">path=/home/ubuntu/corpus/un_en-zh_23/lm/un_en-zh23.blm.cn order=3</span><br><span class="line"></span><br><span class="line">input-factors: 0</span><br><span class="line"></span><br><span class="line">mapping: 0 T 0</span><br><span class="line"></span><br><span class="line">weight: LexicalReordering0= 0.0614344 0.0245557 0.242242 0.0725016 0.0539617</span><br><span class="line">0.0566553 Distortion0= 0.00 534453 LM0= 0.0696027 WordPenalty0= -0.166007</span><br><span class="line">PhrasePenalty0= 0.0688629 TranslationModel0= 0.0390017 0.0457273 0 .0730895</span><br><span class="line">0.0210141 UnknownWordPenalty0= 1</span><br><span class="line"></span><br><span class="line">line=UnknownWordPenalty</span><br><span class="line"></span><br><span class="line">FeatureFunction: UnknownWordPenalty0 start: 0 end: 0</span><br><span class="line"></span><br><span class="line">line=WordPenalty</span><br><span class="line"></span><br><span class="line">FeatureFunction: WordPenalty0 start: 1 end: 1</span><br><span class="line"></span><br><span class="line">line=PhrasePenalty</span><br><span class="line"></span><br><span class="line">FeatureFunction: PhrasePenalty0 start: 2 end: 2</span><br><span class="line"></span><br><span class="line">line=PhraseDictionaryCompact name=TranslationModel0 num-features=4</span><br><span class="line">path=/home/ubuntu/corpus/un_en-zh_23/working/</span><br><span class="line">binarised-model/phrase-table.minphr input-factor=0 output-factor=0</span><br><span class="line"></span><br><span class="line">FeatureFunction: TranslationModel0 start: 3 end: 6</span><br><span class="line"></span><br><span class="line">line=LexicalReordering name=LexicalReordering0 num-features=6</span><br><span class="line"><span class="built_in">type</span>=wbe-msd-bidirectional-fe-allff input-factor=0 output-factor=0</span><br><span class="line">path=/home/ubuntu/corpus/un_en-zh_23/working/binarised-model/reordering-table</span><br><span class="line"></span><br><span class="line">Initializing Lexical Reordering Feature..</span><br><span class="line"></span><br><span class="line">FeatureFunction: LexicalReordering0 start: 7 end: 12</span><br><span class="line"></span><br><span class="line">line=Distortion</span><br><span class="line"></span><br><span class="line">FeatureFunction: Distortion0 start: 13 end: 13</span><br><span class="line"></span><br><span class="line">line=KENLM name=LM0 <span class="built_in">factor</span>=0</span><br><span class="line">path=/home/ubuntu/corpus/un_en-zh_23/lm/un_en-zh23.blm.cn order=3</span><br><span class="line"></span><br><span class="line">FeatureFunction: LM0 start: 14 end: 14</span><br><span class="line"></span><br><span class="line">Loading UnknownWordPenalty0</span><br><span class="line"></span><br><span class="line">Loading WordPenalty0</span><br><span class="line"></span><br><span class="line">Loading PhrasePenalty0</span><br><span class="line"></span><br><span class="line">Loading LexicalReordering0</span><br><span class="line"></span><br><span class="line">Loading Distortion0</span><br><span class="line"></span><br><span class="line">Loading LM0</span><br><span class="line"></span><br><span class="line">Loading TranslationModel0</span><br><span class="line"></span><br><span class="line">Created input-output object : [0.428] seconds</span><br><span class="line"></span><br><span class="line">however , there are good reasons <span class="keyword">for</span> supporting the government</span><br><span class="line"></span><br><span class="line">Translating: however , there are good reasons <span class="keyword">for</span> supporting the government</span><br><span class="line"></span><br><span class="line">Line 0: Initialize search took 0.000 seconds total</span><br><span class="line"></span><br><span class="line">Line 0: Collecting options took 0.567 seconds at moses/Manager.cpp Line 141</span><br><span class="line"></span><br><span class="line">Line 0: Search took 0.308 seconds</span><br><span class="line"></span><br><span class="line">然而 ， 有 充分 理由 支持 政府</span><br><span class="line"></span><br><span class="line">BEST TRANSLATION: 然而 ， 有 充分 理由 支持 政府 [1111111111] [total=-3.462]</span><br><span class="line">core=(0.000,-7.000,4.000,-13.611,-24.516,-3.431,-11.391,-3.059,0.000,0.000,-2.434,0.000,0.000,0.000,-34.379)</span><br><span class="line"></span><br><span class="line">Line 0: Decision rule took 0.000 seconds total</span><br><span class="line"></span><br><span class="line">Line 0: Additional reporting took 0.000 seconds total</span><br><span class="line"></span><br><span class="line">Line 0: Translation took 0.877 seconds total \\</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你会发现，此次加载运行一次翻译系统只需0.877秒，而且在此期间，CPU和内存的占用几乎可以忽略不计。说明我们的二值化取得了非常良好的效果。在这一步，你可能很想知道这个翻译系统的表现如何。为了衡量这一点，我们使用另一组之前没有使用过的平行数据（测试集）。我们的测试集文件名称是un_test.cn和un_test.en。首先，和之前一样，我们需要对测试集进行tokenise<br>和truecase。</p>
<p>此处对un_test.cn进行tokenise时依然采用thulac分词工具，得到un_test.fc文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cd \~/corpus</span><br><span class="line"></span><br><span class="line">\~/mosesdecoder/scripts/tokenizer/tokenizer.perl -l en \\</span><br><span class="line"></span><br><span class="line">\&lt; dev/un_test.en \&gt; un_test.tok.en</span><br><span class="line"></span><br><span class="line">\~/mosesdecoder/scripts/recaser/truecase.perl --model truecase-model.en \\</span><br><span class="line"></span><br><span class="line">\&lt; un_test.tok.en \&gt; un_test.true.en</span><br><span class="line"></span><br><span class="line">\~/mosesdecoder/scripts/recaser/truecase.perl --model truecase-model.cn \\</span><br><span class="line"></span><br><span class="line">\&lt; un_test.fc \&gt; un_test.true.cn</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以针对次测试机过滤我们训练过的模型，这意味着我们只保留需要的条目来翻译。这会使翻译速度加快一些。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cd \~/working</span><br><span class="line"></span><br><span class="line">\~/mosesdecoder/scripts/training/filter-model-given-input.pl \\</span><br><span class="line"></span><br><span class="line">filtered-newstest2011 \~/working/mert-work/moses.ini \~/corpus/un_test.true.en</span><br><span class="line">\\</span><br><span class="line"></span><br><span class="line">\-Binarizer \~/mosesdecoder/bin/processPhraseTableMin</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行命令后，你会看到如下的提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Executing: <span class="built_in">mkdir</span> -p /home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test</span><br><span class="line"></span><br><span class="line">Stripping XML...</span><br><span class="line"></span><br><span class="line">Executing: /home/ubuntu/mosesdecoder/scripts/training/../generic/strip-xml.perl</span><br><span class="line">\&lt; /home/ubuntu/corpus/un_en-zh_23/test/un_test.true.en \&gt;</span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/input.16677</span><br><span class="line"></span><br><span class="line">pt:PhraseDictionaryMemory name=TranslationModel0 num-features=4</span><br><span class="line">path=/home/ubuntu/corpus/un_en-zh_23/working/train/model/phrase-table.gz</span><br><span class="line">input-factor=0 output-factor=0</span><br><span class="line"></span><br><span class="line">Considering <span class="built_in">factor</span> 0</span><br><span class="line"></span><br><span class="line">ro:LexicalReordering name=LexicalReordering0 num-features=6</span><br><span class="line"><span class="built_in">type</span>=wbe-msd-bidirectional-fe-allff input-factor=0 output-factor=0</span><br><span class="line">path=/home/ubuntu/corpus/un_en-zh_23/working/train/model/reordering-table.wbe-msd-bidirectional-fe.gz</span><br><span class="line"></span><br><span class="line">Considering <span class="built_in">factor</span> 0</span><br><span class="line"></span><br><span class="line">Filtering files...</span><br><span class="line"></span><br><span class="line">filtering /home/ubuntu/corpus/un_en-zh_23/working/train/model/phrase-table.gz</span><br><span class="line">-\&gt;</span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/phrase-table.0-0.1.1...</span><br><span class="line"></span><br><span class="line">2351834 of 17491572 phrases pairs used (13.45%) - note: max length 10</span><br><span class="line"></span><br><span class="line">binarizing...</span><br><span class="line"></span><br><span class="line">Executing: gzip -<span class="built_in">cd</span></span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/phrase-table.0-0.1.1.gz \|</span><br><span class="line">LC_ALL=C <span class="built_in">sort</span> --compress-program gzip -T</span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test \| gzip - \&gt;</span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/phrase-table.0-0.1.1.gz.sorted.gz</span><br><span class="line">&amp;&amp; /home/ubuntu/mosesdecoder/bin/processPhraseTableMin -<span class="keyword">in</span></span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/phrase-table.0-0.1.1.gz.sorted.gz</span><br><span class="line">-out /home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/phrase-table.0-0.1.1</span><br><span class="line">-nscores 4 -threads 1 &amp;&amp; <span class="built_in">rm</span></span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/phrase-table.0-0.1.1.gz.sorted.gz</span><br><span class="line"></span><br><span class="line">Used options:</span><br><span class="line"></span><br><span class="line">Text phrase table will be <span class="built_in">read</span> from:</span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/phrase-table.0-0.1.1.gz.sorted.gz</span><br><span class="line"></span><br><span class="line">Output phrase table will be written to:</span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/phrase-table.0-0.1.1.minphr</span><br><span class="line"></span><br><span class="line">Step size <span class="keyword">for</span> <span class="built_in">source</span> landmark phrases: 2\^10=1024</span><br><span class="line"></span><br><span class="line">Source phrase fingerprint size: 16 bits / P(fp)=1.52588e-05</span><br><span class="line"></span><br><span class="line">Selected target phrase encoding: Huffman + PREnc</span><br><span class="line"></span><br><span class="line">Maxiumum allowed rank <span class="keyword">for</span> PREnc: 100</span><br><span class="line"></span><br><span class="line">Number of score components <span class="keyword">in</span> phrase table: 4</span><br><span class="line"></span><br><span class="line">Single Huffman code <span class="built_in">set</span> <span class="keyword">for</span> score components: no</span><br><span class="line"></span><br><span class="line">Using score quantization: no</span><br><span class="line"></span><br><span class="line">Explicitly included alignment information: <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">Running with 1 threads</span><br><span class="line"></span><br><span class="line">Pass 1/3: Creating <span class="built_in">hash</span> <span class="keyword">function</span> <span class="keyword">for</span> rank assignment</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">Pass 2/3: Creating <span class="built_in">source</span> phrase index + Encoding target phrases</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">Intermezzo: Calculating Huffman code sets</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 37180 target phrase symbols</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 59255 scores</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 779126 scores</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 55190 scores</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 1373326 scores</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 50 alignment points</span><br><span class="line"></span><br><span class="line">Pass 3/3: Compressing target phrases</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">Saving to</span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/phrase-table.0-0.1.1.minphr</span><br><span class="line"></span><br><span class="line">Done</span><br><span class="line"></span><br><span class="line">filtering</span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/working/train/model/reordering-table.wbe-msd-bidirectional-fe.gz</span><br><span class="line">-\&gt;</span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/reordering-table.wbe-msd-bidirectional-fe.0-0.1...</span><br><span class="line"></span><br><span class="line">2351834 of 17491572 phrases pairs used (13.45%) - note: max length 10</span><br><span class="line"></span><br><span class="line">binarizing...</span><br><span class="line"></span><br><span class="line">Executing: gzip -<span class="built_in">cd</span></span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/reordering-table.wbe-msd-bidirectional-fe.0-0.1.gz</span><br><span class="line">\| LC_ALL=C <span class="built_in">sort</span> --compress-program gzip -T</span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test \| gzip - \&gt;</span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/reordering-table.wbe-msd-bidirectional-fe.0-0.1.gz.sorted.gz</span><br><span class="line">&amp;&amp; /home/ubuntu/mosesdecoder/bin/processLexicalTableMin -<span class="keyword">in</span></span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/reordering-table.wbe-msd-bidirectional-fe.0-0.1.gz.sorted.gz</span><br><span class="line">-out</span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/reordering-table.wbe-msd-bidirectional-fe.0-0.1</span><br><span class="line">-threads 1 &amp;&amp; <span class="built_in">rm</span></span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/reordering-table.wbe-msd-bidirectional-fe.0-0.1.gz.sorted.gz</span><br><span class="line"></span><br><span class="line">Used options:</span><br><span class="line"></span><br><span class="line">Text reordering table will be <span class="built_in">read</span> from:</span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/reordering-table.wbe-msd-bidirectional-fe.0-0.1.gz.sorted.gz</span><br><span class="line"></span><br><span class="line">Output reordering table will be written to:</span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/reordering-table.wbe-msd-bidirectional-fe.0-0.1.minlexr</span><br><span class="line"></span><br><span class="line">Step size <span class="keyword">for</span> <span class="built_in">source</span> landmark phrases: 2\^10=1024</span><br><span class="line"></span><br><span class="line">Phrase fingerprint size: 16 bits / P(fp)=1.52588e-05</span><br><span class="line"></span><br><span class="line">Single Huffman code <span class="built_in">set</span> <span class="keyword">for</span> score components: no</span><br><span class="line"></span><br><span class="line">Using score quantization: no</span><br><span class="line"></span><br><span class="line">Running with 1 threads</span><br><span class="line"></span><br><span class="line">Pass 1/2: Creating phrase index + Counting scores</span><br><span class="line"></span><br><span class="line">.......................</span><br><span class="line"></span><br><span class="line">Intermezzo: Calculating Huffman code sets</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 14663 scores</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 8197 scores</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 14660 scores</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 14562 scores</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 8162 scores</span><br><span class="line"></span><br><span class="line">Creating Huffman codes <span class="keyword">for</span> 14774 scores</span><br><span class="line"></span><br><span class="line">Pass 2/2: Compressing scores</span><br><span class="line"></span><br><span class="line">.......................</span><br><span class="line"></span><br><span class="line">Saving to</span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/reordering-table.wbe-msd-bidirectional-fe.0-0.1.minlexr</span><br><span class="line"></span><br><span class="line">Done</span><br><span class="line"></span><br><span class="line">To run the decoder, please call:</span><br><span class="line"></span><br><span class="line">moses -f /home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/moses.ini -i</span><br><span class="line">/home/ubuntu/corpus/un_en-zh_23/test/filtered-un_test/input.16677</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你可以在第一次翻译测试数据时运行BLEU脚本来测试解码器。当然，这需要很短一段时间。命令中的<br>-lc是无视大小写的BLEU评分，不使用参数-lc是大小写敏感的BLEU评分。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">nohup nice \~/mosesdecoder/bin/moses \\</span><br><span class="line"></span><br><span class="line">\-f \~/working/filtered-un_test/moses.ini -i \\</span><br><span class="line"></span><br><span class="line">\&lt; \~/corpus/ un_test.true.en \\</span><br><span class="line"></span><br><span class="line">\&gt; \~/working/un_test.translated.cn \\</span><br><span class="line"></span><br><span class="line">2\&gt; \~/working/un_test.out</span><br><span class="line"></span><br><span class="line">\~/mosesdecoder/scripts/generic/multi-bleu.perl \\</span><br><span class="line"></span><br><span class="line">\-lc \~/corpus/un_test.true.cn \\</span><br><span class="line"></span><br><span class="line">\&lt; \~/working/un_test.translated.cn</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述命令中，un_test.true.en<br>是我们待翻译的文件，un_test.translated.cn是我们得到的翻译后的文件，un_test.out是我们在翻译过程中生成的日志文件，你可以用VIM工具查看其中的内容。</p>
<p>命令执行完成后，我们会得到如下的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">BLEU = 29.29, 68.1/36.9/22.0/13.3 (BP=1.000, ratio=1.001, hyp_len=106809,</span><br><span class="line">ref_len=106725)</span><br><span class="line"></span><br><span class="line">It is in-advisable to publish scores from multi-bleu.perl. The scores depend on</span><br><span class="line">your tokenizer, which is unlikely to be reproducible from your paper or</span><br><span class="line">consistent across research groups. Instead you should detokenize then use</span><br><span class="line">mteval-v14.pl, which has a standard tokenization. Scores from multi-bleu.perl</span><br><span class="line">can still be used for internal purposes when you have a consistent tokenizer.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从multi-bleu.perl得到的分数是可信的。<br>最终得到的分数取决于你的分词工具的好坏，在你的论文中或者整个研究小组中每次得到的分数都应该是不同的。相反，你应该使用mteval-v14.pl，它可以进行标准的符号化。当您拥有一致的标记生成器时，来自multi-bleu.perl的分数仍可用于内部目的。</p>
<p>我们这里得到的BLEU成绩是29.29分，每次进行翻译时，得到的BLEU分数应该是不一样的。在tuning和最终test的时候参考译文的数量以及使用不同分词工具所造成的预处理的不同，语言模型是n-gram的不同都会影响到最终BLEU分数。</p>
<h2 id="八-搭建moses-server"><a href="#八-搭建moses-server" class="headerlink" title="八 搭建moses server"></a>八 搭建moses server</h2><p>如果希望把moses作为服务开放使用，必须通过设置将moses设为moses<br>server。具体步骤如下： <br>1.<br>安装xmlrpc（如果前面按照本文档已经安装xmlrpc，该步可以略过。否则参见该文档前半部分。安装完成后重新编译moses）。 <br>2. 修改moses.pl参数 <br>进入~&#x2F;mosesdecoder&#x2F;contrib&#x2F;iSenWeb文件夹，打开moses.pl文件，在该文件中指定moses和moses.ini(配置文件)的位置。我这里的MOSES参数为“&#x2F;home&#x2F;ubuntu&#x2F;mosesdecoder&#x2F;bin&#x2F;moses”，<br>MOSES_INI参数为”<br>&#x2F;home&#x2F;ubuntu&#x2F;corpus&#x2F;un_en-zh_23&#x2F;working&#x2F;binarised-model&#x2F;moses.ini”。关闭并保存。如下所示： </p>
<p>将Moses.pl文件中的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">\#------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">\# constants, global vars, config</span><br><span class="line"></span><br><span class="line">my \$MOSES = &#x27;/home/tianliang/research/moses-smt/scripts/training/model/moses&#x27;;</span><br><span class="line"></span><br><span class="line">my \$MOSES_INI =</span><br><span class="line">&#x27;/home/tianliang/research/moses-smt/scripts/training/model/moses.ini&#x27;;</span><br><span class="line"></span><br><span class="line">die &quot;usage: daemon.pl \&lt;hostname\&gt; \&lt;port\&gt;&quot; unless (\@ARGV == 2);</span><br><span class="line"></span><br><span class="line">my \$LISTEN_HOST = shift;</span><br><span class="line"></span><br><span class="line">my \$LISTEN_PORT = shift;</span><br><span class="line"></span><br><span class="line">\#------------------------------------------------------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\<span class="comment">#------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">\<span class="comment"># constants, global vars, config</span></span><br><span class="line"></span><br><span class="line">my \<span class="variable">$MOSES</span> = <span class="string">&#x27;/home/ubuntu/mosesdecoder/bin/moses&#x27;</span>;</span><br><span class="line"></span><br><span class="line">my \<span class="variable">$MOSES_INI</span> =</span><br><span class="line"><span class="string">&#x27;/home/ubuntu/corpus/un_en-zh_23/working/binarised-model/moses.ini&#x27;</span>;</span><br><span class="line"></span><br><span class="line">die <span class="string">&quot;usage: daemon.pl \&lt;hostname\&gt; \&lt;port\&gt;&quot;</span> unless (\@ARGV == 2);</span><br><span class="line"></span><br><span class="line">my \<span class="variable">$LISTEN_HOST</span> = <span class="built_in">shift</span>;</span><br><span class="line"></span><br><span class="line">my \<span class="variable">$LISTEN_PORT</span> = <span class="built_in">shift</span>;</span><br><span class="line"></span><br><span class="line">\<span class="comment">#------------------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进入到~&#x2F;mosesdecoder&#x2F;contrib&#x2F;iSenWeb文件夹，在terminal中输入：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">./moses.pl 192.168.0.1 9999</span><br></pre></td></tr></table></figure>

<p>即：moses.pl &lt;hostname&gt; &lt;port&gt;</p>
<p>其中， 192.168.1.1 是本机地址，9999是端口号。TCP&#x2F;IP协议中端口号的范围从0~65535,1024以下的端口用于系统服务，1024~65535端口我们可以使用。我们可以在&#x2F;etc&#x2F;service文件中看到各个端口的情况。</p>
<p>我们也可以持续运行moses server：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">nohup</span> \~ /mosesdecoder/contrib/iSenWeb/moses.pl 192.168.0.1 9999&amp;</span><br></pre></td></tr></table></figure>

<p>运行命令后会显示忽略输入并把输出追加到”nohup.out”。即成功运行了moses<br>server。在Linux中，nohup的意思是忽略SIGHUP信号， 所以当运行nohup .&#x2F;a.out的时候，<br>关闭shell,<br>那么a.out进程还是存在的，即对SIGHUP信号免疫。后面的&amp;符号意为让任务在后台运行。 运行后会在当前路径下产生一个文件nohup.out。</p>
<ol>
<li><p>测试翻译平台： </p>
</li>
<li><p>输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot; may I help you&quot;</span> \| nc 192.168.0.1 9999</span><br></pre></td></tr></table></figure></li>
</ol>
<p>可以看到返回结果：</p>
<p>我 是 否 可以 帮助 你</p>
<ol start="5">
<li>如果需要关闭moses server，使用killall moses.pl就可以了。</li>
</ol>
</h6></h6>]]></content>
      <categories>
        <category>Notes</category>
      </categories>
  </entry>
  <entry>
    <title>ES6入门</title>
    <url>/Blog/2022/05/15/ES6%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h6 align="center">编者：艾孜尔江<h6>

<h1 id="1-ECMAScirpt-6-简介"><a href="#1-ECMAScirpt-6-简介" class="headerlink" title="1. ECMAScirpt 6 简介"></a>1. ECMAScirpt 6 简介</h1><p>ESMAScript 6 是javascript 2016年发布的新标准。</p>
<h1 id="2-let和const命令"><a href="#2-let和const命令" class="headerlink" title="2. let和const命令"></a>2. let和const命令</h1><h3 id="2-1-let命令"><a href="#2-1-let命令" class="headerlink" title="2.1 let命令"></a>2.1 let命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>let</code> 声明的变量只在代码块中有效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  let a = 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for</code> 循环的计数器，就很适合使用<code>let</code>命令。此时计数器i只在循环体内有效。</p>
<p>另外，循环语句部分的变量和循环体内部的变量是分离的。</p>
<h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><p><code>let</code> 声明的变量不可以在声明之前被使用。否则会抛出错误。</p>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>只要一个代码块中使用了<code>let</code>声明一个变量，则它的全局同名变量在该代码块中不可用。</p>
<p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  // TDZ开始</span><br><span class="line">  tmp = &#x27;abc&#x27;; // ReferenceError</span><br><span class="line">  console.log(tmp); // ReferenceError</span><br><span class="line"></span><br><span class="line">  let tmp; // TDZ结束</span><br><span class="line">  console.log(tmp); // undefined</span><br><span class="line"></span><br><span class="line">  tmp = 123;</span><br><span class="line">  console.log(tmp); // 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>
<h3 id="2-2块级作用域"><a href="#2-2块级作用域" class="headerlink" title="2.2块级作用域"></a>2.2块级作用域</h3><h4 id="为什么需要块级作用域？"><a href="#为什么需要块级作用域？" class="headerlink" title="为什么需要块级作用域？"></a>为什么需要块级作用域？</h4><ol>
<li>内层变量可能会覆盖外层变量。</li>
<li>用来计数的循环变量泄露为全局变量。</li>
</ol>
<h4 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h4><p><code>let</code>实际上为 JavaScript 新增了块级作用域。</p>
<p>ES6 允许块级作用域的任意嵌套。</p>
<p>内层作用域可以定义外层作用域的同名变量。</p>
<p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// IIFE 写法</span><br><span class="line">(function () &#123;</span><br><span class="line">  var tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">// 块级作用域写法</span><br><span class="line">&#123;</span><br><span class="line">  let tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h4><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p>
<p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</p>
<p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 函数声明语句</span><br><span class="line">&#123;</span><br><span class="line">  let a = &#x27;secret&#x27;;</span><br><span class="line">  function f() &#123;</span><br><span class="line">    return a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">&#123;</span><br><span class="line">  let a = &#x27;secret&#x27;;</span><br><span class="line">  let f = function () &#123;</span><br><span class="line">    return a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p>
<h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h3><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在Node指的是<code>global</code>对象。</p>
<p>ES6为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<h3 id="global对象"><a href="#global对象" class="headerlink" title="global对象"></a>global对象</h3><p>垫片库<code>system.global</code>模拟了这个提案，可以在所有环境拿到<code>global</code>。</p>
<h1 id="3-变量的解构赋值"><a href="#3-变量的解构赋值" class="headerlink" title="3.变量的解构赋值"></a>3.变量的解构赋值</h1><h3 id="3-1数组的结构赋值"><a href="#3-1数组的结构赋值" class="headerlink" title="3.1数组的结构赋值"></a>3.1数组的结构赋值</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let [a, b, c] = [1, 2, 3];</span><br></pre></td></tr></table></figure>
<p>解构赋值允许指定默认值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let [foo = true] = [];</span><br><span class="line">foo // true</span><br><span class="line"></span><br><span class="line">let [x, y = &#x27;b&#x27;] = [&#x27;a&#x27;]; // x=&#x27;a&#x27;, y=&#x27;b&#x27;</span><br><span class="line">let [x, y = &#x27;b&#x27;] = [&#x27;a&#x27;, undefined]; // x=&#x27;a&#x27;, y=&#x27;b&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="3-2对象的解构赋值"><a href="#3-2对象的解构赋值" class="headerlink" title="3.2对象的解构赋值"></a>3.2对象的解构赋值</h3><p>解构不仅可以用于数组，还可以用于对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">foo // &quot;aaa&quot;</span><br><span class="line">bar // &quot;bbb&quot;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-字符串的解构赋值"><a href="#3-3-字符串的解构赋值" class="headerlink" title="3.3 字符串的解构赋值"></a>3.3 字符串的解构赋值</h3><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const [a, b, c, d, e] = &#x27;hello&#x27;;</span><br><span class="line">a // &quot;h&quot;</span><br><span class="line">b // &quot;e&quot;</span><br><span class="line">c // &quot;l&quot;</span><br><span class="line">d // &quot;l&quot;</span><br><span class="line">e // &quot;o&quot;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-数值和布尔值的解构赋值"><a href="#3-4-数值和布尔值的解构赋值" class="headerlink" title="3.4 数值和布尔值的解构赋值"></a>3.4 数值和布尔值的解构赋值</h3><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let &#123;toString: s&#125; = 123;</span><br><span class="line">s === Number.prototype.toString // true</span><br><span class="line"></span><br><span class="line">let &#123;toString: s&#125; = true;</span><br><span class="line">s === Boolean.prototype.toString // true</span><br></pre></td></tr></table></figure>
<h3 id="3-5-函数参数的解构赋值"><a href="#3-5-函数参数的解构赋值" class="headerlink" title="3.5 函数参数的解构赋值"></a>3.5 函数参数的解构赋值</h3><p>函数的参数也可以使用解构赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add([x, y])&#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([1, 2]); // 3</span><br></pre></td></tr></table></figure>
<h3 id="3-6-用途"><a href="#3-6-用途" class="headerlink" title="3.6 用途"></a>3.6 用途</h3><ol>
<li>交换变量的值<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let x = 1;</span><br><span class="line">let y = 2;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>
2.从函数返回多个值<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 返回一个数组</span><br><span class="line"></span><br><span class="line">function example() &#123;</span><br><span class="line">  return [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">let [a, b, c] = example();</span><br><span class="line"></span><br><span class="line">// 返回一个对象</span><br><span class="line"></span><br><span class="line">function example() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    foo: 1,</span><br><span class="line">    bar: 2</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>
3.函数参数的定义<br>解构赋值可以方便地将一组参数与变量名对应起来。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 参数是一组有次序的值</span><br><span class="line">function f([x, y, z]) &#123; ... &#125;</span><br><span class="line">f([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// 参数是一组无次序的值</span><br><span class="line">function f(&#123;x, y, z&#125;) &#123; ... &#125;</span><br><span class="line">f(&#123;z: 3, y: 2, x: 1&#125;);</span><br></pre></td></tr></table></figure></li>
<li>提取JSON数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let jsonData = &#123;</span><br><span class="line">  id: 42,</span><br><span class="line">  status: &quot;OK&quot;,</span><br><span class="line">  data: [867, 5309]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; id, status, data: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line">console.log(id, status, number);</span><br><span class="line">// 42, &quot;OK&quot;, [867, 5309]</span><br></pre></td></tr></table></figure></li>
<li>函数参数的默认值<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jQuery.ajax = function (url, &#123;</span><br><span class="line">  async = true,</span><br><span class="line">  beforeSend = function () &#123;&#125;,</span><br><span class="line">  cache = true,</span><br><span class="line">  complete = function () &#123;&#125;,</span><br><span class="line">  crossDomain = false,</span><br><span class="line">  global = true,</span><br><span class="line">  // ... more config</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  // ... do stuff</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
6.遍历map结构<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var map = new Map();</span><br><span class="line">map.set(&#x27;first&#x27;, &#x27;hello&#x27;);</span><br><span class="line">map.set(&#x27;second&#x27;, &#x27;world&#x27;);</span><br><span class="line"></span><br><span class="line">for (let [key, value] of map) &#123;</span><br><span class="line">  console.log(key + &quot; is &quot; + value);</span><br><span class="line">&#125;</span><br><span class="line">// first is hello</span><br><span class="line">// second is world</span><br></pre></td></tr></table></figure></li>
<li>输入模块的指定方法<br>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="4-字符串的扩展"><a href="#4-字符串的扩展" class="headerlink" title="4. 字符串的扩展"></a>4. 字符串的扩展</h1><h3 id="4-1字符的Unicode表示法"><a href="#4-1字符的Unicode表示法" class="headerlink" title="4.1字符的Unicode表示法"></a>4.1字符的Unicode表示法</h3><p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;\u&#123;20BB7&#125;&quot;</span><br><span class="line">// &quot;𠮷&quot;</span><br><span class="line"></span><br><span class="line">&quot;\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;&quot;</span><br><span class="line">// &quot;ABC&quot;</span><br><span class="line"></span><br><span class="line">let hello = 123;</span><br><span class="line">hell\u&#123;6F&#125; // 123</span><br><span class="line"></span><br><span class="line">&#x27;\u&#123;1F680&#125;&#x27; === &#x27;\uD83D\uDE80&#x27;</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
<h3 id="4-2-codePointAt"><a href="#4-2-codePointAt" class="headerlink" title="4.2 codePointAt()"></a>4.2 codePointAt()</h3><p>ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var s = &#x27;𠮷a&#x27;;</span><br><span class="line"></span><br><span class="line">s.codePointAt(0) // 134071</span><br><span class="line">s.codePointAt(1) // 57271</span><br><span class="line">s.codePointAt(2) // 97</span><br></pre></td></tr></table></figure>
<h3 id="4-3-String-fromCodePoint"><a href="#4-3-String-fromCodePoint" class="headerlink" title="4.3 String.fromCodePoint()"></a>4.3 String.fromCodePoint()</h3><p>ES5提供String.fromCharCode方法，用于从码点返回对应字符。</p>
<h3 id="4-4-字符串的遍历器接口"><a href="#4-4-字符串的遍历器接口" class="headerlink" title="4.4 字符串的遍历器接口"></a>4.4 字符串的遍历器接口</h3><p>ES6为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (let codePoint of &#x27;foo&#x27;) &#123;</span><br><span class="line">  console.log(codePoint)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-at"><a href="#4-5-at" class="headerlink" title="4.5 at()"></a>4.5 at()</h3><p>ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。</p>
<h3 id="4-7-includes-startsWith-endsWith"><a href="#4-7-includes-startsWith-endsWith" class="headerlink" title="4.7 includes(), startsWith(), endsWith()"></a>4.7 includes(), startsWith(), endsWith()</h3><ul>
<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>
</ul>
<h3 id="4-8-repeat"><a href="#4-8-repeat" class="headerlink" title="4.8 repeat()"></a>4.8 repeat()</h3><p>repeat方法返回一个新字符串，表示将原字符串重复n次。</p>
<h3 id="4-9-padStart-，padEnd"><a href="#4-9-padStart-，padEnd" class="headerlink" title="4.9 padStart()，padEnd()"></a>4.9 padStart()，padEnd()</h3><p>ES2017引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</p>
<h3 id="4-10-模板字符串"><a href="#4-10-模板字符串" class="headerlink" title="4.10 模板字符串"></a>4.10 模板字符串</h3><p>模板字符串（template string）是增强版的字符串，用反引号（&#96;）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 普通字符串</span><br><span class="line">`In JavaScript &#x27;\n&#x27; is a line-feed.`</span><br><span class="line"></span><br><span class="line">// 多行字符串</span><br><span class="line">`In JavaScript this is</span><br><span class="line"> not legal.`</span><br><span class="line"></span><br><span class="line">console.log(`string text line 1</span><br><span class="line">string text line 2`);</span><br><span class="line"></span><br><span class="line">// 字符串中嵌入变量</span><br><span class="line">var name = &quot;Bob&quot;, time = &quot;today&quot;;</span><br><span class="line">`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`</span><br></pre></td></tr></table></figure>

<p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<ul>标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。</ul></p>
<p>模板字符串中嵌入变量，需要将变量名写在${}之中。<br>模板字符串之中还能调用函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br></pre></td></tr></table></figure>

<h3 id="4-12-标签模板"><a href="#4-12-标签模板" class="headerlink" title="4.12 标签模板"></a>4.12 标签模板</h3><h3 id="4-13-String-raw"><a href="#4-13-String-raw" class="headerlink" title="4.13 String.raw()"></a>4.13 String.raw()</h3><p>String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</p>
<h1 id="5-正则的扩展（跳过）"><a href="#5-正则的扩展（跳过）" class="headerlink" title="5. 正则的扩展（跳过）"></a>5. 正则的扩展（跳过）</h1><h1 id="6-数值的扩展"><a href="#6-数值的扩展" class="headerlink" title="6. 数值的扩展"></a>6. 数值的扩展</h1><h3 id="6-1-二进制和八进制表示法"><a href="#6-1-二进制和八进制表示法" class="headerlink" title="6.1 二进制和八进制表示法"></a>6.1 二进制和八进制表示法</h3><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。</p>
<h3 id="6-2-Number-isFinite-Number-isNaN"><a href="#6-2-Number-isFinite-Number-isNaN" class="headerlink" title="6.2 Number.isFinite(), Number.isNaN()"></a>6.2 Number.isFinite(), Number.isNaN()</h3><p>Number.isFinite()用来检查一个数值是否为有限的（finite）。<br>Number.isNaN()用来检查一个值是否为NaN。</p>
<h1 id="7-函数的扩展"><a href="#7-函数的扩展" class="headerlink" title="7. 函数的扩展"></a>7. 函数的扩展</h1><h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数变量是默认声明的，所以不能用let或const再次声明。</p>
<h3 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h3><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h3><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<h3 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h3><p>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</p>
<p>这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest 参数也不会计入length属性。</p>
<p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throwIfMissing</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Missing parameter&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">mustBeProvided = throwIfMissing()</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> mustBeProvided;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><p>ES6 引入 rest 参数（<strong>形式为…变量名</strong>），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...values</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><p>函数的name属性，返回该函数的函数名。</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6 允许使用“箭头”（&#x3D;&gt;）定义函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">f</span> = v =&gt; v;</span><br></pre></td></tr></table></figure>
<p>第一个v为参数，第二个v为返回值。</p>
<p>箭头函数的一个用处是简化回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure>
<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">g</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>
<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>
<h3 id="函数参数的尾逗号"><a href="#函数参数的尾逗号" class="headerlink" title="函数参数的尾逗号"></a>函数参数的尾逗号</h3><p>ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。</p>
<h1 id="8-数组的扩展"><a href="#8-数组的扩展" class="headerlink" title="8. 数组的扩展"></a>8. 数组的扩展</h1><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">v, w, x, y, z</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"><span class="title function_">f</span>(-<span class="number">1</span>, ...args, <span class="number">2</span>, ...[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="替代数组的apply方法"><a href="#替代数组的apply方法" class="headerlink" title="替代数组的apply方法"></a>替代数组的apply方法</h3><p>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="title function_">f</span>(...args);</span><br></pre></td></tr></table></figure>

<h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><h4 id="1-合并数组"><a href="#1-合并数组" class="headerlink" title="1. 合并数组"></a>1. 合并数组</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5的合并数组</span></span><br><span class="line">arr1.<span class="title function_">concat</span>(arr2, arr3);</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h4 id="2-与结构赋值结合"><a href="#2-与结构赋值结合" class="headerlink" title="2. 与结构赋值结合"></a>2. 与结构赋值结合</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h4 id="3-函数的返回值"><a href="#3-函数的返回值" class="headerlink" title="3. 函数的返回值"></a>3. 函数的返回值</h4><p>JavaScript 的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。</p>
<h4 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4. 字符串"></a>4. 字符串</h4><p>扩展运算符还可以将字符串转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure>

<h4 id="5-实现了Iterator接口的对象"><a href="#5-实现了Iterator接口的对象" class="headerlink" title="5. 实现了Iterator接口的对象"></a>5. 实现了Iterator接口的对象</h4><p>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> array = [...nodeList];</span><br></pre></td></tr></table></figure>
<p>上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。</p>
<h3 id="Array-form"><a href="#Array-form" class="headerlink" title="Array.form()"></a>Array.form()</h3><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于\uFFFF的Unicode字符，算作两个字符的bug。</p>
<h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of( )"></a>Array.of( )</h3><p>Array.of方法用于将一组值，转换为数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>).<span class="property">length</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="数组示例的copyWithin"><a href="#数组示例的copyWithin" class="headerlink" title="数组示例的copyWithin()"></a>数组示例的copyWithin()</h3><p>数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">copyWithin</span>(target, start = <span class="number">0</span>, end = <span class="variable language_">this</span>.<span class="property">length</span>)</span><br></pre></td></tr></table></figure>
<p>它接受三个参数。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ul>
<p>这三个参数都应该是数值，如果不是，会自动转为数值。</p>
<h3 id="数组实例的find-和findIndex"><a href="#数组实例的find-和findIndex" class="headerlink" title="数组实例的find()和findIndex()"></a>数组实例的find()和findIndex()</h3><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].<span class="title function_">find</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure>
<p>上面代码找出数组中第一个小于0的成员。</p>
<p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>
<h3 id="数组实例的fill"><a href="#数组实例的fill" class="headerlink" title="数组实例的fill()"></a>数组实例的fill()</h3><p>fill方法使用给定值，填充一个数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_">fill</span>(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure>
<h3 id="数组实例的entries-keys-values"><a href="#数组实例的entries-keys-values" class="headerlink" title="数组实例的entries(),keys(),values()"></a>数组实例的entries(),keys(),values()</h3><p>ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="数组实例的includes"><a href="#数组实例的includes" class="headerlink" title="数组实例的includes()"></a>数组实例的includes()</h3><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="title class_">NaN</span>].<span class="title function_">includes</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h3><p>数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。</p>
<p>ES6 则是明确将空位转为undefined。</p>
<p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
<h1 id="9-对象的扩展"><a href="#9-对象的扩展" class="headerlink" title="9. 对象的扩展"></a>9. 对象的扩展</h1><h3 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h3><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;</span><br><span class="line">baz <span class="comment">// &#123;foo: &quot;bar&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h3><p>ES6 允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法的name属性"><a href="#方法的name属性" class="headerlink" title="方法的name属性"></a>方法的name属性</h3><p>函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="property">sayName</span>.<span class="property">name</span>   <span class="comment">// &quot;sayName&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。</p>
<h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致。</p>
<p>不同之处只有两个：一是+0不等于-0，二是NaN等于自身。</p>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>
<p>Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。</p>
<p>Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。</p>
<p>Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>
<h4 id="Object-assign-的用途"><a href="#Object-assign-的用途" class="headerlink" title="Object.assign()的用途"></a>Object.assign()的用途</h4><ol>
<li>为对象添加属性<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>为对象添加方法</li>
<li>克隆对象</li>
<li>合并多个对象</li>
<li>为属性制定默认值</li>
</ol>
<h3 id="属性的可枚举性"><a href="#属性的可枚举性" class="headerlink" title="属性的可枚举性"></a>属性的可枚举性</h3><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</p>
<p>描述对象的enumerable属性，称为”可枚举性“，如果该属性为false，就表示某些操作会忽略当前属性。</p>
<p>ES5 有三个操作会忽略enumerable为false的属性。</p>
<ul>
<li>for…in循环：只遍历对象自身的和继承的可枚举的属性</li>
<li>Object.keys()：返回对象自身的所有可枚举的属性的键名</li>
<li>JSON.stringify()：只串行化对象自身的可枚举的属性</li>
</ul>
<p>ES6 新增了一个操作Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</p>
<h3 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h3><p>ES6 一共有5种方法可以遍历对象的属性。</p>
<ol>
<li>for in</li>
<li>Object.keys(obj)</li>
<li>Object.getOwnPropertyNames(obj)</li>
<li>Object.getOwnPropertySymbols(obj)</li>
<li>Reflect.ownKeys(obj)</li>
</ol>
<h3 id="proto-属性，"><a href="#proto-属性，" class="headerlink" title="__proto__属性，"></a>__proto__属性，</h3><p>__proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es6的写法</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="property">__proto__</span> = someOtherObj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es5的写法</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(someOtherObj);</span><br><span class="line">obj.<span class="property">method</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<p>无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。</p>
<h3 id="Object-keys-Object-values-Object-entries"><a href="#Object-keys-Object-values-Object-entries" class="headerlink" title="Object.keys(),Object.values(),Object.entries()"></a>Object.keys(),Object.values(),Object.entries()</h3><p>ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for…of循环使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="title class_">Object</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="title function_">values</span>(obj)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>([key, value]); <span class="comment">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p>
<p>Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>
<h3 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h3><h5 id="1-解构赋值"><a href="#1-解构赋值" class="headerlink" title="1. 解构赋值"></a>1. 解构赋值</h5><p>对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure>
<p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p>
<h5 id="2-扩展运算符"><a href="#2-扩展运算符" class="headerlink" title="2. 扩展运算符"></a>2. 扩展运算符</h5><p>扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p>ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">bar</span>() &#123; <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line"><span class="comment">// &#123; foo:</span></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"><span class="comment">//    &#123; get: [Function: bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Null传导运算符"><a href="#Null传导运算符" class="headerlink" title="Null传导运算符"></a>Null传导运算符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = message?.<span class="property">body</span>?.<span class="property">user</span>?.<span class="property">firstName</span> || <span class="string">&#x27;default&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码有三个?.运算符，只要其中一个返回null或undefined，就不再往下运算，而是返回undefined。</p>
<h1 id="10-Symbol"><a href="#10-Symbol" class="headerlink" title="10. Symbol"></a>10. Symbol</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<p>Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s</span><br><span class="line"><span class="comment">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意，Symbol函数前不能使用new命令，否则会报错。</p>
<h3 id="作为属性名的Symbol"><a href="#作为属性名的Symbol" class="headerlink" title="作为属性名的Symbol"></a>作为属性名的Symbol</h3><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello!&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p>
<p>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
<p>还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</p>
<h3 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h3><p>Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。</p>
<p>Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="title class_">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="title class_">Symbol</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">obj[b] = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objectSymbols = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols</span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-for-Symbol-keyFor"><a href="#Symbol-for-Symbol-keyFor" class="headerlink" title="Symbol.for( ),Symbol.keyFor( )"></a>Symbol.for( ),Symbol.keyFor( )</h3><p>有时，我们希望重新使用同一个Symbol值，<code>Symbol.for</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol.for()</code>与S<code>ymbol()</code>这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。</p>
<p><code>Symbol.keyFor</code>方法返回一个已登记的 Symbol 类型值的key。</p>
<h3 id="内置的symbol值"><a href="#内置的symbol值" class="headerlink" title="内置的symbol值"></a>内置的symbol值</h3><p>除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。</p>
<h1 id="11-set和map数据结构"><a href="#11-set和map数据结构" class="headerlink" title="11. set和map数据结构"></a>11. set和map数据结构</h1><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h5 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h5><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p>Set 本身是一个构造函数，用来生成 Set 数据结构。</p>
<p>Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line">[...set]</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br><span class="line">items.<span class="property">size</span> <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例三</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">divs</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="title function_">divs</span>());</span><br><span class="line">set.<span class="property">size</span> <span class="comment">// 56</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="title function_">divs</span>().<span class="title function_">forEach</span>(<span class="function"><span class="params">div</span> =&gt;</span> set.<span class="title function_">add</span>(div));</span><br><span class="line">set.<span class="property">size</span> <span class="comment">// 56</span></span><br></pre></td></tr></table></figure>
<p>向Set加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（&#x3D;&#x3D;&#x3D;），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。</p>
<p>另外，两个对象总是不相等的。</p>
<h5 id="set实例的属性和方法"><a href="#set实例的属性和方法" class="headerlink" title="set实例的属性和方法"></a>set实例的属性和方法</h5><p>Set 结构的实例有以下属性。</p>
<ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是Set函数。</li>
<li><code>Set.prototype.size</code>：返回Set实例的成员总数。</li>
</ul>
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>
<ul>
<li><code>add(value)</code>：添加某个值，返回Set结构本身。</li>
<li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。</li>
<li><code>clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<h5 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h5><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p>
<p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>WeakSet 是一个构造函数，可以使用new命令，创建 WeakSet 数据结构。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br></pre></td></tr></table></figure>
<p>WeakSet 结构有以下三个方法。</p>
<ul>
<li>WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。</li>
<li>WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。</li>
<li>WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li>
</ul>
<p>WeakSet没有size属性，没有办法遍历它的成员。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h5 id="基本含义和用法"><a href="#基本含义和用法" class="headerlink" title="基本含义和用法"></a>基本含义和用法</h5><p>它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。</p>
<h5 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h5><ol>
<li>size属性<br> size属性返回 Map 结构的成员总数。</li>
<li>set(key, value)<br> set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。</li>
<li>get(key)<br> get方法读取key对应的键值，如果找不到key，返回undefined。</li>
<li>has(key)<br> has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li>
<li>delete(key)<br> delete方法删除某个键，返回true。如果删除失败，返回false。</li>
<li>clear()<br> clear方法清除所有成员，没有返回值。</li>
</ol>
<h5 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h5><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p>
<ul>
<li>keys()：返回键名的遍历器。</li>
<li>values()：返回键值的遍历器。</li>
<li>entries()：返回所有成员的遍历器。</li>
<li>forEach()：遍历 Map 的所有成员。</li>
</ul>
<p>结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。</p>
<h5 id="与其他数据结构的相互转换"><a href="#与其他数据结构的相互转换" class="headerlink" title="与其他数据结构的相互转换"></a>与其他数据结构的相互转换</h5><ol>
<li>map转换为数组</li>
<li>数组转换为map</li>
<li>map转换为对象</li>
<li>对象转换为map</li>
<li>map转换为json</li>
<li>JSON转换为map</li>
</ol>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</p>
<p>WeakMap的键名所指向的对象，不计入垃圾回收机制。</p>
<h1 id="12-Proxy"><a href="#12-Proxy" class="headerlink" title="12. Proxy"></a>12. Proxy</h1><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<h3 id="Proxy可以拦截的操作"><a href="#Proxy可以拦截的操作" class="headerlink" title="Proxy可以拦截的操作"></a>Proxy可以拦截的操作</h3><ol>
<li>get()<br> get方法用于拦截某个属性的读取操作。</li>
<li>set()<br> set方法用来拦截某个属性的赋值操作。</li>
<li>apply()<br> apply方法拦截函数的调用、call和apply操作。</li>
<li>has()<br> has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。</li>
<li>construct()<br> construct方法用于拦截new命令</li>
<li>deleteProperty()<br> deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。</li>
<li>defineProperty()<br> defineProperty方法拦截了Object.defineProperty操作。</li>
<li>getOwnPropertyDescriptors()<br> <code>getOwnPropertyDescriptor</code>方法拦截<code>Object.getOwnPropertyDescriptor()</code>，返回一个属性描述对象或者undefined。</li>
<li>getPrototypeOf()<br> getPrototypeOf方法主要用来拦截获取对象原型。</li>
<li>isExtensible()<br>isExtensible方法拦截Object.isExtensible操作。</li>
<li>ownKeys()<br>ownKeys方法用来拦截对象自身属性的读取操作。</li>
<li>preventExtensions()<br>preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。</li>
<li>setProrypeOf()<br>setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。</li>
</ol>
<h3 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h3><p>Proxy.revocable方法返回一个可取消的 Proxy 实例。</p>
<h1 id="13-Reflect"><a href="#13-Reflect" class="headerlink" title="13. Reflect"></a>13. Reflect</h1><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。</p>
<p>（1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</p>
<p>（2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</p>
<p>（3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</p>
<p>（4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</p>
<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2. 静态方法"></a>2. 静态方法</h3><ul>
<li>Reflect.apply(target,thisArg,args)</li>
<li>Reflect.construct(target,args)</li>
<li>Reflect.get(target,name,receiver)</li>
<li>Reflect.set(target,name,value,receiver)</li>
<li>Reflect.defineProperty(target,name,desc)</li>
<li>Reflect.deleteProperty(target,name)</li>
<li>Reflect.has(target,name)</li>
<li>Reflect.ownKeys(target)</li>
<li>Reflect.isExtensible(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.getOwnPropertyDescriptor(target, name)</li>
<li>Reflect.getPrototypeOf(target)</li>
<li>Reflect.setPrototypeOf(target, prototype)</li>
</ul>
<h1 id="14-Promise对象"><a href="#14-Promise对象" class="headerlink" title="14. Promise对象"></a>14. Promise对象</h1><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p>Promise对象有以下两个特点。</p>
<p>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。</p>
<p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/posts.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> json.<span class="property">post</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;/posts.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生错误！&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure>
<p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。</p>
<h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsPromise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>($.<span class="title function_">ajax</span>(<span class="string">&#x27;/whatever.json&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。</p>
<h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。</p>
<h3 id="两个有用的附加方法"><a href="#两个有用的附加方法" class="headerlink" title="两个有用的附加方法"></a>两个有用的附加方法</h3><h5 id="done"><a href="#done" class="headerlink" title="done()"></a>done()</h5><p>Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</p>
<h5 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h5><p>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>
<h1 id="15-Iterator-和-for…of循环"><a href="#15-Iterator-和-for…of循环" class="headerlink" title="15. Iterator 和 for…of循环"></a>15. Iterator 和 for…of循环</h1><h3 id="Iterator的概念"><a href="#Iterator的概念" class="headerlink" title="Iterator的概念"></a>Iterator的概念</h3><p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。</p>
<h3 id="默认Iterator接口"><a href="#默认Iterator接口" class="headerlink" title="默认Iterator接口"></a>默认Iterator接口</h3><p>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是”可遍历的“（iterable）。</p>
<p>ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。</p>
<p>原生具备 Iterator 接口的数据结构如下。</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
</ul>
<h3 id="调用Iterator的场合"><a href="#调用Iterator的场合" class="headerlink" title="调用Iterator的场合"></a>调用Iterator的场合</h3><p>有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for…of循环，还有几个别的场合。</p>
<ol>
<li>解构赋值</li>
<li>扩展运算符</li>
<li>yield<br> yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</li>
<li>数组作为参数的场合<ul>
<li>for…of</li>
<li>Array.from()</li>
<li>Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])）</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
</li>
</ol>
<h3 id="字符串的Iterator接口"><a href="#字符串的Iterator接口" class="headerlink" title="字符串的Iterator接口"></a>字符串的Iterator接口</h3><p>字符串是一个类似数组的对象，也原生具有 Iterator 接口。</p>
<h3 id="Iterator接口和Generator函数"><a href="#Iterator接口和Generator函数" class="headerlink" title="Iterator接口和Generator函数"></a>Iterator接口和Generator函数</h3><p>Symbol.iterator方法的最简单实现，还是使用下一章要介绍的Generator函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myIterable[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者采用下面的简洁写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历器对象的return-throw"><a href="#遍历器对象的return-throw" class="headerlink" title="遍历器对象的return(),throw()"></a>遍历器对象的return(),throw()</h3><p>遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。</p>
<p>return方法的使用场合是，如果for…of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。</p>
<h3 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h3><p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。</p>
<p>一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。</p>
<p>for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p>
<h1 id="16-Generator函数的语法"><a href="#16-Generator函数的语法" class="headerlink" title="16. Generator函数的语法"></a>16. Generator函数的语法</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p>
<p>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</p>
<h3 id="yield表达式"><a href="#yield表达式" class="headerlink" title="yield表达式"></a>yield表达式</h3><p>由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。</p>
<h1 id="18-async函数"><a href="#18-async函数" class="headerlink" title="18. async函数"></a>18. async函数</h1><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。<br>（1）内置执行器。</p>
<p>Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</p>
<p><code>var result = asyncReadFile();</code><br>上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。</p>
<p>（2）更好的语义。</p>
<p>async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p>
<p>（3）更广的适用性。</p>
<p>co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p>
<p>（4）返回值是 Promise。</p>
<p>async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</p>
<p>进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</p>
<h3 id="基本用法-3"><a href="#基本用法-3" class="headerlink" title="基本用法"></a>基本用法</h3><p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<h1 id="19-Class基本语法"><a href="#19-Class基本语法" class="headerlink" title="19. Class基本语法"></a>19. Class基本语法</h1><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。</p>
<p>基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。</p>
<h1 id="20-class的继承"><a href="#20-class的继承" class="headerlink" title="20. class的继承"></a>20. class的继承</h1><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>
<h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>Object.getPrototypeOf方法可以用来从子类上获取父类。</p>
<h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><p>第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。</p>
<p>第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<h3 id="类的prototype属性和-proto-属性"><a href="#类的prototype属性和-proto-属性" class="headerlink" title="类的prototype属性和__proto__属性"></a>类的prototype属性和__proto__属性</h3><p>大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。</p>
<p>（1）子类的__proto__属性，表示构造函数的继承，总是指向父类。</p>
<p>（2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。</p>
<h1 id="21-修饰器"><a href="#21-修饰器" class="headerlink" title="21. 修饰器"></a>21. 修饰器</h1><h3 id="类的修饰"><a href="#类的修饰" class="headerlink" title="类的修饰"></a>类的修饰</h3><p>修饰器（Decorator）是一个函数，用来修改类的行为。</p>
<h1 id="22-Module语法"><a href="#22-Module语法" class="headerlink" title="22. Module语法"></a>22. Module语法</h1><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="严格模式-1"><a href="#严格模式-1" class="headerlink" title="严格模式"></a>严格模式</h3><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。</p>
<h3 id="export命令"><a href="#export命令" class="headerlink" title="export命令"></a>export命令</h3><p>模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。</p>
<h3 id="import命令"><a href="#import命令" class="headerlink" title="import命令"></a>import命令</h3><p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;firstName, lastName, year&#125; <span class="keyword">from</span> <span class="string">&#x27;./profile&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  element.<span class="property">textContent</span> = firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h3><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。</p>
<h3 id="export-default命令"><a href="#export-default命令" class="headerlink" title="export default命令"></a>export default命令</h3><p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。</p>
<h1 id="23-Module的加载实现"><a href="#23-Module的加载实现" class="headerlink" title="23. Module的加载实现"></a>23. Module的加载实现</h1><h3 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h3><p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>defer是“渲染完再执行”，async是“下载完就执行”。</p>
<h5 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h5><p>浏览器加载 ES6 模块，也使用&lt;script&gt;标签，但是要加入type&#x3D;”module”属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;foo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&quot;./utils.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// other code</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="24-编程风格"><a href="#24-编程风格" class="headerlink" title="24. 编程风格"></a>24. 编程风格</h1><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><ol>
<li>let取代var</li>
<li>全局常量和线程安全<br> 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。</li>
</ol>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</p>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><ol>
<li>使用数组成员对变量赋值时，优先使用解构赋值。</li>
<li>函数的参数如果是对象的成员，优先使用解构赋值。</li>
</ol>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</p>
<p>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用<code>Object.assign</code>方法。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>使用扩展运算符（…）拷贝数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> itemsCopy = [...items];</span><br></pre></td></tr></table></figure>

<p>使用Array.from方法，将类似数组的对象转为数组。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol>
<li>立即执行函数可以写成箭头函数的形式。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Welcome to the Internet.&#x27;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
<li>箭头函数取代Function.prototype.bind，不应再用self&#x2F;_this&#x2F;that绑定 this。</li>
<li>不要在函数体内使用arguments变量，使用rest运算符（…）代替。</li>
<li>使用默认值语法设置函数参数的默认值。</li>
</ol>
<h3 id="map结构"><a href="#map结构" class="headerlink" title="map结构"></a>map结构</h3><p>注意区分Object和Map，只有模拟现实世界的实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制。</p>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。</p>
<p>使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。</p>
<br>
<br>
<br>
<br>
<br>

<h1 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h1><p><img src="https://ezharjan.github.io/Blog/2022/05/15/ES6%E5%85%A5%E9%97%A8/%E7%BB%B4%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E9%94%AE%E7%9B%98%E5%AF%B9%E5%BA%94%E5%9B%BE.jpg" alt="输入法"></p>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></h6></h6>]]></content>
      <categories>
        <category>Notes</category>
      </categories>
  </entry>
  <entry>
    <title>教资面经</title>
    <url>/Blog/2022/05/15/%E6%95%99%E8%B5%84%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h6 align="center">作者：艾孜尔江<h6>



<br>

<ol>
<li>排队在校外等候</li>
<li>分组进行</li>
<li>报到</li>
<li>带上防疫证明</li>
<li>到一个存包的地方</li>
<li>有一把钥匙</li>
<li>只拿上身份证准考证</li>
<li>排队去大厅</li>
<li>在大厅取考号</li>
<li>抽题</li>
<li>抽到一份课本上面随机截图出来的一小块有知识点的内容</li>
<li>介绍背景性质的东西不会考到（比如冯诺依曼的历史、计算机历史），书上有黑体加粗的肯定是考的，就是知识点</li>
<li>带到房间用20分钟撰写教案</li>
<li>知识与技能，过程与方法，情感态度与价值观</li>
<li>学课核心素养（情感与价值观里写进去👉以此为基准）</li>
<li>教学重难点（重点只有一个，难点有一个；十分钟！！！）</li>
<li>教学过程：分为如下几点内容（… …）</li>
<li>写教案：画四列表格（左边开始：1是环节，2教师活动，3学生活动 4教学意图）<br>（1） 环节： 情境导入（推荐，最流行的）；猜谜语；问题式导入；<br>（2） 教师活动：设置某个情境<br>（3） 学生活动：引入课堂<br>（4） 教学意图：目的、情感态度与价值观（培养学生的xxxx情怀）</li>
<li>这些环节都要非常老练！！！！要熟练！！！不用特别创新！！！！不要搞创新！！！！！</li>
<li>面试是只需要讲授：教师活动！！！</li>
<li>教师活动分类：<br>（1） 活动1 ：根据教材上讲授xxx知识点、然后进行学生活动yyy、然后让学生跟随教师学习zzz；<br>（2） 活动2： 学习xxxxx的知识、然后进行学生活动——学生阅读书本、之后是小组讨论，如何将xxxx；<br>（3） 活动3：教师讲解xxxxx知识的具体方法、举例子引入、教学生怎么做；<br>（4） 活动4： 通过两道题目来练习xxxxx知识点，最后来个小节，找一位同学复述一下。</li>
<li>教案只是告诉你现在要做什么，不必特别详细，不把上课的全部内容写下来，而是只写要做的事情，教案只是一个引导</li>
<li>板书设计：标题👉黑板最中央&#x2F;黑板的左上方！ 标题不要写序号！！知识点：写子序号；黑板上写全！假设只有一步的话就不要写序号了。不用考虑过多的非范围内的方法，非范围内的内容不要讲述。</li>
<li>教学目标要快一些，不要写一大串！！！！</li>
<li>可以简写的地方是：教学环节；把想说的话可以简写；结构：一定要详写。</li>
<li>写好教案之后去各自对应的教室，如果教室内有人，就不要敲门，更不要进去！有考生的话千万不要敲门！他出来之后，把门关上，然后敲门！ 一定一定要敲门！！！！！（他们可能要统计分数之类的）</li>
<li>把准考证号和身份证给评委老师。</li>
<li>说几号考生，不要自我介绍。<br>Eg: 各位评委老师好， 我是x号考证xxx</li>
<li>结构化面试（不占分） 接下来就是考生听好两个结构化的问题：1xxx；2Xxx；不要马上回答：容我思考两分钟。 稍微想一下，大概要说什么，说的过程中千万要记住题目，要能够巧妙地将其化解，有争议性的问题一般不会被问道，幽默的方式化解尴尬，不能上来就来硬的，如果回答不出来，要说一下重要性，然后讲自己背过的内容（“四有”好老师是什么之类的，这些一定要背）。</li>
<li>进门第一件事，把黑板擦找到！找黑板擦！！！！ 如果找不到就问老师找黑板擦。</li>
<li>试讲环节：<br>（1） 上课！同学们好，请坐！<br>（2） 首先在黑板上写好要讲授的东西；<br>（3） 写好之后再讲！！！！<br>（4） 写的时候就是写！讲的时候再讲！写的时候要背着身写！写好题目！走下讲台！手里拿一枝粉笔的话粉笔拿好。<br>（5） 开始引入课程；<br>（6） 提问时走下讲台，边讲边提问；<br>（7） 停顿个三秒，自问自答<br>（8） 做一个局，让对方故意讲错一些东西<br>（9） 如果不小心写错，画完之后马上提问（尽量不要写错），就直接扭转局面，避开这个问题，尽量不要犯错但是犯错的话要懂得扭转局面。<br>（10） 提问要多少个问题：一个活动一个问题</li>
<li>注意事项：<br>（1） 不要出现站在上帝视角的情况，对一年级的学生说有效数字，不能出现学生没学过的东西！<br>（2） 要按照课程顺序讲授！！！！！<br>（3） 面试全国统一，全国教材去抽，人教版是老大哥，跟着人教版走！要对教材特别熟练！<br>（4） 稍微有点手势！<br>（5） 跨立，一只手背后。<br>（6） 不要一只手插口袋。<br>（7） 不要在空中切刀。<br>（8） 讲课的时候要有停顿；讲课的时候一定要有停顿！！！！！<br>（9） 重点的时候要停顿一下，重点的地方慢一点，突出重点！！！！一定要突出重点！！！！重点关键词要慢一些！关键的要突出一些。把握关键词。<br>（10） 口癖不要太多！！！！！<br>（11） 尽量在讲台下面走走！！！！<br>（12） 教学态度。<br>（13） 课程设计。<br>（14） 教学语言。</li>
<li>千万不要给学生讲他们没有学过的东西！！！！拿到教材，上面没写的东西就不要说！！！！就只把那一部分东西讲清楚就行了，讲授的内容要根据课程的内容，不要把高中和大学的知识点相互混淆！！！！</li>
<li>老师会根据你上课的过程提两个问题，问的问题是关于这节课的问题，这个就可以多扯一扯，有些问题可能是有坑，如果这节课确实不能出现哪些知识点，就跟他们说这节课不能出现这个问题，然后讲授，通过练习，不断地联系和培养和学习，不停地回环往复地去学习，报一下核心素养。</li>
<li>一般的面试标准：<br>（1） 教学姿态（写字背对着，手背后，不要迷惑学生）<br>（2） 课程设计（是否合理）<br>（3） 教学语言（中文吐字清不清晰，规范性，抑扬顿挫感，重难点突出，加粗的地方，定义不能乱说，一定要按照书本上的来讲，尤其定义相关的东西不要自己乱讲！！！！）<br>（4） 重点要突出</li>
<li>可以多看看教参！！！！</li>
<li>所有的课程应当按照下方材料进行复习：<br>（1） 课程标准（国务院教育部门统一发布）<br>（2） 教学基本要求（会列举出每一门课的重难点，理解应用）（市级发布）<br>（3） 教参（根据上方两项进行编制的，相当于是高级的民间老方法，很好的东西）</li>
<li>把书上有黑体的地方全都看一遍。知道书上有哪些！先学会写教案，要多练，给对方上一下这门课。</li>
<li>结构化没有分数，但目的是作为后期的参考，结构化要回答的流利一些！不知道就不知道。</li>
<li>着装，礼貌，谈吐，吐字清晰，教学设计正常来，要习惯于课堂。</li>
<li>以问题为引领、自主性、有目标、教师是引导为主，想出答案，也得设置相应的情境。看你对这门课的理解，答案是次要的，要问背后的原因，要设置情境，然后再给出答案。</li>
<li>只有结构化可以直接说“不知道”。</li>
<li>最后走的时候要问评委老师：请问老师要把黑板擦掉吗？</li>
</ol>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></h6></h6>]]></content>
      <categories>
        <category>Exams</category>
      </categories>
  </entry>
  <entry>
    <title>TOEFL-Experience</title>
    <url>/Blog/2022/05/15/TOEFL-Experience/</url>
    <content><![CDATA[<h1 id="TOEFL-Experience"><a href="#TOEFL-Experience" class="headerlink" title="TOEFL Experience"></a>TOEFL Experience</h1><p><strong>For My Brother Guang Yang</strong></p>
<br>

<p><em>by Alexander Ezharjan</em></p>
<br>
<br>

<p>The process or result of learning is never a thing that can be calculated through an exact meter, but preparing for the exams has its own way that we can sometime apply to get good grades. Here are some of my experience on how to get decent scores in TOEFOL.</p>
<br>

<ol>
<li><p>Recite 20 to 100 TOEFL words everyday.<br>Remember 2 things:<br>(1) Review of the past words are more important than reciting the new ones;<br>(2) Never ignore those words that looks familiar to you. Try to recite the familiar word’s all meanings and exampled cases.</p>
</li>
<li><p>Try to do a real exam practice first. You can download some applications or directly practice online.<br>Remember 2 things:<br>(1) Use the REAL OLD EXAMS, not the simulations, to measure your current ability, then you will find out your deficiencies and problems so that you’re able to solve them.<br>(2) Always try to make yourself in a real exam situation when you are taking the test. If you can’t, just try to make an atmosphere like that! For example, you can take your simulation test in a noisy classroom with people going in and out. Yeah, the real situation is somewhat noisy and people will go in and out from the exam hall, you have to be fully focused on your own exam and avoid those distractions.</p>
</li>
<li><p>Practice more! Always practice upon the TOEFL exam itself. DO NOT PRACTICE ANY OTHER THINGS THAT CAN SEEMS UNRELATED WITH THE EXAM ITSELF. (For example: listening to English songs, watching English films, speaking with foreigners online etc.) Note that the TOEFL is a test of your comprehensive ability rather than the test of your real foreign communication ability. </p>
</li>
<li><p>Always catch your mistakes and just calm down to think about the reason why you have mistaken, practice more.</p>
</li>
<li><p>Practice your speed! You should be clarified that the exam time is not enough, especially for your reading test. You can’t read thoroughly through all the details of a passage, so you have to view the current question first and then find out the answer for it. Time control is significant while doing the TOEFL reading test.</p>
</li>
<li><p>When it comes to the preparation of the listening test, find some ways to enhance your note-taking ability. Interpretation note taking methods are listed below in <code>Appendix II</code> for a reference from my point of view, but you may find some more suitable methods to enhance your ability.</p>
</li>
<li><p>While practicing your speaking ability, you have to link your speaking ability with the listening practice. Never separate them! Try to speak loudly so that your voice can be recorded by the microphone clearly. You can record your own voice while you are practicing.</p>
</li>
<li><p>Essay is important and you have to read some tutorials related to the TOEFL Essay Test and practice with those guides. Some of the mottos or sayings of the famous people is strongly recommended. Some of them is listed below in <code>Appendix I</code>.</p>
</li>
<li><p>Do at least 5 real-test-based simulation test before entering the exam day.</p>
</li>
<li><p>Sleep well before the exam day.</p>
</li>
<li><p>Eat well in the morning on the exam day.</p>
</li>
</ol>
<br>
<br>
<br>
<br>



<h3 id="Appendix-I"><a href="#Appendix-I" class="headerlink" title="Appendix I"></a>Appendix I</h3><ol>
<li>Misfortunes never come alone&#x2F;single.祸不单行。</li>
<li>Constant dropping wears the stone. 滴水穿石。</li>
<li>Life is a leaf of paper white, thereon each of us may write his word or two. 生活是一张白纸，每个人都在上面写上自己的一两句话。</li>
<li>For man is man and master of his fate. 人就是人，是自己命运的主人。</li>
<li>A good medicine tasks bitter.良药苦口。</li>
<li>Live and let live. 自己生活也让别人生活。</li>
<li>A great ship asks for deep waters.大船要走深水。</li>
<li>From small beginnings comes great things. 伟大始于渺小。</li>
<li>Great works are performed not by strength but by perseverance.没有恒心只有力量是完不成伟业。</li>
<li>Two heads are better than one. 一人不及二人智；三个臭皮匠，胜个过一个诸葛亮。</li>
<li>The voice of one man is the voice of no one. 一个人的声音没有力量。</li>
<li>It is never too late to learn. 活到老，学到老。</li>
<li>Wise men learn by other men’s mistakes; fools by their own. 聪明人从别人的错误中学得教训；笨人则自己付出代价。他山之石可以攻玉。</li>
<li>Good company on the road is the shortest cut. 行路有良伴就是捷径。</li>
<li>It takes all sorts to make a world. 世界是由各种不同的人所组成的。</li>
<li>Money spent on the brain is never spent in vain. 智力投资绝不会白花。</li>
<li>On earth there is nothing at but man; in the man there is nothing at but mind. 地球上唯一伟大的是人，人身上唯一伟大的是心灵。</li>
<li>Wisdom in the mind is better than money in the hand.脑中有知识，胜过手中有金钱。</li>
<li>Misfortunes tell us what fortune is.不经灾难不知福。</li>
<li>While there is life, there is hope.有生命便有希望&#x2F;留得青山在，哪怕没柴烧</li>
<li>Storms make trees take deeper roots.风暴使树木深深扎根。</li>
<li>It is never too late to mend. 亡羊补牢，犹时未晚。</li>
<li>Truth never fears investigation.事实从来不怕调查。</li>
<li>Misfortunes come on wings and depart on foot.遭祸容易脱祸难。</li>
<li>To an optimist every change is a change for the better.对于乐观者总是越变越好。</li>
<li>Every man is his own worst enemy.一个人最大的敌人就是他自己。</li>
<li>The secret of success is constancy of purpose.成功的秘诀在于持之于恒。</li>
<li>Actions speak louder than words. 行动比语言更响亮。</li>
<li>Saying and doing are two different things. 说和做是迥然不同的两回事。</li>
<li>Better late than never. 迟做总比不做好；晚来总比不来强。</li>
<li>Experience is the mother of wisdom. 经验是智慧之母。</li>
<li>Be honest rather clever. 诚实比聪明更要紧。</li>
<li>Being on sea, sail; being on land, settle. 随遇而安。</li>
<li>Be just to all, but trust not all. 要公正对待所有的人，但不要轻信所有的人。</li>
<li>Believe not all that you see nor half what you hear. 眼见的不能全信，耳闻的也不能半信。</li>
<li>Be slow to promise and quick to perform. 不轻诺，诺必果。</li>
<li>Be swift to hear, slow to speak. 多听少说。</li>
<li>Better an empty purse than an empty head. 宁可钱袋瘪，不要脑袋空。</li>
<li>Better an open enemy than a false friend. 明枪易躲，暗箭难防。</li>
<li>Better good neighbors near than relations far away. 远亲不如近邻。</li>
<li>Between the cup and the lip a morsel may slip. 功亏一篑。</li>
<li>Between two stools one falls to the ground. 脚踏两头要落空。</li>
<li>Beware beginnings. 慎始为上。</li>
<li>Big mouthfuls ofter choke. 贪多嚼不烂。</li>
<li>Bind the sack before it be full. 做事应适可而止。</li>
<li>Birds of a feather flock together. 物以类聚，人以群分。</li>
<li>Birth is much, but breeding is more. 出身固然重要，教养更且重要。</li>
<li>Bite off more than one can chew. 贪多咽不下。</li>
<li>Bite the hand that feeds one. 恩将仇报。</li>
<li>Bitter pills may have wholesome effects. 良药苦口利于病。</li>
<li>Blind men can judge no colors. 不宜问道於盲。</li>
<li>Blood is thicker than water. 血浓于水。</li>
<li>Bread is the staff of life. 民以食为天。</li>
<li>Brevity is the soul of wit. 言以简洁为贵。</li>
<li>Bring up a raven and he’ll pick out your eyes. 养虎贻患。</li>
<li>Burn not your house to rid it of the mouse. 投鼠忌器。</li>
<li>Burnt child dreads the fire. 一朝被蛇咬，十年怕井绳。</li>
<li>Business before pleasure. 事业在先，享乐在后。</li>
<li>Business is business. 公事公办。</li>
<li>By doing we learn. 经一事，长一智。</li>
<li>By falling we learn to go safely. 吃一堑，长一智。</li>
<li>By other’s faults, wise men correct their own. 他山之石，可以攻玉。</li>
<li>By reading we enrich the mind; by conversation we polish it. 读书可以使我门的思想充实，谈话使其更臻完美。</li>
<li>pain past is pleasure. 过去的痛苦即快乐。</li>
<li>All things are difficult before they are easy. 凡事必先难后易。</li>
<li>Nothing is impossible to a willing heart. 心之所愿，无事不成。</li>
<li>Where there is life, there is hope. 有生命必有希望。</li>
<li>I feel strongly that I can make it. 我坚信我一定能成功。</li>
<li>Better to light one candle than to curse the darkness. 与其诅咒黑暗，不如燃起蜡烛。</li>
<li>The shortest answer is doing. 最简短的回答就是行动。</li>
<li>Four short words sum up what has lifted most successful individuals above the crowd: a little bit more. 成功的秘诀就是四个简单的字：多一点点。</li>
<li>All things in their being are good for something. 天生我才必有用。</li>
<li>Difficult circumstances serve as a textbook of life for people. 困难坎坷是人们的生活教科书。</li>
<li>Failure is the mother of success. - Thomas Paine 失败乃成功之母。</li>
<li>For man is man and master of his fate. 人就是人，是自己命运的主人。</li>
<li>The unexamined life is not worth living. – Socrates 混混噩噩的生活不值得过。 – 苏格拉底</li>
<li>None is of freedom or of life deserving unless he daily conquers it anew. -Erasmus 只有每天再度战胜生活并夺取自由的人，才配享受生活的自由。</li>
<li>Our destiny offers not the cup of despair, but the chalice of opportunity. So let us seize it, not in fear, but in gladness. – R.M. Nixon 命运给予我们的不是失望之酒，而是机会之杯。因此，梦颐呛廖薹惧，满心愉悦地把握命？- 尼克松</li>
<li>Living without an aim is like sailing without a compass. – John Ruskin 生活没有目标，犹如航海没有罗盘。– 罗斯金</li>
<li>What makes life dreary is the want of motive. – George Eliot 没有了目的，生活便郁闷无光。 – 乔治 埃略特</li>
<li>Towering genius disdains a beaten path. It seeks regions hitherto unexplored.– Lincoln 卓越的天才不屑走旁人走过的路。他寻找迄今未开拓的地区。</li>
<li>There is no such thing as a great talent without great will - power. – Balzac 没有伟大的意志力，便没有雄才大略。 – 巴尔扎克</li>
</ol>
<br>

<h3 id="Appendix-II"><a href="#Appendix-II" class="headerlink" title="Appendix II"></a>Appendix II</h3><p><img src="https://ezharjan.github.io/Blog/2022/05/15/TOEFL-Experience/%E5%8F%A3%E8%AF%91%E7%AC%94%E8%AE%B0%E7%AC%A6%E5%8F%B7%E5%A4%A7%E6%B1%87%E6%80%BB.jpg" alt="TOEFL-Experience"></p>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>]]></content>
      <categories>
        <category>Exams</category>
      </categories>
  </entry>
  <entry>
    <title>如何谈薪资</title>
    <url>/Blog/2022/03/12/%E5%A6%82%E4%BD%95%E8%B0%88%E8%96%AA%E8%B5%84/</url>
    <content><![CDATA[<h6 align="center">编者：艾孜尔江<h6>



<p><b><details><summary>1、我们先来了解面试官如何评判应聘者的工资，知己知彼才能对症下药啊！</summary></details></b></p>
<p>一些正规的大公司主要是根据以下四个方面进行评判（重要性从上至下）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、掌握的技术（通过笔试、项目经验、工作时间）</span><br><span class="line">2、表达</span><br><span class="line">3、学历</span><br><span class="line">4、其他素质（如英语四六级等）</span><br></pre></td></tr></table></figure>

<p>面试官评判应聘者工资的重要性之所以采取如此的顺序，根本原因在于面试官最最重要的是程序员能不能把工作做好，让公司放心。所以学员技术很重要，表达也很重要（技术牛但不会表达，也会让人怀疑技术实力）</p>


<p><b><details><summary>2、当 HR 问：你对薪资有什么要求？</summary></details></b></p>
<p>大家找工作，都希望找个高薪的，那我们如何和公司去谈薪酬呢？如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。这个问题确实是个比较难于回答的问题，处理不好的话，会影响面试的效果，但又是不可避免的一个现实问题。</p>
<p>对于这个问题，第一首先要知道程序员等级、技能、工资的绑定情况，因为我们前端工程师主要是看技术。技术实力决定了我们的月薪；第二要打探出公司能给出的薪资范围。在这个范围内争取高薪资。</p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一步是了解对方可以提供的薪酬幅度是多少，这里的关键是善于发问，让对方多讲，而自己了解足够的信息。当经过几轮面试后，面试官会问应聘者：你还有什么想了解的问题吗？应聘者就可问：像你们这样的大企业都有自己的一套薪酬体系，请问可以简单介绍一下吗？面试官一般就会简单介绍一下，如果介绍得不是太详细，还可以问：贵公司的薪酬水平在同行业中的位置是怎样的？除了工资之外还有哪些奖金、福利和培训机会？试用期后工资的加幅是多少？等问题。从对方的回答中，你再对照一下市场行情心里就有底了。</span><br><span class="line"></span><br><span class="line">第二步是根据以上信息，提出自己的期望薪酬。如果对自己想提的薪资还是把握不准，那也可以把问题抛给对方：我想请教一个问题，以我现在的经历、学历和您对我面试的了解，在公司的薪酬体系中大约能达到怎么样的水平？对方就会透露给你准备开的工资水平。</span><br></pre></td></tr></table></figure>

<h2 id="迂回战术求高薪"><a href="#迂回战术求高薪" class="headerlink" title="迂回战术求高薪"></a>迂回战术求高薪</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果你对该公司开出的薪资标准不太满意，就可以尝试用探讨式、协商式的口气去争取高一些：比如我认为工作最重要的是合作开心，薪酬是其次的，不过我原来的月薪是××元，如果跳槽的话就希望自己能有点进步，如果不是让您太为难的话，您看这个工资是不是可以有一点提高？这时要看对方的口气是否可以松动，松动的话则可以再举出你值更高价的理由。</span><br><span class="line"></span><br><span class="line">如果对方的口气坚决，则可以迂回争取试用期的缩短，比如说：我对自己是比较有自信的，您看能不能一步到位直接拿转正期的工资，或者把３个月的试用期缩短为１个月？额外工资多争取。</span><br><span class="line"></span><br><span class="line">很多企业除了正式的工资以外，都会产生一些奖金、福利等额外工资，在这方面应聘者就要大胆争取了。应聘者要注意察言观色见好就收，不要过度要求，否则让对方破例后，到时你进来后对方也会以更高的要求来考核你，还可能答应了最后也不兑现。为了保险起见，应聘者最好让对方在接收函上写明薪酬、试用期限、上班时间等，这样可免去日后口说无凭的纠纷。</span><br><span class="line"></span><br><span class="line">总之，好的薪水是要靠势力得到的,但多调查和多注意这方面的资讯,使自己在面试前做到对这个职位的大致薪水有个了解,就会使你不至于提太高或太低不切实际的要求,从而失去到手的工作。</span><br></pre></td></tr></table></figure>



<p><b><details><summary>3、HR 指责要薪太高怎么办？</summary></details></b></p>
<p>想象下，当你实事求是的按照以上的方法报出自己的工资为 7000 元的时候，面试官呵呵笑道：“你是应届生，却要求 7000 元的工资，是不是太高了？”此时，你该怎么办？</p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、北京的生活成本高，3000元在北京生存很艰难，在饭店工作也可能不值这个，北京的web前端平均工资我也是有过了解的。同学大都是这个工资（注意：这个同学可以向HR强调是平时一起讨论问题的同学，暗示水平差不多)；</span><br><span class="line">2、上几家都给我6千了，我没有去（觉得自己值多少钱，那就是值多少）；</span><br><span class="line">3、我不是乱要价，我有能力完成完成上级交代的任务，创造出超过7000元价值的能力（强调自己的能力）；</span><br><span class="line">4、对技术狂热，会沿着前端道路一直往前走（强调自己对这份工作的热爱）；</span><br><span class="line">5、再说公司会有试用期，试用期可以低于7000，我会在这个阶段证明我自己的能力，可以如果没有达到，公司也可以开除我。</span><br></pre></td></tr></table></figure>






<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></h6></h6>]]></content>
      <categories>
        <category>Job Interview</category>
      </categories>
  </entry>
  <entry>
    <title>非技术问题100篇</title>
    <url>/Blog/2022/03/12/%E9%9D%9E%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98100%E7%AF%87/</url>
    <content><![CDATA[<h6 align="center">编者：艾孜尔江<h6>



<h5 id="（1）问题：请给我们谈谈你自己的一些情况"><a href="#（1）问题：请给我们谈谈你自己的一些情况" class="headerlink" title="（1）问题：请给我们谈谈你自己的一些情况"></a>（1）问题：请给我们谈谈你自己的一些情况</h5><p>回答：简要的描述你的相关工作经历以及你的一些特征，包括与人相处的能力和个人的性格特征。如果你一下子不能够确定面试者到底需要什么样的内容，你可以这样说：“有没有什么您特别感兴趣的范围？”</p>
<p>点评：企业以此来判断是否应该聘用你。通过你的谈论，可以看出你想的是如何为公司效力还是那些会影响工作的个人问题。当然，还可以知道你的一些背景。</p>
<br>

<h5 id="（2）问题：你是哪年出生的？你是哪所大学毕业的？等等"><a href="#（2）问题：你是哪年出生的？你是哪所大学毕业的？等等" class="headerlink" title="（2）问题：你是哪年出生的？你是哪所大学毕业的？等等"></a>（2）问题：你是哪年出生的？你是哪所大学毕业的？等等</h5><p>回答：我是XXXX年出生的。我是XX大学毕业的。</p>
<p>点评：这类问题至为关键的是要针对每个问题简洁明了的回答，不可拖泥带水，也不必再加什么说明。完全不必再画蛇添足的说“我属X，今年XX岁”之类的话。至于专业等或许主考官接下来的问题就是针对此而言的，故而不必迫不及待和盘托出。</p>
<br>

<h5 id="（3）问题：请谈一下你对公司的看法，为什么你想来公司工作？"><a href="#（3）问题：请谈一下你对公司的看法，为什么你想来公司工作？" class="headerlink" title="（3）问题：请谈一下你对公司的看法，为什么你想来公司工作？"></a>（3）问题：请谈一下你对公司的看法，为什么你想来公司工作？</h5><p>回答：可根据你先前对该公司的情报收集，叙述一下你对公司的了解。适当的对公司的声誉、产品和发展情况予以赞美。还可以提提你为了了解公司的情况所做的努力然后就说你非常喜欢这个工作，而且你的能力也非常适合并能胜任这份工作。</p>
<p>点评：此问目的测试一下你对公司的了解和喜欢的程度，看看你的能力是否符合公司的要求和方向。看看你是真正地愿意为公司效力，还是仅仅冲着公司的福利、声望和工作的稳定。</p>
<br>

<h5 id="（4）问题：你认为对你来说现在找一份工作是不是不太容易，或者你很需要这份工作？"><a href="#（4）问题：你认为对你来说现在找一份工作是不是不太容易，或者你很需要这份工作？" class="headerlink" title="（4）问题：你认为对你来说现在找一份工作是不是不太容易，或者你很需要这份工作？"></a>（4）问题：你认为对你来说现在找一份工作是不是不太容易，或者你很需要这份工作？</h5><p>回答：<br>1.是的。<br>2.我看不见得。</p>
<p>点评：<br>一般按1回答，一切便大功告成。<br>有些同学为了显示自己的“不卑不亢“，强调个人尊严，故按2回答。结果，用人单位打消了录用该生的念头，理由是：“此人比较傲“一句话，断送了该生一次较好的就业机会。</p>
<br>

<h5 id="（5）问题：你是怎么应聘到我们公司的？"><a href="#（5）问题：你是怎么应聘到我们公司的？" class="headerlink" title="（5）问题：你是怎么应聘到我们公司的？"></a>（5）问题：你是怎么应聘到我们公司的？</h5><p>回答：贵公司是国际上有名的汽车工业公司，虽然我学的专业不是汽车专业，但我一直留意、关心贵公司的发展，特别是贵公司注重对员工的培训，更让我心动，另外象贵公司这样大的企业，我想是各种专业人才都需要的，便毅然前来应聘。</p>
<p>点评：该毕业生的专业虽然不是该公司紧缺的专业，但他分析了公司招聘职位的具体要求，认为可以应试该公司的某一种职位要求。<br></p>
<p>（如管理、营销、秘书），如食品工程专业的求职面远不只局限于食品的加工企业，可延伸至饮品、酒类、保健品、调味品甚至酒楼等多个行业。都会有适合自己的职位。</p>
<br>

<h5 id="（6）问题：请你谈谈对我单位的看法"><a href="#（6）问题：请你谈谈对我单位的看法" class="headerlink" title="（6）问题：请你谈谈对我单位的看法"></a>（6）问题：请你谈谈对我单位的看法</h5><p>回答：我对贵单位还没什么了解，故谈不出看法</p>
<p>点评：象这样的回答，一般面试不成功多，如你很想进入该单位，就不妨实地去单位“侦察”一番，或收集有关的资料。如有一位毕业生，他有意去国家进出口银行工作，便通过朋友的关系弄到了一本进出口银行的基本业务材料，从而在面试中对答如流，赢得了招聘单位的赏识。并能以自身的优势来说明为何应聘这工作，做到有的防矢，给主考官留下了深刻的印象。因此，收集资料，了解单位，可以帮助求职者认清主要方向，更精确，更客观地审视主聘单位，选择适合自己发展的单位，避免走弯路。</p>
<br>

<h5 id="（7）问题：以你的资历条件，完全可以到大公司任职，你怎么想到我们小企业？"><a href="#（7）问题：以你的资历条件，完全可以到大公司任职，你怎么想到我们小企业？" class="headerlink" title="（7）问题：以你的资历条件，完全可以到大公司任职，你怎么想到我们小企业？"></a>（7）问题：以你的资历条件，完全可以到大公司任职，你怎么想到我们小企业？</h5><p>回答：<br>1.哎，没办法，一时没有应聘到大企业，况且，毕业时间又到了，否则只能回当地就业，因此先就业再说。<br>2.小企业有他自己的优势，在用人方面非常重视，自己虽然资历条件尚可，我想，在你们这样的企业更能发挥自己的作用。</p>
<p>点评：一个还未工作就想以后跳槽的员工，是无论如何不能指望他尽心尽力的干好工作的，因此，即使有此想法，也不能说出来，说不定工作后受到企业重用，本人的作用也发挥的特别好，而不想再走了呢？</p>
<br>

<h5 id="（8）问题：你为什么希望到我们公司工作？"><a href="#（8）问题：你为什么希望到我们公司工作？" class="headerlink" title="（8）问题：你为什么希望到我们公司工作？"></a>（8）问题：你为什么希望到我们公司工作？</h5><p>回答：我觉得贵公司力量雄厚，领导得力，上下一心，适于一切有才干的人发展。<br>忌：“我是学电子的，我到这里才是专业对口。”看情况而定。<br>“我来这里上班离家近。”<br>“我喜欢你们这儿。”<br>“听说你们公司月薪较高。”</p>
<p>点评：回答问题要从对方入题，引起对方好感，使对方感到你能尊重，关心公司的需要，愿为公司尽微薄之力。</p>
<br>

<h5 id="（9）问题：如果本公司录用你，你最希望在哪个部门工作？"><a href="#（9）问题：如果本公司录用你，你最希望在哪个部门工作？" class="headerlink" title="（9）问题：如果本公司录用你，你最希望在哪个部门工作？"></a>（9）问题：如果本公司录用你，你最希望在哪个部门工作？</h5><p>回答：<br>忌：“到哪个部门都行”<br>应：“本人希望到XX部门，但也很乐意接受公司的其他安排。</p>
<p>点评：不要说得太随意，太肯定。比较稳妥的办法是首先表明自己的志向和兴趣，再表示服从安排。</p>
<br>

<h5 id="（10）问题：你愿意被外派工作吗？你愿意经常出差吗？"><a href="#（10）问题：你愿意被外派工作吗？你愿意经常出差吗？" class="headerlink" title="（10）问题：你愿意被外派工作吗？你愿意经常出差吗？"></a>（10）问题：你愿意被外派工作吗？你愿意经常出差吗？</h5><p>回答：愿意，反正我无牵无挂，到哪儿工作都可以。</p>
<p>点评：这是主试者通过提问来透露他要找的是什么样的人，此信息已经很明白地告诉你，他所期待的回答是什么。对于此类问题应聘者留意倾听。从“话中之话”中找出应试者实际需要的线索。</p>
<br>

<h5 id="（11）问题：我怎样相信对这个职位你是最好的人选呢？"><a href="#（11）问题：我怎样相信对这个职位你是最好的人选呢？" class="headerlink" title="（11）问题：我怎样相信对这个职位你是最好的人选呢？"></a>（11）问题：我怎样相信对这个职位你是最好的人选呢？</h5><p>回答：根据这个职位的性质和我们刚才的谈话，我推断你需要的是工作积极的人，能够设定目标，不惧怕挑战的人。我就具有这些品质，让我再告诉你一些我在校时的经历，它们能说明我确实是你所需要的最好的人选。</p>
<p>点评：设身处地替面试官想一想，考虑一下招聘者需要什么样的人，你又在哪些方面符合他们的要求。根据要求，谈出自己应聘的优势。</p>
<br>

<h5 id="（12）问题：如果我能给你任何你想要的工作，你会选择什么？你真正想做的是什么工作？"><a href="#（12）问题：如果我能给你任何你想要的工作，你会选择什么？你真正想做的是什么工作？" class="headerlink" title="（12）问题：如果我能给你任何你想要的工作，你会选择什么？你真正想做的是什么工作？"></a>（12）问题：如果我能给你任何你想要的工作，你会选择什么？你真正想做的是什么工作？</h5><p>回答：就是这份工作。</p>
<p>点评：你可能觉得这是个怪问题，事实上常有这样的问题。这个问题是假设每个人都有未实现的梦想，都不能做他真正想做的事，亦即或多或少每个人都在妥协。若你真的谈了你的梦想，而他只会为圆你梦想的梦，而不录用你。因此，你确实要这份工作，那么参考答案只有一个。</p>
<br>

<h5 id="（13）问题：为什么你还没有找到工作？"><a href="#（13）问题：为什么你还没有找到工作？" class="headerlink" title="（13）问题：为什么你还没有找到工作？"></a>（13）问题：为什么你还没有找到工作？</h5><p>回答：我正在谨慎选择我的工作，本来我可以选择别的工作的，可是那些工作和现在这一个不同，我实在看不出它们会对我的事业进展有帮助。</p>
<p>点评：如果你真的拒绝了其他人的录取，那是再好不过了，如果其他企业都没有录取你，哪也不一定有问题。别人不能只因为你现在没有工作，就断定都没有人录取你，不要给人这样的错觉。</p>
<br>

<h5 id="（14）问题：你对我们公司有多少了解？"><a href="#（14）问题：你对我们公司有多少了解？" class="headerlink" title="（14）问题：你对我们公司有多少了解？"></a>（14）问题：你对我们公司有多少了解？</h5><p>回答：<br>1.完全不了解。<br>2.因为对贵公司有关方面相当有兴趣,所以才来应聘.</p>
<p>点评：若回答1.那就没有必要再说下去了，但录用的机会也就小了。最好的回答是2，这是公司想测试应聘者对公司的兴趣，关注程度，以后进公司工作的意愿的问题，因此，最好要稍稍记住公司的简介内容和招聘人事广告内容。</p>
<br>

<h5 id="（15）问题：你对公司有何印象？"><a href="#（15）问题：你对公司有何印象？" class="headerlink" title="（15）问题：你对公司有何印象？"></a>（15）问题：你对公司有何印象？</h5><p>回答：感觉很好，在其他公司没有这样的感受。</p>
<p>点评：或者说出面试当天的印象就可以了，因为还没有正式进入公司上班，所以主试者也不会太过刁难。</p>
<br>

<h5 id="（16）问题：你谈谈选择这份工作的动机？"><a href="#（16）问题：你谈谈选择这份工作的动机？" class="headerlink" title="（16）问题：你谈谈选择这份工作的动机？"></a>（16）问题：你谈谈选择这份工作的动机？</h5><p>回答：“这个职位刚好是我的专业对口，能把学的书本知识在实践中更好地应用。”<br>“我虽然学的专业与这职位有区别，但我对这方面的能力较强，相信自己能干好这份工作。</p>
<p>点评：这是测试面试者对这份工作的理解程度及热忱，并筛选因一时兴起而来应聘的人。</p>
<br>

<h5 id="（17）问题：你家在外地，我们单位无住宿，你如何看待呢？"><a href="#（17）问题：你家在外地，我们单位无住宿，你如何看待呢？" class="headerlink" title="（17）问题：你家在外地，我们单位无住宿，你如何看待呢？"></a>（17）问题：你家在外地，我们单位无住宿，你如何看待呢？</h5><p>回答：家在外地，贵单位无住宿条件，这些都不影响我来应聘贵公司，住宿我可以自己解决，无须单位操心，我看重贵公司的发展前途。</p>
<p>点评：不要因为个人生活上的小问题，而错失良机。主试者也想看看你对困难的看法，自信心程度。</p>
<br>

<h5 id="（18）问题：我们不限定固定职位，你认为自己最适合做什么？"><a href="#（18）问题：我们不限定固定职位，你认为自己最适合做什么？" class="headerlink" title="（18）问题：我们不限定固定职位，你认为自己最适合做什么？"></a>（18）问题：我们不限定固定职位，你认为自己最适合做什么？</h5><p>回答：<br>忌：“公司安排我做什么就做什么！”太随意。<br>“理想的职位就是有机会让我一展专长，为公司的发展贡献自己的学识。”太空。<br>应：我学的是XX专业，我认为XX职位比较适合我。</p>
<p>点评：主试者问你问题，就是想要一个明确的参考答案，且明确的回答给人以有思想、有主见、有活力的印象。象上面的回答，是犯了一个错误，然而几乎每个人都会犯同样的错误，他们总是说自己干什么都可以。因此，回答这样的问题，干脆用自己的心里话表白，实事求是，至少让主试者听起来感到舒服些。</p>
<br>

<h5 id="（19）问题：你希望从事什么样的工作？"><a href="#（19）问题：你希望从事什么样的工作？" class="headerlink" title="（19）问题：你希望从事什么样的工作？"></a>（19）问题：你希望从事什么样的工作？</h5><p>回答：根据贵公司的招聘职位，我认为x职位可能比较适合我，有利于我的能力的发挥。当然，其他有些职位也是可做的，人贵在学习。</p>
<p>点评：应试者可以应聘的职位作出大致的设想，让主试人了解自己的抱负与努力方向。由于每个单位都有自己的人事政策，其工作安排未必能完全与求职者的愿望相一致，尤其对一个初出茅庐的大学生来说，从基层做起，从小事做起也是应该的。但是，又不能随便回答：“到哪里工作都可以。”这让人觉得像在“乞讨工作”，被人看轻。所以要掌握分寸。</p>
<br>

<h5 id="（20）问题：你为什么要应聘我们公司？"><a href="#（20）问题：你为什么要应聘我们公司？" class="headerlink" title="（20）问题：你为什么要应聘我们公司？"></a>（20）问题：你为什么要应聘我们公司？</h5><p>回答：看了贵公司的广告及要求，感到自己比较符合公司的招聘条件，另外，对贵公司也有些了解，自己若能有幸成为贵公司的一员，是能有助于自己能力的发挥与发展的。</p>
<p>点评：这样的回答，可显示出自己积极进取的态度。在谈论用人单位时，态度要诚恳、谦和。不论大单位或小单位，都有其优胜和劣势，应试者应视其实际情况，提出自己的见解，不要牵强附会，如果一味往对方脸上贴金，反而会令人反感。</p>
<br>

<h5 id="（21）问题：你在以前实习的公司从事什么样的工作？"><a href="#（21）问题：你在以前实习的公司从事什么样的工作？" class="headerlink" title="（21）问题：你在以前实习的公司从事什么样的工作？"></a>（21）问题：你在以前实习的公司从事什么样的工作？</h5><p>回答：在具体说明对工作的理解程度和熟悉度时，回答要领有三个方面：担任的工作内容、职务、成绩三项。</p>
<p>点评：这个问题可以让公司知道面试者是否符合所要招聘的职位，以前在其他公司的职位是否重要，来判断应聘者的发展可能。</p>
<br>

<h5 id="（22）问题：为何辞去原来的工作？"><a href="#（22）问题：为何辞去原来的工作？" class="headerlink" title="（22）问题：为何辞去原来的工作？"></a>（22）问题：为何辞去原来的工作？</h5><p>回答：工作地点离家较远，路上花费时间多，发生交通问题时，影响工作。贵公司的工作岗位更适合自己专业<br></p>
<p>（个性）的发展。</p>
<p>点评：为了避免应聘者以相同的原因辞职，公司尽量能做到对这方面原因的了解，有助于创造一个良好的工作环境和人际氛围。因此，应聘者最好说出对方能信服的理由。如果自己确有缺点，要说出“将尽量克服自己缺点”，作为有信心改变这类情况的答复。</p>
<br>

<h5 id="（23）问题：你为何选择应聘我们公司？"><a href="#（23）问题：你为何选择应聘我们公司？" class="headerlink" title="（23）问题：你为何选择应聘我们公司？"></a>（23）问题：你为何选择应聘我们公司？</h5><p>回答：我对贵公司有一定的了解，特别对公司的XX经营理念，产品质量及员工培训比较看好。</p>
<p>点评：为了表明应聘原因及工作意愿，应聘者在回答时最好要了解企业状况，不要笼统回答因为自己将来有发展，更不要回答为了安定等参考答案。</p>
<br>

<h5 id="（24）问题：在公司想做什么样的工作？"><a href="#（24）问题：在公司想做什么样的工作？" class="headerlink" title="（24）问题：在公司想做什么样的工作？"></a>（24）问题：在公司想做什么样的工作？</h5><p>回答：现在想在某工作方面冲刺，将来则希望能在某方面努力等。朝自己想要的目标陈述即可。</p>
<p>点评：同时招聘很多职种的公司，最有可能问到这样的问题，这是判断应聘者个人的能力倾向。面试者如果不论职种都回答“可以”的话，反而会让人怀疑工作态度。如果这家公司只招聘一个职种，还是被问到这个问题时，是为了确认应聘者有无犹豫，应聘者只要清楚的叙述自己想做的事就可以了。</p>
<br>

<h5 id="（25）问题：你为何要跳槽？"><a href="#（25）问题：你为何要跳槽？" class="headerlink" title="（25）问题：你为何要跳槽？"></a>（25）问题：你为何要跳槽？</h5><p>回答：虽然在前面公司工作挺顺的，同事间合作也很愉快，但我感到贵公司更适合我的发展。</p>
<p>点评：公司根据你跳槽原因，意在了解你的就业动机。</p>
<br>

<h5 id="（26）问题：请问你有什么样的工作观？"><a href="#（26）问题：请问你有什么样的工作观？" class="headerlink" title="（26）问题：请问你有什么样的工作观？"></a>（26）问题：请问你有什么样的工作观？</h5><p>回答：我认为工作是为了实现自己的人生价值，发挥自己的最大潜能，解决自己的生活问题。</p>
<p>点评：此话是问工作在你的生活中意味着什么？为何而工作？从工作中得到了什么？几年后想变成怎样等。因此，别把它想得太复杂，可根据自己的具体情况回答。</p>
<br>

<h5 id="（27）问题：你是否可以接受加班？"><a href="#（27）问题：你是否可以接受加班？" class="headerlink" title="（27）问题：你是否可以接受加班？"></a>（27）问题：你是否可以接受加班？</h5><p>回答：我愿意接受挑战。在自己责任范围内的工作，不能算是加班。</p>
<p>点评：这是面试者针对应聘者的工作热忱而提的问题，因无理的加班不一定是好的。</p>
<br>

<h5 id="（28）问题：你认为这份工作最重要的是什么？"><a href="#（28）问题：你认为这份工作最重要的是什么？" class="headerlink" title="（28）问题：你认为这份工作最重要的是什么？"></a>（28）问题：你认为这份工作最重要的是什么？</h5><p>回答：最重要的是对自己的挑战和提高。</p>
<p>点评：对工作要加上自己的看法。<br>兴趣、学业、优点、缺点</p>
<br>

<h5 id="（29）问题：你现在最感兴趣的是什么？"><a href="#（29）问题：你现在最感兴趣的是什么？" class="headerlink" title="（29）问题：你现在最感兴趣的是什么？"></a>（29）问题：你现在最感兴趣的是什么？</h5><p>回答：做个人网站，练习口语，但越做越感到自己知识欠缺。</p>
<p>点评：可以简述你的兴趣，及这个兴趣带给你个性或能力的正面效果。</p>
<br>

<h5 id="（30）问题：空闲时喜欢什么消遣？"><a href="#（30）问题：空闲时喜欢什么消遣？" class="headerlink" title="（30）问题：空闲时喜欢什么消遣？"></a>（30）问题：空闲时喜欢什么消遣？</h5><p>回答：看书、集邮、上网。有空与朋友聚聚聊聊也不错。</p>
<p>点评：对工作之外，拥有其他兴趣的应聘者较受欢迎。</p>
<br>

<h5 id="（31）问题：你在自我调节方面做何种努力？"><a href="#（31）问题：你在自我调节方面做何种努力？" class="headerlink" title="（31）问题：你在自我调节方面做何种努力？"></a>（31）问题：你在自我调节方面做何种努力？</h5><p>回答：一般情况下，我会听音乐来放松自己，若能约上几个朋友一起搞搞运动感觉也是很好的。</p>
<p>点评：听到这种提问，你可以舒坦地笑一下。此问是为了了解应聘者自我管理能力、自我调节、自我完善的能力。</p>
<br>

<h5 id="（32）问题：你在学校里学了哪些课程？这些课程对所应聘的工作有些什么帮助？"><a href="#（32）问题：你在学校里学了哪些课程？这些课程对所应聘的工作有些什么帮助？" class="headerlink" title="（32）问题：你在学校里学了哪些课程？这些课程对所应聘的工作有些什么帮助？"></a>（32）问题：你在学校里学了哪些课程？这些课程对所应聘的工作有些什么帮助？</h5><p>回答：回答时只要将所学过的重要课程以及与所应聘的工作岗位有关的课程说出来就行了，不必把每一门课程都罗列出来。可稍为详细地介绍一下与应聘岗位有关的科目。</p>
<p>点评：不要强调所学科目会对今后的工作会有极大的作用，只着重强调打好了理论和技能基础。</p>
<p>问题；你有哪些兴趣爱好或具备什么资格证书？</p>
<p>回答：“书法、乐器、体育、集邮、唱歌、舞蹈等，如钢琴能达到十级水平。我还有打字达到A级，中英文都比较熟练，同时还有一张驾驶执照呢。”</p>
<p>点评：一个人的兴趣爱好，能显示他的多方面的才能和修养，这样的人除比别人多一种技能外，更重要的是，他们往往有进取心，有发散性的思维，比较热爱生活，另外，打字、计算机、口译证书、驾驶证、报关员证书等也可以作为技能，但一般要求有资格证书作证明，如果拥有这类操作性技能证书，则也是一张“硬派司”。在开放度极大的都市里，企业最欣赏的是一专多能的复合型人才。如没有，则说实话，如爱好广泛，但都不太精。</p>
<br>

<h5 id="（33）问题：你的学习成绩如何？"><a href="#（33）问题：你的学习成绩如何？" class="headerlink" title="（33）问题：你的学习成绩如何？"></a>（33）问题：你的学习成绩如何？</h5><p>回答：<br>“较好。”<br>“一般。”我在学校里除课堂上学习的知识外，比较喜欢扩充自己的其他方面的知识，对XX类的书也看了不少。</p>
<p>点评：对自己的学习成绩一定要如实回答。如果成绩优秀，应该用平和的口气，实事求是地介绍，决不可自我炫耀，让人觉得轻浮；如果成绩不好则应说明理由，或者哪门课程不好，隐瞒或欺骗，只会暴露自己的不良品行。总之，应表现出对学习的态度是认真的，努力的，对成绩又看得比较客观。这样即使你的成绩不太理想，主试人的反应也不会太强烈。</p>
<br>

<h5 id="（34）问题：请谈一谈你的弱点。"><a href="#（34）问题：请谈一谈你的弱点。" class="headerlink" title="（34）问题：请谈一谈你的弱点。"></a>（34）问题：请谈一谈你的弱点。</h5><p>回答：<br>我是一个完美主义者，总是追求事物完美无缺。<br>我对准时要求得非常严格。<br>我从不轻易放弃，以至有些固执。<br>我喜欢独立工作，而不喜欢主管领导在我的工作中安排一切。</p>
<p>点评：一般的策略是说出一些表面上是弱点，实际上却是优点的特征。当你在叙述个人弱点时，要能够说出过去的具体相关事例，来说明你的观点。这点非常重要。当然，你也可以说一个你明显的缺点，然后举出例子说明你是怎样克服这个缺点的。此问是主试者看看你是不是由于缺少某种经验、训练，甚至由于某些性格弱点而不能胜任工作。</p>
<br>

<h5 id="（35）问题：请谈谈你的优点。"><a href="#（35）问题：请谈谈你的优点。" class="headerlink" title="（35）问题：请谈谈你的优点。"></a>（35）问题：请谈谈你的优点。</h5><p>回答：我非常喜欢和善于学习新东西，在工作中有责任心，真诚，有热情，有灵活性，能够合理地安排时间使工作有条理、有效率，能够在紧张压力下工作等等。</p>
<p>点评：以上回答要有具体实例来证明你的说法。优点除了你的工作技能、具有的各类证书和实践经验外，主试者要想听的优点不见得是你最突出的优点，而应该是和你应聘的那份工作相关的优点，从中找出雇佣你的理由，同时可以知道你对自己的了解程度，看看你对自己有没有自信，以及你到底适合不适合这份工作。因此，你要精确地描述，不可泛泛说些无意义的话，例如，适应力强，具有幽默感，合群等等。</p>
<br>

<h5 id="（36）问题：你认为自己最大的缺点是什么？"><a href="#（36）问题：你认为自己最大的缺点是什么？" class="headerlink" title="（36）问题：你认为自己最大的缺点是什么？"></a>（36）问题：你认为自己最大的缺点是什么？</h5><p>回答：我认为自己的长处是能够热衷于某件事情，并且始终乐此不疲，能够专心致志直到完成。从某方面来讲，这也是我的短处，有时过分热衷于某件事，有时对一些事的看法可能会有失偏颇。其实我也了解自己的这一点，因此，今后会经常反思和检讨的。</p>
<p>点评：<br>这个问题也是较难回答的，它考察你的应变能力的成分多于问题参考答案的本身。<br>一个人的最大的缺点可能对你的家人和朋友来讲更清楚一些，自己可能有时会意识不到，所谓不识庐山真面目，只缘身在此山中。但是对一个大学生来说，应该能够意识到自己性格中的缺点。聘方知道你的优缺点就可以知道你是否能够适合某个职位。</p>
<br>

<h5 id="（37）问题：你所取得的最大成就是什么？"><a href="#（37）问题：你所取得的最大成就是什么？" class="headerlink" title="（37）问题：你所取得的最大成就是什么？"></a>（37）问题：你所取得的最大成就是什么？</h5><p>回答：从你过去或目前的相关工作中，找出具体的实例来加以说明。如为了举办校园歌手比赛，成功地联系了一家企业作为赞助商，使比赛开展的很成功，或大三开始，自己边学习，边工作，勤工助学，生活不依靠父母，完全自立等等。</p>
<p>点评：进一步了解你的能力和背景，你要有备而去，想些可能成就比较小，但和他们的需求比较相关的一件成就来叙述。</p>
<br>

<h5 id="（38）问题：请你说说在以前的工作上成功与失败的地方？"><a href="#（38）问题：请你说说在以前的工作上成功与失败的地方？" class="headerlink" title="（38）问题：请你说说在以前的工作上成功与失败的地方？"></a>（38）问题：请你说说在以前的工作上成功与失败的地方？</h5><p>回答：<br>在学校里，我成功地组织了一次“创业与知识”的主题讨论会，得到了老师与同学的肯定，在组织中碰到了不少问题，但使我感到做任何事情，只要有信心，困难都会迎刃而解的。<br>在班级里，曾组织过一次活动，原来想活动肯定有意义，但实际上参加的人不多，活动是失败的，事后了解，有些同学对此活动不感兴趣。主观上找了原因，是和同学沟通不够，使我在以后工作中注意了凡事多与同学商量。</p>
<p>点评：成功的地方可举出目前为止的实绩，来强调对经历的自信，也可以叙述工作所带来的乐趣；失败经验可以说曾经遇到的业务或人际障碍，也可以将如何克服失败的经验说出来，并说出由失败中所得到的教训。</p>
<br>

<h5 id="（39）问题：你的好朋友怎样形容你？"><a href="#（39）问题：你的好朋友怎样形容你？" class="headerlink" title="（39）问题：你的好朋友怎样形容你？"></a>（39）问题：你的好朋友怎样形容你？</h5><p>回答：他们说我开朗大方，对朋友的困难会尽力帮助，很有号召力，但有时不拘小节。</p>
<p>点评：这类问题是你表现自己的最好机会，不要错过。因此也最需要预先准备，否则你可能不知道从何说起，往往要想一会儿才答，或者随便回答，这两种情形都不会争取到好印象。</p>
<br>

<h5 id="（40）问题：你在大学里的学习成绩不敢恭维，你如何解释呢？"><a href="#（40）问题：你在大学里的学习成绩不敢恭维，你如何解释呢？" class="headerlink" title="（40）问题：你在大学里的学习成绩不敢恭维，你如何解释呢？"></a>（40）问题：你在大学里的学习成绩不敢恭维，你如何解释呢？</h5><p>回答：是的，我的学习成绩不是很理想，即学习分数不是很高，但我注重实践能力的锻炼，我已经实习过好几家企业，他们对我反映都不错。</p>
<p>点评：这类问题往往是一种“压迫法”的面试技巧，主试者故意提出应试者的弱点，令其尴尬，看他在压力之下怎样反应。故提到的弱点，不是问题关键所在。因此，应试者应沉着应付，想办法扭转劣势，表现出自己的急才与修养。</p>
<br>

<h5 id="（41）问题：你认为你的优势在哪些方面？"><a href="#（41）问题：你认为你的优势在哪些方面？" class="headerlink" title="（41）问题：你认为你的优势在哪些方面？"></a>（41）问题：你认为你的优势在哪些方面？</h5><p>回答：<br>1.我性格开朗活泼，善于与人沟通，有较强的亲和力，营销工作与管理工作比较适合我。<br>2．我和其他同学相比不是很活跃，可能最合适我的工作是财务与行政工作，我有信心做好这样的工作。</p>
<p>点评：回答2.他在面试者前谈了自己的“缺点”，显示了他的诚实和勇敢，他知道什么工作适合自己，显示了很强的自我意识，人家谈优点，他没有人云亦云，而坚持原则是财务与行政人员重要的素质之一。<br>工作经验、工作态度</p>
<br>

<h5 id="（42）问题：你有什么社会实践经验？"><a href="#（42）问题：你有什么社会实践经验？" class="headerlink" title="（42）问题：你有什么社会实践经验？"></a>（42）问题：你有什么社会实践经验？</h5><p>回答：一年级暑假参加过学校的社会实践调查。调查“xxxx”写了一篇《xxxx》小论文。二、三年级时利用暑假<br></p>
<p>（周末）、业余时间做英语家教，受到学生家长的好评。还曾在xxxx公司、xxxx公司打过工，这是企业对我的评价。</p>
<p>点评：现在的就业市场相当重视工作经验。如果应试者曾在假期或业余时间外出打工，积累了一定的社会工作经验，将会令用人单位更加满意，哪怕应试者的打工与求职的工作无关，如果应试者曾在大学里担任过一些学生工作或参加一些社团活动，也应作些介绍，表明自己具有一定的阅历与能力。用人单位都有这样的共识，具有社会经验的人往往比较成熟，能够更快地适应工作环境。</p>
<br>

<h5 id="（43）问题：你为什么选择现在的学校和专业？"><a href="#（43）问题：你为什么选择现在的学校和专业？" class="headerlink" title="（43）问题：你为什么选择现在的学校和专业？"></a>（43）问题：你为什么选择现在的学校和专业？</h5><p>回答：高考填报志愿时，当然有好几个高校是我理想的选择。按高考进入现在的学校，它是我的选择之一，当然这个专业是我喜欢的专业。喜欢的、或感兴趣的专业，也是我学习的动力之一，事实上，通过四年的的学习生活，我对我的学校所学专业感觉很好。</p>
<p>点评：回答这一问题时，要对自己的学校和所学的专业有一种崇高和热爱的心情，并应抱有信心。随意菲薄母校和所学的专业是一种极不负责的态度，会引起别人的反感，甚至让人怀疑应试者是否有真才实学。</p>
<br>

<h5 id="（44）问题：你比较喜欢独立工作还是集体工作？"><a href="#（44）问题：你比较喜欢独立工作还是集体工作？" class="headerlink" title="（44）问题：你比较喜欢独立工作还是集体工作？"></a>（44）问题：你比较喜欢独立工作还是集体工作？</h5><p>回答：我对独立工作或集体工作没有什么偏好，如果工作比较接近团队工作，我会做的很愉快的。如工作需要相当的自主性，我也很喜欢负责那样的工作。</p>
<p>点评：如果你知道应聘的工作性质是自主的或需要依赖集体合作的，那么你可以顺势决定回答这个问题。但是如果你一无所知，不论你怎么回答都可能惹祸上身。因此，不要让自己必须在两者中抉择，你不必非得说出喜欢哪一种不可。</p>
<br>

<h5 id="（45）问题：请你谈一下和本工作有关的工作经验"><a href="#（45）问题：请你谈一下和本工作有关的工作经验" class="headerlink" title="（45）问题：请你谈一下和本工作有关的工作经验"></a>（45）问题：请你谈一下和本工作有关的工作经验</h5><p>回答：如果你做过这一类工作，说出地点，并以具体的实例来说明你的工作成绩，不要用空洞的词语。如果你没有做过这类工作，就应强调你有能力来学做这个工作，你要表明你非常喜欢这个工作，也非常想学习新东西。尽可能把你过去经历中和这个工作有联系的内容提出来，尽可能将你具有的与这个工作有关联的技能提出来。</p>
<p>点评：此问题判断你能不能做这份工作。</p>
<br>

<h5 id="（46）问题：若你到我们公司后，如何看待你本人的地位。"><a href="#（46）问题：若你到我们公司后，如何看待你本人的地位。" class="headerlink" title="（46）问题：若你到我们公司后，如何看待你本人的地位。"></a>（46）问题：若你到我们公司后，如何看待你本人的地位。</h5><p>回答：<br>1.把自己当主人，能极大地发挥个人的潜能，与公司有共同的忧患意识。<br>2.不计较个人暂时得失，做到以公司利益为重，不急功近利或搞短期行为，在工作上任劳任怨、兢兢业业。<br>3.公司以真待我，我以诚回应。</p>
<p>点评：只有把“自己当主人”，才能干劲十足，激发活力，迸发才智，干出业绩，最终凭业绩成为该企业的主人。而如果这山望着那山高，不专心工作岗位，公司稍一陷入困境就辞职走人，只同甘不共苦，把自己当成打工仔，人格上就低人一等。</p>
<br>

<h5 id="（47）问题：你希望在本公司工作多长时间？"><a href="#（47）问题：你希望在本公司工作多长时间？" class="headerlink" title="（47）问题：你希望在本公司工作多长时间？"></a>（47）问题：你希望在本公司工作多长时间？</h5><p>回答：如果我们彼此感到满意的话，我将很乐意一直继续工作下去。</p>
<p>点评：一般情况下，公司都希望所提供的工作和氛围能使未来的雇员才华得到最大程度的发挥，而你也不乐意自己的大好时光耗费在一份自己不喜欢或不适合的工作上。因此这是一个比较好的回答。</p>
<br>

<h5 id="（48）问题：你对本公司"><a href="#（48）问题：你对本公司" class="headerlink" title="（48）问题：你对本公司"></a>（48）问题：你对本公司<br></h5><p>（或这份工作）有什么看法吗？</p>
<p>回答：我对贵公司<br></p>
<p>（或这份工作）很感兴趣，很乐意在公司里发挥自己的潜能，我也相信以自己积极的心态，努力工作，在贵公司我会得以发展的。</p>
<p>点评：考官问这个问题的真正目的想要了解你能做这份工作吗？你在这公司工作安心吗？若你感到没有准备的话，你最好先说：“让我想一下”然后深呼吸放松，再做回答，这有助于增加你在回答问题时的自信。</p>
<br>

<h5 id="（49）问题：你为什么要离开前一家单位？"><a href="#（49）问题：你为什么要离开前一家单位？" class="headerlink" title="（49）问题：你为什么要离开前一家单位？"></a>（49）问题：你为什么要离开前一家单位？</h5><p>回答：事实上，离开原来的单位对我来说是比较痛苦的选择，因为我在那里工作了x年之后<br></p>
<p>（一段时间），与那里的领导和同事相处的非常好，同时，通过我的努力，也取得了大家的信任，大家不愿我离开。但是，我心中一直希望自己在xx领域内有所发展，由于客观原因，在前面的单位里一直没能实现这个愿望，所以我还是做出了这个选择，离开前一个单位。</p>
<p>点评：这个问题看起来较为简单，但回答要注意。你回答的如果不合适，对方就可能产生这样的想法，离开前一个单位是不是你不得已而为之，问题在你个人，你会因为同样或者类似的原因离开我们？因此，要避免过多的抱怨前一雇主。要强调自己个人发展需要的原因，不要归咎于别人。要让聘方相信，你在原单位也是工作出色，人际关系良好，但是为了你个人的某种理想和追求，你愿意到新公司工作。</p>
<br>

<h5 id="（50）问题：你大学刚毕业，在相关工作经验方面较为欠缺你怎么看？"><a href="#（50）问题：你大学刚毕业，在相关工作经验方面较为欠缺你怎么看？" class="headerlink" title="（50）问题：你大学刚毕业，在相关工作经验方面较为欠缺你怎么看？"></a>（50）问题：你大学刚毕业，在相关工作经验方面较为欠缺你怎么看？</h5><p>回答：<br>1.“不见得吧！”“我看未必”“不会！”“完全不是这么回事！”等等。<br>2．“这样的说法未必全对”“这样的看法值得探讨”“这样的说法有一定的道理，但恐怕不能完全接受。”等等。</p>
<p>点评：<br>1.象这样的回答方式虽然求职者也能表达清楚个人的想法并对主考官的设问进行反驳或申诉，但由于语气太过生硬，否定太过直接而会引起主考官的不悦。<br>2.在表达的过程中较为委婉地表示出自己的不同意见，不致会影响到主考官的情绪。</p>
<br>

<h5 id="（51）问题：你如何看自己缺少工作经验这问题？"><a href="#（51）问题：你如何看自己缺少工作经验这问题？" class="headerlink" title="（51）问题：你如何看自己缺少工作经验这问题？"></a>（51）问题：你如何看自己缺少工作经验这问题？</h5><p>回答：<br>忌：“本人想到贵公司，目的也就是为了取得工作经验。”<br>应：“自己确实缺乏工作经验，在读书时，我就注意这个问题，作为学生、只能利用假期进行社会实践，到公司去打工，锻炼，平时勤工助学，曾在.XX公司工作过，这是XX公司对我的评价。”</p>
<p>点评：如何理解，如何解释缺少经验，缺少经验并不是毫无经验。一人在同一职位干了五年的人，并不意味着此人就具备了五年的经验，他极有可能只是将一年经验重复了五次而已。</p>
<br>

<h5 id="（52）问题：你没有营销方面的经验，不是吗？"><a href="#（52）问题：你没有营销方面的经验，不是吗？" class="headerlink" title="（52）问题：你没有营销方面的经验，不是吗？"></a>（52）问题：你没有营销方面的经验，不是吗？</h5><p>回答：<br>1.“我很喜欢营销方面的挑战，我会达到你们的要求，而且我也期望能扩大增长我的经验。营销这一行很吸引我，因为我适应力强，接受新知识能力又较快，我自信会干好营销工作的。”<br>2.“是啊，我是没有这方面的经验。”</p>
<p>点评：记住！如果这真的是一个问题，企业就不会请你来面试了。因此，不要按2.回答，按1.的回答显示了你的热忱和自信，无形中多了一些应征的可能，所以，要懂得化缺点为优点，转劣势为优势。<br>能力表现</p>
<br>

<h5 id="（53）问题：你谈恋爱了吗？你如何看待大学生谈恋爱？"><a href="#（53）问题：你谈恋爱了吗？你如何看待大学生谈恋爱？" class="headerlink" title="（53）问题：你谈恋爱了吗？你如何看待大学生谈恋爱？"></a>（53）问题：你谈恋爱了吗？你如何看待大学生谈恋爱？</h5><p>回答：没有。我个人认为大学生最好不要谈恋爱，因为大学生毕竟不是很成熟，自控力比较差，因恋爱荒废学业、不求上进的大有人在，大学生应集中精力搞好学业、锻炼能力。</p>
<p>点评：通过这个问题来考察应试者的成熟程度和处理生活事务的能力，考察应试者的人生观和价值观。因此，应提高认识的层次，从用人单位领导的角度思考问题。</p>
<br>

<h5 id="（54）问题：你有能力胜任应聘的职位吗？"><a href="#（54）问题：你有能力胜任应聘的职位吗？" class="headerlink" title="（54）问题：你有能力胜任应聘的职位吗？"></a>（54）问题：你有能力胜任应聘的职位吗？</h5><p>回答：没问题！这虽然较难，但是我会想办法做好的！对我来说这是一个新的挑战，我相信能够战胜它。<br>忌:“对不起，我缺乏经验，可能做不好吧？”“一个人做，恐怕我现在不行”<br>如果听到这种毫无生气与活力的话时，自然会在失望之余产生一种想法：“也许他是一个缺乏能力与自信的人吧！“</p>
<p>点评：掌握好谦虚的度，实在是一个大有学问的问题。中国的传统教育总是教导人们处事要谦虚，这方面的古训很多，“满招损，谦受益”；久而久之。一方面想出人头地，一方面又自觉不自觉的受这种思想的左右，不敢大胆的发表自己的意见，礼让过头，贬低自己。这种虚伪的过谦，特别在应聘外企中很不合时宜。往往弊大于利，适得其反。作为一个企业，理所当然的选择自信敬业的人。</p>
<br>

<h5 id="（55）问题：依你现在的水平，恐怕能找到比我们企业更好的公司吧？"><a href="#（55）问题：依你现在的水平，恐怕能找到比我们企业更好的公司吧？" class="headerlink" title="（55）问题：依你现在的水平，恐怕能找到比我们企业更好的公司吧？"></a>（55）问题：依你现在的水平，恐怕能找到比我们企业更好的公司吧？</h5><p>回答：<br>1.“YES”说明你这个人“身在曹营心在汉。”<br>2.“NO”说明你的能力有问题或是对自己自信心不足，总之你会左右为难。而如果你说“不知道”或“不清楚”。则又拒绝回答之嫌。<br>3.“不可一概而论。”<br>“或许我能找到比贵公司更好的企业，但别的企业或许在对人才培养方面不如贵公司重视，机会也不如贵公司多，或许我找不到更好的企业，我想珍惜已有的最为重要的。”</p>
<p>点评：象上面这个问题以3回答最好，可以说把一个“模糊”的参考答案抛给主考官，做到滴水不漏。这类问题的特点是主考官设定了一个特定的背景式条件，让求职者作出回答，有时任何一种条件参考答案都不是很理想，这时就需要用模糊语言表示。</p>
<br>

<h5 id="（56）问题：你的面试通过了，现在我们签约。"><a href="#（56）问题：你的面试通过了，现在我们签约。" class="headerlink" title="（56）问题：你的面试通过了，现在我们签约。"></a>（56）问题：你的面试通过了，现在我们签约。</h5><p>回答：让我考虑一下，我要和父母商量过再决定。</p>
<p>点评：其实这是一种不成熟的回答，在应聘外企时不可取得，设想如果将来让这样的人代表公司和客户谈判，凡事都回公司请示报告，到手的生意也会飞了。该同学是一个条件很不错的人选，应聘的是一家非常出名的跨国公司。她走后，公司马上通知了“替补队员”<br></p>
<p>（为防意外，公司面试人数比正式录取的人数总多1—2名）那位小伙子看完公司聘函立即签了约。他表示，我就想到该公司工作。待女孩子回来。说跟家人商量好了，同意签约，而此时，那个职位已招到新人，就是那位替补队员。所以当机会来临时，千万要抓住，犹豫就会错失良机，后悔也无济于事。</p>
<br>

<h5 id="（57）问题：今天来参加面试的有近十位候选人，而我们只挑选二名，如何证明你是他们中最优秀的呢？"><a href="#（57）问题：今天来参加面试的有近十位候选人，而我们只挑选二名，如何证明你是他们中最优秀的呢？" class="headerlink" title="（57）问题：今天来参加面试的有近十位候选人，而我们只挑选二名，如何证明你是他们中最优秀的呢？"></a>（57）问题：今天来参加面试的有近十位候选人，而我们只挑选二名，如何证明你是他们中最优秀的呢？</h5><p>回答：恐怕不能一下子讲清，得具体情况具体分析，比如贵公司现在所最需要的是行政管理方面的人才，虽然前来应征的都是这方面的对口人才，但我深信我在大学四年中担任过的学生干部及组织过多次大型活动的经验已经为我打下了扎实的基础，我想这一点恐怕也是我自认为比较突出的一点。</p>
<p>点评：这样的回答可以说比较圆滑，以免主考官抓住某一“把柄”，再度发难。此问题是考察求职者随机应变的能力。无论你列举多少优点别人总有比你更多的优点，因此，你从正面去回答这样的问题毫无意义的。</p>
<br>

<h5 id="（58）问题：听说你对XX工作"><a href="#（58）问题：听说你对XX工作" class="headerlink" title="（58）问题：听说你对XX工作"></a>（58）问题：听说你对XX工作<br></h5><p>（业务）很精通，不妨谈些你的看法吧？</p>
<p>回答：谈不上精通，只是略知一二，可以共同探讨一下。</p>
<p>点评：给自己留下一点回旋的余地。对于此类问题，特别要谨慎，这往往是一个“陷阱”，是主考官有意想进一步对求职者有更加深入的了解所设定的“圈套”。因此，求职者要小心回答问题，即使你真的对XX业务很精通，也千万不要自以为是，否则你将面临难度更大的问题。</p>
<br>

<h5 id="（59）问题：如果你被录用，是否马上就可来上班？"><a href="#（59）问题：如果你被录用，是否马上就可来上班？" class="headerlink" title="（59）问题：如果你被录用，是否马上就可来上班？"></a>（59）问题：如果你被录用，是否马上就可来上班？</h5><p>回答：今天听到你的聘用邀请十分感激，但学校里学业还未全部结束，论文撰写正是关键的时候，还在准备论文答辩阶段，容我回去征求导师意见，看能否抽出时间上班，所以允许我明天正式回复。</p>
<p>点评：面对开门见山的质问，如当时无法确定答复，且自己未决定真正意愿应允，应考虑到事后可能还会有更让自己心动的工作机会。在回答时即应巧妙预设一个转弯的空间。同时，避免得罪对方而错失良机，这比“对不起，我还不能回答这个问题，我必须仔细考虑看看。”这种答复圆滑的多。</p>
<br>

<h5 id="（60）问题：你救了我女儿，是我们家的救命恩人，对你的录用我们会优先考虑的。"><a href="#（60）问题：你救了我女儿，是我们家的救命恩人，对你的录用我们会优先考虑的。" class="headerlink" title="（60）问题：你救了我女儿，是我们家的救命恩人，对你的录用我们会优先考虑的。"></a>（60）问题：你救了我女儿，是我们家的救命恩人，对你的录用我们会优先考虑的。</h5><p>回答：不，先生，你弄错了吧，我未曾救过任何人<br>考官：年轻人，你说的很对，是我弄错了，我很欣赏你的诚实，我决定，不是优先，而是你的复试已经通过了</p>
<p>点评：此问题是考官设的一个“陷阱”。一个人的优秀品质会引起他人喜欢的，而诚实是招聘者看重的必备品质。因此大学生虽有良好的资历和优秀的学业成绩，更必备诚实的品格。</p>
<br>

<h5 id="（61）问题：“会打羽毛球吗？”"><a href="#（61）问题：“会打羽毛球吗？”" class="headerlink" title="（61）问题：“会打羽毛球吗？”"></a>（61）问题：“会打羽毛球吗？”</h5><p>“给你们一辆小轿车，有没有把握学会驾驶？”<br>“厨房里有蔬菜，你俩能不能给我做几样拿手的好菜？”</p>
<p>回答：<br>男：会女：打的不好<br>男：有女：不敢保证<br>男：没问题女：做得不好</p>
<p>点评：<br>此应聘面试单位是一家中外合资公司，已经过了几道关卡的面试，此是最后复试，主考经理是外国人，以上是闲聊中随便地问了三个问题。最后，公司录用了男学生，淘汰了女学生。公司对女学生的评价是：有自卑情绪，缺乏自信心，无法胜任本公司职务。其实，该女同学是个不错的羽毛球选手。</p>
<br>

<h5 id="（62）问题：在工作中你怎样看待错误？"><a href="#（62）问题：在工作中你怎样看待错误？" class="headerlink" title="（62）问题：在工作中你怎样看待错误？"></a>（62）问题：在工作中你怎样看待错误？</h5><p>回答：<br>1.我尽量不出错误<br>2.我并不担心自己会出错，但我能做到不重复同样的一个错误。</p>
<p>点评：对回答1的公司没有录用。<br>人非圣贤，熟能无过？错误是必不可少的，但关键是要能很快地吸取经验教训，总结经验。求职也如此，不要害怕失败，你应牢牢记住：“失败乃成功之母！”“失败是成功的踏脚石。”通往成功的路从不平坦，跌倒是难免的，但是，跌倒了并不是失败，真正的失败是跌倒了怕不起来了。”</p>
<br>

<h5 id="（63）问题：我们公司今年计划一般不招女学生"><a href="#（63）问题：我们公司今年计划一般不招女学生" class="headerlink" title="（63）问题：我们公司今年计划一般不招女学生"></a>（63）问题：我们公司今年计划一般不招女学生</h5><p>回答：贵公司的用人计划我了解，但我想性别差异并非是挑选人才的关键，还是要看个人的基本素质，何况我各方面表现都较优秀，有些男同学还赶不上我，而且女生在贵公司的职位更能显示女同学的优势。</p>
<p>点评：女同学碰到此类问题，不要愤怒、憎恨，要靠耐心和韧性，回答问题不要带怒意，要不卑不亢，充满自信，介绍自己的优势，有与男同学一比高低的勇气。</p>
<br>

<h5 id="（64）问题：你可以有三分钟的表现自己的机会，若表现得使我感兴趣，就留下来，否则另请高就。"><a href="#（64）问题：你可以有三分钟的表现自己的机会，若表现得使我感兴趣，就留下来，否则另请高就。" class="headerlink" title="（64）问题：你可以有三分钟的表现自己的机会，若表现得使我感兴趣，就留下来，否则另请高就。"></a>（64）问题：你可以有三分钟的表现自己的机会，若表现得使我感兴趣，就留下来，否则另请高就。</h5><p>回答：这三分钟的表现，可以成为你去留的依据，有的学生充分显示实力，把握了机会，有的学生则不会表现而被淘汰。有的学生为了显得谦虚，尽量少讲自己的优点，少表现自己，结果也失去了这个机会。</p>
<p>点评：此类面试问题一般是企业总经理面试时提的，他们的话简单明了：“你连自己都推销不掉，你帮我推什么？要帮我推销商品，推销企业形象，首先学会推销自己。”因此针对不同的面试对象，自己认真准备好几个三分钟是有必要的。因此，自我表现时要充满自信，落落大方，态度诚恳。</p>
<br>

<h5 id="（65）问题：小姐，假如在将来的工作中，你接待的客人要你陪跳舞，你不想跳，但不跳又不行，你会怎么办？"><a href="#（65）问题：小姐，假如在将来的工作中，你接待的客人要你陪跳舞，你不想跳，但不跳又不行，你会怎么办？" class="headerlink" title="（65）问题：小姐，假如在将来的工作中，你接待的客人要你陪跳舞，你不想跳，但不跳又不行，你会怎么办？"></a>（65）问题：小姐，假如在将来的工作中，你接待的客人要你陪跳舞，你不想跳，但不跳又不行，你会怎么办？</h5><p>回答：<br>1.你们是什么样的鬼单位，在这里摆摊招舞女。”说完头也不回扬长而去。<br>2.若是工作需要，要陪客人跳舞，跳跳也无妨。若是客人另有意思，那可约男同事一起去娱乐。</p>
<p>点评：此是外贸进出口公司在人才会上招聘秘书，单位是很正派很有声望的企业，提出这一问题，考官只是想试试求职者的口头应变能力和处事能力。该小姐只要冷静下来，思考考官提出的问题，把自己的看法如实说出，作机敏的回答，就不至于失去一份很有前途的工作。</p>
<br>

<h5 id="（66）问题：你喜欢和何种人共事？"><a href="#（66）问题：你喜欢和何种人共事？" class="headerlink" title="（66）问题：你喜欢和何种人共事？"></a>（66）问题：你喜欢和何种人共事？</h5><p>回答：总的说来我是一个开朗的人，我喜欢和有相同个性的人打交道。</p>
<p>点评：此句意在了解求职者本身的个性特点，并借此来分析求职者一旦进入新的机构后与现职位的其他人员的相容程度，主考官据此判断此人是否能与其他人融洽相处。按照一句时髦的话来说，就是看看求职者是否具有团队精神。作为求职者，应当注意不要过分对此句话“躲躲闪闪”或是故意回避，回答这个问题时，要先大概介绍一下自己的个性特点，然后再说喜欢同什么样的人相处，总之要言之有理，顺理成章。</p>
<br>

<h5 id="（67）问题：你对大学生就业市场的评价如何？"><a href="#（67）问题：你对大学生就业市场的评价如何？" class="headerlink" title="（67）问题：你对大学生就业市场的评价如何？"></a>（67）问题：你对大学生就业市场的评价如何？</h5><p>回答：这个问题很大，很难用三言两语概括清楚。在双向选择，自主择业的政策下，要就业，找市场已被学生接受，虽然就业市场形势严峻，但我们乐意在市场中参与竞争，选择合适自己的职业。</p>
<p>点评：主试人为测验应试者分析问题与逻辑思维能力，有意提一些很难回答的问题。回答此问题时应边说边想。若想好了再说，主试人会认为你反映迟钝。为了赢得思考的时间，开头可以先说一句开场白，后面边想边说，分条回答。想起一条答一条，在答第一条时就想第二条，依此类推。回答完了的时候，再从中找出一两个重点。这样就容易获得构思敏捷，思路清晰，善于抓住要害的好评。</p>
<br>

<h5 id="（68）问题：你喜欢什么样的上司？"><a href="#（68）问题：你喜欢什么样的上司？" class="headerlink" title="（68）问题：你喜欢什么样的上司？"></a>（68）问题：你喜欢什么样的上司？</h5><p>回答：<br>忌：“谁做我的上司都喜欢。”或“不知道”<br>应：“我本人比较喜欢有真才实学，公正严明的上司。”</p>
<p>点评：大多数应聘者对上司的背景毫不知情，因此，用一些普通适用的公认标准为好</p>
<br>

<h5 id="（69）问题：假如我们聘用你，但有时需要做些倒茶端水的杂务，你会反对吗？"><a href="#（69）问题：假如我们聘用你，但有时需要做些倒茶端水的杂务，你会反对吗？" class="headerlink" title="（69）问题：假如我们聘用你，但有时需要做些倒茶端水的杂务，你会反对吗？"></a>（69）问题：假如我们聘用你，但有时需要做些倒茶端水的杂务，你会反对吗？</h5><p>回答：“只要需要，我不会斤斤计较。”“如果有客人到我所在的那个部门，我会主动倒茶端水，这些杂务只是我的工作内容的一小部分而已。”</p>
<p>点评：这是一个试探性问题，目的是观察应聘者的反应，以判断你对工作的态度。因没有任何一家公司会聘用大学毕业生专门从事杂务工作。若明确拒绝接受这类杂务，则意味着拒绝接受职位，且在面试时与主试者争论差别毫无意义。</p>
<br>

<h5 id="（70）问题：如果公司与另外一家公司同时录用你，你将如何选择？"><a href="#（70）问题：如果公司与另外一家公司同时录用你，你将如何选择？" class="headerlink" title="（70）问题：如果公司与另外一家公司同时录用你，你将如何选择？"></a>（70）问题：如果公司与另外一家公司同时录用你，你将如何选择？</h5><p>回答：<br>1.贵公司是我的第一选择。<br>2.我不敢奢望有两家公司同时看上我，即使有此情况，我还是首选贵公司。</p>
<p>点评：无论你到哪家公司应聘，都应这么回答，在未确定最后的归属前，回答这个问题不能有丝毫犹豫。</p>
<br>

<h5 id="（71）问题：你对营销、管理工作如何看待？"><a href="#（71）问题：你对营销、管理工作如何看待？" class="headerlink" title="（71）问题：你对营销、管理工作如何看待？"></a>（71）问题：你对营销、管理工作如何看待？</h5><p>回答：现在社会竞争非常激烈，营销、管理工作不是光凭热情能干好的，它需要经常做些调查研究，了解社会需求，提出目标、计划，同时，需要各方面的配合，才能把工作做的更好。</p>
<p>点评：应聘者对所应聘的岗位不能仅仅是有热情，同时还要冷静、理智地作出一些工作设想，这既说明了工作的积极主动性，也表明了应聘者是一个聪慧且思考成熟的人。</p>
<br>

<h5 id="（72）问题：你认为对员工的管理严厉的好，还是宽松的好？"><a href="#（72）问题：你认为对员工的管理严厉的好，还是宽松的好？" class="headerlink" title="（72）问题：你认为对员工的管理严厉的好，还是宽松的好？"></a>（72）问题：你认为对员工的管理严厉的好，还是宽松的好？</h5><p>回答：我想这要因时因人而定的，不能千篇一律。有些人对严厉的管理方法反应良好，有些人却需要鼓励才能做得更好。好的管理人员应该知道怎么使他的部属发挥更大的潜力。</p>
<p>点评：你不清楚企业需要的是什么样的管理作风，也是测试你能接受什么样的管理风格，如你确实不能接受他们的管理风格，那等到录取了再抉择。</p>
<br>

<h5 id="（73）问题：你好象不适合到我们公司工作？"><a href="#（73）问题：你好象不适合到我们公司工作？" class="headerlink" title="（73）问题：你好象不适合到我们公司工作？"></a>（73）问题：你好象不适合到我们公司工作？</h5><p>回答：可能在刚才的陈述中没把问题谈清楚，是我引起你的误解。其实我对贵公司非常尊重，对公司业务也有一些了解，我想在贵公司经过培训和工作后，是能够达到贵公司要求的，请务必再次考虑录用的问题。</p>
<p>点评：应答时，千万要注意不可反问对方提出的此问题的理由。此问有时也是主试者考验应试者到企业的决心，和应试者的自信心。</p>
<br>

<h5 id="（74）问题：你的计算机能力如何？"><a href="#（74）问题：你的计算机能力如何？" class="headerlink" title="（74）问题：你的计算机能力如何？"></a>（74）问题：你的计算机能力如何？</h5><p>回答：<br>如果你这方面能力较差的话，你就应该告诉他们你的计算机能力较为欠缺，但是你目前还在继续学习计算机。<br>如果能力强的话，就可直接告诉他们你所得到的高级或中级编程员证书，及计算机的其他能力。</p>
<p>点评：遇到的问题属于自己的长处，也不要洋洋洒洒，滔滔不绝。对方问到自己的短处，不要避而不谈，或者转移话题，其实每一个人即使是非常优秀的人都会有自己的弱点，这种情况下应该正面回答对方的问题，同时如果自己认为这是一个欠缺而又是对方的招聘条件的话，应该积极表示自己现在的或者即将的行动用来克服这方面的缺点。</p>
<br>

<h5 id="（75）问题：你的外语水平如何？"><a href="#（75）问题：你的外语水平如何？" class="headerlink" title="（75）问题：你的外语水平如何？"></a>（75）问题：你的外语水平如何？</h5><p>回答：<br>如果你水平高的话，对方又是懂外语的面试官你可以直接用外语进行回答你外语所具备的能力，得到的证书或托福的考分，以表示你的能力。但表示还不够，还需努力继续学习。<br>若你的水平较低，就应如实回答，讲出低的原因，如笔头翻译不差，口语听力稍差，或专业词汇较熟悉，人文词汇掌握较少等。并表示你目前还在学习。</p>
<p>点评：遇到的问题属于自己的长处，也不要洋洋洒洒，滔滔不绝。对方问到自己的短处，不要避而不谈，或者转移话题，其实每一个人即使是非常优秀的人都会有自己的弱点，这种情况下应该正面回答对方的问题，同时如果自己认为这是一个欠缺而又是对方的招聘条件的话，应该积极表示自己现在的或者即将的行动用来克服这方面的缺点。</p>
<br>

<h5 id="（76）问题：能否介绍一下你的社会活动能力"><a href="#（76）问题：能否介绍一下你的社会活动能力" class="headerlink" title="（76）问题：能否介绍一下你的社会活动能力"></a>（76）问题：能否介绍一下你的社会活动能力</h5><p>回答：<br>1.我的外交能力较强，在校学生会我担任外联部长。<br>2.我在校尽可能多地参加一些能发挥自己特长的活动，使社会活动能力得到了一定的提高。<br>3.我善于组织同学开展活动，如组织演讲赛，辩论赛，知识抢答赛等等，而且活动也较成功，从中可以证实我有一定的社会活动能力。<br>4.在校期间，我曾担任过班长职务。为了把班级基础文明建设搞好，组织全班同学进行校规校纪学习，集思广益，制定了“班规十条”，并要求全班同学严格遵守班级纪律。经过大家的努力，我班评为校先进班级，全班同学学习努力，团结友爱。</p>
<p>点评：<br>1.过于简单，草率，效果不好。<br>2.比较谦虚地说明自己有一定的能力，但言之无物，有些空洞。<br>3.如实的介绍自己曾组织过活动，但不具体。<br>4.通过例举事例，来说明自己的能力，有理有据，效果最佳，使主试者了解其素质和能力。</p>
<br>

<h5 id="（77）问题：你今后打算是什么？"><a href="#（77）问题：你今后打算是什么？" class="headerlink" title="（77）问题：你今后打算是什么？"></a>（77）问题：你今后打算是什么？</h5><p>回答：“我希望我能够在这个公司里长久地工作。根据自己的能力和表现，不断地增加工作中所担负的责任。”</p>
<p>点评：看看你真正想要得到的是什么，以判定你是否会长期在公司工作。明确你的个人目标和公司是否一致。</p>
<br>

<h5 id="（78）问题：你为什么这么长时间没有工作？"><a href="#（78）问题：你为什么这么长时间没有工作？" class="headerlink" title="（78）问题：你为什么这么长时间没有工作？"></a>（78）问题：你为什么这么长时间没有工作？</h5><p>回答：我花了很长一段时间对自己的经历进行了反省和总结，并仔细研究了目前的就业市场，以确定自己的目标和方向，当然我也有过一些工作机会，但我的目的不仅仅是找一份工作，我追求的是有发展前途的未来。今天来应聘贵公司，我觉得贵公司适合我的发展。</p>
<p>点评：判断你对难题的应变能力，以及你对实际生活中问题的判断和处理能力。</p>
<br>

<h5 id="（79）问题：为什么要录用你？"><a href="#（79）问题：为什么要录用你？" class="headerlink" title="（79）问题：为什么要录用你？"></a>（79）问题：为什么要录用你？</h5><p>回答：这是你要回答好的最重要的问题。根据公司目前的需要，强调你的背景优势，根据工作的需求叙述一下你的能力。如果你没有相关工作经验，强调你的其他工作经验和所受的教育，适合这个工作。</p>
<p>点评：确定你是不是最佳人选，看看你有没有自信心。</p>
<br>

<h5 id="（80）问题：你为什么想要换工作？"><a href="#（80）问题：你为什么想要换工作？" class="headerlink" title="（80）问题：你为什么想要换工作？"></a>（80）问题：你为什么想要换工作？</h5><p>回答：“我想进一步发挥我的能力”，或“我目前单位的发展机会非常有限。”</p>
<p>点评：这个问题是判断你的动机，和你处理问题的能力。切记，不要抱怨你过去或目前的雇主。</p>
<br>

<h5 id="（81）问题：谈一谈你在过去工作中生活中遇到的问题，以及如何解决。"><a href="#（81）问题：谈一谈你在过去工作中生活中遇到的问题，以及如何解决。" class="headerlink" title="（81）问题：谈一谈你在过去工作中生活中遇到的问题，以及如何解决。"></a>（81）问题：谈一谈你在过去工作中生活中遇到的问题，以及如何解决。</h5><p>回答：举一个你在过去的工作中或生活中遇到的问题，说明你是如何解决该问题的。</p>
<p>点评：判断你对问题的分析能力，看看你有没有团队精神和克服困难的信心。这也是给你一个表现自我的机会。</p>
<br>

<h5 id="（82）问题：你喜欢你们学校吗？你的老师怎么样？"><a href="#（82）问题：你喜欢你们学校吗？你的老师怎么样？" class="headerlink" title="（82）问题：你喜欢你们学校吗？你的老师怎么样？"></a>（82）问题：你喜欢你们学校吗？你的老师怎么样？</h5><p>回答：我很喜欢学校，那是我学习、生活了四年的地方，也是我成材、成熟的人生车站。四年中也碰到了许多好老师，对我思想上引导、学业上指导、能力上辅导，我从心里感谢他们。特别我们的英语老师，上课非常幽默，回想起来仍感到回味无穷。</p>
<p>点评：每个学生对这个问题一定要持积极肯定的态度。这是主考者考察应试者的个人品格的题目。作为一个具有高度思想觉悟和良好道德品质的现代大学生，尊师爱校是应有的品质。此外，人们普遍认为，一个不热爱母校、不尊敬老师的大学毕业生，也很难谈得上热爱就业单位，尊敬单位领导及老同志。因此，因充满激情地简单说明喜欢自己母校的原因，及老师对自己在学业和能力上的帮助和影响。</p>
<br>

<h5 id="（83）问题：假如你流落荒岛，可以拥有一本书，你会选择哪一本？为什么？"><a href="#（83）问题：假如你流落荒岛，可以拥有一本书，你会选择哪一本？为什么？" class="headerlink" title="（83）问题：假如你流落荒岛，可以拥有一本书，你会选择哪一本？为什么？"></a>（83）问题：假如你流落荒岛，可以拥有一本书，你会选择哪一本？为什么？</h5><p>回答：我选择生活百科全书，因为此时人最基本的问题是解决生存问题。</p>
<p>点评：这是假设性问题，来测试应试者的想象力、解决问题的能力，目的看你有没有急才，思想有没有条理。</p>
<br>

<h5 id="（84）问题：如果你的任务完成了，而同伴尚未完成，你应该怎么办？"><a href="#（84）问题：如果你的任务完成了，而同伴尚未完成，你应该怎么办？" class="headerlink" title="（84）问题：如果你的任务完成了，而同伴尚未完成，你应该怎么办？"></a>（84）问题：如果你的任务完成了，而同伴尚未完成，你应该怎么办？</h5><p>回答；我应该处理好其他事情，主动地去支援同伴。</p>
<p>点评：用人单位希望员工能更好地融入集体，勇于承担个人责任。要求员工在工作中应和睦相处，互相帮助，互相合作。一家外资公司总经理说：“可能这里不一定每个人都是一流的，但他们结合起来，绝对是一流的。”</p>
<p>其他问题</p>
<br>

<h5 id="（85）问题：毕业后为何不马上工作"><a href="#（85）问题：毕业后为何不马上工作" class="headerlink" title="（85）问题：毕业后为何不马上工作"></a>（85）问题：毕业后为何不马上工作<br></h5><p>（为何现在才应聘工作）</p>
<p>回答：<br>为了取得xx资格证书，故一直在复习应考，使应聘时更具实力。<br>参加了xx大学的短训班，使自己的xx水平提高。<br>花了很多时间了解就业市场和有关信息。</p>
<p>点评：要以肯定、积极、正面的活动进行回答为佳。如果没有任何活动，也可讲述这段时间自己的想法。只要有上进性，面试者会满意的。</p>
<br>

<h5 id="（86）问题：你择业考虑的主要问题是什么？"><a href="#（86）问题：你择业考虑的主要问题是什么？" class="headerlink" title="（86）问题：你择业考虑的主要问题是什么？"></a>（86）问题：你择业考虑的主要问题是什么？</h5><p>回答：主要谈考虑应聘的职业对自己将来事业的发展，及发挥自己的专业所长。另外，良好的企业文化<br></p>
<p>（工作氛围）能激发自己的能动性等等。</p>
<p>点评：凡是与物质利益有关的条件，如工资、福利、环境等等，最好少谈，即使问到，也要把握分寸，适可而止。</p>
<br>

<h5 id="（87）问题：你觉得自己干这项工作是大材小用还是小材大用？"><a href="#（87）问题：你觉得自己干这项工作是大材小用还是小材大用？" class="headerlink" title="（87）问题：你觉得自己干这项工作是大材小用还是小材大用？"></a>（87）问题：你觉得自己干这项工作是大材小用还是小材大用？</h5><p>回答：我相信我能干好这项工作。我觉得自己既不是大材小用也不是小材大用，它正好适合我干。</p>
<p>点评：如果你对这项工作确实很感兴趣，那么不管情况怎样，你都应如上面回答。</p>
<br>

<h5 id="（88）问题：你正在和其他公司洽谈吗？"><a href="#（88）问题：你正在和其他公司洽谈吗？" class="headerlink" title="（88）问题：你正在和其他公司洽谈吗？"></a>（88）问题：你正在和其他公司洽谈吗？</h5><p>回答：是的。</p>
<p>点评：<br>如果你的回答是否定的，那么你应征的希望必然削弱不少。<br>如果你没有同时应征其他公司，那么表示你的求职计划出了严重的错误。若确实在谈，你也不必告诉他们你正和谁接洽。只要让他们知道，如果他们想要你，最好得马上采取行动才行，认为你是值得给第二次面试机会的人选。</p>
<br>

<h5 id="（89）问题：薪水和工作，哪个对你更重要？"><a href="#（89）问题：薪水和工作，哪个对你更重要？" class="headerlink" title="（89）问题：薪水和工作，哪个对你更重要？"></a>（89）问题：薪水和工作，哪个对你更重要？</h5><p>回答：两者对我都很重要。因为薪水可以解决个人生存问题，是生活条件基本需要，工作是为了发展自己的能力。点评：此题是非A即B题，如果你希望获得一个既有高薪待遇，又有长期职业发展前途的工作的话，没必要非排除一个选择另一个。</p>
<br>

<h5 id="（90）问题：这份工作起薪点不高，你不会介意吧？"><a href="#（90）问题：这份工作起薪点不高，你不会介意吧？" class="headerlink" title="（90）问题：这份工作起薪点不高，你不会介意吧？"></a>（90）问题：这份工作起薪点不高，你不会介意吧？</h5><p>回答：不介意。</p>
<p>点评：一般碰到这类问题都顺水推舟，照对方的意思回答，如果你有特别理由要说相反的话，也不妨鼓起勇气照说出来，但要言之有理，在对方大感意外之余，说不定会赞赏你有主见。可是一般来说，还是尽可能不要冒险。</p>
<br>

<h5 id="（91）问题：你希望待遇月薪大约是多少金额？"><a href="#（91）问题：你希望待遇月薪大约是多少金额？" class="headerlink" title="（91）问题：你希望待遇月薪大约是多少金额？"></a>（91）问题：你希望待遇月薪大约是多少金额？</h5><p>回答：依贵公司的规定大概是什么样的薪金行情？</p>
<p>点评：若你心里没底的话，感到难回答，那么上面这一反问就行了，因一个有制度的公司不会因为你要求得多就多给，要求得少就少给。</p>
<br>

<h5 id="（92）问题：你如何看待你原来的薪金问题"><a href="#（92）问题：你如何看待你原来的薪金问题" class="headerlink" title="（92）问题：你如何看待你原来的薪金问题"></a>（92）问题：你如何看待你原来的薪金问题</h5><p>回答：我并不是说原来工作的单位不好，但工作几年下来的工资奖金没有增长，可能是他们的企业所决定的，但别人还以为我能力不够，现在，我到贵公司来应聘，薪金有所提高，算是自我价值的认定吧。”</p>
<p>点评：薪金问题一向是单位吸引人才的重要手段，也是求职者的追求目的之一，因此，薪金问题既是个敏感的问题，又是个重要问题，须小心处理。</p>
<br>

<h5 id="（93）问题：请谈一下你期望的月薪要求"><a href="#（93）问题：请谈一下你期望的月薪要求" class="headerlink" title="（93）问题：请谈一下你期望的月薪要求"></a>（93）问题：请谈一下你期望的月薪要求</h5><p>回答：如果我能到贵公司工作，这将是我跨出校门，第一次走上社会工作，我相信我自己的能力，如果能受聘这个职位我一定会非常努力的工作，因此每月xxxx元的工资是我个人的要求，但我更关心的是能找到一份工作来充分发挥我个人的能力。</p>
<p>点评：实际上用人单位决定录用你时，对你的待遇其实已基本确定。特别在一些国企跨国大公司中，对大学生的工资待遇公司都有了相关规定的，但也不是绝对不可更改的。此问也是面试者为了了解你对自己的估价。因此对月薪不能要求过高，但也要合理。如果你觉得单位给你的月薪偏低，可以将你的关注告诉单位。你要让单位觉得你是在同他们商议，而不是要挟。重点放在你关注的原因上。比如，你要租房、车费、生活费等基本开销或探亲等，希望单位算一下你的基本生活开销，那么效果会比简单地说你要多少多少工资要来得好些。</p>
<p>忌问：我不是名牌大学毕业生<br></p>
<p>（研究生），你们要吗？</p>
<p>点评：此问话首先让人感到你缺少自信心，有一种自卑感。有的招聘单位招聘条件很醒目地提出，只招聘名牌大学毕业生<br></p>
<p> （研究生），遇到这种情况，你要调节好自己的心态，以积极自信的态度前往应聘，讲出自己的优点，对应聘岗位的了解，希望公司不要以牌子取人，应注重真才实学，给你面试机会。</p>
<p>忌问：“外地生源要否？”</p>
<p>点评：一些外地学生或出于坦诚，或急于得到“兑现”，一到用人单位招聘摊位前劈头就提这么一个问题，弄得主试人无话可说。因为实际情况是，不是外地生源不要，也不是所有外地生源都要，而是要看应聘者的实际情况能否与招聘者要求相符合。这么简单地提问，很有可能同样简单地得到回绝。</p>
<p>忌问：“你单位招几个？”</p>
<p>点评：这种提问似乎无可厚非，但招聘者对此会从另外的角度认为，招一个也是招，招两个也是招，问题不在于招几个，而是应聘者有没有成为百分之一或二分之一或独一无二的竞争能力和实力。因为一百个名额要竞争，一个名额更要竞争。</p>
<p>忌问：“你们单位招女生吗？”</p>
<p>点评：这样提问的女生，首先自己先打了“折扣”，是一种缺乏自信心的表现。面对已明显表露出“胆怯”的女性，招聘单位若想拒绝，就正好“顺水推舟”。这时，如果这位女生面对主试人来一番非同凡响的慷慨陈词或巧妙的介绍，反倒会使主试人认真“考虑考虑。”</p>
<p>忌问：你们单位有住宿吗？</p>
<p>点评：对于在异地就业的毕业生，住宿问题是一个大问题，但在应聘中，什么问题都没谈，企业根本还没决定录用你，你就提出住宿问题，这是自信心不足的表现。何况，现在社会上租房也是很方便的一件事。</p>
<br>

<h5 id="（94）问题：请问你还有问题要问吗？"><a href="#（94）问题：请问你还有问题要问吗？" class="headerlink" title="（94）问题：请问你还有问题要问吗？"></a>（94）问题：请问你还有问题要问吗？</h5><p>回答：回答这个问题，大有学问。首先，你可以将你在面试中还没有机会提出的相关问题提出来。其次，进一步强调一下你在面试过程中没有机会谈到的个人优势。如果实在没有什么可以说的，也不要说没有问题。你可以问面试者下一次的面试<br></p>
<p>（如果有的话）是什么时间？或者问面试者什么时候可以得到结果，以及什么时候可以打电话给他。如果你确定得到这份工作，这个时候你就应该对面试者这么说：“我很想得到这份工作。我认为我完全能够胜任这份工作。请给我这个机会。”最后，对面试者表示致谢，握手，告别。</p>
<p>点评：此问一般当面试者要结束面试时，常常会问的问题。</p>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></h6></h6>]]></content>
      <categories>
        <category>Job Interview</category>
      </categories>
  </entry>
  <entry>
    <title>非技术问题回答方略</title>
    <url>/Blog/2022/03/12/%E9%9D%9E%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98%E5%9B%9E%E7%AD%94%E6%96%B9%E7%95%A5/</url>
    <content><![CDATA[<h6 align="center">编者：艾孜尔江<h6>


<p><b><details><summary>1、请你自我介绍一下你自己</summary></details></b></p>
<p>回答提示：一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历上都有，其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以和学习无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句“谢谢”。企业喜欢有礼貌的求职者。</p>
<p>回答样本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、我叫xxx,来自于xxx，从网上看得到公司招聘的这个职位，觉得非常适合自己的发展。所以来这里争取下这份工作。</span><br><span class="line">2、接下来可以讲解自己的核心竞争力（最强的技能、最深入研究的知识领域、个性中最积极的部分）和闪光点（做过的最成功的事，主要的成就）。核心就是要体现自己胜任这份工作（介绍时候要自然有底气，合情合理，面试前要充分准备好）。</span><br><span class="line">3、先介绍到这里，面试官看看有什么问题，我可以再补充。</span><br><span class="line">4、最后要说谢谢，任何企业都喜欢有礼貌的人！</span><br></pre></td></tr></table></figure>

<p>注意：自曝其短（说自己的缺点）没有必要，自我介绍的时候千万不要和简历有冲突！</p>


<p><b><details><summary>2、你觉得你个性上最大的优点是什么？</summary></details></b></p>
<p>回答提示：沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱、技术狂热、学习能力强、为人谦和。</p>


<p><b><details><summary>3、说说你最大的缺点？</summary></details></b></p>
<p>回答提示：这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，企业肯定不会录用你。绝对不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌芨可危了。企业喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转回到优点上，突出优点的部分。企业喜欢聪明的求职者。</p>


<p><b><details><summary>4、你对加班的看法？</summary></details></b></p>
<p>回答提示：实际上好多公司问这个问题，并不证明一定要加班。 只是想测试你是否愿意为公司奉献。<br>回答样本：如果是工作需要我会义不容辞加班。我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。</p>


<p><b><details><summary>5、你对薪资的要求？</summary></details></b></p>
<p>回答提示：如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱。他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。</p>
<p>回答样本一：“我对工资没有硬性要求。我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多</p>
<p>回答样本二：我受过系统的软件编程的训练，不需要进行大量的培训。而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。</p>
<p>回答样本三：如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场作了调查，知道像自己这样学历的雇员有什么样的价值。</p>


<p><b><details><summary>6、在五年的时间内，你的职业规划？</summary></details></b></p>
<p>回答提示：这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到。比较多的参考答案是“管理者”。但是近几年来，许多公司都已经建立了专门的技术途径。这些工作地位往往被称作“顾问”、“参议技师”或“高级软件工程师”等等。当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是 “我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。</p>


<p><b><details><summary>7、你朋友对你的评价？</summary></details></b></p>
<p>回答提示： 想从侧面了解一下你的性格及与人相处的问题。<br>回答样本：“我的朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。<br>回答样本：”我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题“</p>


<p><b><details><summary>8、你还有什么问题要问吗？</summary></details></b></p>
<p>回答提示：企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没有问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。</p>


<p><b><details><summary>9、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？</summary></details></b></p>
<p>回答提示：一段时间发现工作不适合我，有两种情况：</p>
<p>1、如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；</p>
<p>2、你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。</p>


<p><b><details><summary>10、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？</summary></details></b></p>
<p>回答提示：①.原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法；<br>② 如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作；<br>③.还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见；如领导仍固执己见，我会毫不犹豫地再向上级领导反映。</p>


<p><b><details><summary>11、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？</summary></details></b></p>
<p>回答提示：<br>① 我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决；<br>② 是责任问题。分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。<br>③ 总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。</p>


<p><b><details><summary>12、如果你在这次考试中没有被录用，你怎么打算？</summary></details></b></p>
<p>回答提示：现在的社会是一个竞争的社会,从这次面试中也可看出这一点,有竞争就必然有优劣,有成功必定就会有失败.往往成功的背后有许多的困难和挫折,如果这次失败了也仅仅是一次而已,只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败.</p>
<p>第一、要敢于面对,面对这次失败不气馁,接受已经失去了这次机会就不会回头这个现实,从心理意志和精神上体现出对这次失败的抵抗力。要有自信,相信自己经历了这次之后经过努力一定能行.能够超越自我.</p>
<p>第二、善于反思,对于这次面试经验要认真总结,思考剖析,能够从自身的角度找差距。正确对待自己,实事求是地评价自己,辩证的看待自己的长短得失,做一个明白人.</p>
<p>第三、走出阴影,要克服这一次失败带给自己的心理压力,时刻牢记自己弱点,防患于未然,加强学习,提高自身素质.</p>
<p>第四、认真工作,回到原单位岗位上后,要实实在在、踏踏实实地工作,三十六行,行行出状元,争取在本岗位上做出一定的成绩.</p>
<p>第五、再接再厉,成为软件工程师或网络工程师一直是我的梦想,以后如果有机会我仍然后再次参加竞争.</p>


<p><b><details><summary>13、如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？</summary></details></b></p>
<p>回答提示：我首先不会找那位上级领导说明这件事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他；2.他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。</p>


<p><b><details><summary>14、谈谈你对跳槽的看法？</summary></details></b></p>
<p>回答提示：（1）正常的”跳槽”能促进人才合理流动，应该支持；<br>（2）频繁的跳槽对单位和个人双方都不利，应该反对。</p>


<p><b><details><summary>15、工作中你难以和同事、上司相处，你该怎么办？</summary></details></b></p>
<p>回答提示：<br>① 我会服从领导的指挥，配合同事的工作。<br>② 我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好。如果是这样的话 我会努力改正。<br>③ 如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足。有问题就及时改正。<br>④ 作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的！</p>


<p><b><details><summary>16、假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？</summary></details></b></p>


<p>回答提示：<br>① 成绩比较突出，得到领导的肯定是件好事情，以后更加努力<br>② 检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。<br>③ 工作中，切勿伤害别人的自尊心<br>④ 不再领导前拨弄是非<br>⑤ 乐于助人对面</p>


<p><b><details><summary>17、你最近是否参加了培训课程？谈谈培训课程的内容。是公司资助还是自费参加？</summary></details></b></p>
<p>回答提示：请自行根据自己情况做回答，这个没有统一标准参考答案。</p>


<p><b><details><summary>18、你对于我们公司了解多少？</summary></details></b></p>
<p>回答提示：在去公司面试前上网查一下该公司主营业务。</p>


<p><b><details><summary>19、请说出你选择这份工作的动机？你为什么选择我们公司？</summary></details></b></p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.面试前，对应聘公司各方面，要了解详尽！至少要了解到行业、企业、岗位这三方面！最好要准备一些具体的数据和实例！</span><br><span class="line">2.面试时候，可以将之前对公司的了解（行业、企业、数据、实例）结合自己的面试岗位，大略的说一遍，然后强调自己“觉得这个工作合适”即可。</span><br><span class="line">3.如果对这个行业确实很喜欢，要说出你对这个行业的认识与热爱。</span><br></pre></td></tr></table></figure>





<p><b><details><summary>20、你最擅长的技术方向是什么？</summary></details></b></p>
<p>回答提示：说和你要应聘的职位相关的技术，表现一下自己的热诚没有什么坏处。</p>


<p><b><details><summary>21、你能为我们公司带来什么呢？</summary></details></b></p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① 假如你可以的话，试着告诉他们你可以减低他们的费用——“我已经接受过专业的培训或者工作 X 年，立刻就可以上岗工作”。</span><br><span class="line">② 企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。”等等。</span><br></pre></td></tr></table></figure>





<p><b><details><summary>22、最能概括你自己的三个词是什么？</summary></details></b></p>
<p>回答提示：我经常用的三个词是适应能力强，有责任心和做事有始终，结合具体例子向主考官解释。</p>


<p><b><details><summary>23、你的业余爱好是什么？</summary></details></b></p>
<p>回答提示：找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作。</p>


<p><b><details><summary>24、作为被面试者给我打一下分</summary></details></b></p>
<p>回答提示：试着列出四个优点和一个非常非常非常小的缺点，（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。</p>


<p><b><details><summary>25、你怎么理解你应聘的职位？</summary></details></b></p>
<p>回答提示：把岗位职责和任务及工作态度阐述一下</p>


<p><b><details><summary>26、喜欢这份工作的哪一点？</summary></details></b></p>
<p>回答提示：相信其实大家心中一定都有参考答案了吧！每个人的价值观不同，自然评断的标准也会不同，但是，在回答面试官这个问题时可不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的参考答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。</p>


<p><b><details><summary>27、为什么要离职?您在前一家公司的离职原因是什么?</summary></details></b></p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① 回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言，都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象；建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的参考答案最好是积极正面的。</span><br><span class="line">② 我希望能获得一份更好的工作，如果机会来临，我会抓住；我觉得目前的工作，已经达到顶峰，即沒有升迁机会。</span><br><span class="line">③ 最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”在此家招聘单位里不存在；</span><br><span class="line">④ 避免把“离职原因”说得太详细、太具体；</span><br><span class="line">⑤ 不能掺杂主观的负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥我们某某的员工”等；但也不能躲闪、回避，如“想换换环境”、“个人原因”等；</span><br><span class="line">⑥ 不能涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等；尽量使解释的理由为应聘者个人形象添彩；</span><br></pre></td></tr></table></figure>

<p>回答样本：如“我离职是因为这家公司倒闭；我在公司工作了三年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只有一个参考答案，而同一个参考答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。</p>
<p>分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能准假，所以辞职。这个参考答案一般面试官还能接受。</p>


<p><b><details><summary>28、说说你对行业、技术发展趋势的看法？</summary></details></b></p>
<p>回答提示：企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。</p>


<p><b><details><summary>29、对工作的期望与目标何在？</summary></details></b></p>
<p>回答提示：这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的参考答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。</p>


<p><b><details><summary>30、说说你的家庭。</summary></details></b></p>
<p>回答提示：企业面试时询问家庭问题不是非要知道求职者家庭的情况，探究隐私，企业不喜欢探究个人隐私，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。企业最喜欢听到的是：我很爱我的家庭！我的家庭一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。企业相信，和睦的家庭关系对一个人的成长有潜移默化的影响。</p>


<p><b><details><summary>31、就你申请的这个职位，你认为你还欠缺什么？</summary></details></b></p>
<p>回答提示：企业喜欢问求职者弱点，但精明的求职者一般不直接回答。他们希望看到这样的求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地躲过难题的求职者。</p>


<p><b><details><summary>32、你欣赏哪种性格的人？</summary></details></b></p>
<p>回答提示：诚实、不死板而且容易相处的人、有”实际行动”的人。</p>


<p><b><details><summary>33、你通常如何处理別人的批评？</summary></details></b></p>
<p>回答提示：① 沈默是金。不必说什么，否则情况更糟，不过我会接受建设性的批评；② 我会等大家冷靜下来再讨论。</p>


<p><b><details><summary>34、你怎样对待自己的失敗？</summary></details></b></p>
<p>回答提示：我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。</p>


<p><b><details><summary>35、什么会让你有成就感？</summary></details></b></p>
<p>回答提示：为贵公司竭力效劳；尽我所能，完成一个项目</p>


<p><b><details><summary>36、眼下你生活中最重要的是什么？</summary></details></b></p>
<p>回答提示：对我来说，能在这个领域找到工作是最重要的；望能在贵公司任职对我说最重要。</p>


<p><b><details><summary>37、你为什么愿意到我们公司来工作？</summary></details></b></p>
<p>回答提示：对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”，“我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。”“你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”或者“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。</p>


<p><b><details><summary>38、你和别人发生过争执吗？你是怎样解决的？</summary></details></b></p>
<p>回答提示：这是面试中最险恶的问题。其实是考官布下的一个陷阱。千万不要说任何人的过错。应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的一个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确参考答案。</p>


<p><b><details><summary>39、问题：你做过的哪件事最令自己感到骄傲?</summary></details></b></p>
<p>回答提示：这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去午餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。</p>


<p><b><details><summary>40、你新到一个部门,一天一个客户来找你解决问题,你努力想让他满意，可是始终达不到群众得满意,他投诉你们部门工作效率低,你这个时候怎么作?</summary></details></b></p>
<p>回答提示：</p>
<p>(1)首先，我会保持冷静。作为一名工作人员，在工作中遇到各种各样的问题是正常的，关键是如何认识它，积极应对，妥善处理。</p>
<p>(2)其次，我会反思一下客户不满意的原因。一是看是否是自己在解决问题上的确有考虑的不周到的地方，二是看是否是客户不太了解相关的服务规定而提出超出规定的要求，三是看是否是客户了解相关的规定，但是提出的要求不合理。</p>
<p>(3)再次，根据原因采取相对的对策。如果是自己确有不周到的地方，按照服务规定作出合理的安排，并向客户作出解释；如果是客户不太了解政策规定而造成的误解，我会向他作出进一步的解释，消除他的误会；如果是客户提出的要求不符合政策规定，我会明确地向他指出。</p>
<p>(4)再次，我会把整个事情的处理情况向领导作出说明，希望得到他的理解和支持。</p>
<p>(5)我不会因为客户投诉了我而丧失工作的热情和积极性，而会一如既往地牢记为客户服务的宗旨，争取早日做一名领导信任、公司放心、客户满意的职员。</p>


<p><b><details><summary>41、对这项工作，你有哪些可预见的困难？</summary></details></b></p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① 不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行；</span><br><span class="line">② 可以尝试迂回战术，说出应聘者对困难所持有的态度——“工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。”</span><br></pre></td></tr></table></figure>

<p>分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节。但常规思路中的回答，又被面试官“骗”了。当面试官询问这个问题的时候，有两个目的。</p>
<p>第一，看看应聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。</p>
<p>第二，是想看一下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难的态度。</p>


<p><b><details><summary>42、如果我录用你，你将怎样开展工作？</summary></details></b></p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① 如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法；</span><br><span class="line">② 可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。”</span><br></pre></td></tr></table></figure>

<p>分析：这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性，而且重点想要知道细节。如果向思路中所讲的迂回战术，面试官会认为回避问题，如果引导了几次仍然是回避的话。此人绝对不会录用了。</p>


<p><b><details><summary>43、你希望与什么样的上级共事？</summary></details></b></p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① 通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会；</span><br><span class="line">② 最好回避对上级具体的希望，多谈对自己的要求；</span><br><span class="line">③ 如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了</span><br></pre></td></tr></table></figure>

<p>分析：这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏。</p>


<p><b><details><summary>44、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？</summary></details></b></p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">①.原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法；</span><br><span class="line">② 如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作；</span><br><span class="line">③.还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见；如领导仍固执己见，我会毫不犹豫地再向上级领导反映。</span><br></pre></td></tr></table></figure>





<p><b><details><summary>45、与上级意见不一是，你将怎么办？</summary></details></b></p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① 一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”</span><br><span class="line">② 如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。”</span><br></pre></td></tr></table></figure>

<p>分析：这个问题的标准参考答案是思路 1，如果用 2 的回答，必死无疑。你没有摸清楚改公司的内部情况，先想打小报告，这样的人没有人敢要。</p>


<p><b><details><summary>46、你工作经验欠缺，如何能胜任这项工作？</summary></details></b></p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① 如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎“经验”，关键看应聘者怎样回答；</span><br><span class="line">② 对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业；</span><br><span class="line">③ 如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。”</span><br></pre></td></tr></table></figure>

<p>点评：这个问题思路中的参考答案尚可。突出自己的吃苦能力和适应性以及学习能力（不是学习成绩）为好。</p>


<p><b><details><summary>47、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？</summary></details></b></p>
<p>回答提示：每个公司都在不断变化发展的过程中；你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。此外，他们遇到矛盾和问题时，也能泰然处之。下面的问题能够考核应聘者这方面的能力。<br>据说有人能从容避免正面冲突。请讲一下你在这方面的经验和技巧。<br>有些时候，我们得和我们不喜欢的人在一起共事。说说你曾经克服了性格方面的冲突而取得预期工作效果的经历。</p>


<p><b><details><summary>48、项目中遇到困难，你怎么办？怎么回答</summary></details></b></p>
<p>回答提示：自己能搞定的，就自己上网找资料；但如果比如在 2 个小时之内还没有头绪，就考虑问公司技术水平比较高的同事之类的，然后还要及时和项目经理沟通</p>
<p>那不浪费了 2 个小时时间 业务问题的话，谁清楚就问谁啊……即时沟通能够大大提高工作效率。</p>
<p>技术问题查资料，需求问题重新分析</p>
<p>还是写程序的时候有技术难点、技术难点又分普遍的技术难点、还是你个人不会做、</p>
<p>第一种这个要找项目负责人商量、甚至要找产品&#x2F;运行或其他甲方沟通、</p>
<p>第二种普遍技术难点的话、参考资料或者和项目负责人商量看看怎么办、</p>
<p>第三种的话、先自己查资料试着解决、不行就找人其他资讯、、</p>


<p><b><details><summary>49、对前端界面工程师这个职位是怎么样理解的？</summary></details></b></p>
<p>回答提示：</p>
<p>a. 前端是最贴近用户的程序员，前端的能力就是能让产品从 90 分进化到 100 分，甚至更好</p>
<p>b. 参与项目，快速高质量完成实现效果图，精确到 1px；</p>
<p>c. 与团队成员，UI 设计，产品经理的沟通；</p>
<p>d. 做好的页面结构，页面重构和用户体验；</p>
<p>e. 处理 hack，兼容、写出优美的代码格式；</p>
<p>f. 针对服务器的优化、拥抱最新前端技术。</p>


<p><b><details><summary>50、你在现在的团队处于什么样的角色，起到了什么明显的作用？</summary></details></b></p>
<p>回答提示：请自行根据自己情况做回答，这个没有统一标准参考答案。</p>


<p><b><details><summary>51、最近在学什么？能谈谈你未来 3，5 年给自己的规划吗？</summary></details></b></p>
<p>面试时，经常会被面试官问到关于职业规划的问题，比如：你准备在我们公司做多久？你未来几年的职业规划是什么？等等。还没有进入公司，对公司工作环境还不太了解就被面试官问到这些问题，该怎么答才能合情有合理呢？</p>
<p>问：你准备在我们这家单位做多久？</p>
<p>答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 这不是自己单方面决定的，还要看公司，但是可以肯定的是，如果公司跟自己的职业发展一致，我是会一直干下去的。</span><br><span class="line">2．以我对公司和现有职位的了解，如果能应聘上的话，目前来看至少可以稳定三年。</span><br></pre></td></tr></table></figure>

<p>问：未来五年的规划是怎样的？</p>
<p>答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.如果应聘成功，我至少会稳定的做两年，踏实的做好自己的本职工作。</span><br><span class="line">2.在工作中，会向高手请教，研究些新技术，提高自己的技术水平。</span><br><span class="line">3.目前的规划是要优先做一名技术高手，如果有可能的话，做管理也是可以考虑的。</span><br></pre></td></tr></table></figure>

<p>当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。</p>
<p>大部分面试官司都会问你是否有职业规划，这个问题的背后是了解你的求职动机和对自己中长期职业发展的思考。在回答这个问题之前，要对自己有个清晰的认识，知道自己想往哪个方向发展以及未来有什么计划，要给面试官一种积极向上，好学上进，有追求，有规划的感觉，面试官喜欢有规划的求职者。</p>


<p><b><details><summary>52、如何向 HR 介绍你做过的项目</summary></details></b></p>
<p>项目经验与工作经验是相辅相成的，但较之于工作经验，项目经验更侧重于表现求职者在某个专业领域内的技能水平（技能水平决定了工资水平）。因而，技术类岗招聘的时候，更注重项目经验。项目介绍是有套路的，面试时，要将简历中的项目准备好！</p>
<p>回答提示：</p>
<p>我们在跟面试官讲解的时候，讲解项目一定要围绕着以下几个方面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、项目名称</span><br><span class="line">2、开发时间（这里有个注意点：时间不要说的太短，而应该把前期的构思、需求分析、准备工作等时间都可以加进去）；</span><br><span class="line">3、项目描述（做什么的）；</span><br><span class="line">4、项目职责（说清楚自己职责，同时为了提高自己的技术形象，可以将项目说大点）；</span><br><span class="line">5、项目使用的技术（除了说现在使用的技术，还可以说项目进行了压力测试、兼容性处理、数据库的3F、未来还要放mysql集群技术、页面静态化技术、以提升自己在对方心目中的技术形象）；</span><br><span class="line">6、项目的亮点；</span><br><span class="line">7、在自己的项目上可以想一些市面上没有但是自己觉得很有创意的点子。实现不实现都是无所谓了，但是你给面试官的印象会再上一个层次。</span><br><span class="line">8、项目体会（可以说说：多人协作、命名规范、模块划分）；</span><br></pre></td></tr></table></figure>





<p><b><details><summary>53、HR 贬低项目时你该怎么办</summary></details></b></p>
<p>我们在上文讲解了如何向 HR 介绍项目。由于项目反映了技术，技术决定了薪资，所以面试官一般会把打压我们的项目变相打压我们技术，以达到打压我们薪资预期的目的，同时观察我们在打压环境中的表现来决定到底打压薪资到何种程度！所以，当 HR 说：“一个月的时间，四五个人的配合就完成了项目，可见你们项目不大、技术含量不高啊”，各位面试者一定要冷静！来学学在 HR 贬低项目时的应对方法！</p>
<p>回答提示：</p>
<p>HR 说：一个月的时间，四五个人的配合就完成了项目，可见你们项目不大、技术含量不高啊！如何应对，别慌，我们应该按下面的方法答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.项目实现也许花的时间不多，但是前期的构思、需求分析、页面设计等等准备工作是花了很多时间的。</span><br><span class="line">2.项目大小和技术含量并不能够成正比，我们的项目，虽然小，但麻雀虽小，却五脏俱全。接着向面试官介绍你们团队在项目过程中所使用的技术等等。</span><br><span class="line">3.项目大小主要是体现在功能上，有些功能客户并没有提出。如果后期客户有提出，我们也能够快速的实现。</span><br></pre></td></tr></table></figure>





<p><b><details><summary>54、项目经验少该怎么办</summary></details></b></p>
<p>对于前端来说，技术水平是决定我们工资最重要的因素。技术水平是要通过我们的项目体现出来的，但项目经验少该怎么办？</p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、项目经验是拿高工资最重要的一个指标。这反映了程序员的价值，也是用人单位给出薪资报价最重要的因素。所以面试者一定要重视项目。</span><br><span class="line">2、简历中至少要写出3个项目。</span><br><span class="line">3、项目可以适当包装。可以多说一些比较高端大气上档次的技术。</span><br><span class="line">4、面试官问到简历中的项目细节你要能答上来。否则，就算是你做的，面试官因你答不上来也会认为不是你做的。所以要花时间，搞定写在简历上的项目模块。</span><br><span class="line">5、项目抓亮点来说，可以对照企业的需求，将最有竞争力的点说清楚。这种能够加分的亮点一定要说到。</span><br></pre></td></tr></table></figure>





<p><b><details><summary>55、你学历低，为什么要录用你？</summary></details></b></p>
<p>面试一份工作时，学历有时候是一块敲门砖。对于学历不高的面试者，如果 HR 问：你才高中学历，而现在大学生一大把，我们为什么要录用你？你如果学历真的很低，那该怎么回答呢？</p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、通过自信的表现，有效的沟通，让面试官主动忽略这个问题。或者说是你把你最好的展现出来，让面试官信服，觉得你是合适的人选而不提及或忽略掉这个问题。</span><br><span class="line">2、即使面试官提出来了，勇敢面对主动承认，赞同面试官的提问，确实学历较低，自已已经深刻认识此问题，也因为认识到这个事实，你才更加注重能力的培养，同时自己也在工作之余继续课堂学习，增加扎实的理论知识。同时说出你的学历提升打算，提升计划一定要与你现行的工作职位结合。</span><br><span class="line">3、如果面试官对学历一直抓住不放，或作为必要条件，以退为进吧，委婉表达自己想得到职位的态度，并做好了放弃的心理准备。</span><br></pre></td></tr></table></figure>

<p>总的来说，在面试的时候，表现出自信，从谈吐和沟通上，给面试官好印象。如果问到你学历的时候，表现出“学历不代表能力”的自信来就好，一般的企业不会把这个当做决定性因素，还是看综合素质。</p>


<p><b><details><summary>56、你是不是年龄太大了？</summary></details></b></p>
<p>都说 IT 行业是个吃青春饭的行业，你现在已经接近 30 岁了，你是不是年龄太大了？这个问题应该被问到的不多，但是万一真的被问到这个问题，你该如何作答呢？</p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、 能不能做事才是大问题。而不是年龄。是不是有能力，试用期间可以检验。</span><br><span class="line">2、 要表现出自己很喜欢这份工作，要长久的做下去（年龄大的人，工作经历多，接触的东西多，才能够在众多的经历中明确知道自己未来到底要走什么路）。要突出自己年龄大的优势，比如思想更成熟，眼界更开阔等等。</span><br></pre></td></tr></table></figure>





<p><b><details><summary>57、你太小了，你能承担项目吗？</summary></details></b></p>
<p>虽说 IT 行业是个吃青春饭的行业，但是你年纪太小了，让人感觉不踏实。虽然我们最重要拼的是技术，但真的被问到这个问题，你该如何作答呢？</p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、虽然我年纪小，但是我技术是没有问题的，也是有担当的。试用期间可以检验。</span><br><span class="line">2、对于前端，我做过很多的项目，也有系统的学习过。并不比年纪大的人差。</span><br><span class="line">3、正因为我年纪小，我对于工作有十足的干劲，我很想在这行好好的发展，也能承受比较强的工作压力。</span><br></pre></td></tr></table></figure>





<p><b><details><summary>58、你对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</summary></details></b></p>
<p>回答提示：<br>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。</p>
<ul>
<li>1、实现界面交互</li>
<li>2、提升用户体验</li>
<li>3、有了 Node.js，前端可以实现服务端的一些事情</li>
</ul>
<ul>
<li>前端是最贴近用户的程序员，前端的能力就是能让产品从 90 分进化到 100 分，甚至更好，</li>
<li>参与项目，快速高质量完成实现效果图，精确到 1px；</li>
<li>与团队成员，UI 设计，产品经理的沟通；</li>
<li>做好的页面结构，页面重构和用户体验；</li>
<li>处理 hack，兼容、写出优美的代码格式；</li>
<li>针对服务器的优化、拥抱最新前端技术。</li>
</ul>
<p>其它相关的加分项：</p>
<ol>
<li>都使用和了解过哪些编辑器?都使用和了解过哪些日常工具?</li>
<li>都知道有哪些浏览器内核?开发过的项目都兼容哪些浏览器?</li>
<li>瀑布流布局或者流式布局是否有了解</li>
<li>HTML5 都有哪些新的 API?</li>
<li>都用过什么代码调试工具?</li>
<li>是否有接触过或者了解过重构。</li>
<li>你遇到过比较难的技术问题是？你是如何解决的？</li>
</ol>


<p><b><details><summary>59.现如今面对如层出不穷的类库，说说你的感受</summary></details></b></p>
<p>参考答案：百花齐放，百家争鸣的感觉。<br>说明社区活跃，这一片欣欣尚荣的风景，蛮好！</p>





<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></h6></h6>]]></content>
      <categories>
        <category>Job Interview</category>
      </categories>
  </entry>
  <entry>
    <title>技能面试考前冲刺</title>
    <url>/Blog/2022/03/05/%E6%8A%80%E8%83%BD%E9%9D%A2%E8%AF%95%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BA/</url>
    <content><![CDATA[<h6 align="center">编者：艾孜尔江<h6>


<hr>
<h1 id="一、编程之美"><a href="#一、编程之美" class="headerlink" title="一、编程之美"></a>一、编程之美</h1><h2 id="1-2-中国象棋将帅问题"><a href="#1-2-中国象棋将帅问题" class="headerlink" title="1.2 中国象棋将帅问题"></a>1.2 中国象棋将帅问题</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b:<span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i.a = <span class="number">1</span>; i.a &lt;= <span class="number">9</span>; i.a++)</span><br><span class="line">    <span class="keyword">for</span> (i.b = <span class="number">1</span>; i.b &lt;= <span class="number">9</span>; i.b++)</span><br><span class="line">        <span class="keyword">if</span> (i.a % <span class="number">3</span> != i.b % <span class="number">3</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%u:%u&quot;</span>, i.a, i.b);</span><br></pre></td></tr></table></figure>

<h2 id="1-14-连连看"><a href="#1-14-连连看" class="headerlink" title="1.14 连连看"></a>1.14 连连看</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Grid* preClick = <span class="literal">NULL</span>, * curClick = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// listen user event</span></span><br><span class="line">    <span class="keyword">if</span> (点击格子 xy 非空) &#123;</span><br><span class="line">        preClick = curClick;</span><br><span class="line">        curClick.pos = x, y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preClick &amp;&amp; curClick &amp;&amp; findPath(preClick, curClick)) &#123;</span><br><span class="line">        显示路径</span><br><span class="line">        消去</span><br><span class="line">        preClick = curClick = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-2-6-LeetCode"><a href="#2-1-2-6-LeetCode" class="headerlink" title="2.1 - 2.6 LeetCode"></a>2.1 - 2.6 LeetCode</h2><h2 id="2-7-最大公约数"><a href="#2-7-最大公约数" class="headerlink" title="2.7 最大公约数"></a>2.7 最大公约数</h2><p>辗转相除法，如果一个数能够整除x,y，那么他也能够整除x,x%y。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> gcd(y, x % y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// iterative</span><br><span class="line">int gcd(int x, int y) &#123;</span><br><span class="line">    while (y) &#123;</span><br><span class="line">        int t = x;</span><br><span class="line">        x = y</span><br><span class="line">        y = t % y;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">取模运算开销较大，但如下方法在y比较小时，求解次数过多，容易溢出</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">int gcd(int x, int y) &#123;</span><br><span class="line">    if (x &lt; y)</span><br><span class="line">        return gcd(y, x);</span><br><span class="line">    if (y == 0)</span><br><span class="line">        return x;</span><br><span class="line">    return gcd(x - y, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">        <span class="keyword">return</span> gcd(y, x);</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">0x1</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">0x1</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> gcd(x&gt;&gt;<span class="number">1</span>, y&gt;&gt;<span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> gcd(x &gt;&gt;<span class="number">1</span>, y);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">0x1</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> gcd(x, y&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> gcd(y, x-y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="2-8-看下讲解"><a href="#2-8-看下讲解" class="headerlink" title="2.8 看下讲解"></a>2.8 看下讲解</h2><h2 id="2-9-斐波那契数列"><a href="#2-9-斐波那契数列" class="headerlink" title="2.9 斐波那契数列"></a>2.9 斐波那契数列</h2><p>使用动态规划(Memoization)的算法不在赘述O(n)。</p>
<p>O(logn)的解法</p>
<p>通项公式</p>
<pre><code>f(n), f(n-1) = (f(n-1), f(n-2)) * A

A = |1  1|
    |1  0| 

f(n), f(n-1) = (f(n-1), f(n-2)) * A = ... = (f1, f0) * A^(n-1)
</code></pre>
<p>下面我们计算<code>A^n-1</code>，太简单了，使用<code>A^(2n) = A^n * A^n</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// pesudo code</span><br><span class="line">int fib(int n) &#123;</span><br><span class="line">    Matrix factor = matrixPow(A, n-1);</span><br><span class="line">    return f1*factor + f0*factor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Matrix matrixPow(Matrix m, int n) &#123;</span><br><span class="line">    Matrix result = Matrix::Identity;</span><br><span class="line">    while (n) &#123;</span><br><span class="line">        if (n &amp; 1)</span><br><span class="line">            result *= m;</span><br><span class="line">        m *= m;</span><br><span class="line">        n &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展问题，如果是前三项相加的数列呢，依然可以求出转移矩阵</p>
<h2 id="2-11-最近点对问题"><a href="#2-11-最近点对问题" class="headerlink" title="2.11 最近点对问题"></a>2.11 最近点对问题</h2><h2 id="2-12-2-14-LeetCode-2-15-Cracking-2-16-2-17-LeetCode"><a href="#2-12-2-14-LeetCode-2-15-Cracking-2-16-2-17-LeetCode" class="headerlink" title="2.12-2.14 LeetCode 2.15 Cracking 2.16 2.17 LeetCode"></a>2.12-2.14 LeetCode 2.15 Cracking 2.16 2.17 LeetCode</h2><h2 id="2-18-数组分割"><a href="#2-18-数组分割" class="headerlink" title="2.18 数组分割"></a>2.18 数组分割</h2><h2 id="2-19-LeetCode"><a href="#2-19-LeetCode" class="headerlink" title="2.19 LeetCode"></a>2.19 LeetCode</h2><h2 id="3-1-有时间可以尝试写一下"><a href="#3-1-有时间可以尝试写一下" class="headerlink" title="3.1 有时间可以尝试写一下"></a>3.1 有时间可以尝试写一下</h2><h2 id="3-2-电话号码对应英文单词"><a href="#3-2-电话号码对应英文单词" class="headerlink" title="3.2 电话号码对应英文单词"></a>3.2 电话号码对应英文单词</h2><p>递归写法</p>
<h2 id="3-3-Edit-Distance"><a href="#3-3-Edit-Distance" class="headerlink" title="3.3 Edit Distance"></a>3.3 Edit Distance</h2><h2 id="3-4-删除链表节点"><a href="#3-4-删除链表节点" class="headerlink" title="3.4 删除链表节点"></a>3.4 删除链表节点</h2><h2 id="3-5-最短摘要的生成"><a href="#3-5-最短摘要的生成" class="headerlink" title="3.5 最短摘要的生成"></a>3.5 最短摘要的生成</h2><p>问题转化为，在一个单词词组中，找出包含所有给定单词的最短区间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">abstract</span><span class="params">(vector&lt;string&gt; article, unordered_set&lt;string&gt; keywords)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, range = INT_MAX;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; indecies;</span><br><span class="line">    unordered_set&lt;string&gt; having;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">while</span> (end &lt; article.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; article.<span class="built_in">size</span>() &amp;&amp; !<span class="built_in">isContain</span>(keywords, having)) &#123;</span><br><span class="line">            indecies[articel[end]] = end;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isContain</span>(keywords, having)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end - start + <span class="number">1</span> &lt; range) &#123;</span><br><span class="line">                range = end - start + <span class="number">1</span>;</span><br><span class="line">                result.first = start;</span><br><span class="line">                result.second = end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (indecies[aritcle[start]] == start)</span><br><span class="line">                having.erase[article[start]];</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-判断两个链表是否相交"><a href="#3-6-判断两个链表是否相交" class="headerlink" title="3.6 判断两个链表是否相交"></a>3.6 判断两个链表是否相交</h2><p>如果链表中有环呢？</p>
<h2 id="3-7-队列中取最大值"><a href="#3-7-队列中取最大值" class="headerlink" title="3.7 队列中取最大值"></a>3.7 队列中取最大值</h2><p>使用连个minstack模拟队列</p>
<h2 id="3-8-二叉树中两个节点之间的最远距离"><a href="#3-8-二叉树中两个节点之间的最远距离" class="headerlink" title="3.8 二叉树中两个节点之间的最远距离"></a>3.8 二叉树中两个节点之间的最远距离</h2><p>显然，对一个根节点，最远距离有两种情况：</p>
<ol>
<li>左子树或者右子树中的最远距离</li>
<li>左子树最长路径＋有子树最长路径+1</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> max_distance;</span><br><span class="line">    <span class="type">int</span> max_depth;</span><br><span class="line">&#125; <span class="type">result_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get max distance of two nodes in a tree</span></span><br><span class="line"><span class="type">result_t</span> <span class="title function_">get_max</span><span class="params">(<span class="type">tree_node_t</span>* root)</span> &#123;</span><br><span class="line">    <span class="type">result_t</span> result;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        result.max_distance = <span class="number">0</span>;</span><br><span class="line">        result.max_depth = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">result_t</span> left = get_max(root-&gt;left);</span><br><span class="line">    <span class="type">result_t</span> right = get_max(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    result.max_depth = max(left.max_depth, right.max_depth) + <span class="number">1</span>;</span><br><span class="line">    result.max_distance = max(max(left.max_distance, right.max_distance), left.max_depth + right.max_depth + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于递归问题，书上的心得：</p>
<ol>
<li>在递归的实现中，往往假设后续的调用已经完成，在此基础上，才能实现递归的逻辑。</li>
<li>分析清楚递归体的逻辑。</li>
<li>考虑清楚递归退出的边界条件，也就是return的地方。</li>
</ol>
<h2 id="3-9-重建二叉树"><a href="#3-9-重建二叉树" class="headerlink" title="3.9 重建二叉树"></a>3.9 重建二叉树</h2><p>拓展问题，如何判断前序遍历和中序遍历是合理的？</p>
<p>测试用例：<br>非完全二叉树，退化的二叉树，满二叉树，普通二叉树，空树。。。</p>
<h2 id="3-10-层序遍历"><a href="#3-10-层序遍历" class="headerlink" title="3.10 层序遍历"></a>3.10 层序遍历</h2><p>注意把LeetCode上的ZigZag层序都看一遍。</p>
<p>递归的遍历需要先计算level</p>
<h2 id="3-11-注意问题"><a href="#3-11-注意问题" class="headerlink" title="3.11 注意问题"></a>3.11 注意问题</h2><p>对于询问知识点，要答得<em>正确</em>，<em>有条理</em>。最后写出来的程序已定要是<em>没有严重错误</em>，<em>完整</em>，并尝试用一些测试用例。</p>
<h2 id="4-1-金刚"><a href="#4-1-金刚" class="headerlink" title="4.1 金刚"></a>4.1 金刚</h2><p>询问李博士</p>
<h2 id="4-2-瓷砖覆盖地板"><a href="#4-2-瓷砖覆盖地板" class="headerlink" title="4.2 瓷砖覆盖地板"></a>4.2 瓷砖覆盖地板</h2><p>斐波那契额数列</p>
<p>1x2覆盖8x8？从小到大，先找出2x2有多少种，再找出4x4有多少种，再找出8x8有多少种。还有考虑好多种，注意不要有重复<br>pxq覆盖mxn？</p>
<h2 id="4-3-Catalan数"><a href="#4-3-Catalan数" class="headerlink" title="4.3  Catalan数"></a>4.3  Catalan数</h2><h2 id="4-4-点是否在三角形内部"><a href="#4-4-点是否在三角形内部" class="headerlink" title="4.4 点是否在三角形内部"></a>4.4 点是否在三角形内部</h2><p>给定 ABC，逆时针顺序，判断 D 是否在 ABC 内部</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 利用面积，如果 D 和 ABC 分别构成的三角形的面积小于 ABC 的面积，那么 D 在三角形内部</span><br><span class="line">double area(Point A, Point B, Point, C) &#123;</span><br><span class="line">    double a, b, c;</span><br><span class="line">    b = distance(A, C);</span><br><span class="line">    a = distance(B, C);</span><br><span class="line">    c = distance(A, B);</span><br><span class="line"></span><br><span class="line">    double p = (a + b + c) / 2;</span><br><span class="line">    return sqrt((p-a) * (p-b) * (p-c) * p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isInTriangle(A, B, C, D) &#123;</span><br><span class="line">    return area(A, B, D) + area(A, C, D) + area(B, C, D) &lt;= area(A, B, C);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 根据角度考虑，如果两个向量叉积为正，那么 P3 在P1P2的左边，如果一个点同时在 AB，BC，CA 的左边</span><br><span class="line">double cross(Point A, Point B, Point X) &#123;</span><br><span class="line">    return (B.x - A.x) * (X.y - A.y) - (X.x - A.x) * (B.y - A.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isInTriangle(A, B, C, D) &#123;</span><br><span class="line">    return cross(A, B, D) &gt;= 0 &amp;&amp; cross(B, C, D) &gt;= 0 &amp;&amp; cross(C, A, D) &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-磁带文件存储优化"><a href="#4-5-磁带文件存储优化" class="headerlink" title="4.5 磁带文件存储优化"></a>4.5 磁带文件存储优化</h2><p>只考虑长度，按照文件长度由短到长存放。<br>只考虑访问频率，按照访问频率由高到低存放。<br>综合考虑，按照频率&#x2F;长度由高到低</p>
<h2 id="4-6-桶中取黑白球"><a href="#4-6-桶中取黑白球" class="headerlink" title="4.6 桶中取黑白球"></a>4.6 桶中取黑白球</h2><p>相当于使用 XOR，可以解任意问题</p>
<h2 id="4-7-蚂蚁爬杆"><a href="#4-7-蚂蚁爬杆" class="headerlink" title="4.7 蚂蚁爬杆"></a>4.7 蚂蚁爬杆</h2><p>相当于穿越</p>
<h2 id="4-8-三角形测试用例"><a href="#4-8-三角形测试用例" class="headerlink" title="4.8 三角形测试用例"></a>4.8 三角形测试用例</h2><p><code>int isTriangle(int a, int b, int c);</code></p>
<ol>
<li>用一个字节编码各种情况。</li>
</ol>
<p>用不同的位表示不同的结果，注意要正交</p>
<ol start="2">
<li><p>测试用例</p>
<ol>
<li><p>合法输入，各种三角形的形状，以及不是三角形的，还需要考虑交换不同边的顺序；</p>
</li>
<li><p>非法输入，负数，0，类型错误等等；</p>
</li>
<li><p>边界值，一般程序可能在<code>&lt; &lt;= &gt; &gt;=</code>上犯错误；</p>
</li>
<li><p>很大的数，很小的数，等等。</p>
</li>
</ol>
</li>
</ol>
<p>一般需要给出15-20个用例</p>
<h2 id="4-10-数字哑谜"><a href="#4-10-数字哑谜" class="headerlink" title="4.10 数字哑谜"></a>4.10 数字哑谜</h2><p>列出方程，使用深度优先搜索，注意剪枝</p>
<h2 id="4-11-扫雷游戏的概率"><a href="#4-11-扫雷游戏的概率" class="headerlink" title="4.11 扫雷游戏的概率"></a>4.11 扫雷游戏的概率</h2><br>
<br>
<br>

<h1 id="二、C-x2F-C-基本算法考点"><a href="#二、C-x2F-C-基本算法考点" class="headerlink" title="二、C&#x2F;C++基本算法考点"></a>二、C&#x2F;C++基本算法考点</h1><h2 id="1-1-确定一个字符串中所有数字是否完全不同"><a href="#1-1-确定一个字符串中所有数字是否完全不同" class="headerlink" title="1.1 确定一个字符串中所有数字是否完全不同"></a>1.1 确定一个字符串中所有数字是否完全不同</h2><p>首先应该询问面试官字符集的大小，是ASCII还是Unicode还是GBK，对于ASCII和GBK，<br>因为字符集大小有限，而且都不太大，可以使用一个数组统计，而对于Unicode，<br>显然只能使用Hash统计</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isUniqueChars</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">256</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">charSet</span><span class="params">(<span class="number">256</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">        <span class="keyword">if</span> (charSet[s])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            charSet[c] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：还可以使用位向量提高效率，但是C++的vector<bool>本身就是特质化的。</bool></p>
<h2 id="1-2-实现reverse-char-s"><a href="#1-2-实现reverse-char-s" class="headerlink" title="1.2 实现reverse(char* s)"></a>1.2 实现reverse(char* s)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">char</span>* end = s;</span><br><span class="line">    <span class="keyword">while</span> (*end++) ;</span><br><span class="line">    end--; <span class="comment">// back one</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (s &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> t = *s;</span><br><span class="line">        *s++ = *end;</span><br><span class="line">        *end-- = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-判断两个词是否是变位词-Anagram"><a href="#1-3-判断两个词是否是变位词-Anagram" class="headerlink" title="1.3 判断两个词是否是变位词(Anagram)"></a>1.3 判断两个词是否是变位词(Anagram)</h2><h2 id="1-4-编写一个方法，将字符串中的空格全部替换为-20，假设字符串结尾有足够空间"><a href="#1-4-编写一个方法，将字符串中的空格全部替换为-20，假设字符串结尾有足够空间" class="headerlink" title="1.4 编写一个方法，将字符串中的空格全部替换为%20，假设字符串结尾有足够空间"></a>1.4 编写一个方法，将字符串中的空格全部替换为<code>%20</code>，假设字符串结尾有足够空间</h2><p>对于数组操作的好多题目，尝试从尾部做起一下子就简单多了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">replaceSpaces</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> spaceCount = <span class="number">0</span>, newLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(s[i]))</span><br><span class="line">            newLength++;</span><br><span class="line"></span><br><span class="line">    newLength = len + spaceCount * <span class="number">2</span>;</span><br><span class="line">    s[newLength] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(s[i])) &#123;</span><br><span class="line">            s[--newLength] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            s[--newLength] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            s[--newLength] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s[--newLength] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-压缩字符串-aabcccccaaa-gt-a2b1c5a3如果压缩后变短，返回压缩后的字符串"><a href="#1-5-压缩字符串-aabcccccaaa-gt-a2b1c5a3如果压缩后变短，返回压缩后的字符串" class="headerlink" title="1.5 压缩字符串 aabcccccaaa -&gt; a2b1c5a3如果压缩后变短，返回压缩后的字符串"></a>1.5 压缩字符串 <code>aabcccccaaa -&gt; a2b1c5a3</code>如果压缩后变短，返回压缩后的字符串</h2><p>首先要计算出新的长度，然后比较是否变短，如果变短，则执行压缩，否则返回</p>
<h2 id="1-6-给定一幅由N＊N矩阵表示的图像，顺时针旋转90度"><a href="#1-6-给定一幅由N＊N矩阵表示的图像，顺时针旋转90度" class="headerlink" title="1.6 给定一幅由N＊N矩阵表示的图像，顺时针旋转90度"></a>1.6 给定一幅由N＊N矩阵表示的图像，顺时针旋转90度</h2><h2 id="1-7-若m＊n矩阵中某个元素为0，就把这一行和这一列都清零"><a href="#1-7-若m＊n矩阵中某个元素为0，就把这一行和这一列都清零" class="headerlink" title="1.7 若m＊n矩阵中某个元素为0，就把这一行和这一列都清零"></a>1.7 若m＊n矩阵中某个元素为0，就把这一行和这一列都清零</h2><p>LeetCode 73 注意同样可以使用位向量提高效率</p>
<h2 id="1-8-给定方法isSubstring-，判断s1是不是可以由s2旋转组成"><a href="#1-8-给定方法isSubstring-，判断s1是不是可以由s2旋转组成" class="headerlink" title="1.8 给定方法isSubstring()，判断s1是不是可以由s2旋转组成"></a>1.8 给定方法isSubstring()，判断s1是不是可以由s2旋转组成</h2><p>假设s1 &#x3D; xy, s2 &#x3D; yx，yx一定是xyxy的字串，而且是中间部分。注意先判断长度，提高效率</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isRotation</span><span class="params">(string&amp; s1, string&amp; s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.<span class="built_in">size</span>() != s2.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    string s1s1 = s1 + s1;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isSubstring</span>(s1s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-移除未排序列表中的重复节点"><a href="#2-1-移除未排序列表中的重复节点" class="headerlink" title="2.1 移除未排序列表中的重复节点"></a>2.1 移除未排序列表中的重复节点</h2><p>因为是无序的，所以我们还是需要记录重复节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显然第一个节点是不可能被移除的，所以不用返回新的头部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">    ListNode dummy, *p = dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vals.<span class="built_in">find</span>(p-&gt;next-&gt;val) != vals.<span class="built_in">end</span>())</span><br><span class="line">            ListNode* next = p-&gt;next;</span><br><span class="line">            p-&gt;next = next-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vals.<span class="built_in">insert</span>(p-&gt;next-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不允许使用额外空间，那么这个功能至少需要O(N^2)实现</p>
<h2 id="2-2-实现一个算法，找出链表中倒数第K个元素"><a href="#2-2-实现一个算法，找出链表中倒数第K个元素" class="headerlink" title="2.2 实现一个算法，找出链表中倒数第K个元素"></a>2.2 实现一个算法，找出链表中倒数第K个元素</h2><h2 id="2-3-删除单向链表中的某个节点，假设你只有访问该节点的权限"><a href="#2-3-删除单向链表中的某个节点，假设你只有访问该节点的权限" class="headerlink" title="2.3 删除单向链表中的某个节点，假设你只有访问该节点的权限"></a>2.3 删除单向链表中的某个节点，假设你只有访问该节点的权限</h2><h2 id="2-4-以给定的值x分割列表，使得小于x的元素都排在x的前面"><a href="#2-4-以给定的值x分割列表，使得小于x的元素都排在x的前面" class="headerlink" title="2.4 以给定的值x分割列表，使得小于x的元素都排在x的前面"></a>2.4 以给定的值x分割列表，使得小于x的元素都排在x的前面</h2><p>LeetCode 83</p>
<h2 id="2-5-给定一个链表，每个链表节点存放一位数字，并且是反向存放的，求两个链表的和"><a href="#2-5-给定一个链表，每个链表节点存放一位数字，并且是反向存放的，求两个链表的和" class="headerlink" title="2.5 给定一个链表，每个链表节点存放一位数字，并且是反向存放的，求两个链表的和"></a>2.5 给定一个链表，每个链表节点存放一位数字，并且是反向存放的，求两个链表的和</h2><p>LeetCode 2</p>
<p>如果是正向存放的呢？</p>
<p>先求出两个列表的长度，然后用零填充一个较短的链表，然后在从前往后相加。</p>
<h2 id="2-6-给定一个有环链表，找到环的开头"><a href="#2-6-给定一个有环链表，找到环的开头" class="headerlink" title="2.6 给定一个有环链表，找到环的开头"></a>2.6 给定一个有环链表，找到环的开头</h2><p>LeetCode 141 142</p>
<h2 id="2-7-判断链表是否是回文-Palindrome"><a href="#2-7-判断链表是否是回文-Palindrome" class="headerlink" title="2.7 判断链表是否是回文(Palindrome)"></a>2.7 判断链表是否是回文(Palindrome)</h2><p>LeetCode 234</p>
<h2 id="3-1-如何用一个数组实现3个栈"><a href="#3-1-如何用一个数组实现3个栈" class="headerlink" title="3.1 如何用一个数组实现3个栈"></a>3.1 如何用一个数组实现3个栈</h2><p>如果是实现两个堆栈，可以把两头作为栈底，向中间生长。</p>
<p>解法1: 固定分割，显然这样是不能让面试官满意的。。</p>
<p>解法2: 弹性分割，并把数组看成是环状的！</p>
<h2 id="3-2-设计一个栈，支持min方法，返回栈中的最小值"><a href="#3-2-设计一个栈，支持min方法，返回栈中的最小值" class="headerlink" title="3.2 设计一个栈，支持min方法，返回栈中的最小值"></a>3.2 设计一个栈，支持min方法，返回栈中的最小值</h2><p>LeetCode 155</p>
<h2 id="3-3-实现SetOfStacks，由多个栈组成"><a href="#3-3-实现SetOfStacks，由多个栈组成" class="headerlink" title="3.3 实现SetOfStacks，由多个栈组成"></a>3.3 实现SetOfStacks，由多个栈组成</h2><p>这实际上是一道OOD(面向对象设计)的题目</p>
<h2 id="3-4-汉诺塔"><a href="#3-4-汉诺塔" class="headerlink" title="3.4 汉诺塔"></a>3.4 汉诺塔</h2><p>经典问题了，考虑 n＝2的时候，把上面1块放到中间，然后把下面一块移动完成。那么对于n，我们把n-1块移到中间即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void moveDisks(int n, tower_t origin, tower_t dest, tower_t buffer) &#123;</span><br><span class="line">    if (n &lt;= 0) return;</span><br><span class="line"></span><br><span class="line">    moveDisks(n-1, origin, buffer, dest); // 先把上面的n-1块放到中间</span><br><span class="line">    moveBottom(origin, dest) // 把最底下的盘子直接放过去</span><br><span class="line">    moveDisks(n-1, buffer, dest, origin) // 把中间的再放到最后</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-使用两个栈模拟一个队列"><a href="#3-5-使用两个栈模拟一个队列" class="headerlink" title="3.5 使用两个栈模拟一个队列"></a>3.5 使用两个栈模拟一个队列</h2><h2 id="3-6-对栈进行排序，额外的数据只能使用栈"><a href="#3-6-对栈进行排序，额外的数据只能使用栈" class="headerlink" title="3.6 对栈进行排序，额外的数据只能使用栈"></a>3.6 对栈进行排序，额外的数据只能使用栈</h2><p>使用简单插入排序，在一个新的栈中保存排序好的数据，从unsorted中弹出以后，不断弹出sorted为新元素找到正确位置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; <span class="title function_">sortStack</span><span class="params">(<span class="type">const</span> <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;&amp; unsorted)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; sorted;</span><br><span class="line">    <span class="keyword">while</span> (!unsorted.empty()) &#123;</span><br><span class="line">        <span class="type">int</span> temp = unsorted.top(); <span class="comment">// 待插入的新元素</span></span><br><span class="line">        unsorted.pop();</span><br><span class="line">        <span class="keyword">while</span> (!sorted.empty() &amp;&amp; sorted.top() &gt; temp) &#123; <span class="comment">// 不断弹出，找到合适位置</span></span><br><span class="line">            <span class="type">int</span> big = sorted.top(); sorted.pop();</span><br><span class="line">            unsorted.push(big);</span><br><span class="line">        &#125;</span><br><span class="line">        sorted.push(temp); <span class="comment">// 插入新元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sorted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="4-1-检查二叉树是否平衡-任意两个节点之间的高度差不超过1"><a href="#4-1-检查二叉树是否平衡-任意两个节点之间的高度差不超过1" class="headerlink" title="4.1 检查二叉树是否平衡: 任意两个节点之间的高度差不超过1"></a>4.1 检查二叉树是否平衡: 任意两个节点之间的高度差不超过1</h2><h2 id="4-2-给定一个有向图，找出两个节点之间是否存在一条路径"><a href="#4-2-给定一个有向图，找出两个节点之间是否存在一条路径" class="headerlink" title="4.2 给定一个有向图，找出两个节点之间是否存在一条路径"></a>4.2 给定一个有向图，找出两个节点之间是否存在一条路径</h2><blockquote>
<p>碰到这类问题，有必要和面试官探讨一下DFS和BFS之间的利弊，例如，DFS实现起来比较简单，只需要简单的递归即可。BFS适合用来查找最短路径。<br>而DFS在访问临近借点之前可能会深度便利其中一个临近节点</p>
</blockquote>
<p>🌲的遍历一定要注意visited数组或者集合，因为树中可能有几个节点指向同一个节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(Graph* graph, Node* start, Node* end)</span> </span>&#123;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    unordered_set&lt;Node*&gt; visited;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> node = q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> adj : q.<span class="built_in">adjs</span>())</span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">find</span>(adj) == visited.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">if</span> (adj == end)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    q.<span class="built_in">push</span>(adj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-给定一个有序数组，元素各不相同且按升序排列，创建一颗高度最小的二叉查找树"><a href="#4-3-给定一个有序数组，元素各不相同且按升序排列，创建一颗高度最小的二叉查找树" class="headerlink" title="4.3 给定一个有序数组，元素各不相同且按升序排列，创建一颗高度最小的二叉查找树"></a>4.3 给定一个有序数组，元素各不相同且按升序排列，创建一颗高度最小的二叉查找树</h2><p>LeetCode 108</p>
<h2 id="4-4-给定一棵二叉树，创建层序访问的链表"><a href="#4-4-给定一棵二叉树，创建层序访问的链表" class="headerlink" title="4.4 给定一棵二叉树，创建层序访问的链表"></a>4.4 给定一棵二叉树，创建层序访问的链表</h2><p>LeetCode 102</p>
<h2 id="4-5-检查一棵二叉树是否为二叉查找树"><a href="#4-5-检查一棵二叉树是否为二叉查找树" class="headerlink" title="4.5 检查一棵二叉树是否为二叉查找树"></a>4.5 检查一棵二叉树是否为二叉查找树</h2><p>LeetCode 98</p>
<h2 id="4-6-找到二叉查找树指定节点的下一个节点-中序后继-，假设每个节点都有指向父节点的指针"><a href="#4-6-找到二叉查找树指定节点的下一个节点-中序后继-，假设每个节点都有指向父节点的指针" class="headerlink" title="4.6 找到二叉查找树指定节点的下一个节点(中序后继)，假设每个节点都有指向父节点的指针"></a>4.6 找到二叉查找树指定节点的下一个节点(中序后继)，假设每个节点都有指向父节点的指针</h2><p>按照中序遍历，左子树，当前节点，右子树，显然下一个节点应该在右边。也就是右子树中最左边的节点。<br>考虑没有右子树的情况，如果当前节点是左子节点，下一个节点应该是父节点。如果是右节点，我们继续向上，如果到达了root，显然没有更多节点了。</p>
<p>对于树这种可以分情况的最好先把各种情况想好了，在写代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">inorderSucc</span><span class="params">(TreeNode* n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (n-&gt;right) &#123;</span><br><span class="line">        TreeNode* right = n-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (right-&gt;left)</span><br><span class="line">            right = right-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode* q = n, * parent = q.parent;</span><br><span class="line">        <span class="keyword">while</span> (parent &amp;&amp; parent-&gt;left != q) &#123; <span class="comment">// 找到当前节点可以作为左子节点的父节点</span></span><br><span class="line">            q = parent;</span><br><span class="line">            parent = parent-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-7-查找二叉树的公共祖先"><a href="#4-7-查找二叉树的公共祖先" class="headerlink" title="4.7 查找二叉树的公共祖先"></a>4.7 查找二叉树的公共祖先</h2><p>LeetCode 236</p>
<h2 id="4-8-又两棵非常大的二叉树：T1-有几百万个节点，T2，有几百个节点。判断T2是否是T1的子树"><a href="#4-8-又两棵非常大的二叉树：T1-有几百万个节点，T2，有几百个节点。判断T2是否是T1的子树" class="headerlink" title="4.8 又两棵非常大的二叉树：T1 有几百万个节点，T2，有几百个节点。判断T2是否是T1的子树"></a>4.8 又两棵非常大的二叉树：T1 有几百万个节点，T2，有几百个节点。判断T2是否是T1的子树</h2><p>这道题并没有标准解法。值得和面试官探讨，详见树上的讲解（161页）。</p>
<h2 id="4-9-打印节点数值总和为给定值的路径，路径可以从任意节点开始，任意节点结束"><a href="#4-9-打印节点数值总和为给定值的路径，路径可以从任意节点开始，任意节点结束" class="headerlink" title="4.9 打印节点数值总和为给定值的路径，路径可以从任意节点开始，任意节点结束"></a>4.9 打印节点数值总和为给定值的路径，路径可以从任意节点开始，任意节点结束</h2><p>对于一个没有见过的问题，可以先简化，然后在推广。假设路径必须从root开始，那很简单。<br>如果路径可以从任意节点开始，那么我们需要向上检查是否得到了相符的总和，而不能假定root是起点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">findSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="type">int</span> depth = depth(root);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">path</span><span class="params">(depth)</span>;</span><br><span class="line">    findSum(root, sum, path, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">depth</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> max(depth(root-&gt;left), depth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">findSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    path[level] = root-&gt;val;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = level, t= <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        t += path[i];</span><br><span class="line">        <span class="keyword">if</span> (t == sum)</span><br><span class="line">            print(path, i ,level); <span class="comment">// printing out path from i to level</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    findSum(root-&gt;left, sum, path, level + <span class="number">1</span>);</span><br><span class="line">    findSum(root-&gt;right, sum, path, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-1-给定一个数n，和另一个数字m，然后给定区间-i-j-，区间保证可以大于m的二进制长度，把m的二进制表示插入到n的区间内"><a href="#5-1-给定一个数n，和另一个数字m，然后给定区间-i-j-，区间保证可以大于m的二进制长度，把m的二进制表示插入到n的区间内" class="headerlink" title="5.1 给定一个数n，和另一个数字m，然后给定区间(i, j)，区间保证可以大于m的二进制长度，把m的二进制表示插入到n的区间内"></a>5.1 给定一个数n，和另一个数字m，然后给定区间(i, j)，区间保证可以大于m的二进制长度，把m的二进制表示插入到n的区间内</h2><p>示例：n&#x3D;100&#x2F;000&#x2F;00, m &#x3D; 101, i &#x3D; 2, j &#x3D; 4 -&gt; 100&#x2F;101&#x2F;00</p>
<ol>
<li>把n中对应位置清零</li>
<li>把m移动到对应的位置</li>
<li>合并</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left_mask = ~<span class="number">0</span> &lt;&lt; (j+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> right_mask = (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span></span><br><span class="line">    <span class="type">int</span> mask = left_mask | right_mask;</span><br><span class="line"></span><br><span class="line">    n &amp;= mask;</span><br><span class="line">    m &lt;&lt;= i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n | m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-给定一个0和1之间的实数，打印他的二进制表示，如果32位以内无法表示，打印error"><a href="#5-2-给定一个0和1之间的实数，打印他的二进制表示，如果32位以内无法表示，打印error" class="headerlink" title="5.2 给定一个0和1之间的实数，打印他的二进制表示，如果32位以内无法表示，打印error"></a>5.2 给定一个0和1之间的实数，打印他的二进制表示，如果32位以内无法表示，打印error</h2><p>我们知道 (0.101)2 &#x3D; 1 * 2^-1 + 0 * 2^-2 + 1 * 2^-3，我们只要让这个数字不断的乘2，然后看它是否大于1，然后就可以得到第一位是不是1了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">printBinary</span><span class="params">(<span class="type">double</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= <span class="number">1</span> || num &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line"></span><br><span class="line">    string result;</span><br><span class="line">    result += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() &gt;= <span class="number">32</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">        num *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            result += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">            num -= <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-给定一个正整数，找出和其二进制表示中一的数字相同的数字，并且最接近，一共两个"><a href="#5-3-给定一个正整数，找出和其二进制表示中一的数字相同的数字，并且最接近，一共两个" class="headerlink" title="5.3 给定一个正整数，找出和其二进制表示中一的数字相同的数字，并且最接近，一共两个"></a>5.3 给定一个正整数，找出和其二进制表示中一的数字相同的数字，并且最接近，一共两个</h2><p>我们需要把某个0反转为1，把某个1反转为0。<br>0 -&gt; 1在1-&gt;0 左边，数字变大，在右边数字变小。<br>如果想变大，反转的0需要在1的左边。</p>
<p>把p位置1；把0到p之间请0；在添加ending1 - 1个1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = n, ending0 = <span class="number">0</span>, ending1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c &amp; <span class="number">1</span> == <span class="number">0</span>) &amp;&amp; c != <span class="number">0</span>) &#123;</span><br><span class="line">        ending0++;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (c &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        ending1++;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n + (<span class="number">1</span> &lt;&lt; ending0) + (<span class="number">1</span> &lt;&lt; (ending1 - <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把位p值0；把位p右边的位值1，再把0到ending0-1置0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getPrev</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = n, ending0 = <span class="number">0</span>, ending1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (c &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        ending1++;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; c != <span class="number">0</span>) &#123;</span><br><span class="line">        ending0++;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - (<span class="number">1</span> &lt;&lt; ending1) - (<span class="number">1</span> &lt;&lt; (ending0 - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-解释n-amp-n-10-0"><a href="#5-4-解释n-amp-n-10-0" class="headerlink" title="5.4 解释n &amp; (n-10) == 0"></a>5.4 解释<code>n &amp; (n-10) == 0</code></h2><p>LeetCode 231</p>
<h2 id="5-5-A和B之间有多少位不相同-x2F-需要改变多少位，才能把A变成B"><a href="#5-5-A和B之间有多少位不相同-x2F-需要改变多少位，才能把A变成B" class="headerlink" title="5.5 A和B之间有多少位不相同&#x2F;需要改变多少位，才能把A变成B"></a>5.5 A和B之间有多少位不相同&#x2F;需要改变多少位，才能把A变成B</h2><p>使用XOR找出不同的位，然后统计1的个位数。需要注意的是不同的题目</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitSwapRequired</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> diff = a ^ b, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (diff) &#123;</span><br><span class="line">        diff &amp;= diff - <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-6-交换一个整数的奇数位和偶数位"><a href="#5-6-交换一个整数的奇数位和偶数位" class="headerlink" title="5.6 交换一个整数的奇数位和偶数位"></a>5.6 交换一个整数的奇数位和偶数位</h2><p>这道题很有趣，选取特殊的掩码即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 考虑32bit int</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">swapBits</span><span class="params">(<span class="type">int32_t</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> odd_bits = x &amp; <span class="number">0xAAAAAAAA</span>; <span class="comment">// 0xAA as 10101010</span></span><br><span class="line">    <span class="type">int32_t</span> even_bits = x &amp; <span class="number">0x55555555</span>; <span class="comment">// 0x55 as 01010101</span></span><br><span class="line">    <span class="keyword">return</span> (odd_bits &gt;&gt; <span class="number">1</span>) | (even_bits &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-8-单色屏幕存贮在一维字节数组中，每个字节存储八个像素，屏幕宽度为w-px，绘制从x1到达x2的水平线"><a href="#5-8-单色屏幕存贮在一维字节数组中，每个字节存储八个像素，屏幕宽度为w-px，绘制从x1到达x2的水平线" class="headerlink" title="5.8 单色屏幕存贮在一维字节数组中，每个字节存储八个像素，屏幕宽度为w px，绘制从x1到达x2的水平线"></a>5.8 单色屏幕存贮在一维字节数组中，每个字节存储八个像素，屏幕宽度为w px，绘制从x1到达x2的水平线</h2><p>显然可以逐bit设定，然而这样是拿不到offer的。更好的做法是逐字节设定。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">drawHorizentalLine</span><span class="params">(<span class="type">uint8_t</span> * screen, <span class="type">int</span> width, <span class="type">int</span> x1, <span class="type">int</span> x2, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start_offset = x1 % <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> start_full_byte = x1 / <span class="number">8</span>; <span class="comment">// x1 所在字节</span></span><br><span class="line">    <span class="keyword">if</span> (start_offset != <span class="number">0</span>)</span><br><span class="line">        start_full_byte++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> end_offset = x2 % <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> end_full_byte = x2 / <span class="number">8</span>; <span class="comment">// x2 所在字节</span></span><br><span class="line">    <span class="keyword">if</span> (end_offset != <span class="number">7</span>)</span><br><span class="line">        end_full_byte--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐字节设定</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start_full_byte; i &lt;= end_full_byte; i++)</span><br><span class="line">        screen[width / <span class="number">8</span> * y + i] = (<span class="type">uint8_t</span>)<span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> start_mask = (<span class="type">uint8_t</span>) (<span class="number">0xff</span> &gt;&gt; start_offset);</span><br><span class="line">    <span class="type">uint8_t</span> end_mast = (<span class="type">uint8_t</span>) ~(<span class="number">0xff</span> &gt;&gt; end_offset + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((x1 / <span class="number">8</span>) == (x2 / <span class="number">8</span>)) &#123;</span><br><span class="line">        <span class="type">uint8_t</span> mask = (<span class="type">uint8_t</span>)(start_mask &amp; end_mask);</span><br><span class="line">        screen[(width / <span class="number">8</span>) * y + x1 / <span class="number">8</span>] |= mask;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start_offset != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> byte_number = (width / <span class="number">8</span>) * y + start_full_byte - <span class="number">1</span>;</span><br><span class="line">            screen[byte_number] |= start_mask;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end_offset != <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="type">int</span> byte_number = (width / <span class="number">8</span>) * y + end_full_byte + <span class="number">1</span>;</span><br><span class="line">            screen[byte_number] |= end_mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6-1-给定直角坐标系的两条线，确定他们会不会相交"><a href="#6-1-给定直角坐标系的两条线，确定他们会不会相交" class="headerlink" title="6.1 给定直角坐标系的两条线，确定他们会不会相交"></a>6.1 给定直角坐标系的两条线，确定他们会不会相交</h2><p>我们知道在二维平面上两条线的关系不外乎：平行，相交，重合。问题是两条线重合算不算相交呢，需要问清楚。<br>对于两条线如何表示，这又是面向对象设计的问题，需要讨论。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> EPSILON;</span><br><span class="line">    <span class="type">double</span> m_slope; <span class="comment">// 斜率</span></span><br><span class="line">    <span class="type">double</span> m_y_intercept; <span class="comment">// y轴交点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Line</span>(<span class="type">double</span> s, <span class="type">double</span> y): <span class="built_in">m_slope</span>(s), <span class="built_in">m_y_intercept</span>(y) &#123;&#125;;</span><br><span class="line">    <span class="comment">// 重合视作相交</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">intersect</span><span class="params">(<span class="type">const</span> Line&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="built_in">slope</span>() - other.<span class="built_in">slope</span>()) &gt; EPSILON || <span class="comment">// 斜率不同</span></span><br><span class="line">            <span class="built_in">abs</span>(<span class="built_in">y_intercept</span>() - other.<span class="built_in">y_intercept</span>()) &lt; EPSILON; <span class="comment">// y轴交点相同</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">slope</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_slope;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">y_intercept</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_y_intercept;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Line::EPSILON = <span class="number">0.00001</span>;</span><br></pre></td></tr></table></figure>

<p>遇到这类问题，务必：</p>
<ol>
<li>多问，面试官可能故意模糊问题</li>
<li>仔细设计数据结构，权衡利弊，和面试官讨论</li>
<li>千万不要用＝＝判定浮点数</li>
</ol>
<h2 id="6-2-只使用加号实现减法和乘除法"><a href="#6-2-只使用加号实现减法和乘除法" class="headerlink" title="6.2 只使用加号实现减法和乘除法"></a>6.2 只使用加号实现减法和乘除法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">neg</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> d = a &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (a) &#123;</span><br><span class="line">        result += d;</span><br><span class="line">        a += d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; <span class="number">0</span> ? a : neg(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">minus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + neg(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sign = (a &gt; <span class="number">0</span>) == (b &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    a = <span class="built_in">abs</span>(a);</span><br><span class="line">    b = <span class="built_in">abs</span>(b);</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b--)</span><br><span class="line">        result += a;</span><br><span class="line">    <span class="keyword">return</span> sign == <span class="number">1</span> ? result : neg(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">devide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="comment">// see leetcode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-找出第k个丑数"><a href="#6-3-找出第k个丑数" class="headerlink" title="6.3 找出第k个丑数"></a>6.3 找出第k个丑数</h2><p>LeetCode 264</p>
<h2 id="7-1-小孩上楼梯，楼梯有n阶，小孩可以一次上1，2，3步，请问一共有多少种方法"><a href="#7-1-小孩上楼梯，楼梯有n阶，小孩可以一次上1，2，3步，请问一共有多少种方法" class="headerlink" title="7.1 小孩上楼梯，楼梯有n阶，小孩可以一次上1，2，3步，请问一共有多少种方法"></a>7.1 小孩上楼梯，楼梯有n阶，小孩可以一次上1，2，3步，请问一共有多少种方法</h2><p> 注意如果只能1或2就是斐波那契数列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countSteps</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> vector&lt;<span class="type">int</span>&gt; <span class="title">steps</span><span class="params">(<span class="number">1000</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span> &amp;&amp; steps[n] == <span class="number">1</span>)</span><br><span class="line">        steps[n] = <span class="built_in">countSteps</span>(n <span class="number">-1</span>) + <span class="built_in">countSteps</span>(n - <span class="number">2</span>) + <span class="built_in">countSteps</span>(n - <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> steps[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">countSteps</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n3 = <span class="number">1</span>; <span class="comment">// starts from n = 0</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">1</span>; <span class="comment">// starts from n = 1</span></span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">2</span>; <span class="comment">// starts from n = 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        steps = n3 + n2 + n1;</span><br><span class="line">        n3 = n2;</span><br><span class="line">        n2 = n1;</span><br><span class="line">        n1 = steps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-1-设计一种算法，机器人只能向右向下移动，从-0-0-移动到-x-y-有几种走法"><a href="#8-1-设计一种算法，机器人只能向右向下移动，从-0-0-移动到-x-y-有几种走法" class="headerlink" title="8.1 设计一种算法，机器人只能向右向下移动，从(0, 0)移动到(x, y)有几种走法"></a>8.1 设计一种算法，机器人只能向右向下移动，从(0, 0)移动到(x, y)有几种走法</h2><p>LeetCode 62 63</p>
<h2 id="9-1-在有序数组A-0…n-1-中存在A-i-x3D-x3D-i，找出该数字。如果存在重复值，又该如何做"><a href="#9-1-在有序数组A-0…n-1-中存在A-i-x3D-x3D-i，找出该数字。如果存在重复值，又该如何做" class="headerlink" title="9.1 在有序数组A[0…n-1]中存在A[i] &#x3D;&#x3D; i，找出该数字。如果存在重复值，又该如何做"></a>9.1 在有序数组A[0…n-1]中存在A[i] &#x3D;&#x3D; i，找出该数字。如果存在重复值，又该如何做</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">magic</span><span class="params">(<span class="type">int</span>* A, n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>; right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] == mid)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &lt; mid)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-2-返回一个集合的所有子集"><a href="#9-2-返回一个集合的所有子集" class="headerlink" title="9.2 返回一个集合的所有子集"></a>9.2 返回一个集合的所有子集</h2><p>LeetCode 78</p>
<h2 id="9-3-全排列"><a href="#9-3-全排列" class="headerlink" title="9.3 全排列"></a>9.3 全排列</h2><p>LeetCode</p>
<h2 id="9-4-生成n对括号的全部有效集合"><a href="#9-4-生成n对括号的全部有效集合" class="headerlink" title="9.4 生成n对括号的全部有效集合"></a>9.4 生成n对括号的全部有效集合</h2><p>LeetCode</p>
<h2 id="9-5-实现填充颜色功能"><a href="#9-5-实现填充颜色功能" class="headerlink" title="9.5 实现填充颜色功能"></a>9.5 实现填充颜色功能</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintFill</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; screen, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (screen[y][x] == color)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">paintFill</span>(screen, <span class="type">int</span> x, <span class="type">int</span> y, screen[y][x], <span class="type">int</span> color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintFill</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; screen, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> start, <span class="type">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= screen[<span class="number">0</span>].<span class="built_in">size</span>() || y &lt; <span class="number">0</span> || y &gt;= screen.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (screen[y][x] == start) &#123;</span><br><span class="line">        screen[y][x] == color;</span><br><span class="line">        <span class="built_in">paintFill</span>(screen, <span class="type">int</span> x<span class="number">-1</span>, <span class="type">int</span> y, start, color);</span><br><span class="line">        <span class="built_in">paintFill</span>(screen, x+<span class="number">1</span>, y, start, color);</span><br><span class="line">        <span class="built_in">paintFill</span>(screen, x, y+<span class="number">1</span>, start, color);</span><br><span class="line">        <span class="built_in">paintFill</span>(screen, x, y<span class="number">-1</span>, start, color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-6-给定数量不限的硬币，编写代码计算有几种表示方法"><a href="#9-6-给定数量不限的硬币，编写代码计算有几种表示方法" class="headerlink" title="9.6 给定数量不限的硬币，编写代码计算有几种表示方法"></a>9.6 给定数量不限的硬币，编写代码计算有几种表示方法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">makeChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; coins, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">solution</span><span class="params">(coins.size(), <span class="number">0</span>)</span></span><br><span class="line">    <span class="title function_">make</span><span class="params">(result, coins, solution, <span class="number">0</span>, target)</span>;</span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">make</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; coins, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; solution, <span class="type">int</span> start, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= <span class="number">0</span> || start &gt;= coins.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)</span><br><span class="line">            result.push_back(solution);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i *coins[start] &lt; target ; i++) &#123;</span><br><span class="line">        solution[start] = i;</span><br><span class="line">        make(result, coins, solution, start + <span class="number">1</span>, target - i * coins[start]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9-7-N-Queen问题"><a href="#9-7-N-Queen问题" class="headerlink" title="9.7 N-Queen问题"></a>9.7 N-Queen问题</h2><p>LeetCode</p>
<h2 id="9-8-给你一堆箱子，上面的箱子的长宽高要求小于下面的箱子，实现一个方法，搭出最高的箱子"><a href="#9-8-给你一堆箱子，上面的箱子的长宽高要求小于下面的箱子，实现一个方法，搭出最高的箱子" class="headerlink" title="9.8 给你一堆箱子，上面的箱子的长宽高要求小于下面的箱子，实现一个方法，搭出最高的箱子"></a>9.8 给你一堆箱子，上面的箱子的长宽高要求小于下面的箱子，实现一个方法，搭出最高的箱子</h2><h2 id="10-1-合并两个有序数组"><a href="#10-1-合并两个有序数组" class="headerlink" title="10.1 合并两个有序数组"></a>10.1 合并两个有序数组</h2><p>LeetCode 88</p>
<h2 id="11-1-对一个字符串数组排序，把变位词-Anagram-放在一起"><a href="#11-1-对一个字符串数组排序，把变位词-Anagram-放在一起" class="headerlink" title="11.1 对一个字符串数组排序，把变位词(Anagram)放在一起"></a>11.1 对一个字符串数组排序，把变位词(Anagram)放在一起</h2><p>LeetCode 49</p>
<h2 id="11-2-在已经被旋转过的排序数组中，查找元素"><a href="#11-2-在已经被旋转过的排序数组中，查找元素" class="headerlink" title="11.2 在已经被旋转过的排序数组中，查找元素"></a>11.2 在已经被旋转过的排序数组中，查找元素</h2><p>LeetCode 81</p>
<h2 id="11-3-有一个20GB的文件，每行一个字符串，如何排序"><a href="#11-3-有一个20GB的文件，每行一个字符串，如何排序" class="headerlink" title="11.3 有一个20GB的文件，每行一个字符串，如何排序"></a>11.3 有一个20GB的文件，每行一个字符串，如何排序</h2><p>20GB暗示无法放入内存中，把文件分块后，分别载入内存中，采用归并排序</p>
<h2 id="12-1-使用-C-写个方法，打印输入文件的最后-K-行"><a href="#12-1-使用-C-写个方法，打印输入文件的最后-K-行" class="headerlink" title="12.1 使用 C++ 写个方法，打印输入文件的最后 K 行"></a>12.1 使用 C++ 写个方法，打印输入文件的最后 K 行</h2><p>使用循环数组，容量设为 K，同时记录当前的最早元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printLastKLines</span><span class="params">(<span class="type">char</span>* filename)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> K = <span class="number">10</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">    string lines[K];</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (file.<span class="built_in">good</span>())</span><br><span class="line">        <span class="built_in">getline</span>(file, lines[size++ % K];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start = size &gt; K ? (size % K) : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">min</span>(K, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) </span><br><span class="line">        cout &lt;&lt; lines[(start + i) % K] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="12-2-编写malloc-aligned"><a href="#12-2-编写malloc-aligned" class="headerlink" title="12.2 编写malloc_aligned"></a>12.2 编写malloc_aligned</h2><h2 id="12-3-malloc2d函数，分配二维数组，返回int-可以通过a-i-j-访问，并且尽量少调用malloc"><a href="#12-3-malloc2d函数，分配二维数组，返回int-可以通过a-i-j-访问，并且尽量少调用malloc" class="headerlink" title="12.3 malloc2d函数，分配二维数组，返回int**可以通过a[i][j]访问，并且尽量少调用malloc"></a>12.3 malloc2d函数，分配二维数组，返回int**可以通过a[i][j]访问，并且尽量少调用malloc</h2><p>前面rows大小的区域用作存储指针，后面存储数据。</p>
<pre><code>hhh|ddddd|ddddd|ddddd
</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>** <span class="title function_">malloc2d</span><span class="params">(<span class="type">int</span> rows, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line">    <span class="type">int</span> header = rows * <span class="keyword">sizeof</span>(<span class="type">void</span>*);</span><br><span class="line">    <span class="type">void</span>** ptr = (<span class="type">void</span>**)<span class="built_in">malloc</span>(header + rows * cols);</span><br><span class="line">    <span class="keyword">if</span> (!ptr)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">void</span>* buf = (<span class="type">void</span>*)(rawptr + rows);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">         ptr[i] = buf + i * cols;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free2d</span><span class="params">(<span class="type">void</span>** ptr)</span> &#123;</span><br><span class="line">    <span class="type">void</span>* p = <span class="type">void</span>* p;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="12-4-不用中间变量，直接交换两个数字"><a href="#12-4-不用中间变量，直接交换两个数字" class="headerlink" title="12.4 不用中间变量，直接交换两个数字"></a>12.4 不用中间变量，直接交换两个数字</h2><p>想像把 a 和 b 都放在数轴上，假设 a0，b0分别是初值，那么有 diff &#x3D; a - b。我们把<br>diff 保存在 a 中，然后 b &#x3D; b0 + diff 也就是 a0 ，而再另 a &#x3D; b - diff，也就是 b0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    a = a - b;</span><br><span class="line">    b = b + a;</span><br><span class="line">    a = b - a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更巧妙的是，我们还可以使用异或 XOR 在解。假设 a &#x3D; a0 ^ b0，那么 b &#x3D; a ^ b0 &#x3D; a0 ^ b0 ^ b0 &#x3D; a0，然后 a &#x3D; a ^ b &#x3D; a0 ^ b0 ^ a0 &#x3D; b0。完美解决！<br>值得注意的是，因为使用异或不考虑变量的实际类型，只是粗暴地按 bit 位交换，因此适用于各种类型。不过值得注意的是千万不要用这种方法去交换变量的值，当x&#x3D;&#x3D;y的时候会有灾难性后果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="13-1-n-结尾有多少个零"><a href="#13-1-n-结尾有多少个零" class="headerlink" title="13.1 n! 结尾有多少个零"></a>13.1 n! 结尾有多少个零</h2><p>LeetCode 172</p>
<h2 id="13-2-找出两个数字中较大的一个，但不得使用判断语句"><a href="#13-2-找出两个数字中较大的一个，但不得使用判断语句" class="headerlink" title="13.2 找出两个数字中较大的一个，但不得使用判断语句"></a>13.2 找出两个数字中较大的一个，但不得使用判断语句</h2><p>判断a&gt;b就是判断a-b的正负号，显然我们可以使用bit运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">flip</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="comment">// flip last bit</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ^ a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sign</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">flip</span>((a &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="13-3-把数字转换为英文单词"><a href="#13-3-把数字转换为英文单词" class="headerlink" title="13.3 把数字转换为英文单词"></a>13.3 把数字转换为英文单词</h2><h2 id="13-4-把数字转换为汉语句子"><a href="#13-4-把数字转换为汉语句子" class="headerlink" title="13.4 把数字转换为汉语句子"></a>13.4 把数字转换为汉语句子</h2><h2 id="13-5-数组最大序列和"><a href="#13-5-数组最大序列和" class="headerlink" title="13.5 数组最大序列和"></a>13.5 数组最大序列和</h2><p>LeetCode 53</p>
<h2 id="13-6-给定产生数字概率相同的rand5-，实现一个方法rand7-，要求产生每个数字的概率相同"><a href="#13-6-给定产生数字概率相同的rand5-，实现一个方法rand7-，要求产生每个数字的概率相同" class="headerlink" title="13.6 给定产生数字概率相同的rand5()，实现一个方法rand7()，要求产生每个数字的概率相同"></a>13.6 给定产生数字概率相同的rand5()，实现一个方法rand7()，要求产生每个数字的概率相同</h2><p>扩大rand5产生随机数的范围，然后对舍去一定范围的数字，对剩下的数字取模，虽然这样会导致调用次数不固定，但实现了效果<br>对于randx，扩大范围的方法是 x * randx() + randx()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rand7</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">5</span> * rand5() + rand5();</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">21</span>)</span><br><span class="line">            <span class="keyword">return</span> num % <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该问题可以拓展到对于 x &lt; y，由randx() 构造 randy()</p>
<h2 id="13-7-在数组中找到两个数字，是的他们的和为指定的数字"><a href="#13-7-在数组中找到两个数字，是的他们的和为指定的数字" class="headerlink" title="13.7 在数组中找到两个数字，是的他们的和为指定的数字"></a>13.7 在数组中找到两个数字，是的他们的和为指定的数字</h2><p>LeetCode 1</p>
<h2 id="13-8-把二叉树转化为双向链表"><a href="#13-8-把二叉树转化为双向链表" class="headerlink" title="13.8 把二叉树转化为双向链表"></a>13.8 把二叉树转化为双向链表</h2><p>先把二叉树变成一个环形链表，然后再从头部解开即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">concat</span><span class="params">(<span class="keyword">struct</span> tree_node* x, <span class="keyword">struct</span> tree_node* y)</span> &#123;</span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tree_node* <span class="title function_">convert_circular</span><span class="params">(<span class="keyword">struct</span> tree_node* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span>* <span class="title">left</span> =</span> convert_circular(root-&gt;left);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span>* <span class="title">right</span> =</span> convert_circular(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!left &amp;&amp; !right) &#123;</span><br><span class="line">        root-&gt;left = root;</span><br><span class="line">        root-&gt;right = root;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span>* <span class="title">tail_right</span> =</span> right ? right-&gt;left : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把左边添加到根部</span></span><br><span class="line">    <span class="keyword">if</span> (!left)</span><br><span class="line">        concat(right-&gt;left, root);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        concat(left-&gt;left, root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把右边添加到根部</span></span><br><span class="line">    <span class="keyword">if</span> (!right)</span><br><span class="line">        concat(root, left);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        concat(root, right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把右边和左边链接</span></span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right)</span><br><span class="line">        concat(tail_right, left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left ? left : root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tree_node* <span class="title function_">convert</span><span class="params">(<span class="keyword">struct</span> tree_node* root)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span>* <span class="title">head</span> =</span> convert_circular(root);</span><br><span class="line">    head-&gt;left-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-2-实现加法"><a href="#14-2-实现加法" class="headerlink" title="14.2 实现加法"></a>14.2 实现加法</h2><p>显然是使用位运算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int add(int a, int b) &#123;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        int sum = a ^ b;</span><br><span class="line">        int carry = (a &amp; b) &lt;&lt; 1;</span><br><span class="line">        a = sum, b = carry;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-2-完美洗牌，使得一副牌中任意一种排列出现的概率都相等"><a href="#15-2-完美洗牌，使得一副牌中任意一种排列出现的概率都相等" class="headerlink" title="15.2 完美洗牌，使得一副牌中任意一种排列出现的概率都相等"></a>15.2 完美洗牌，使得一副牌中任意一种排列出现的概率都相等</h2><p>显然全排列是n!个，那么我们保证每一个全排列都可能出现就好了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> k = rand(i);</span><br><span class="line">        swap(A[k], A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-1-从n个数组中选出m个，要求被选中概率一样"><a href="#16-1-从n个数组中选出m个，要求被选中概率一样" class="headerlink" title="16.1 从n个数组中选出m个，要求被选中概率一样"></a>16.1 从n个数组中选出m个，要求被选中概率一样</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">pink_k</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">result</span><span class="params">(k)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-2-小于-n-的数字中出现2的个数"><a href="#16-2-小于-n-的数字中出现2的个数" class="headerlink" title="16.2 小于 n 的数字中出现2的个数"></a>16.2 小于 n 的数字中出现2的个数</h2><h2 id="16-3-矩阵链乘法问题"><a href="#16-3-矩阵链乘法问题" class="headerlink" title="16.3 矩阵链乘法问题"></a>16.3 矩阵链乘法问题</h2><h2 id="16-4-判断是否是合法地出栈序列"><a href="#16-4-判断是否是合法地出栈序列" class="headerlink" title="16.4 判断是否是合法地出栈序列"></a>16.4 判断是否是合法地出栈序列</h2><p><a href="https://blog.csdn.net/The_star_is_at/article/details/72790961">参考</a></p>
<h2 id="16-5-二叉树的非递归遍历"><a href="#16-5-二叉树的非递归遍历" class="headerlink" title="16.5 二叉树的非递归遍历"></a>16.5 二叉树的非递归遍历</h2><p><a href="https://www.cnblogs.com/dolphin0520/archive/2011/08/25/2153720.html">参考</a></p>
<br>
<br>
<br>
<br>
<br>


<h1 id="三、树的遍历"><a href="#三、树的遍历" class="headerlink" title="三、树的遍历"></a>三、树的遍历</h1><p>树的递归遍历都非常简单，但是非递归遍历有时候不是很简单。一般做题的时候直接写递归版就行了，<br>但是对于三个基础的遍历方法，有时候会要求写迭代版本，基本就是花式用栈就行了。</p>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> [root.val, *self.preorderTraversal(root.left), *self.preorderTraversal(root.right)]</span><br></pre></td></tr></table></figure>

<h3 id="非递归版"><a href="#非递归版" class="headerlink" title="非递归版"></a>非递归版</h3><p>使用栈做了一个顺序的反转。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归版-1"><a href="#递归版-1" class="headerlink" title="递归版"></a>递归版</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> [*self.inorderTraversal(root.left), root.val, *self.inorderTraversal(root.right)]</span><br></pre></td></tr></table></figure>

<h3 id="非递归版-1"><a href="#非递归版-1" class="headerlink" title="非递归版"></a>非递归版</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">            left = stack.pop()</span><br><span class="line">            ans.append(left.val)</span><br><span class="line">            <span class="keyword">if</span> left.right:</span><br><span class="line">                node = left.right</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">LeetCode 145</a></p>
<h3 id="递归版-2"><a href="#递归版-2" class="headerlink" title="递归版"></a>递归版</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> [*self.postorderTraversal(root.left), *self.postorderTraversal(root.right), root.val]</span><br></pre></td></tr></table></figure>

<h3 id="非递归版-2"><a href="#非递归版-2" class="headerlink" title="非递归版"></a>非递归版</h3><p>这个方法还是有点 trick 的，类似于前序遍历，但是把左右子树反过来了，最后再翻转一遍，就变成<br>了后序遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br></pre></td></tr></table></figure>

<p>比如：前序遍历是 123, 现在这种遍历方式是 132, 在翻转一次正好是 231, 也就是后续遍历了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">reversed</span>(ans))</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/</a></li>
</ol>
<br>
<br>
<br>
<br>
<br>






<h1 id="四、LeetCode-突击手册"><a href="#四、LeetCode-突击手册" class="headerlink" title="四、LeetCode 突击手册"></a>四、LeetCode 突击手册</h1><p>一共定义了几个标签，可以通过 Ctrl+F&#x2F;Cmd+F 搜索这些标签还快速浏览相同的题目。</p>
<p>标签：#hash #backtracking #slidewindow #stack #queue #pointers</p>
<h2 id="1-从数组中找出两个数字使得他们的和是给定的数字"><a href="#1-从数组中找出两个数字使得他们的和是给定的数字" class="headerlink" title="1 从数组中找出两个数字使得他们的和是给定的数字"></a>1 从数组中找出两个数字使得他们的和是给定的数字</h2><p>tags: #hash</p>
<p>使用一个散列，存储数字和他对应的索引。然后遍历数组，如果另一半在散列当中，那么返回<br>这两个数的索引，程序结束；如果不在，把当前数字加入到散列中。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> reminder = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">find</span>(reminder) != hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            result[<span class="number">0</span>] = hash[reminder] + <span class="number">1</span>;</span><br><span class="line">            result[<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        hash[nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        seen = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> [seen[target-num], i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                seen[num] = i</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">two_sum</span>(nums: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;, target: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">with_capacity</span>(nums.<span class="title function_ invoke__">len</span>());</span><br><span class="line">        <span class="title function_ invoke__">for</span> (idx, num) <span class="keyword">in</span> nums.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">            <span class="keyword">match</span> map.<span class="title function_ invoke__">get</span>(&amp;(target - num)) &#123;</span><br><span class="line">                <span class="literal">None</span> =&gt; &#123;map.<span class="title function_ invoke__">insert</span>(num, idx);&#125;,</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(sub_idx) =&gt; &#123;<span class="keyword">return</span> <span class="built_in">vec!</span>[*sub_idx <span class="keyword">as</span> <span class="type">i32</span>, idx <span class="keyword">as</span> <span class="type">i32</span>]; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vec!</span> []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>go 解答</summary>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> index, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        last_index, ok := m[num]</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;last_index, index&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m[target - num] = index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>Follow up: 如果数组是已经排序的呢？</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()) <span class="comment">// 假设已经排序，只有一个结果</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> s = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (s == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make_pair</span>(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; sum)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="2-给两个列表，数字在其中按低位到高位存储，求他们的和"><a href="#2-给两个列表，数字在其中按低位到高位存储，求他们的和" class="headerlink" title="2 给两个列表，数字在其中按低位到高位存储，求他们的和"></a>2 给两个列表，数字在其中按低位到高位存储，求他们的和</h2><p>直接迭代遍历数组，考察细节操作。注意 dummy head 的使用。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 注意最后如果有 carry 的话，需要再生成一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">        <span class="type">int</span> v1 = l1 ? l1-&gt;val: <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> v2 = l2 ? l2-&gt;val: <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> v = v1 + v2 + carry;</span><br><span class="line">        p-&gt;next = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        p-&gt;val = v % <span class="number">10</span>;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        carry = v / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        l1 = l1 ? l1-&gt;next: <span class="literal">NULL</span>;</span><br><span class="line">        l2 = l2 ? l2-&gt;next: <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">ListNode *<span class="title">addTwoNumbers</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">            <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">            <span class="type">int</span> shift = <span class="number">0</span>;</span><br><span class="line">            ListNode* result = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">            ListNode* p = result;</span><br><span class="line">            <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> || l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="type">int</span> v1 = l1 != <span class="literal">NULL</span> ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> v2 = l2 != <span class="literal">NULL</span> ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">                newNode-&gt;val = v1 + v2 + shift;</span><br><span class="line">                <span class="keyword">if</span> (newNode-&gt;val &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                    newNode-&gt;val -= <span class="number">10</span>;</span><br><span class="line">                    shift = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    shift = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">                    l1 = l1-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">                    l2 = l2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;next = newNode;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意最后多余的一个进位处理</span></span><br><span class="line">            <span class="keyword">if</span> (shift == <span class="number">1</span>) &#123;</span><br><span class="line">                p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two_numbers</span>(l1: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;ListNode&gt;&gt;, l2: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;ListNode&gt;&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;ListNode&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> l1, <span class="keyword">mut</span> l2) = (l1, l2);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">dummy</span> = <span class="type">Box</span>&lt;ListNode::<span class="title function_ invoke__">new</span>(<span class="number">0</span>)&gt;;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">carry</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">p</span> = dummy;</span><br><span class="line">        <span class="keyword">while</span> l1.<span class="title function_ invoke__">is_some</span>() || l2.<span class="title function_ invoke__">is_some</span>() || carry != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> l1, l2&#123;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(a), <span class="title function_ invoke__">Some</span>(b) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = a + b + carry;</span><br><span class="line">                    l1 = l1.<span class="title function_ invoke__">next</span>();</span><br><span class="line">                    l2 = l2.<span class="title function_ invoke__">next</span>();</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(a), <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = a + carry;</span><br><span class="line">                    l1 = l1.<span class="title function_ invoke__">next</span>();</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="literal">None</span>, <span class="title function_ invoke__">Some</span>(b) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = b + carry;</span><br><span class="line">                    l2 = l2.<span class="title function_ invoke__">next</span>();</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="literal">None</span>, <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p.next = <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>&lt;ListNode::<span class="title function_ invoke__">new</span>(v)&gt;);</span><br><span class="line">            p = p.next;</span><br><span class="line">            p.val = v % <span class="number">10</span>;</span><br><span class="line">            carry = v / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> carry:</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                v1 = l1.val</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                v1 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                v2 = l2.val</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                v2 = <span class="number">0</span></span><br><span class="line">            v = v1 + v2 + carry  <span class="comment"># 别忘了这里</span></span><br><span class="line">            <span class="keyword">if</span> v &gt;= <span class="number">10</span>:</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">                v -= <span class="number">10</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            p.<span class="built_in">next</span> = ListNode(v)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="3-最长不重复子串"><a href="#3-最长不重复子串" class="headerlink" title="3 最长不重复子串"></a>3 最长不重复子串</h2><p>tags: #slidewindow</p>
<p>滑动窗口解决</p>
<p>注意，当字符有限的时候，比如限定为 ASCII 字符，可以使用一个数组代替 Hash。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> indices[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  <span class="comment">// init the array, memset can only be used for char</span></span><br><span class="line">        indices[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> longest = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; s[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        left = max(left, indices[s[i]] + <span class="number">1</span>);   <span class="comment">// 考虑新加入字符后对左边界的影响</span></span><br><span class="line">        indices[s[i]] = i;                     <span class="comment">// 更新元素上次出现位置</span></span><br><span class="line">        longest = max(longest, i - left + <span class="number">1</span>);  <span class="comment">// 应用动态规划</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        last_seen = &#123;&#125;</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            lo = <span class="built_in">max</span>(lo, last_seen.get(c, -<span class="number">1</span>) + <span class="number">1</span>)  <span class="comment"># 更新下边界</span></span><br><span class="line">            last_seen[c] = i</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - lo + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<h2 id="4-找到两个排序数组的中位数"><a href="#4-找到两个排序数组的中位数" class="headerlink" title="4 找到两个排序数组的中位数"></a>4 找到两个排序数组的中位数</h2><p>解法参见<a href="https://leetcode.com/discuss/15790/share-my-o-log-min-m-n-solution-with-explanation">这里</a></p>
<p>使用两个数字 i 和 j, 分别作为 AB 的分隔元素，把 AB 分成两份，比如<br><code>A[0..i]</code>, <code>B[0..j]</code> 和 <code>A[i, m]</code>, <code>B[j, n]</code>，这样我们只需要下面两个条件就可以了：</p>
<ul>
<li><code>i+j = m-i + n-j</code>, 也就是 <code>i+j = (m+n)/2</code></li>
<li><code>B[j-1] &lt;= A[i] &amp;&amp; A[i-1] &lt;= B[j]</code>,  B 的前一半元素小于 A 的分隔符，A 的前一半元素小于 B 的分隔符</li>
</ul>
<p>这时候我们就得到了 A[i] 就是我们的中位数，或者之一。 i 的初始值在 0 到 m 之间，<br>然后我们二分搜索 <code>i = (imin + imax) / 2, j = mid - i</code>。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> m, <span class="type">int</span>* B, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> findMedianSortedArrays(B, n, A, m);</span><br><span class="line">    <span class="type">int</span> imin = <span class="number">0</span>, imax = m, i, j, num1, mid = (m + n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, num2;</span><br><span class="line">    <span class="keyword">while</span> (imin &lt;= imax) &#123;</span><br><span class="line">        i = (imin + imax) <span class="comment">// 2;</span></span><br><span class="line">        j = mid - i;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; m &amp;&amp; j &gt; <span class="number">0</span> &amp;&amp; B[j<span class="number">-1</span>] &gt; A[i]) &#123;  <span class="comment">// B 中的数字偏大</span></span><br><span class="line">            imin = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; B[j] &lt; A[i<span class="number">-1</span>]) &#123; <span class="comment">// A 中的数字偏大</span></span><br><span class="line">            imax = i - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                num1 = B[j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                num1 = A[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num1 = max(A[i<span class="number">-1</span>],B[j<span class="number">-1</span>]);  <span class="comment">// 普通情况</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((m + n) &amp; <span class="number">0x1</span>) <span class="comment">// odd</span></span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="keyword">if</span> (i == m)</span><br><span class="line">        num2 = B[j];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (j == n)</span><br><span class="line">        num2 = A[i];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        num2 = min(A[i], B[j]); <span class="comment">// 普通情况</span></span><br><span class="line">    <span class="keyword">return</span> (num1 + num2) / <span class="number">2.0</span>; <span class="comment">// 注意整数除法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5 最长回文子串"></a>5 最长回文子串</h2><ol>
<li>以某个元素为中心，向两边展开，注意处理奇数和偶数两种情况</li>
<li>Manacher 算法，参见<a href="http://taop.marchtea.com/01.05.html">这里</a></li>
</ol>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        ans = <span class="string">&quot;&quot;</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 奇数长度回文子串</span></span><br><span class="line">            <span class="keyword">while</span> i - j &gt;= <span class="number">0</span> <span class="keyword">and</span> i + j &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i-j] == s[i+j]:</span><br><span class="line">                <span class="keyword">if</span> j * <span class="number">2</span> + <span class="number">1</span> &gt; length:</span><br><span class="line">                    length = j * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    ans = s[i-j:i+j+<span class="number">1</span>]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 偶数长度回文子串</span></span><br><span class="line">            <span class="keyword">while</span> i - j &gt;= <span class="number">0</span> <span class="keyword">and</span> i + j + <span class="number">1</span> &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i-j] == s[i+j+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> j * <span class="number">2</span> + <span class="number">2</span> &gt; length:</span><br><span class="line">                    length = j * <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">                    ans = s[i-j:i+j+<span class="number">2</span>]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">longestPalindrome</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>; <span class="comment">// length of the longest palindromic string</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">-1</span>; <span class="comment">// start of the lonest palidromic string</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 奇数长度的回文子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; (i - j &gt;= <span class="number">0</span>) &amp;&amp; (i + j &lt; len); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - j] != s[i + j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (j * <span class="number">2</span> + <span class="number">1</span> &gt; length) &#123;</span><br><span class="line">                length = j * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                start = i - j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偶数长度的回文子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; (i - j &gt;= <span class="number">0</span>) &amp;&amp; (i + j + <span class="number">1</span> &lt; len); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - j] != s[i + j + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (j * <span class="number">2</span> + <span class="number">2</span> &gt; length) &#123;</span><br><span class="line">                length = j * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">                start = i - j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * length + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(result, s + start, length);</span><br><span class="line">    result[length] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="6-ZigZag-字符串，把字符串掰弯，然后再按行输出"><a href="#6-ZigZag-字符串，把字符串掰弯，然后再按行输出" class="headerlink" title="6 ZigZag 字符串，把字符串掰弯，然后再按行输出"></a>6 ZigZag 字符串，把字符串掰弯，然后再按行输出</h2><p>考察数学，找出规律，所以实际上并不是 Z 子形，而是由 V 组成的，然后组合按行号重构后的字符串即可。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个方法不容易理解，建议看 Python 的</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">convert</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (!s || numRows &lt;= <span class="number">1</span> || len &lt; numRows) <span class="keyword">return</span> s; <span class="comment">// no need to convert</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* zigzag = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; len; j += <span class="number">2</span> * (numRows - <span class="number">1</span>)) &#123; <span class="comment">// 每个 v 字型长度</span></span><br><span class="line">            zigzag[cur++] = s[j];</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != numRows - <span class="number">1</span>) &#123; <span class="comment">// 中间行有斜线</span></span><br><span class="line">                <span class="type">int</span> t = j + <span class="number">2</span> * (numRows - <span class="number">1</span>) - <span class="number">2</span> * i; <span class="comment">// V 的第二笔</span></span><br><span class="line">                <span class="keyword">if</span> (t &lt; len)</span><br><span class="line">                    zigzag[cur++] = s[t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    zigzag[cur] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> zigzag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">self, s: <span class="built_in">str</span>, numRows: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> numRows &lt;= <span class="number">1</span> <span class="keyword">or</span> <span class="built_in">len</span>(s) &lt;= numRows:  <span class="comment"># 没有这个条件会超时</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        interval = <span class="number">2</span> * numRows - <span class="number">2</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># 第一行</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            ans.append(s[j])</span><br><span class="line">            j += interval</span><br><span class="line">        <span class="comment"># 中间行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, numRows-<span class="number">1</span>):</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">if</span> i + j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                    ans.append(s[i+j])</span><br><span class="line">                <span class="keyword">if</span> interval - i + j &lt; <span class="built_in">len</span>(s):  <span class="comment"># 一定要注意这里的索引</span></span><br><span class="line">                    ans.append(s[interval - i + j])</span><br><span class="line">                j += interval</span><br><span class="line">        <span class="comment"># 最后一行</span></span><br><span class="line">        j = numRows - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            ans.append(s[j])</span><br><span class="line">            j += interval</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(ans)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="7-翻转数字，溢出返回-0"><a href="#7-翻转数字，溢出返回-0" class="headerlink" title="7 翻转数字，溢出返回 0"></a>7 翻转数字，溢出返回 0</h2><p>注意溢出</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == INT_MIN) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> -reverse(-x);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        result = result * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result &gt; INT_MAX ? <span class="number">0</span> : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sign = <span class="number">1</span> <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        x *= sign</span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            y = y * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> y &gt; <span class="number">2</span>**<span class="number">31</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> y * sign</span><br></pre></td></tr></table></figure>
</details>


<h2 id="8-实现-atoi"><a href="#8-实现-atoi" class="headerlink" title="8 实现 atoi"></a>8 实现 atoi</h2><p>这道题考察各种细节，注意各种特殊情况：</p>
<ol>
<li>首先过滤空格</li>
<li>判定符号，符号只能出现一次</li>
<li>是否溢出，溢出返回 <code>INT_MAX</code> 或者 <code>INT_MIN</code></li>
</ol>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myAtoi</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = s.lstrip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">            sign = -<span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> s[i] == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i].isdigit():</span><br><span class="line">            ans = ans * <span class="number">10</span> + <span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        ans *= sign</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">min</span>(ans, <span class="number">2</span>**<span class="number">31</span>-<span class="number">1</span>), - <span class="number">2</span> ** <span class="number">31</span>)</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(<span class="type">char</span>* str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// discarding spaces</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isspace</span>(*str))</span><br><span class="line">        str++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// determining sign</span></span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">&#x27;-&#x27;</span> || *str == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">&#x27;-&#x27;</span>) sign = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">&#x27;+&#x27;</span>) sign = <span class="number">1</span>;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructing integer</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(*str)) &#123;</span><br><span class="line">        <span class="comment">// handling overflow</span></span><br><span class="line">        <span class="keyword">if</span> (result &gt; INT_MAX / <span class="number">10</span> || result == INT_MAX / <span class="number">10</span> &amp;&amp; *str - <span class="string">&#x27;0&#x27;</span> &gt; INT_MAX % <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> sign &gt; <span class="number">0</span> ? INT_MAX : INT_MIN;</span><br><span class="line">        result = *str - <span class="string">&#x27;0&#x27;</span> + result * <span class="number">10</span>;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result * sign;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="9-是否是回文数字"><a href="#9-是否是回文数字" class="headerlink" title="9 是否是回文数字"></a>9 是否是回文数字</h2><p>限定不能用额外空间，所以直接把 x 取余得到的数字作为一个反向作为一个新的数字</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> x != <span class="number">0</span> <span class="keyword">and</span> x % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 回文走到一半就行了，没必要完全翻转过来</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; y:</span><br><span class="line">            y = y * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> x == y <span class="keyword">or</span> x == y // <span class="number">10</span></span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tricky here, for x == k * 10^j</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &amp;&amp; (x % <span class="number">10</span> == <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; y) &#123;</span><br><span class="line">        y = y * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x == y || x == y / <span class="number">10</span>; <span class="comment">// 注意 x 可能是奇数长度也可能是偶数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="10-正则表达式"><a href="#10-正则表达式" class="headerlink" title="10 正则表达式"></a>10 正则表达式</h2><p>实现正则表达式，只需要实现<code>.</code>代表任意字符，<code>*</code>代表任意重复。只需要特殊处理<code>*</code>，<br>如果遇到了<code>*</code>，贪婪地向后匹配。和通配符的不同之处在于，正则表达式需要两个字母<br>组成模式，<code>*</code>是对前一个字母的修饰。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isMatch</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* p)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c = *p; c != <span class="number">0</span>; s++, c = *p) &#123;</span><br><span class="line">        <span class="comment">// if next char in pattern is not *</span></span><br><span class="line">        <span class="keyword">if</span> (*(p+<span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            p++;</span><br><span class="line">        <span class="comment">// if we got an *, check if we can skip `.*` or `x*`</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isMatch(s, p + <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s ends or p and s differs</span></span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="number">0</span> || c != <span class="string">&#x27;.&#x27;</span> &amp;&amp; c != *s)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *s == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11 盛最多水的容器"></a>11 盛最多水的容器</h2><p>从左右向中间逼近，如果有更大的就更新。简单的一道双指针题目，别想太多。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        water = <span class="built_in">min</span>(height[left], height[right]) * (right - left)</span><br><span class="line">        result = <span class="built_in">max</span>(result, water);</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right])</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            water = <span class="built_in">min</span>(height[lo], height[hi]) * (hi - lo)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, water)</span><br><span class="line">            <span class="keyword">if</span> height[lo] &lt; height[hi]:</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<h2 id="12-十进制转换为罗马数字"><a href="#12-十进制转换为罗马数字" class="headerlink" title="12 十进制转换为罗马数字"></a>12 十进制转换为罗马数字</h2><p>直接按每位把罗马数字转换出来在拼接就好了，使用 C 的话，拼接字符串很麻烦。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intToRoman</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        thousands = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>]</span><br><span class="line">        hundreds = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>]</span><br><span class="line">        tens = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>]</span><br><span class="line">        ones = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> thousands[x//<span class="number">1000</span>] + hundreds[x%<span class="number">1000</span>//<span class="number">100</span>] + tens[x%<span class="number">100</span>//<span class="number">10</span>] + ones[x%<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// note, the leading empty string is the trick here</span></span><br><span class="line">    string thousands[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>&#125;;</span><br><span class="line">    string handreds[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>&#125;;</span><br><span class="line">    string tens[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>&#125;;</span><br><span class="line">    string ones[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> thousands[num / <span class="number">1000</span>] + handreds[num % <span class="number">1000</span> / <span class="number">100</span>] + tens[num % <span class="number">100</span> / <span class="number">10</span>] + ones[num % <span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> digits[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span>* romans = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="type">char</span>* cursor = romans;</span><br><span class="line">    <span class="comment">// if num = 1234, then</span></span><br><span class="line">    <span class="comment">// digits = &#123;1, 2, 3, 4&#125;;</span></span><br><span class="line">    <span class="type">int</span> base = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        digits[i] = num / base;</span><br><span class="line">        num = num % base;</span><br><span class="line">        base /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    doRoman(digits[<span class="number">0</span>], <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, &amp;cursor); <span class="comment">// &#x27;_&#x27; can be anything</span></span><br><span class="line">    doRoman(digits[<span class="number">1</span>], <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, &amp;cursor);</span><br><span class="line">    doRoman(digits[<span class="number">2</span>], <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, &amp;cursor);</span><br><span class="line">    doRoman(digits[<span class="number">3</span>], <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, &amp;cursor);</span><br><span class="line">    *cursor = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> romans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">doRoman</span><span class="params">(<span class="type">int</span> number, <span class="type">char</span> ten, <span class="type">char</span> five, <span class="type">char</span> one, <span class="type">char</span>** str)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (number) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str)[<span class="number">1</span>] = ten;</span><br><span class="line">            (*str) += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = five;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str)[<span class="number">2</span>] = one;</span><br><span class="line">            (*str)[<span class="number">3</span>] = one;</span><br><span class="line">            (*str) += <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = five;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str)[<span class="number">2</span>] = one;</span><br><span class="line">            (*str) += <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = five;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str) += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = five;</span><br><span class="line">            (*str) += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str)[<span class="number">1</span>] = five;</span><br><span class="line">            (*str) += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str)[<span class="number">2</span>] = one;</span><br><span class="line">            (*str) += <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str) += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str) += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="13-罗马数字转为十进制"><a href="#13-罗马数字转为十进制" class="headerlink" title="13 罗马数字转为十进制"></a>13 罗马数字转为十进制</h2><p>主要是当前一个数字小于后一个数字的时候，需要添加的是后一个数和前一个数字的差。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        vals = &#123;</span><br><span class="line">            <span class="string">&quot;I&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;V&quot;</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">&quot;X&quot;</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">&quot;L&quot;</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="string">&quot;C&quot;</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="string">&quot;D&quot;</span>: <span class="number">500</span>,</span><br><span class="line">            <span class="string">&quot;M&quot;</span>: <span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> i+<span class="number">1</span>&lt;<span class="built_in">len</span>(s) <span class="keyword">and</span> vals[s[i]] &lt; vals[s[i+<span class="number">1</span>]]:</span><br><span class="line">                ans += vals[s[i+<span class="number">1</span>]] - vals[s[i]]</span><br><span class="line">                i += <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += vals[s[i]]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// acts like a dict or map</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getVal</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; s[i] != <span class="number">0</span>; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getVal(s[i]) &lt; getVal(s[i+<span class="number">1</span>]))</span><br><span class="line">            result += getVal(s[i+<span class="number">1</span>]) - getVal(s[i]), i += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result += getVal(s[i]), i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14 最长公共前缀"></a>14 最长公共前缀</h2><p>纵向扫描，从头到尾，如果不一致，返回当前子串即可。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">        minlen = <span class="built_in">min</span>([<span class="built_in">len</span>(<span class="built_in">str</span>) <span class="keyword">for</span> <span class="built_in">str</span> <span class="keyword">in</span> strs])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(minlen):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(strs)):</span><br><span class="line">                <span class="keyword">if</span> strs[j][i] != strs[<span class="number">0</span>][i]:</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>][:minlen]</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 纵向扫描</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">longestCommonPrefix</span><span class="params">(<span class="type">char</span>** strs, <span class="type">int</span> strsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!strs || !strs[<span class="number">0</span>]) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (strsSize == <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(strs[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; strsSize; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[j][i] != strs[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                strs[<span class="number">0</span>][i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="15-从数组中找出三个数使得他们的和是-0"><a href="#15-从数组中找出三个数使得他们的和是-0" class="headerlink" title="15 从数组中找出三个数使得他们的和是 0"></a>15 从数组中找出三个数使得他们的和是 0</h2><p>首先把数组排序，然后使用类似 two sum 的方法做就好了。做这种数组题的套路就是实在不行排个<br>序。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            k = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                <span class="built_in">sum</span> = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span> &gt; <span class="number">0</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">sum</span> &lt; <span class="number">0</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans.append([nums[i], nums[j], nums[k]])</span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j+<span class="number">1</span>]:</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k-<span class="number">1</span>]:</span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &gt; <span class="number">0</span>)</span><br><span class="line">                k--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span>)</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line">                <span class="comment">// skipping duplicates</span></span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k - <span class="number">1</span>])</span><br><span class="line">                    k--;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j + <span class="number">1</span>])</span><br><span class="line">                    j++;</span><br><span class="line">                k--; <span class="comment">// 别忘了这里，还要继续寻找下一组</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="16-在数组中找到三个数字使得他们得和尽可能的接近给定数字，假设结果唯一"><a href="#16-在数组中找到三个数字使得他们得和尽可能的接近给定数字，假设结果唯一" class="headerlink" title="16 在数组中找到三个数字使得他们得和尽可能的接近给定数字，假设结果唯一"></a>16 在数组中找到三个数字使得他们得和尽可能的接近给定数字，假设结果唯一</h2><p>和上一题解法类似，在 <a href="http://stackoverflow.com/q/2070359">http://stackoverflow.com/q/2070359</a> 有详尽解释</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            k = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                <span class="built_in">sum</span> = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span> == target:</span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">abs</span>(target-<span class="built_in">sum</span>) &lt; <span class="built_in">abs</span>(target-ans):</span><br><span class="line">                    ans = <span class="built_in">sum</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">sum</span> &gt; target:</span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>





<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *a - *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt;= <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] +nums[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> k = numsSize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            <span class="type">int</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">            <span class="keyword">if</span> (sum == target)</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(target - sum) &lt; <span class="built_in">abs</span>(target - result))</span><br><span class="line">                result = sum;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target)</span><br><span class="line">                k--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="17-生成电话键盘按键数字对应的所有可能的字符串，不限制返回结果的顺序"><a href="#17-生成电话键盘按键数字对应的所有可能的字符串，不限制返回结果的顺序" class="headerlink" title="17 生成电话键盘按键数字对应的所有可能的字符串，不限制返回结果的顺序"></a>17 生成电话键盘按键数字对应的所有可能的字符串，不限制返回结果的顺序</h2><p>tags: #backtracking</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="键盘"></p>
<p>递归：</p>
<p>这道题是一道典型的，最简单的深度优先遍历，生成所有可能解的问题。</p>
<p>迭代：</p>
<p>遍历数字，设当前结果为<code>&#123;a, b, c&#125;</code>, 下一个数字是<code>3</code>, 找出对应的字母<code>&#123;d, e, f&#125;</code>, 则新的结果是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; a + &#123;def&#125;, b + &#123;def&#125;, c + &#123;def&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>然后把新获得的数组作为下一轮的初始数组。最开始时，使用空数组开始。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        c2n = &#123;</span><br><span class="line">            <span class="string">&quot;2&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;3&quot;</span>: <span class="string">&quot;def&quot;</span>,</span><br><span class="line">            <span class="string">&quot;4&quot;</span>: <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">            <span class="string">&quot;5&quot;</span>: <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">            <span class="string">&quot;6&quot;</span>: <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">            <span class="string">&quot;7&quot;</span>: <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">            <span class="string">&quot;8&quot;</span>: <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">            <span class="string">&quot;9&quot;</span>: <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">combination, next_digits</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> next_digits:</span><br><span class="line">                ans.append(combination)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> c2n[next_digits[<span class="number">0</span>]]:</span><br><span class="line">                dfs(combination + char, next_digits[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        dfs(<span class="string">&quot;&quot;</span>, digits)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iterative</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> vector&lt;string&gt; &#123;&#125;;</span><br><span class="line">    string mapping[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">combinations</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;&quot;</span>)</span></span>; <span class="comment">// 注意使用空字符串作为种子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; digits.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> digit = digits[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (mapping[digit].<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vector&lt;string&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : mapping[digit])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; combination : combinations)</span><br><span class="line">                temp.<span class="built_in">push_back</span>(combination + c);</span><br><span class="line">        <span class="built_in">swap</span>(combinations, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> combinations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>还可以使用深度优先的搜索方法</p>
<p>追问：如何通过用户按的数字来查找是否有对应的单词呢</p>
<ol>
<li>通过把所有的单词计算出来，然后查询哪个是合法的，查询可以使用 Trie</li>
<li>通过把已经有的单词字典转换为数字字典，然后通过数字序列查询可能的单词组合。</li>
</ol>
<h2 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18 4Sum"></a>18 4Sum</h2><p>tags: #backtracking</p>
<p>其实可以用 深度优先搜索的方式直接解答 nSum</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">return</span> self.nSum(nums, target, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nSum</span>(<span class="params">self, nums, target, n</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">pos: <span class="built_in">int</span>, cur: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">                j = pos</span><br><span class="line">                k = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                    <span class="built_in">sum</span> = nums[j] + nums[k]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">sum</span> &lt; target:</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> <span class="built_in">sum</span> &gt; target:</span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        solution = cur[:] + [nums[j], nums[k]]</span><br><span class="line">                        ans.append(solution)</span><br><span class="line">                        <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j+<span class="number">1</span>]:</span><br><span class="line">                            j += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k-<span class="number">1</span>]:</span><br><span class="line">                            k -= <span class="number">1</span></span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            i = pos</span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums) - n + <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 剪枝的一种情况</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] * n &gt; target <span class="keyword">or</span> nums[-<span class="number">1</span>] * n &lt; target:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 排除重复数字</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; pos <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                cur.append(nums[i])</span><br><span class="line">                dfs(i+<span class="number">1</span>, cur, n-<span class="number">1</span>, target-nums[i])</span><br><span class="line">                cur.pop()</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        ans = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        dfs(<span class="number">0</span>, [], n, target)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<p>下面的 C++ 解法是一个传统解法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">4</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; hash;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            hash[nums[i]+nums[j]].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(i,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> re = target - nums[i] - nums[j];</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">find</span>(re) != hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> match : hash[re]) &#123;</span><br><span class="line">                    <span class="type">int</span> k = match.first, l = match.second;</span><br><span class="line">                    <span class="keyword">if</span> (k &gt; j) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!result.<span class="built_in">empty</span>()</span><br><span class="line">                            &amp;&amp; result.<span class="built_in">back</span>()[<span class="number">0</span>] == nums[i] &amp;&amp; result.<span class="built_in">back</span>()[<span class="number">1</span>] == nums[j]</span><br><span class="line">                            &amp;&amp; result.<span class="built_in">back</span>()[<span class="number">2</span>] == nums[k] &amp;&amp; result.<span class="built_in">back</span>()[<span class="number">3</span>] == nums[l])</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                        result.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k], nums[l]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="19-删除链表中倒数第-k-的节点"><a href="#19-删除链表中倒数第-k-的节点" class="headerlink" title="19 删除链表中倒数第 k 的节点"></a>19 删除链表中倒数第 k 的节点</h2><p>tags: #pointers</p>
<p>双指针经典题目，一个快指针先走 k 步，另一个慢指针再出发，注意链表长度小于 k 时。</p>
<p>注意：LeetCode 给定的 n 都是有效地，但要求返回头指针，如果头指针被删除需要额外注意，因此采用 dummy head</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        q = dummy</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        q.<span class="built_in">next</span> = q.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">fast</span>, *<span class="title">slow</span>;</span></span><br><span class="line">    dummy.next = fast = head;</span><br><span class="line">    slow = &amp;dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> slow-&gt;next;</span><br><span class="line">    slow-&gt;next = next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(next); <span class="comment">// remeber to free memory</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="20-判定给定的字符串是否是合法的括号序列，可能包括大中小三类"><a href="#20-判定给定的字符串是否是合法的括号序列，可能包括大中小三类" class="headerlink" title="20 判定给定的字符串是否是合法的括号序列，可能包括大中小三类"></a>20 判定给定的字符串是否是合法的括号序列，可能包括大中小三类</h2><p>tags: #stack</p>
<p>使用栈的基础题，注意逻辑简化</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        valid = <span class="literal">True</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">match</span> = &#123;<span class="string">&quot;)&quot;</span>: <span class="string">&quot;(&quot;</span>, <span class="string">&quot;]&quot;</span>: <span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#125;&quot;</span>: <span class="string">&quot;&#123;&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> (<span class="string">&quot;(&quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#123;&quot;</span>):</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> stack[-<span class="number">1</span>] != <span class="keyword">match</span>[c]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">opposite</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span> : <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span> : <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span> : <span class="keyword">return</span> <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            stk.push(c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!stk.empty() &amp;&amp; stk.top() == opposite(c))</span><br><span class="line">            stk.pop();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stk.empty(); <span class="comment">// 注意为空的条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_valid</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stack</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="comment">// let map =</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">ch</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">            <span class="keyword">match</span> ch &#123;</span><br><span class="line">                <span class="string">&#x27;(&#x27;</span> | <span class="string">&#x27;&#123;&#x27;</span> | <span class="string">&#x27;[&#x27;</span> =&gt; stack.<span class="title function_ invoke__">push</span>(ch),</span><br><span class="line">                <span class="string">&#x27;)&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="string">&#x27;(&#x27;</span>) = stack.<span class="title function_ invoke__">pop</span>() &#123;&#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;,</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="string">&#x27;&#123;&#x27;</span>) = stack.<span class="title function_ invoke__">pop</span>() &#123;&#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;,</span><br><span class="line">                <span class="string">&#x27;]&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="string">&#x27;[&#x27;</span>) = stack.<span class="title function_ invoke__">pop</span>() &#123;&#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;,</span><br><span class="line">                _ =&gt; <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="title function_ invoke__">len</span>() == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="21-合并两个已经排序的链表"><a href="#21-合并两个已经排序的链表" class="headerlink" title="21 合并两个已经排序的链表"></a>21 合并两个已经排序的链表</h2><p>tags: #pointers</p>
<p>考察链表的基本操作，很简单</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                p.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            p.<span class="built_in">next</span> = l1</span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            p.<span class="built_in">next</span> = l2</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span></span><br><span class="line">    dummy.next == <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1)</span><br><span class="line">        p-&gt;next = l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l2)</span><br><span class="line">        p-&gt;next = l2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="22-给定数字-n-生成所有合法的-n-个括号组成的序列"><a href="#22-给定数字-n-生成所有合法的-n-个括号组成的序列" class="headerlink" title="22 给定数字 n, 生成所有合法的 n 个括号组成的序列"></a>22 给定数字 n, 生成所有合法的 n 个括号组成的序列</h2><p>tags: #backtracking</p>
<p>一道典型的深度优先搜索题目</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">s, lefts, rights</span>):</span><br><span class="line">            <span class="keyword">if</span> lefts == <span class="number">0</span> <span class="keyword">and</span> rights == <span class="number">0</span>:</span><br><span class="line">                ans.append(s)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> lefts &gt; <span class="number">0</span>:</span><br><span class="line">                dfs(s+<span class="string">&quot;(&quot;</span>, lefts-<span class="number">1</span>, rights)</span><br><span class="line">            <span class="keyword">if</span> (lefts &lt; rights):</span><br><span class="line">                dfs(s+<span class="string">&quot;)&quot;</span>, lefts, rights-<span class="number">1</span>)</span><br><span class="line">        ans = []</span><br><span class="line">        dfs(<span class="string">&quot;&quot;</span>, n, n)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="built_in">gen</span>(result, <span class="string">&quot;&quot;</span>, n, n);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// left 剩下的左括号，right 剩下的右括号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gen</span><span class="params">(vector&lt;string&gt;&amp; result, string s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">gen</span>(result, s + <span class="string">&#x27;(&#x27;</span>, left - <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">        <span class="built_in">gen</span>(result, s + <span class="string">&#x27;)&#x27;</span>, left, right - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="23-合并-K-个排序的列表"><a href="#23-合并-K-个排序的列表" class="headerlink" title="23 合并 K 个排序的列表"></a>23 合并 K 个排序的列表</h2><p>使用优先级队列，复杂度最小。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">把列表看做一个队列，每次拿出两个列表，合并他们后放回到列表中，每次遍历列表的一半，这样每次遍历完一遍，</span><br><span class="line">列表的长度都会减半，直到列表的长度为 <span class="number">1</span>,  合并函数使用 <span class="number">21</span> 题中的合并两个列表的函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;C 解答&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) &#123;</span><br><span class="line">    // see above</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct ListNode* mergeKLists(struct ListNode** lists, <span class="built_in">int</span> listsSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!lists || listsSize &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (listsSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        // listsize <span class="keyword">is</span> halfed</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; listsSize / <span class="number">2</span>; i++)</span><br><span class="line">            // merge i <span class="keyword">and</span> last i <span class="built_in">list</span></span><br><span class="line">            lists[i] = mergeTwoLists(lists[i], lists[listsSize-<span class="number">1</span>-i]);</span><br><span class="line">        listsSize = (listsSize + <span class="number">1</span>) / <span class="number">2</span>; // 注意这里！</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="24-给定一个链表，交换两个相邻节点的值"><a href="#24-给定一个链表，交换两个相邻节点的值" class="headerlink" title="24 给定一个链表，交换两个相邻节点的值"></a>24 给定一个链表，交换两个相邻节点的值</h2><p>最简单的做法显然是直接把前后两个节点的值交换，但是 LeetCode 规定不能改变节点的值。<br>主要考察链表的指针操作，注意各种细节，一定要在纸上先把链表画出来。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> <span class="keyword">and</span> p.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            t = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = t.<span class="built_in">next</span></span><br><span class="line">            t.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span>.<span class="built_in">next</span> = t</span><br><span class="line">            p = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">swapPairs</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">temp</span>, *<span class="title">pnext</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;next) &#123;</span><br><span class="line">        temp = p-&gt;next;</span><br><span class="line">        p-&gt;next = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        p-&gt;next-&gt;next = temp;</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="25-给定一个链表，把相邻的-k-个节点反转"><a href="#25-给定一个链表，把相邻的-k-个节点反转" class="headerlink" title="25 给定一个链表，把相邻的 k 个节点反转"></a>25 给定一个链表，把相邻的 k 个节点反转</h2><p>和上题一样，同样禁止改变节点的值。比较简单地解法是浪费一点空间，使用 Stack, 实现<br>逆转 k 个节点，注意如果 k 较大的话，这种方法是不合适的。另一种方法是直接翻转，空间是<br>O(1) 的，但是时间复杂度是 2N。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head</span>):</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="built_in">next</span> = curr.<span class="built_in">next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> prev</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        p = dummy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            n = k</span><br><span class="line">            q = p</span><br><span class="line">            <span class="comment"># 找到下一组接点的头</span></span><br><span class="line">            <span class="keyword">while</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> q.<span class="built_in">next</span>:</span><br><span class="line">                q = q.<span class="built_in">next</span></span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果节点不够了直接退出</span></span><br><span class="line">            <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 把这段链表先截下来</span></span><br><span class="line">            <span class="built_in">next</span> = q.<span class="built_in">next</span></span><br><span class="line">            q.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            tail = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = self.reverseList(p.<span class="built_in">next</span>)</span><br><span class="line">            p = tail</span><br><span class="line">            p.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>


<p>使用 Stack 的 C++ 解法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    stack&lt;ListNode*&gt; stk;</span><br><span class="line">    <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">-1</span>)</span>, *p </span>= &amp;dummy, *pp;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pp = p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pp-&gt;next) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(pp-&gt;next);</span><br><span class="line">                pp = pp-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">size</span>() &lt; k) <span class="comment">// 剩下的节点不够 k 个了</span></span><br><span class="line">            <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">        pp = stk.<span class="built_in">top</span>()-&gt;next; <span class="comment">// 下一组中的第一个</span></span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            p-&gt;next = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p-&gt;next = pp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26 删除排序数组中的重复项"></a>26 删除排序数组中的重复项</h2><p>tags: #naive</p>
<p>in-place 的删除重复元素，使用两个指针，一个遍历，一个指向当前的结尾。</p>
<p>PS：这个基础题竟然做了半个小时才做对，⊙﹏⊙b 汗，要加强基础啊！</p>
<p>这类数组中去除中间元素的题写的时候还是很容易出错，重点是使用一个 length 变量，<br>然后还是要遍历整个数组。不要想什么双指针了。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 处理 i == 0 的情况也是需要注意的</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> nums[i] != nums[length-<span class="number">1</span>]:</span><br><span class="line">                nums[length] = nums[i]</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt;= <span class="number">1</span>) <span class="keyword">return</span> numsSize;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i] != nums[len - <span class="number">1</span>])</span><br><span class="line">            nums[len++] = nums[i];</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="27-删除元素"><a href="#27-删除元素" class="headerlink" title="27 删除元素"></a>27 删除元素</h2><p>和上一题类似，注意细节</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != val:</span><br><span class="line">                nums[length] = nums[i]</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums || numsSize == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != val)</span><br><span class="line">            nums[len++] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="28-实现-strstr-函数，即查找子串"><a href="#28-实现-strstr-函数，即查找子串" class="headerlink" title="28 实现 strstr 函数，即查找子串"></a>28 实现 strstr 函数，即查找子串</h2><p>使用暴力算法，时间复杂度 O(n)。也可以用 kmp 算法。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kmp 算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="built_in">next</span> = [<span class="number">0</span>]</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 特别注意这里的 1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(needle)):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> needle[i] != needle[j]:</span><br><span class="line">                j = <span class="built_in">next</span>[j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> needle[i] == needle[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="built_in">next</span>.append(j)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(haystack)):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> haystack[i] != needle[j]:</span><br><span class="line">                j = <span class="built_in">next</span>[j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(needle):</span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Brute Force</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strStr</span><span class="params">(<span class="type">char</span>* haystack, <span class="type">char</span>* needle)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="built_in">strlen</span>(haystack);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(needle);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// note h - n + 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h - n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (needle[j] != haystack[i+j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="29-给定连个整数，不使用乘法和除法计算除法。"><a href="#29-给定连个整数，不使用乘法和除法计算除法。" class="headerlink" title="29 给定连个整数，不使用乘法和除法计算除法。"></a>29 给定连个整数，不使用乘法和除法计算除法。</h2><p><a href="https://leetcode.com/discuss/38997/detailed-explained-8ms-c-solution">这里</a> 有一个非常好的算法</p>
<p>计算可以从被除数中减去除数的次数</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> &#123;</span><br><span class="line">    <span class="comment">// abs(INT_MIN) == INT_MAX + 1</span></span><br><span class="line">    <span class="keyword">if</span> (divisor == <span class="number">0</span> || (dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    <span class="type">int</span> sign = (dividend &gt; <span class="number">0</span>) == (divisor &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n = <span class="built_in">labs</span>(dividend);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d = <span class="built_in">labs</span>(divisor);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= d) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> temp = d;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> multi = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;= (temp &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            multi &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n -= temp;</span><br><span class="line">        result += multi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sign * result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="30-包串联所有单词的子串"><a href="#30-包串联所有单词的子串" class="headerlink" title="30 包串联所有单词的子串"></a>30 包串联所有单词的子串</h2><p>tags: #slidewindow</p>
<p>一道诡异的滑动窗口的题目，对这类问题还是不很熟啊。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;C++ 解答&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">vector&lt;<span class="built_in">int</span>&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">    unordered_map&lt;string, <span class="built_in">int</span>&gt; counts;</span><br><span class="line">    <span class="keyword">for</span> (string word : words)</span><br><span class="line">        counts[word]++;</span><br><span class="line">    <span class="built_in">int</span> n = s.length(), num = words.size(), <span class="built_in">len</span> = words[<span class="number">0</span>].size();</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; indexes;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n - num * <span class="built_in">len</span> + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        unordered_map&lt;string, <span class="built_in">int</span>&gt; seen;</span><br><span class="line">        <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; num; j++) &#123;</span><br><span class="line">            string word = s.substr(i + j * <span class="built_in">len</span>, <span class="built_in">len</span>);</span><br><span class="line">            <span class="keyword">if</span> (counts.find(word) != counts.end()) &#123;</span><br><span class="line">                seen[word]++;</span><br><span class="line">                <span class="keyword">if</span> (seen[word] &gt; counts[word])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == num)</span><br><span class="line">            indexes.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> indexes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="31-全排列，下一个"><a href="#31-全排列，下一个" class="headerlink" title="31 全排列，下一个"></a>31 全排列，下一个</h2><p>首先，对于所有的组合，最小的一个一定是按照升序排序的，最大的一定是倒过来，因此</p>
<ol>
<li>如果我们发现是完全倒序的，直接翻转就好了；</li>
<li>如果是一般情况，从后向前遍历，找到逆序的数字的边界，假设是 k。那么后边这段已经是完全<br>逆序的，无法变小了，为了保证生成的数字变大，我们再从后向前找到第一个比 k 大的数字，交<br>换这两个数字，再把后续的逆序数组翻转。</li>
</ol>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextPermutation</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 前后都是闭区间</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">nums, lo, hi</span>):</span><br><span class="line">            <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">                nums[lo], nums[hi] = nums[hi], nums[lo]</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        k = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i + <span class="number">1</span>]:</span><br><span class="line">                k = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> k == -<span class="number">1</span>:</span><br><span class="line">            reverse(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        l = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>, k, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[k]:</span><br><span class="line">                l = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        nums[l], nums[k] = nums[k], nums[l]</span><br><span class="line">        reverse(nums, k+<span class="number">1</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>; <span class="comment">// 升序排列的最后一个数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            k = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完全是逆序的，直接返回第一个，也就是升序排列</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">-1</span>; <span class="comment">// 逆序数字中比 k 大的最小的数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; k; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[k]) &#123;</span><br><span class="line">            l = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[k], nums[l]); <span class="comment">// 保证变大</span></span><br><span class="line">    <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k + <span class="number">1</span>, nums.<span class="built_in">end</span>()); <span class="comment">// 保证是下一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="32-从一个括号构成的字符串中找出最长的合法括号序列"><a href="#32-从一个括号构成的字符串中找出最长的合法括号序列" class="headerlink" title="32 从一个括号构成的字符串中找出最长的合法括号序列"></a>32 从一个括号构成的字符串中找出最长的合法括号序列</h2><p>动态规划的基础题目。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestValidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i-<span class="number">1</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span> i &gt;= <span class="number">2</span>:</span><br><span class="line">                        dp[i] = dp[i-<span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i] = <span class="number">2</span></span><br><span class="line">                <span class="keyword">elif</span> i - dp[i-<span class="number">1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> s[i-dp[i-<span class="number">1</span>]-<span class="number">1</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span> i - dp[i-<span class="number">1</span>] &gt;= <span class="number">2</span>:</span><br><span class="line">                        dp[i] = dp[i-<span class="number">1</span>] + dp[i-dp[i-<span class="number">1</span>]-<span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i] = dp[i-<span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<p>也可以使用栈来解。但是这种方法非常 tricky, 因为要考虑到 <code>()()</code> 的情况。</p>
<h2 id="33-在排序后又被反转的数组中搜索"><a href="#33-在排序后又被反转的数组中搜索" class="headerlink" title="33 在排序后又被反转的数组中搜索"></a>33 在排序后又被反转的数组中搜索</h2><p>既然是部分有序的，自然还是使用二分搜索了，注意终止条件。<br>不同于普通二分搜索的两种情况，我们有了四种情况：</p>
<ol>
<li>前半部分有序，并且在前半部分当中，</li>
<li>前半部分有序，但是不在前半部分</li>
<li>后半部分有序，并且在后半部分</li>
<li>后半部分有序，但是不在后半部分</li>
</ol>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            mi = lo + (hi - lo) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mi] == target:</span><br><span class="line">                <span class="keyword">return</span> mi</span><br><span class="line">            <span class="comment"># 这里为什么要包含等于号呢</span></span><br><span class="line">            <span class="keyword">if</span> nums[lo] &lt;= nums[mi]:</span><br><span class="line">                <span class="keyword">if</span> nums[lo] &lt;= target &lt; nums[mi]:</span><br><span class="line">                    hi = mi - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mi] &lt; target &lt;= nums[hi]:</span><br><span class="line">                    lo = mi + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    hi = mi - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// left half is sorted</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// right half is sorted</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34 在排序数组中查找元素的第一个和最后一个位置"></a>34 在排序数组中查找元素的第一个和最后一个位置</h2><p>在 C++ 的标准库中包含了这两个函数，分别是<code>std::lower_bound</code>和<code>std::upper_bound</code>.</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="function">def <span class="title">searchRange</span><span class="params">(self, nums: List[<span class="type">int</span>], target: <span class="type">int</span>)</span> -&gt; List[<span class="type">int</span>]:</span></span><br><span class="line"><span class="function">        if not nums:</span></span><br><span class="line"><span class="function">            return [<span class="number">-1</span>, <span class="number">-1</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        lo =</span> <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums)</span><br><span class="line">        lower = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = lo + (hi - lo) <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mi] &lt; target:</span><br><span class="line">                lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi</span><br><span class="line">        <span class="keyword">if</span> lo &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[lo] == target:</span><br><span class="line">            lower = lo</span><br><span class="line"></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums)</span><br><span class="line">        upper = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = lo + (hi - lo) <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mi] &lt;= target:</span><br><span class="line">                lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi</span><br><span class="line">        <span class="keyword">if</span> nums[lo<span class="number">-1</span>] == target:</span><br><span class="line">            upper = lo - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [lower, upper]</span><br></pre></td></tr></table></figure>
</details>


<h2 id="35-二分查找数字，如果没有找到，返回应该插入的位置"><a href="#35-二分查找数字，如果没有找到，返回应该插入的位置" class="headerlink" title="35 二分查找数字，如果没有找到，返回应该插入的位置"></a>35 二分查找数字，如果没有找到，返回应该插入的位置</h2><p>就是最基础的二分查找</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = lo + (hi - lo) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mi] == target:</span><br><span class="line">                <span class="keyword">return</span> mi</span><br><span class="line">            <span class="keyword">elif</span> nums[mi] &lt; target:</span><br><span class="line">                lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi</span><br><span class="line">        <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="36-合法数独，给定一个数独表，判定当前是否合法"><a href="#36-合法数独，给定一个数独表，判定当前是否合法" class="headerlink" title="36 合法数独，给定一个数独表，判定当前是否合法"></a>36 合法数独，给定一个数独表，判定当前是否合法</h2><details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        这道题的关键就在于小格子也是可以用 i 和 j 来计算的：</span></span><br><span class="line"><span class="string">        box_index = (row / 3) * 3 + columns / 3</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 特别注意浅拷贝的问题</span></span><br><span class="line">        used_i = [[<span class="number">0</span>] * <span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        used_j = [[<span class="number">0</span>] * <span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        used_k = [[<span class="number">0</span>] * <span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                piece = board[i][j]</span><br><span class="line">                <span class="keyword">if</span> piece == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                n = <span class="built_in">int</span>(piece) - <span class="number">1</span></span><br><span class="line">                k = i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span></span><br><span class="line">                <span class="keyword">if</span> used_i[i][n] <span class="keyword">or</span> used_j[j][n] <span class="keyword">or</span> used_k[k][n]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                used_i[i][n] = used_j[j][n] = used_k[k][n] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有点浪费空间</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>** board, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> used_row[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;, used_col[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;, used_box[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> num = board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> k = i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span> (used_row[i][num] || used_col[j][num] || used_box[k][num])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                used_row[i][num] = used_col[j][num] = used_box[k][num] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="37-求解数独"><a href="#37-求解数独" class="headerlink" title="37 求解数独"></a>37 求解数独</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>(board, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> ind)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ind==<span class="number">81</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> i=ind/<span class="number">9</span>, j=ind%<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span>(board[i][j]!=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">solve</span>(board, ind+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> f = <span class="string">&#x27;1&#x27;</span>; f &lt;= <span class="string">&#x27;9&#x27;</span>; f++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValidFill</span>(board, i, j, f)) &#123;</span><br><span class="line">                board[i][j]= f;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">solve</span>(board, ind+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                board[i][j]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidFill</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span> fill)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">9</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i][k]==fill) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//check the row</span></span><br><span class="line">        <span class="keyword">if</span>(board[k][j]==fill) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//check the column</span></span><br><span class="line">        <span class="type">int</span> r= i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>;   <span class="comment">//select the block</span></span><br><span class="line">        <span class="keyword">if</span>(board[r/<span class="number">3</span>*<span class="number">3</span>+k/<span class="number">3</span>][r%<span class="number">3</span>*<span class="number">3</span>+k%<span class="number">3</span>]==fill) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//check the block</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="38-数数并说出来"><a href="#38-数数并说出来" class="headerlink" title="38 数数并说出来"></a>38 数数并说出来</h2><p>不太理解这道题有什么意义，直接暴力做出来了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    string result = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n <span class="number">-1</span>; i++) &#123;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; result.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j + <span class="number">1</span> &lt; result.<span class="built_in">size</span>() &amp;&amp; result[j+<span class="number">1</span>] == result[j]) &#123;</span><br><span class="line">                j++; count++;</span><br><span class="line">            &#125;</span><br><span class="line">            temp += count + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            temp += result[j];</span><br><span class="line">        &#125;</span><br><span class="line">        result = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="39-给定一个集合，在集合中找出和为-target-的数字，数字可以使用多次，集合中没有重复数字"><a href="#39-给定一个集合，在集合中找出和为-target-的数字，数字可以使用多次，集合中没有重复数字" class="headerlink" title="39 给定一个集合，在集合中找出和为 target 的数字，数字可以使用多次，集合中没有重复数字"></a>39 给定一个集合，在集合中找出和为 target 的数字，数字可以使用多次，集合中没有重复数字</h2><p>典型的深度优先搜索</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">dfs</span>(result, candidates, &#123;&#125;, target);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt;&amp; candidates, vector&lt;<span class="type">int</span>&gt; comb, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(comb);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : candidates) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; target) <span class="keyword">continue</span>; <span class="comment">// 数字太大了</span></span><br><span class="line">        <span class="keyword">if</span> (!comb.<span class="built_in">empty</span>() &amp;&amp; c &lt; comb.<span class="built_in">back</span>()) <span class="keyword">continue</span>; <span class="comment">// 保证不重复且升序</span></span><br><span class="line">        comb.<span class="built_in">push_back</span>(c);</span><br><span class="line">        <span class="built_in">dfs</span>(result, candidates, comb, target - c);</span><br><span class="line">        comb.<span class="built_in">pop_back</span>(); <span class="comment">// 注意此处还需要弹出，因为需要循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="40-同上题一样，但是集合中的数字只能使用一次，并且集合中有重复数字"><a href="#40-同上题一样，但是集合中的数字只能使用一次，并且集合中有重复数字" class="headerlink" title="40 同上题一样，但是集合中的数字只能使用一次，并且集合中有重复数字"></a>40 同上题一样，但是集合中的数字只能使用一次，并且集合中有重复数字</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">dfs</span>(result, candidates, &#123;&#125;, target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt;&amp; candidates, vector&lt;<span class="type">int</span>&gt; comb, <span class="type">int</span> target, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(comb);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidates[i] &gt; target)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i != start &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        comb.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">        <span class="built_in">dfs</span>(result, candidates, comb, target - candidates[i], i + <span class="number">1</span>);</span><br><span class="line">        comb.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="41-给定一个数组，找到第一个缺失的正数"><a href="#41-给定一个数组，找到第一个缺失的正数" class="headerlink" title="41 给定一个数组，找到第一个缺失的正数"></a>41 给定一个数组，找到第一个缺失的正数</h2><p>显然，结果的范围是 [1..n+1]. 而数组的长度为 n 我们把每个位置都放上 i+1,<br>这样如果有位置不是 i+1, 则找到了结果，如果都相等则是 n+1.</p>
<details>
    <summary>c 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *a; *a = *b; *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        <span class="comment">// 注意此处的 while</span></span><br><span class="line">        <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= numsSize &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>])</span><br><span class="line">            swap(&amp;nums[i], &amp;nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numsSize + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="42-给定一个数组表示柱子的高度，求能存贮的雨水的总量"><a href="#42-给定一个数组表示柱子的高度，求能存贮的雨水的总量" class="headerlink" title="42 给定一个数组表示柱子的高度，求能存贮的雨水的总量"></a>42 给定一个数组表示柱子的高度，求能存贮的雨水的总量</h2><p>从两边向中间收拢</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>* height, <span class="type">int</span> heightSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = heightSize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_left = <span class="number">0</span>, max_right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从两侧向中间缩小，可以算作是两个指针吧</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt;= height[right]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[left] &gt;= max_left)</span><br><span class="line">                max_left = height[left];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                water += max_left - height[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[right] &gt;= max_right)</span><br><span class="line">                max_right = height[right];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                water += max_right - height[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> water;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trap</span>(height: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> height.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">left</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">right</span> = height.<span class="title function_ invoke__">len</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">water</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max_left</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max_right</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right &#123;</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt;= height[right] &#123;</span><br><span class="line">                <span class="keyword">if</span> height[left] &gt;= max_left &#123;</span><br><span class="line">                    max_left = height[left];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    water += max_left - height[left];</span><br><span class="line">                &#125;</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> height[right] &gt;= max_right &#123;</span><br><span class="line">                    max_right = height[right];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    water += max_right - height[right];</span><br><span class="line">                &#125;</span><br><span class="line">                right -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        water</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
t

<h2 id="43-给定两个任意长的字符串，返回一个字符串，代表他们相乘的结果"><a href="#43-给定两个任意长的字符串，返回一个字符串，代表他们相乘的结果" class="headerlink" title="43 给定两个任意长的字符串，返回一个字符串，代表他们相乘的结果"></a>43 给定两个任意长的字符串，返回一个字符串，代表他们相乘的结果</h2><p>按整数除法运算即可，重点是下标的表示</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> tonum(c) (c - <span class="string">&#x27;0&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tochar(i) (i + <span class="string">&#x27;0&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">multiply</span><span class="params">(<span class="type">char</span>* num1, <span class="type">char</span>* num2)</span> &#123;</span><br><span class="line">    <span class="comment">// 结果的长度不会超过 m+n,</span></span><br><span class="line">    <span class="comment">// 假设某个数是 n 位的 9, 则结果比另一个数结尾加上 n 个 0 还小</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(num1), m = <span class="built_in">strlen</span>(num2);</span><br><span class="line">    <span class="type">int</span> len = m+n;</span><br><span class="line">    <span class="type">char</span>* result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        result[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    result[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> v = tonum(result[i+j+<span class="number">1</span>]) +  tonum(num1[i]) * tonum(num2[j]) + carry;</span><br><span class="line">            result[i+j+<span class="number">1</span>] = tochar(v % <span class="number">10</span>);</span><br><span class="line">            carry = v / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result[i] += carry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (result[i] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> result+i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="44-通配符匹配，-代表任意一个字符，-代表任意一个或多个字符"><a href="#44-通配符匹配，-代表任意一个字符，-代表任意一个或多个字符" class="headerlink" title="44 通配符匹配，? 代表任意一个字符，*代表任意一个或多个字符"></a>44 通配符匹配，<code>?</code> 代表任意一个字符，<code>*</code>代表任意一个或多个字符</h2><p>注意和正则表达式的区别，要求完全匹配。这道题的关键在于对星号的处理，如果出现星号的时候，我们记录当时的 p 和 s 的值，如果发生了不匹配的话，我们尝试回到该位置的下一个位置开始匹配</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isMatch</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* p)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* star = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>* revert = s;</span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s == *p || *p == <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            s++, p++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            star = p++, revert = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (star)</span><br><span class="line">            p = star + <span class="number">1</span>, s = ++revert;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果剩下了 p, 那应该全都是*才对</span></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p++ != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="45-跳跃游戏，给定一个数组，每个数字是在该位置可以向前移动的距离，返回最少需要多少次才能到达终点"><a href="#45-跳跃游戏，给定一个数组，每个数字是在该位置可以向前移动的距离，返回最少需要多少次才能到达终点" class="headerlink" title="45 跳跃游戏，给定一个数组，每个数字是在该位置可以向前移动的距离，返回最少需要多少次才能到达终点"></a>45 跳跃游戏，给定一个数组，每个数字是在该位置可以向前移动的距离，返回最少需要多少次才能到达终点</h2><p>比较简单，看注释吧</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> last = <span class="number">0</span>; <span class="comment">// last range</span></span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>; <span class="comment">// current range</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="comment">// beyond range, make another jump</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; last)</span><br><span class="line">            last = cur, steps++;</span><br><span class="line">        <span class="comment">// if we could reach longer?</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] + i &gt; cur)</span><br><span class="line">            cur = nums[i] + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="46-生成全排列"><a href="#46-生成全排列" class="headerlink" title="46 生成全排列"></a>46 生成全排列</h2><p>Cracking 上给出了一种解法，通过不断的添加下一个元素到上一组元素的不同位置来生成全排列，这样固然可以，但是大规模的拼接数组或者字符串是很耗费资源的。</p>
<p>在已经有了字符串（或者数组）的初始排列以后，可以通过不断交换的方法生成每一组全排列。<br>比如对于 xyz，我们有全排列为</p>
<pre><code>x + per(yx)
y + per(xz)
z + per(xy)
</code></pre>
<p>那么我们通过把每个元素交换到第一个位置，就把问题规模缩小了，知道把问题规模缩小为 1.</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">per</span>(result, nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">per</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> begin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意是从 begin 开始，这样未改变的才能加入进来</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[begin], nums[i]);</span><br><span class="line">        <span class="built_in">per</span>(result, nums, begin + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">swap</span>(nums[begin], nums[i]); <span class="comment">// 注意因为参数中是传引用，这里需要复原</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">permute</span>(nums: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt; = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">per</span>(&amp;<span class="keyword">mut</span> result, nums, <span class="number">0</span>);</span><br><span class="line">        result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">per</span>(result: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt;, nums: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;, begin: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> begin &gt;= nums.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">            result.<span class="title function_ invoke__">push</span>(nums);</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> begin..nums.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = nums.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">            nums.<span class="title function_ invoke__">swap</span>(begin, i);</span><br><span class="line">            <span class="keyword">Self</span>::<span class="title function_ invoke__">per</span>(result, nums, begin + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="47-全排列，数组中有重复元素"><a href="#47-全排列，数组中有重复元素" class="headerlink" title="47 全排列，数组中有重复元素"></a>47 全排列，数组中有重复元素</h2><p>和上一题基本是一样的，注意跳过重复元素就好了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">per</span>(result, nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">per</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start != i &amp;&amp; nums[start] == nums[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">swap</span>(nums[start], nums[i]);</span><br><span class="line">        <span class="built_in">per</span>(result, nums, start + <span class="number">1</span>); <span class="comment">// 事实证明，传引用反倒会超时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="48-给定一个n-n的图像旋转图像，顺时针旋转-90-度"><a href="#48-给定一个n-n的图像旋转图像，顺时针旋转-90-度" class="headerlink" title="48 给定一个n*n的图像旋转图像，顺时针旋转 90 度"></a>48 给定一个<code>n*n</code>的图像旋转图像，顺时针旋转 90 度</h2><p>做法显然是从里到外，一层一层的旋转，这道题主要考察下标的操作</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> layer = <span class="number">0</span>; layer &lt; n / <span class="number">2</span>; layer++) &#123;</span><br><span class="line">        <span class="type">int</span> first  = layer;</span><br><span class="line">        <span class="type">int</span> last = n - <span class="number">1</span> - layer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = first; i &lt; last; i++) &#123;</span><br><span class="line">            <span class="type">int</span> offset = i - first;</span><br><span class="line">            <span class="type">int</span> top = matrix[first][i];</span><br><span class="line">            <span class="comment">// up &lt;- left</span></span><br><span class="line">            matrix[first][i] = matrix[last-offset][first];</span><br><span class="line">            <span class="comment">// left &lt;- down</span></span><br><span class="line">            matrix[last-offset][first] = matrix[last][last-offset];</span><br><span class="line">            <span class="comment">// down &lt;- right</span></span><br><span class="line">            matrix[last][last-offset] = matrix[i][last];</span><br><span class="line">            <span class="comment">// right &lt;- up</span></span><br><span class="line">            matrix[i][last] = top;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="49-给定字符数组，把他们按照-Anagram-分组"><a href="#49-给定字符数组，把他们按照-Anagram-分组" class="headerlink" title="49 给定字符数组，把他们按照 Anagram 分组"></a>49 给定字符数组，把他们按照 Anagram 分组</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Anagram 分组</span></span><br><span class="line"><span class="comment">// 这道题没什么可做的，只需要统计</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    string temp;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; records;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        temp = strs[i];</span><br><span class="line">        <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">        records[temp].<span class="built_in">push_back</span>(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; record : records) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(record.second.<span class="built_in">begin</span>(), record.second.<span class="built_in">end</span>());</span><br><span class="line">        result.<span class="built_in">push_back</span>(record.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="50-实现-pow-x-n"><a href="#50-实现-pow-x-n" class="headerlink" title="50 实现 pow(x, n)"></a>50 实现 pow(x, n)</h2><p>显然不能直接阶乘过去，分治法</p>
<p>递归做法</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// recursive</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == INT_MIN) <span class="keyword">return</span> myPow(x, n - <span class="number">1</span>) * x;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> / myPow(x, -n);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">double</span> y = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">0x1</span>)</span><br><span class="line">        <span class="keyword">return</span> y * y * x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> y * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>迭代做法</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iteratively</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> p)</span> &#123;</span><br><span class="line">    <span class="type">double</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span> / myPow(x, -p);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            result *= x;</span><br><span class="line">        x *= x;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="51-N-皇后问题"><a href="#51-N-皇后问题" class="headerlink" title="51 N 皇后问题"></a>51 N 皇后问题</h2><p>需要大幅度修改</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// N 皇后问题，皇后不能再一条直线，一条竖线，一条斜线上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用深度优先求解，对于 dfs 问题，我们首先把算法的框架写下来，然后确定这个问题的限制条件</span></span><br><span class="line"><span class="comment">// 对于这个问题，限制条件当前行的元素不能在以前的列中出现过，也不能在对角线中出现过</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">x</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, x, n);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> t, vector&lt;<span class="type">int</span>&gt;&amp; x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当新添加一个 Q 到当前解的时候</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) &#123;</span><br><span class="line">        <span class="comment">// result.push_back(make_solution(x));</span></span><br><span class="line">        <span class="comment">// return;</span></span><br><span class="line">        vector&lt;string&gt; solution;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="function">string <span class="title">line</span><span class="params">(n, <span class="string">&#x27;.&#x27;</span>)</span></span>;</span><br><span class="line">            line[x[i]] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            solution.<span class="built_in">push_back</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(solution);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">bool</span> skip = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x[j] == i || <span class="built_in">abs</span>(i - x[j]) == <span class="built_in">abs</span>(t - j)) &#123;</span><br><span class="line">                    skip = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (skip) <span class="keyword">continue</span>;</span><br><span class="line">            x[t] = i;</span><br><span class="line">            <span class="built_in">dfs</span>(t+<span class="number">1</span>, x, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="52-N-皇后一共有多少个解"><a href="#52-N-皇后一共有多少个解" class="headerlink" title="52 N 皇后一共有多少个解"></a>52 N 皇后一共有多少个解</h2><p>不要直接把皇后放好，而是把占用的都记录下来，然后继续深度优先搜索</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; cols, digs1, digs2;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">total</span>(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">total</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> count, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cols.<span class="built_in">find</span>(col) != cols.<span class="built_in">end</span>()</span><br><span class="line">                || digs1.<span class="built_in">find</span>(row - col) != digs1.<span class="built_in">end</span>()</span><br><span class="line">                || digs2.<span class="built_in">find</span>(row + col) != digs2.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (row == n<span class="number">-1</span>)</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cols.<span class="built_in">insert</span>(col);</span><br><span class="line">                digs1.<span class="built_in">insert</span>(row-col);</span><br><span class="line">                digs2.<span class="built_in">insert</span>(row+col);</span><br><span class="line">                count = <span class="built_in">total</span>(row+<span class="number">1</span>, count, n);</span><br><span class="line">                cols.<span class="built_in">erase</span>(col);</span><br><span class="line">                digs1.<span class="built_in">erase</span>(row-col);</span><br><span class="line">                digs2.<span class="built_in">erase</span>(row+col);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="53-最大子序列和"><a href="#53-最大子序列和" class="headerlink" title="53 最大子序列和"></a>53 最大子序列和</h2><p>动态规划经典题目，遍历数组，如果已经当前子序列已经小于 0 了，抛弃并置 sum &#x3D; 0<br>如果比当前和更大，更新。对于一个子序列，要么使得序列和增大，要么减小。</p>
<p><code>dp[n+1] = max(dp[n], dp[n] + A[n+1])</code></p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>; i&lt; numsSize; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; m)</span><br><span class="line">            m = sum;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        current_sum = <span class="number">0</span></span><br><span class="line">        max_value = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            current_sum += i</span><br><span class="line">            max_value = <span class="built_in">max</span>(max_value, current_sum)</span><br><span class="line">            current_sum = <span class="built_in">max</span>(<span class="number">0</span>, current_sum)</span><br><span class="line">        <span class="keyword">return</span> max_value</span><br></pre></td></tr></table></figure>
</details>


<h2 id="54-顺时针螺旋打印矩阵"><a href="#54-顺时针螺旋打印矩阵" class="headerlink" title="54 顺时针螺旋打印矩阵"></a>54 顺时针螺旋打印矩阵</h2><p>一圈一圈地打印就好了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row == <span class="number">0</span> || col == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>, right = col - <span class="number">1</span>, down = row - <span class="number">1</span>, left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * row * col);</span><br><span class="line">    <span class="keyword">while</span> (top &lt;= down &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">            result[index++] = matrix[top][i];</span><br><span class="line">        top++; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = top; i &lt;= down; i++)</span><br><span class="line">            result[index++] = matrix[i][right];</span><br><span class="line">        right--; <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 注意这个 if 语句</span></span><br><span class="line">        <span class="keyword">if</span> (top &lt;= down)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = right; i &gt;= left; i--)</span><br><span class="line">                result[index++] = matrix[down][i];</span><br><span class="line">        down--; <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 注意这个 if 语句</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = down; i &gt;= top; i--)</span><br><span class="line">                result[index++] = matrix[i][left];</span><br><span class="line">        left++; <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="55-给定一个数组，每个数字表示在当前步可以移动的距离，返回是不是能够到达终点"><a href="#55-给定一个数组，每个数字表示在当前步可以移动的距离，返回是不是能够到达终点" class="headerlink" title="55 给定一个数组，每个数字表示在当前步可以移动的距离，返回是不是能够到达终点"></a>55 给定一个数组，每个数字表示在当前步可以移动的距离，返回是不是能够到达终点</h2><p>使用动态规划求解，如果当前距离大于最远距离，更新最远距离，如果已经超过了最远距离，跳出</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> reach = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize &amp;&amp; i &lt;= reach; i++)</span><br><span class="line">            reach = max(reach, nums[i] + i);</span><br><span class="line">    <span class="keyword">return</span> i == numsSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="56-合并序列，给定一组序列，把其中重叠的序列合并"><a href="#56-合并序列，给定一组序列，把其中重叠的序列合并" class="headerlink" title="56 合并序列，给定一组序列，把其中重叠的序列合并"></a>56 合并序列，给定一组序列，把其中重叠的序列合并</h2><p>这道题用 Python 做竟然比用 C++ 还要快</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">class Interval(object):</span></span><br><span class="line"><span class="string">    def __init__(self, start=0, end=0):</span></span><br><span class="line"><span class="string">        self.start = start</span></span><br><span class="line"><span class="string">        self.end= end</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">intervals</span>):</span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x.start)</span><br><span class="line">    combined = []</span><br><span class="line">    <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="keyword">if</span> combined <span class="keyword">and</span> interval.start &lt;= combined[-<span class="number">1</span>].end:</span><br><span class="line">            combined[-<span class="number">1</span>].end = <span class="built_in">max</span>(combined[-<span class="number">1</span>].end, interval.end)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            combined.append(interval)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure>
</details>


<h2 id="57-添加序列，给定一组已经排序的序列，向其中插入一个序列，需要合并的合并"><a href="#57-添加序列，给定一组已经排序的序列，向其中插入一个序列，需要合并的合并" class="headerlink" title="57 添加序列，给定一组已经排序的序列，向其中插入一个序列，需要合并的合并"></a>57 添加序列，给定一组已经排序的序列，向其中插入一个序列，需要合并的合并</h2><p>把剩余的部分都拷贝过来也不失为一种机智的做法。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, intervals, newInterval</span>):</span><br><span class="line">        ans = []</span><br><span class="line">        start, end = newInterval</span><br><span class="line">        remainder = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="comment"># 未重叠</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; y:</span><br><span class="line">                ans.append([x, y])</span><br><span class="line">            <span class="comment"># 进入重叠状态</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> end &lt; x:  <span class="comment"># 当前区间已经不重叠了</span></span><br><span class="line">                    <span class="keyword">break</span>  <span class="comment"># 找到了结尾了</span></span><br><span class="line">                start = <span class="built_in">min</span>(start, x)</span><br><span class="line">                end = <span class="built_in">max</span>(end, y)</span><br><span class="line">            remainder += <span class="number">1</span></span><br><span class="line">        ans.append([start, end])</span><br><span class="line">        ans += intervals[remainder:]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<h2 id="58-给定一个字符串，求其中最后一个单词的长度"><a href="#58-给定一个字符串，求其中最后一个单词的长度" class="headerlink" title="58 给定一个字符串，求其中最后一个单词的长度"></a>58 给定一个字符串，求其中最后一个单词的长度</h2><p>显然这道题可以用 strlen 求出长度然后从后往前数，但是，这样相当于多遍历了一次<br>直接从后往前可以保证只遍历一次</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLastWord</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> inWord = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(*s)) &#123;</span><br><span class="line">            inWord = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!inWord) &#123;</span><br><span class="line">                len = <span class="number">1</span>;</span><br><span class="line">                inWord = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="59-给定-n，把-1-2-3-…-螺旋打印到矩阵中"><a href="#59-给定-n，把-1-2-3-…-螺旋打印到矩阵中" class="headerlink" title="59 给定 n，把 1, 2, 3 … 螺旋打印到矩阵中"></a>59 给定 n，把 1, 2, 3 … 螺旋打印到矩阵中</h2><p>和上一个完全一样的思路，只是这次是打印罢了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays.</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>** <span class="title function_">generateMatrix</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>** matrix = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        matrix[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>, left = <span class="number">0</span>, down = n - <span class="number">1</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (top &lt;= down &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;=right; i++)</span><br><span class="line">            matrix[top][i] = a++;</span><br><span class="line">        top++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = top; i &lt;= down; i++) &#123;</span><br><span class="line">            matrix[i][right] = a++;</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="keyword">if</span> (top &lt;= down)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = right; i &gt;= left; i--)</span><br><span class="line">                matrix[down][i] = a++;</span><br><span class="line">        down--;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = down; i &gt;= top; i--)</span><br><span class="line">                matrix[i][left] = a++;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="60-给定-n-个数字，找出第-k-个-Permutation"><a href="#60-给定-n-个数字，找出第-k-个-Permutation" class="headerlink" title="60 给定 n 个数字，找出第 k 个 Permutation"></a>60 给定 n 个数字，找出第 k 个 Permutation</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*The logic is as follows:</span></span><br><span class="line"><span class="comment">    for n numbers the permutations can be divided to (n-1)! groups,</span></span><br><span class="line"><span class="comment">    thus k/(n-1)! indicates the index of current number,</span></span><br><span class="line"><span class="comment">    and k%(n-1)! denotes remaining sequence (to the right).</span></span><br><span class="line"><span class="comment">    We keep doing this until n reaches 0, then we get n numbers permutations that is kth.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">string <span class="title">getPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">        <span class="function">string <span class="title">s</span><span class="params">(n, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            f *= i;</span><br><span class="line">            s[i<span class="number">-1</span>] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 给定 n, 一共有 n! 个序列，f == n!</span></span><br><span class="line"></span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            f /= n - i; <span class="comment">// f /= n, f /= n - 1 ...</span></span><br><span class="line">            <span class="type">int</span> j = i + k / f;</span><br><span class="line">            <span class="type">char</span> c= s[j];</span><br><span class="line">            <span class="keyword">for</span> (;j &gt; i; j--) <span class="comment">// shift space to put `c`, actually we could use swap</span></span><br><span class="line">                s[j] = s[j<span class="number">-1</span>];</span><br><span class="line">            s[i] = c;</span><br><span class="line">            k %= f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="61-把列表旋转到倒数第-k-位"><a href="#61-把列表旋转到倒数第-k-位" class="headerlink" title="61 把列表旋转到倒数第 k 位"></a>61 把列表旋转到倒数第 k 位</h2><p>需要注意的是 k 大于列表长度的情况，这时候需要取余</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">rotateRight</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">n</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (n-&gt;next) &#123;</span><br><span class="line">        n = n-&gt;next;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n is now the tail!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k &gt;= l) k %= l;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="type">int</span> i = l - k;</span><br><span class="line">    <span class="keyword">while</span> (i--)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">    dummy.next = p-&gt;next;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    n-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="62-给定一个m-n的矩阵，有多少种方法从左上角移动到右下角"><a href="#62-给定一个m-n的矩阵，有多少种方法从左上角移动到右下角" class="headerlink" title="62 给定一个m*n的矩阵，有多少种方法从左上角移动到右下角"></a>62 给定一个<code>m*n</code>的矩阵，有多少种方法从左上角移动到右下角</h2><p>显然可以使用组合数学直接求出来解，但是容易溢出。而且这是一道经典的动态规划题目，对于<br>每个格子，可以从他的上部或者左面移动过来。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            grid[i][j] = grid[i - <span class="number">1</span>][j] + grid[i][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="63-同上题，区别是在一些位置是有障碍物的"><a href="#63-同上题，区别是在一些位置是有障碍物的" class="headerlink" title="63 同上题，区别是在一些位置是有障碍物的"></a>63 同上题，区别是在一些位置是有障碍物的</h2><p>经过分析可知，递推关系是一样的，只需要把有障碍格子的到达方法设定为 0。这个主要是实现上的一些技巧，<br>见注释。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>(), n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 注意设定长宽均 +1，但是初始化为 0，边界就成了障碍</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathes</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    pathes[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 给定一个入口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++)</span><br><span class="line">            <span class="comment">// 注意此处的偏移</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="number">1</span>)</span><br><span class="line">                pathes[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pathes[i][j] = pathes[i<span class="number">-1</span>][j] + pathes[i][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> pathes[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="64-给定一个m-n矩阵，每个数字代表经过该处的耗费，找出一条耗费最小的路径"><a href="#64-给定一个m-n矩阵，每个数字代表经过该处的耗费，找出一条耗费最小的路径" class="headerlink" title="64 给定一个m*n矩阵，每个数字代表经过该处的耗费，找出一条耗费最小的路径"></a>64 给定一个<code>m*n</code>矩阵，每个数字代表经过该处的耗费，找出一条耗费最小的路径</h2><p>依然是动态规划</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if modifying the grid is disallowed, copy it</span></span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>)</span><br><span class="line">                grid[i][j] += grid[i][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                grid[i][j] += grid[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                grid[i][j] += <span class="built_in">min</span>(grid[i<span class="number">-1</span>][j], grid[i][j<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> grid[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="65-判定一个字符串是否是合法的数字，包括了正负号，小数点，e等"><a href="#65-判定一个字符串是否是合法的数字，包括了正负号，小数点，e等" class="headerlink" title="65 判定一个字符串是否是合法的数字，包括了正负号，小数点，e等"></a>65 判定一个字符串是否是合法的数字，包括了正负号，小数点，<code>e</code>等</h2><p>一些例子：</p>
<pre><code>&quot;0&quot; =&gt; true
&quot; 0.1 &quot; =&gt; true
&quot;abc&quot; =&gt; false
&quot;1 a&quot; =&gt; false
&quot;2e10&quot; =&gt; true
</code></pre>
<p>这道题就是细节题，用 C 处理字符串太蛋疼了，直接上 Python 了</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isNumber</span>(<span class="params">self, s</span>):</span><br><span class="line">    BEFORE = <span class="number">0</span> <span class="comment"># before dot</span></span><br><span class="line">    AFTER = <span class="number">1</span> <span class="comment"># after dot</span></span><br><span class="line">    EXP = <span class="number">2</span> <span class="comment"># after e</span></span><br><span class="line">    phase = BEFORE</span><br><span class="line">    allow_sign = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    s = s.strip()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">any</span>([c.isdigit() <span class="keyword">for</span> c <span class="keyword">in</span> s]):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> s[-<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> s == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> <span class="keyword">and</span> s[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> <span class="keyword">and</span> s[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">            allow_sign = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">            allow_sign = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> phase == EXP <span class="keyword">or</span> phase == AFTER:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                phase = AFTER</span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> phase == EXP:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            allow_sign = <span class="literal">True</span></span><br><span class="line">            phase = EXP</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;-&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> allow_sign:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            allow_sign = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> phase == EXP:</span><br><span class="line">        <span class="keyword">return</span> s[-<span class="number">1</span>].isdigit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="66-给定一个字符串代表的数字，返回加-1-后的数字"><a href="#66-给定一个字符串代表的数字，返回加-1-后的数字" class="headerlink" title="66 给定一个字符串代表的数字，返回加 1 后的数字"></a>66 给定一个字符串代表的数字，返回加 1 后的数字</h2><p>乍一看如果需要进位的话，可能需要拷贝整个数组。实际上并不需要，我们知道只有当数字是 999…999 的时候，才会使得数字的长度 +1 变为 1000…000。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = digits.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits[i] == <span class="number">9</span>) &#123;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            digits[i]++;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// trick here, we know that the number is 999...999</span></span><br><span class="line">    digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    digits.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">plus_one</span>(<span class="keyword">mut</span> digits: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">0</span>..digits.<span class="title function_ invoke__">len</span>()).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">            <span class="keyword">match</span> digits[i] &#123;</span><br><span class="line">                <span class="number">9</span> =&gt; digits[i] = <span class="number">0</span>,</span><br><span class="line">                _ =&gt; &#123;digits[i] += <span class="number">1</span>; <span class="keyword">return</span> digits&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        digits.<span class="title function_ invoke__">push</span>(<span class="number">0</span>);</span><br><span class="line">        digits</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="67-给定两个字符串代表的二进制数字，返回他们相加的和"><a href="#67-给定两个字符串代表的二进制数字，返回他们相加的和" class="headerlink" title="67 给定两个字符串代表的二进制数字，返回他们相加的和"></a>67 给定两个字符串代表的二进制数字，返回他们相加的和</h2><p>和上一题一样，按照加法定义做就好了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> tonum(c) (c - <span class="string">&#x27;0&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tochar(i) (i + <span class="string">&#x27;0&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">addBinary</span><span class="params">(<span class="type">char</span>* a, <span class="type">char</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(a), n = <span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="type">int</span> len = (m &gt; n ? m : n) + <span class="number">1</span>; <span class="comment">// strlen(c)</span></span><br><span class="line">    <span class="type">char</span>* c = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * len + <span class="number">1</span>); <span class="comment">// with ending null</span></span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="string">&#x27;0&#x27;</span>, len+<span class="number">1</span>);</span><br><span class="line">    c[len] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">         c[len-i] = tochar((i &lt;= m ? tonum(a[m-i]) : <span class="number">0</span>) ^ (i &lt;= n ? tonum(b[n-i]) : <span class="number">0</span>) ^ carry);</span><br><span class="line">         carry = ((i &lt;= m ? tonum(a[m-i]) : <span class="number">0</span>) + (i &lt;= n ? tonum(b[n-i]) : <span class="number">0</span>) + carry) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> ? c+<span class="number">1</span> : c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="68-文字对齐"><a href="#68-文字对齐" class="headerlink" title="68 文字对齐"></a>68 文字对齐</h2><p>待研究</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">fullJustify</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="type">int</span> L)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, k, l; i &lt; words.<span class="built_in">size</span>(); i += k) &#123;</span><br><span class="line">        <span class="keyword">for</span>(k = l = <span class="number">0</span>; i + k &lt; words.<span class="built_in">size</span>() <span class="keyword">and</span> l + words[i+k].<span class="built_in">size</span>() &lt;= L - k; k++) &#123;</span><br><span class="line">            l += words[i+k].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        string tmp = words[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i + k &gt;= words.<span class="built_in">size</span>()) tmp += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> tmp += <span class="built_in">string</span>((L - l) / (k - <span class="number">1</span>) + (j &lt; (L - l) % (k - <span class="number">1</span>)), <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            tmp += words[i+j+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        tmp += <span class="built_in">string</span>(L - tmp.<span class="built_in">size</span>(), <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="69-给定整数-x，求-sqrt-x"><a href="#69-给定整数-x，求-sqrt-x" class="headerlink" title="69 给定整数 x，求 sqrt(x)"></a>69 给定整数 x，求 sqrt(x)</h2><p>比较坑的是 LeetCode 要求的是 <code>y*y &lt; x</code> 的最大整数</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> EPS = x * <span class="number">0.0001</span>;</span><br><span class="line">    <span class="type">double</span> y = x / <span class="number">2</span>; <span class="comment">// initial guess</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(y * y - x) &gt; EPS) &#123;</span><br><span class="line">        y = (y + x / y) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> z = (<span class="type">long</span>) y;</span><br><span class="line">    <span class="keyword">while</span> (z * z &gt; x) z--;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="70-爬梯子，一次可以爬一步或者两步，有几种方法爬完梯子"><a href="#70-爬梯子，一次可以爬一步或者两步，有几种方法爬完梯子" class="headerlink" title="70 爬梯子，一次可以爬一步或者两步，有几种方法爬完梯子"></a>70 爬梯子，一次可以爬一步或者两步，有几种方法爬完梯子</h2><p>斐波那契数列，也可以理解为动态规划</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        t = b, b += a, a = t;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="71-简化-Unix-路径，需要处理-和多个斜杠等情况"><a href="#71-简化-Unix-路径，需要处理-和多个斜杠等情况" class="headerlink" title="71 简化 Unix 路径，需要处理., .. 和多个斜杠等情况"></a>71 简化 Unix 路径，需要处理<code>.</code>, <code>..</code> 和多个斜杠等情况</h2><p>没有什么需要注意的，主要是使用 stringstream 用作 string.split</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">simplifyPath</span><span class="params">(string&amp; path)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; dirs;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(path)</span></span>;</span><br><span class="line">    string dir;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, dir, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dir == <span class="string">&quot;.&quot;</span> || dir == <span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dir == <span class="string">&quot;..&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dirs.<span class="built_in">empty</span>())</span><br><span class="line">            dirs.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            dirs.<span class="built_in">push_back</span>(dir);</span><br><span class="line">    &#125;</span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; dir : dirs)</span><br><span class="line">        <span class="keyword">if</span> (!dir.<span class="built_in">empty</span>())</span><br><span class="line">            result += <span class="string">&quot;/&quot;</span> + dir;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">size</span>() ? result : <span class="string">&quot;/&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="72-编辑距离，允许替换，删除，插入三种操作"><a href="#72-编辑距离，允许替换，删除，插入三种操作" class="headerlink" title="72 编辑距离，允许替换，删除，插入三种操作"></a>72 编辑距离，允许替换，删除，插入三种操作</h2><p>对于两个字符串比较，往往要使用二维的动态规划。<br>使用 f[i][j] 表示 word1[1..i] 和 word2[1..j] 之间的距离。<br>see <a href="https://leetcode.com/discuss/43398/20ms-detailed-explained-c-solutions-o-n-space">here</a></p>
<p>那么：</p>
<ol>
<li><p>相等 f[i][j] &#x3D; f[i-1][j-1];</p>
</li>
<li><p>不相等</p>
<ol>
<li>替换：f[i][j] &#x3D; f[i-1][j-1] + 1;  都向前一步</li>
<li>添加：f[i][j] &#x3D; f[i][j-1] + 1; word2 向前一步</li>
<li>删除：f[i][j] &#x3D; f[i-1][j] + 1; word1 向前一步</li>
</ol>
</li>
</ol>
<p>另外使用一维数组表示二维数组还需要了解</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// unoptimized code</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = word1.<span class="built_in">length</span>(), n = word2.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>, <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j] + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// optimized</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = word1.<span class="built_in">length</span>(), n = word2.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cur</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 把剩余的字符删掉的距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        cur[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="type">int</span> pre = cur[<span class="number">0</span>];</span><br><span class="line">        cur[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = cur[i];</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                cur[i] = pre;</span><br><span class="line">            <span class="keyword">else</span> cur[i] = <span class="built_in">min</span>(pre + <span class="number">1</span>, <span class="built_in">min</span>(cur[i] + <span class="number">1</span>, cur[i - <span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// recursive code from beauty of programming</span></span><br><span class="line"><span class="comment">// TLE on LeetCode</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">minDistance</span>(&amp;word1.<span class="built_in">front</span>(), &amp;word1.<span class="built_in">back</span>(), &amp;word2.<span class="built_in">front</span>(), &amp;word2.<span class="built_in">back</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">minDistance</span>(<span class="type">char</span>* start1, <span class="type">char</span>* end1, <span class="type">char</span>* start2, <span class="type">char</span>* end2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (start1 &gt; end1)</span><br><span class="line">        <span class="keyword">return</span> start2 &gt; end2 ? <span class="number">0</span> : end2 - start2 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start2 &gt; end2)</span><br><span class="line">        <span class="keyword">return</span> start1 &gt; end1 ? <span class="number">0</span> : end1 - start1 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*start1 == *start2)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">minDistance</span>(start1 + <span class="number">1</span>, end1, start2 + <span class="number">1</span>, end2);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> t1 = <span class="built_in">minDistance</span>(start1 + <span class="number">1</span>, end1, start2 + <span class="number">1</span>, end2);</span><br><span class="line">        <span class="type">int</span> t2 = <span class="built_in">minDistance</span>(start1 + <span class="number">1</span>, end1, start2, end2);</span><br><span class="line">        <span class="type">int</span> t3 = <span class="built_in">minDistance</span>(start1, end1, start2 + <span class="number">1</span>, end2);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(t1, <span class="built_in">min</span>(t2, t3)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="73-给定一个矩阵，如果某个元素为零，把所在的行和所在的列都设为零"><a href="#73-给定一个矩阵，如果某个元素为零，把所在的行和所在的列都设为零" class="headerlink" title="73 给定一个矩阵，如果某个元素为零，把所在的行和所在的列都设为零"></a>73 给定一个矩阵，如果某个元素为零，把所在的行和所在的列都设为零</h2><p>一种可以接受的方法是使用 O(m+n) 的空间，记录哪行哪列需要设为零</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">row</span><span class="params">(m)</span>, <span class="title">column</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                row[i] = <span class="literal">true</span>, column[j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (row[i] || column[j])</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="74-搜索矩阵，矩阵每行从左到右依次增大，每行都比上一行大"><a href="#74-搜索矩阵，矩阵每行从左到右依次增大，每行都比上一行大" class="headerlink" title="74 搜索矩阵，矩阵每行从左到右依次增大，每行都比上一行大"></a>74 搜索矩阵，矩阵每行从左到右依次增大，每行都比上一行大</h2><p>当做数组直接二分搜索就可以了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = row * col - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix[mid/col][mid%col] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[mid/col][mid%col] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="75-颜色排序，每个物体有颜色属性，把他们按照-RGB-的顺序排序-🇳🇱国旗问题）"><a href="#75-颜色排序，每个物体有颜色属性，把他们按照-RGB-的顺序排序-🇳🇱国旗问题）" class="headerlink" title="75 颜色排序，每个物体有颜色属性，把他们按照 RGB 的顺序排序 (🇳🇱国旗问题）"></a>75 颜色排序，每个物体有颜色属性，把他们按照 RGB 的顺序排序 (🇳🇱国旗问题）</h2><p>一种方法是简单地 2 pass 解法，遍历一遍计数再输出。另一种方法是把红色往前交换，蓝色往后交换</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *a; *a = *b; *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> RED = <span class="number">0</span>, GREEN = <span class="number">1</span>, BLUE = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> reds = <span class="number">0</span>,  blues = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= blues; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] == BLUE &amp;&amp; i &lt; blues) swap(&amp;nums[i], &amp;nums[blues--]);</span><br><span class="line">        <span class="keyword">while</span> (nums[i] == RED &amp;&amp; i &gt; reds) swap(&amp;nums[i], &amp;nums[reds++]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>76 跳过</p>
<h2 id="77-给定数字-n-和-k，生成从-n-中取出-k-个数字的所有情况"><a href="#77-给定数字-n-和-k，生成从-n-中取出-k-个数字的所有情况" class="headerlink" title="77 给定数字 n 和 k，生成从 n 中取出 k 个数字的所有情况"></a>77 给定数字 n 和 k，生成从 n 中取出 k 个数字的所有情况</h2><p>数学上的组合，使用回溯来做，对状态空间进行深度搜索。</p>
<p>回溯方法通常适合对状态空间树的深度优先搜索相结合的，当一个解已经不满足条件时，剪枝；<br>如果满足条件，直到找到完全解未知。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组合是不要求顺序的</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; k)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">0</span>, k)</span></span>;</span><br><span class="line">    <span class="built_in">combine</span>(result, temp, <span class="number">0</span>, <span class="number">0</span>, n, k);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">combine</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt;&amp; temp, <span class="type">int</span> start, <span class="type">int</span> count, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 回溯条件，找到了一个解</span></span><br><span class="line">    <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 深度优先搜索</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; n; i++) &#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 只搜索比 i 大的即可</span></span><br><span class="line">        <span class="built_in">combine</span>(result, temp, i+ <span class="number">1</span>, count+<span class="number">1</span>, n, k);</span><br><span class="line">        temp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="78-给定一个集合，找到它的所有子集"><a href="#78-给定一个集合，找到它的所有子集" class="headerlink" title="78 给定一个集合，找到它的所有子集"></a>78 给定一个集合，找到它的所有子集</h2><p>这道题至少有 3 种解法：</p>
<ol>
<li>DFS，我们知道对于 n 个元素的集合，有 2^n 个子集，通过每个元素在不在子集中构造一个状态空间树</li>
<li>类似于电话键盘生成字母，迭代</li>
<li>巧妙的利用 1..2^n 对应</li>
</ol>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// use backtracking and do a dfs search</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="built_in">subsets</span>(nums, result, temp, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for each solution, the can be divided into two sub solutions: in or out</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">subsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt; temp, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t = temp;</span><br><span class="line">    <span class="built_in">subsets</span>(nums, result, temp, i + <span class="number">1</span>);</span><br><span class="line">    temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">    <span class="built_in">subsets</span>(nums, result, temp, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iterative</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    result.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, nums[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> size = result.<span class="built_in">size</span>(); <span class="comment">// notice the cached size</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> new_subset = result[j];</span><br><span class="line">            new_subset.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">sort</span>(new_subset.<span class="built_in">begin</span>(), new_subset.<span class="built_in">end</span>());</span><br><span class="line">            result.<span class="built_in">push_back</span>(new_subset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tricky</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="type">int</span> size = (<span class="number">1</span> &lt;&lt; nums.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; subset;</span><br><span class="line">        <span class="type">int</span> k = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &amp; <span class="number">0x1</span>)</span><br><span class="line">                subset.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(subset.<span class="built_in">begin</span>(), subset.<span class="built_in">end</span>());</span><br><span class="line">        result.<span class="built_in">push_back</span>(subset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="79-给定一个二维字符数组，查找一个单词是否能够有连续的字母构成，不能交叉"><a href="#79-给定一个二维字符数组，查找一个单词是否能够有连续的字母构成，不能交叉" class="headerlink" title="79 给定一个二维字符数组，查找一个单词是否能够有连续的字母构成，不能交叉"></a>79 给定一个二维字符数组，查找一个单词是否能够有连续的字母构成，不能交叉</h2><p>也是深度优先的做法，首先找到开始的字母，然后依次向上下左右查找，注意还需要统计有没有访问过</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> row = board.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> col = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(row, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; (col, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">findNext</span>(board, word, visited, i, j, <span class="number">0</span>))</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">findNext</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string&amp; word, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == word.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (m &gt;= board.<span class="built_in">size</span>() || n &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || m &lt; <span class="number">0</span> || n &lt; <span class="number">0</span>|| visited[m][n] || board[m][n] != word[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">char</span> temp = board[m][n];</span><br><span class="line">    board[m][n] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> exist = <span class="built_in">findNext</span>(board, word, visited, m + <span class="number">1</span>, n, i+<span class="number">1</span>) ||</span><br><span class="line">        <span class="built_in">findNext</span>(board, word, visited, m - <span class="number">1</span>, n, i+<span class="number">1</span>) ||</span><br><span class="line">        <span class="built_in">findNext</span>(board, word, visited, m, n+<span class="number">1</span>, i+<span class="number">1</span>) ||</span><br><span class="line">        <span class="built_in">findNext</span>(board, word, visited, m, n<span class="number">-1</span>, i+<span class="number">1</span>);</span><br><span class="line">    board[m][n] = temp;</span><br><span class="line">    <span class="keyword">return</span> exist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="80-从排序数组中删除重复元素，但是允许一个元素重复出现两次"><a href="#80-从排序数组中删除重复元素，但是允许一个元素重复出现两次" class="headerlink" title="80 从排序数组中删除重复元素，但是允许一个元素重复出现两次"></a>80 从排序数组中删除重复元素，但是允许一个元素重复出现两次</h2><p>巧妙地解法，和<code>i-2</code>的元素对比</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums || numsSize &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>, counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span> || nums[i] != nums[len<span class="number">-2</span>])</span><br><span class="line">            nums[len++] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="81-在被翻转的数组中查找元素，可能包含重复元素"><a href="#81-在被翻转的数组中查找元素，可能包含重复元素" class="headerlink" title="81 在被翻转的数组中查找元素，可能包含重复元素"></a>81 在被翻转的数组中查找元素，可能包含重复元素</h2><p>经典题目，还是一个二分查找问题，只是要分很多种情况</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//return m in Search in Rotated Array I</span></span><br><span class="line">        <span class="keyword">if</span> (A[left] &lt; A[mid]) &#123; <span class="comment">//left half is sorted</span></span><br><span class="line">            <span class="keyword">if</span> (A[left] &lt;= key &amp;&amp; key &lt; A[mid])</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[left] &gt; A[mid]) &#123; <span class="comment">//right half is sorted</span></span><br><span class="line">            <span class="keyword">if</span> (A[mid] &lt; key &amp;&amp; key &lt;= A[right])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// A[left] == A[mid]</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="82-从已经排序的链表中删除所有重复过的元素，只留下只出现一次的元素"><a href="#82-从已经排序的链表中删除所有重复过的元素，只留下只出现一次的元素" class="headerlink" title="82 从已经排序的链表中删除所有重复过的元素，只留下只出现一次的元素"></a>82 从已经排序的链表中删除所有重复过的元素，只留下只出现一次的元素</h2><p>考察链表操作</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;next &amp;&amp; p-&gt;next-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next-&gt;val == p-&gt;next-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">distinct</span> =</span> p-&gt;next;</span><br><span class="line">            <span class="type">int</span> dup = p-&gt;next-&gt;val;</span><br><span class="line">            <span class="keyword">while</span> (distinct &amp;&amp; distinct-&gt;val == dup) &#123;</span><br><span class="line">                distinct = distinct-&gt;next; <span class="comment">// <span class="doctag">TODO:</span> fix mem leak</span></span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;next = distinct;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="83-从已经排序的链表中删除所有重复过的元素，但是重复过的也留下一个，即，使新链表不重复"><a href="#83-从已经排序的链表中删除所有重复过的元素，但是重复过的也留下一个，即，使新链表不重复" class="headerlink" title="83 从已经排序的链表中删除所有重复过的元素，但是重复过的也留下一个，即，使新链表不重复"></a>83 从已经排序的链表中删除所有重复过的元素，但是重复过的也留下一个，即，使新链表不重复</h2><p>同样是考察链表基本操作</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy; dummy.next = head; dummy.val = head-&gt;val + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val == p-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="type">int</span> dup = p-&gt;val;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;val == dup)</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next; <span class="comment">// <span class="doctag">TODO:</span> fix mem leak</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="84-在柱状图中查找最大的矩形"><a href="#84-在柱状图中查找最大的矩形" class="headerlink" title="84 在柱状图中查找最大的矩形"></a>84 在柱状图中查找最大的矩形</h2><p>见注释</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    height.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="comment">// dummy end</span></span><br><span class="line">    <span class="type">int</span> result  =<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 总结，对于需要查找上一次最大元素的问题，可以考虑使用栈存储</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); ) &#123;</span><br><span class="line">        <span class="comment">// 当遇到更高的柱子时候，先存入堆栈</span></span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() || height[i] &gt; height[stk.<span class="built_in">top</span>()]) <span class="comment">// meet higher</span></span><br><span class="line">            stk.<span class="built_in">push</span>(i++);</span><br><span class="line">        <span class="comment">// 当遇到低一些的柱子时候，计算这些柱子到上一个更矮的柱子之间的最大举行，如果已经清空，说明之前所有柱子都更低</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// lower</span></span><br><span class="line">            <span class="type">int</span> h = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            result = <span class="built_in">max</span>(result, height[h] * (stk.<span class="built_in">empty</span>() ? i : i - stk.<span class="built_in">top</span>() <span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="85-最大的长方形"><a href="#85-最大的长方形" class="headerlink" title="85 最大的长方形"></a>85 最大的长方形</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>** matrix, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!matrix) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left[col], right[col], height[col];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; col; i++)</span><br><span class="line">        left[i] = <span class="number">0</span>, right[i] = col, height[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="type">int</span> cur_left = <span class="number">0</span>, cur_right = col;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)  <span class="comment">// 在第 j 列的高度</span></span><br><span class="line">                height[j]++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                height[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                left[j] = max(left[j], cur_left);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left[j] = <span class="number">0</span>, cur_left = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = col - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                right[j] = min(right[j], cur_right);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right[j] = col, cur_right = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            area = max(area, (right[j] - left[j]) * height[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="86-链表分区，要求把小于某个值得元素全都放到前面"><a href="#86-链表分区，要求把小于某个值得元素全都放到前面" class="headerlink" title="86 链表分区，要求把小于某个值得元素全都放到前面"></a>86 链表分区，要求把小于某个值得元素全都放到前面</h2><p>对于链表这道题很简单，分两个列表在合并就好了，问题是当我们处理类似的数组问题时，也有一种巧妙地 O(n) 的解法</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">partition</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">small</span>, *<span class="title">psmall</span> =</span> &amp;small; <span class="comment">// double dummy head</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">big</span>, *<span class="title">pbig</span> =</span> &amp;big;</span><br><span class="line">    psmall-&gt;next = pbig-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val &lt; x) &#123;</span><br><span class="line">            psmall-&gt;next = head;</span><br><span class="line">            psmall = psmall-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pbig-&gt;next = head;</span><br><span class="line">            pbig = pbig-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    psmall-&gt;next = big.next;</span><br><span class="line">    pbig-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> small.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="87-把字符串分区后，交换得到的字符串"><a href="#87-把字符串分区后，交换得到的字符串" class="headerlink" title="87 把字符串分区后，交换得到的字符串"></a>87 把字符串分区后，交换得到的字符串</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isScramble</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s1==s2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先判断字符是否一致</span></span><br><span class="line">    <span class="type">int</span> len = s1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> count[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">        count[s1[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        count[s2[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(count[i]!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(<span class="number">0</span>,i), s2.<span class="built_in">substr</span>(<span class="number">0</span>,i)) &amp;&amp; <span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(i), s2.<span class="built_in">substr</span>(i)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(<span class="number">0</span>,i), s2.<span class="built_in">substr</span>(len-i)) &amp;&amp; <span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(i), s2.<span class="built_in">substr</span>(<span class="number">0</span>,len-i)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="88-合并已排序数组，要求合并到其中一个空间较大的数组中"><a href="#88-合并已排序数组，要求合并到其中一个空间较大的数组中" class="headerlink" title="88 合并已排序数组，要求合并到其中一个空间较大的数组中"></a>88 合并已排序数组，要求合并到其中一个空间较大的数组中</h2><p>对于这种要求 in-place 的算法，从后往前往往可以解决</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* nums1, <span class="type">int</span> m, <span class="type">int</span>* nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = m + n - <span class="number">1</span>;</span><br><span class="line">    m--, n--;</span><br><span class="line">    <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[m] &gt; nums2[n]) &#123;</span><br><span class="line">            nums1[len--] = nums1[m--];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[len--] = nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[n] = nums2[n];</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="89-生成格雷码-Gray-Code"><a href="#89-生成格雷码-Gray-Code" class="headerlink" title="89 生成格雷码 (Gray Code)"></a>89 生成格雷码 (Gray Code)</h2><p>记住格雷码的生成规则</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>((i &gt;&gt; <span class="number">1</span>) ^ i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="90-由给定元素生成子集，可能包含重复元素"><a href="#90-由给定元素生成子集，可能包含重复元素" class="headerlink" title="90 由给定元素生成子集，可能包含重复元素"></a>90 由给定元素生成子集，可能包含重复元素</h2><p>使用了和手机键盘生成字符串号码类似的迭代算法，注意其中对重复元素的处理，当然也可以用 DFS 来做</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; sets;</span><br><span class="line">    sets.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 处理包含重复元素的一半需要预排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ) &#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// dup count</span></span><br><span class="line">        <span class="keyword">while</span> (count + i &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[count+i] == nums[i])</span><br><span class="line">            count++;</span><br><span class="line">        <span class="type">int</span> prev_n = sets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; prev_n; j++) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; instance = sets[j];</span><br><span class="line">            <span class="comment">// put dup element `count` times</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; count; k++) &#123;</span><br><span class="line">                instance.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                sets.<span class="built_in">push_back</span>(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i += count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="91-给定一个数组只包含-1-9，可以用-1-26-代表字母，求出从其中能都得到多少字符串"><a href="#91-给定一个数组只包含-1-9，可以用-1-26-代表字母，求出从其中能都得到多少字符串" class="headerlink" title="91 给定一个数组只包含 1-9，可以用 1-26 代表字母，求出从其中能都得到多少字符串"></a>91 给定一个数组只包含 1-9，可以用 1-26 代表字母，求出从其中能都得到多少字符串</h2><p>使用动态规划，但是注意其中 0 的处理，很玄妙</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s || <span class="built_in">strlen</span>(s) == <span class="number">0</span> || s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r1 = <span class="number">1</span>, r2 = <span class="number">1</span>; <span class="comment">// r1: 前一个字符， r2：前两个字符</span></span><br><span class="line">    <span class="type">char</span>* p = s++; <span class="comment">// 上一个字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">             r1 = <span class="number">0</span>; <span class="comment">// 0 不能单独构成字母</span></span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="string">&#x27;1&#x27;</span> || *p == <span class="string">&#x27;2&#x27;</span> &amp;&amp; *s &lt; <span class="string">&#x27;7&#x27;</span>) &#123; <span class="comment">// 形成两种可能</span></span><br><span class="line">            <span class="type">int</span> t = r1;</span><br><span class="line">            r1 = r2 + r1;</span><br><span class="line">            r2 = t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r2 = r1; <span class="comment">// 新加入的数字只能单独构成字母</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="92-在给定区间上翻转数组"><a href="#92-在给定区间上翻转数组" class="headerlink" title="92 在给定区间上翻转数组"></a>92 在给定区间上翻转数组</h2><p>同样是数组操作细节题</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseBetween</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m == n) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy, * small_node, * big_node; <span class="comment">// actually the prev ones</span></span><br><span class="line">    dummy.next = head;</span><br><span class="line">    n -= m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--m) <span class="comment">// m starts from 1, so not m--</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">start</span> =</span> p-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> start-&gt;next;</span><br><span class="line">        start-&gt;next = next-&gt;next;</span><br><span class="line">        next-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="93-恢复-IP-地址，给定一个字符串，适当插入点，一共有多少种方式构成-IP-地址"><a href="#93-恢复-IP-地址，给定一个字符串，适当插入点，一共有多少种方式构成-IP-地址" class="headerlink" title="93 恢复 IP 地址，给定一个字符串，适当插入点，一共有多少种方式构成 IP 地址"></a>93 恢复 IP 地址，给定一个字符串，适当插入点，一共有多少种方式构成 IP 地址</h2><p>又是一道 DFS 的题，注意对于字符串问题如何处理</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="built_in">restore</span>(result, s, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">restore</span><span class="params">(vector&lt;string&gt;&amp; result, string&amp; s, string restored, <span class="type">int</span> start, <span class="type">int</span> dots)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dots &gt; <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (dots == <span class="number">4</span> &amp;&amp; start == s.<span class="built_in">size</span>())</span><br><span class="line">        result.<span class="built_in">push_back</span>(restored);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start + i &gt; s.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        string part = s.<span class="built_in">substr</span>(start, i);</span><br><span class="line">        <span class="keyword">if</span> (part[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; part.<span class="built_in">size</span>() &gt; <span class="number">1</span> || i == <span class="number">3</span> &amp;&amp; <span class="built_in">stoi</span>(part) &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">restore</span>(result, s, restored + part + (dots==<span class="number">3</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;.&quot;</span>), start + i, dots + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="94-中序遍历二叉树"><a href="#94-中序遍历二叉树" class="headerlink" title="94 中序遍历二叉树"></a>94 中序遍历二叉树</h2><p>当然是使用栈了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    TreeNode* current = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() || current) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(current);</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(current-&gt;val);</span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>递归解法</p>
<details>
    <summary>go 解答</summary>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    left := inorderTraversal(root.Left)</span><br><span class="line">    right := inorderTraversal(root.Right)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(<span class="built_in">append</span>(left, root.Val), right...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="95-生成二叉树，同下题一样"><a href="#95-生成二叉树，同下题一样" class="headerlink" title="95 生成二叉树，同下题一样"></a>95 生成二叉树，同下题一样</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gen</span>(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">gen</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    vector&lt;TreeNode*&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> leftTrees = <span class="built_in">gen</span>(start, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> rightTrees = <span class="built_in">gen</span>(i + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; l : leftTrees) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : rightTrees) &#123;</span><br><span class="line">                <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                root-&gt;left = l;</span><br><span class="line">                root-&gt;right = r;</span><br><span class="line">                result.<span class="built_in">push_back</span>(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="96-给定数字-n，从-1-到-n-作为节点有多少种方式生成二叉树"><a href="#96-给定数字-n，从-1-到-n-作为节点有多少种方式生成二叉树" class="headerlink" title="96 给定数字 n，从 1 到 n 作为节点有多少种方式生成二叉树"></a>96 给定数字 n，从 1 到 n 作为节点有多少种方式生成二叉树</h2><p>这道题看似是树，实际上是一个动态规划问题。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* dp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) <span class="comment">// 依次选取第 k 个点作为根</span></span><br><span class="line">            num += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">        dp[i] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="97-给定两个字符串交叉是否能够构成第三个字符串"><a href="#97-给定两个字符串交叉是否能够构成第三个字符串" class="headerlink" title="97 给定两个字符串交叉是否能够构成第三个字符串"></a>97 给定两个字符串交叉是否能够构成第三个字符串</h2><p>这道题是一道二维的 DP 问题，因为需要对于每个字符串的每个位置用另一个字符串尝试匹配</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isInterleave</span><span class="params">(<span class="type">char</span>* s1, <span class="type">char</span>* s2, <span class="type">char</span>* s3)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l1 = <span class="built_in">strlen</span>(s1), l2 = <span class="built_in">strlen</span>(s2), l3 = <span class="built_in">strlen</span>(s3);</span><br><span class="line">    <span class="keyword">if</span> (l1 + l2 != l3) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 在 i+j 位置 s1[i] s2[j] 是否能够构成 s[i+j]</span></span><br><span class="line">    <span class="type">bool</span>** dp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>*) * (l1 + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= l1; i++)</span><br><span class="line">        dp[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * (l2 + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= l1; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= l2; j++)</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = (dp[i][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>]); <span class="comment">// 注意：赋值的优先级更高</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = (dp[i<span class="number">-1</span>][j] &amp;&amp; s1[i<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = (dp[i<span class="number">-1</span>][j] &amp;&amp; s1[i<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>] || dp[i][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[l1][l2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="98-验证二叉搜索树是否合法"><a href="#98-验证二叉搜索树是否合法" class="headerlink" title="98 验证二叉搜索树是否合法"></a>98 验证二叉搜索树是否合法</h2><p>先序遍历即可</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">valid</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">long</span> left, <span class="type">long</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="literal">NULL</span> || root-&gt;val &gt; left &amp;&amp; root-&gt;val &lt; right &amp;&amp;</span><br><span class="line">        valid(root-&gt;left, left, root-&gt;val) &amp;&amp;</span><br><span class="line">        valid(root-&gt;right, root-&gt;val, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValidBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> valid(root, INT_MIN - <span class="number">1l</span>, INT_MAX + <span class="number">1l</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="99-在二叉搜索树中有两个节点被调换了，找出这两个节点，并恢复该二叉树"><a href="#99-在二叉搜索树中有两个节点被调换了，找出这两个节点，并恢复该二叉树" class="headerlink" title="99 在二叉搜索树中有两个节点被调换了，找出这两个节点，并恢复该二叉树"></a>99 在二叉搜索树中有两个节点被调换了，找出这两个节点，并恢复该二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">first</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">second</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    traverse(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (prev &amp;&amp; prev-&gt;val &gt; root-&gt;val) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!first) first = prev;</span><br><span class="line">         second = root;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = root;</span><br><span class="line">    traverse(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recoverTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    prev = first = second = <span class="literal">NULL</span>;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">if</span> (!first) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> temp = first-&gt;val;</span><br><span class="line">    first-&gt;val = second-&gt;val;</span><br><span class="line">    second-&gt;val = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="100-判断是否是相同的树"><a href="#100-判断是否是相同的树" class="headerlink" title="100 判断是否是相同的树"></a>100 判断是否是相同的树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isSameTree</span><span class="params">(<span class="keyword">struct</span> TreeNode *p, <span class="keyword">struct</span> TreeNode *q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p == q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val</span><br><span class="line">            &amp;&amp; isSameTree(p-&gt;left, q-&gt;left)</span><br><span class="line">            &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="101-判断是不是左右对称的树"><a href="#101-判断是不是左右对称的树" class="headerlink" title="101 判断是不是左右对称的树"></a>101 判断是不是左右对称的树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">sym</span><span class="params">(<span class="keyword">struct</span> TreeNode* left, <span class="keyword">struct</span> TreeNode* right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; !right || !left &amp;&amp; right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> !left &amp;&amp; !right ||</span><br><span class="line">        left-&gt;val == right-&gt;val &amp;&amp;</span><br><span class="line">        sym(left-&gt;left, right-&gt;right) &amp;&amp;</span><br><span class="line">        sym(right-&gt;left, left-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSymmetric</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> sym(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="102-二叉树层序遍历"><a href="#102-二叉树层序遍历" class="headerlink" title="102 二叉树层序遍历"></a>102 二叉树层序遍历</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    vector&lt;TreeNode*&gt; current, next;</span><br><span class="line">    current.<span class="built_in">push_back</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!current.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        next.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; current.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;left)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;right)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;right);</span><br><span class="line">            vals.<span class="built_in">push_back</span>(current[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(vals);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="103-二叉树-ZigZag-层序遍历"><a href="#103-二叉树-ZigZag-层序遍历" class="headerlink" title="103 二叉树 ZigZag 层序遍历"></a>103 二叉树 ZigZag 层序遍历</h2><p>这道题更好的做法是使用一个栈，从而使得每行的顺序都是上一行的翻转</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    vector&lt;TreeNode*&gt; current, next;</span><br><span class="line">    current.<span class="built_in">push_back</span>(root);</span><br><span class="line">    <span class="type">bool</span> odd = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!current.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        next.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; current.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;left)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;right)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;right);</span><br><span class="line">            vals.<span class="built_in">push_back</span>(current[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!odd) <span class="built_in">reverse</span>(vals.<span class="built_in">begin</span>(), vals.<span class="built_in">end</span>());</span><br><span class="line">        odd = !odd;</span><br><span class="line">        result.<span class="built_in">push_back</span>(vals);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="104-树的最大深度"><a href="#104-树的最大深度" class="headerlink" title="104 树的最大深度"></a>104 树的最大深度</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = maxDepth(root-&gt;left), right = maxDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> (left &gt; right ?left : right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="105-从前序遍历和中序遍历生成生二叉树"><a href="#105-从前序遍历和中序遍历生成生二叉树" class="headerlink" title="105 从前序遍历和中序遍历生成生二叉树"></a>105 从前序遍历和中序遍历生成生二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">build</span><span class="params">(<span class="type">int</span>* prestart, <span class="type">int</span>* preend, <span class="type">int</span>* instart, <span class="type">int</span>* inend)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    root-&gt;val = *prestart;</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prestart == preend)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* root_inorder = instart;</span><br><span class="line">    <span class="keyword">while</span> (root_inorder &lt;= inend &amp;&amp; *root_inorder != *prestart)</span><br><span class="line">        root_inorder++;</span><br><span class="line">    <span class="type">int</span> left_len = root_inorder - instart;</span><br><span class="line">    <span class="type">int</span> right_len = inend - root_inorder;</span><br><span class="line">    <span class="keyword">if</span> (left_len &gt; <span class="number">0</span>)</span><br><span class="line">        root-&gt;left = build(prestart + <span class="number">1</span>, prestart + left_len, instart, root_inorder - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (right_len &gt; <span class="number">0</span>)</span><br><span class="line">        root-&gt;right = build(prestart + left_len + <span class="number">1</span>, preend, root_inorder + <span class="number">1</span>, inend);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// m always equals n, otherwise it&#x27;s bad input</span></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>* preorder, <span class="type">int</span> m, <span class="type">int</span>* inorder, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> build(preorder, preorder + n - <span class="number">1</span>, inorder, inorder + n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="106-从中序遍历和后序遍历生成二叉树"><a href="#106-从中序遍历和后序遍历生成二叉树" class="headerlink" title="106 从中序遍历和后序遍历生成二叉树"></a>106 从中序遍历和后序遍历生成二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">build</span><span class="params">(<span class="type">int</span>* instart, <span class="type">int</span>* inend, <span class="type">int</span>* poststart, <span class="type">int</span>* postend)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    root-&gt;val = *postend;</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (poststart == postend)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* root_inorder = instart;</span><br><span class="line">    <span class="keyword">while</span> (root_inorder &lt;= inend &amp;&amp; *root_inorder != *postend)</span><br><span class="line">        root_inorder++;</span><br><span class="line">    <span class="type">int</span> left_len = root_inorder - instart;</span><br><span class="line">    <span class="type">int</span> right_len = inend - root_inorder;</span><br><span class="line">    <span class="keyword">if</span> (left_len &gt; <span class="number">0</span>)</span><br><span class="line">        root-&gt;left = build(instart, root_inorder - <span class="number">1</span>, poststart, poststart + left_len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (right_len &gt; <span class="number">0</span>)</span><br><span class="line">        root-&gt;right = build(root_inorder + <span class="number">1</span>, inend, poststart + left_len, postend - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>* inorder, <span class="type">int</span> m, <span class="type">int</span>* postorder, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> build(inorder, inorder + n - <span class="number">1</span>, postorder, postorder +n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="107-二叉树层序遍历，但要生成翻转的遍历序列"><a href="#107-二叉树层序遍历，但要生成翻转的遍历序列" class="headerlink" title="107 二叉树层序遍历，但要生成翻转的遍历序列"></a>107 二叉树层序遍历，但要生成翻转的遍历序列</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    vector&lt;TreeNode*&gt; current, next;</span><br><span class="line">    current.<span class="built_in">push_back</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!current.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        next.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; current.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;left)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;right)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;right);</span><br><span class="line">            vals.<span class="built_in">push_back</span>(current[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(vals);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="108-把排序数组转化为二叉树"><a href="#108-把排序数组转化为二叉树" class="headerlink" title="108 把排序数组转化为二叉树"></a>108 把排序数组转化为二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">struct</span> TreeNode* <span class="title function_">bst</span><span class="params">(<span class="type">int</span>* left, <span class="type">int</span>* right)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    root-&gt;val = *mid;</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; mid)</span><br><span class="line">        root-&gt;left = bst(left, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; right)</span><br><span class="line">        root-&gt;right = bst(mid+<span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> bst(nums, nums + n <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="109-把排序列表转化为二叉树"><a href="#109-把排序列表转化为二叉树" class="headerlink" title="109 把排序列表转化为二叉树"></a>109 把排序列表转化为二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">list</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">len</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head)</span><br><span class="line">        head = head-&gt;next, l++;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">bst</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    root-&gt;left = bst(n/<span class="number">2</span>);</span><br><span class="line">    root-&gt;val = <span class="built_in">list</span>-&gt;val;</span><br><span class="line">    <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    root-&gt;right = bst(n - n / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">sortedListToBST</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span> = head;</span><br><span class="line">    <span class="keyword">return</span> bst(len(head));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110 平衡二叉树"></a>110 平衡二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">height</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = height(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> right = height(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right + <span class="number">1</span> || right &gt; left + <span class="number">1</span> || left == <span class="number">-1</span> || right == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (left &gt; right ? left : right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isBalanced</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> height(root) != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="111-二叉树最小高度"><a href="#111-二叉树最小高度" class="headerlink" title="111 二叉树最小高度"></a>111 二叉树最小高度</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = minDepth(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> right = minDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (!right) <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!left) <span class="keyword">return</span> right + <span class="number">1</span>; <span class="comment">// tricky here, 当有空节点时，不能返回 0，而是返回另一个值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (left &lt; right ? left : right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="112-二叉树中是否存在和为某个数的路径"><a href="#112-二叉树中是否存在和为某个数的路径" class="headerlink" title="112 二叉树中是否存在和为某个数的路径"></a>112 二叉树中是否存在和为某个数的路径</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">hasPathSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> sum == root-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val) ||</span><br><span class="line">        hasPathSum(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="113-接上题，把这个路径找出来"><a href="#113-接上题，把这个路径找出来" class="headerlink" title="113 接上题，把这个路径找出来"></a>113 接上题，把这个路径找出来</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> sum) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">getPaths</span>(result, path, root, sum);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPaths</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt; path, TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == root-&gt;val) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getPaths</span>(result, path, root-&gt;left, sum - root-&gt;val);</span><br><span class="line">    <span class="built_in">getPaths</span>(result, path, root-&gt;right, sum - root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="114-把二叉树扁平成列表"><a href="#114-把二叉树扁平成列表" class="headerlink" title="114 把二叉树扁平成列表"></a>114 把二叉树扁平成列表</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TreeNode* prev;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">flatten</span>(root-&gt;right);</span><br><span class="line">    <span class="built_in">flatten</span>(root-&gt;left);</span><br><span class="line">    root-&gt;right = prev;</span><br><span class="line">    root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    prev = root; <span class="comment">// last flattened element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="115-通过删掉一些字母得到子序列，问有多少种方法能够得到子序列呢"><a href="#115-通过删掉一些字母得到子序列，问有多少种方法能够得到子序列呢" class="headerlink" title="115 通过删掉一些字母得到子序列，问有多少种方法能够得到子序列呢"></a>115 通过删掉一些字母得到子序列，问有多少种方法能够得到子序列呢</h2><p>使用 DP，</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution (DP):</span></span><br><span class="line"><span class="comment"> * 我们扫描字符串 s</span></span><br><span class="line"><span class="comment"> * Path[i][j] 代表 T.substr(1...i) 在 S(1...j) 不同的子序列的数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Path[i][j] = Path[i][j-1]            (discard S[j])</span></span><br><span class="line"><span class="comment"> *              +     Path[i-1][j-1]    (S[j] == T[i] and we are going to use S[j])</span></span><br><span class="line"><span class="comment"> *                 or 0                 (S[j] != T[i] so we could not use S[j])</span></span><br><span class="line"><span class="comment"> * while Path[0][j] = 1 and Path[i][0] = 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">path</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            path[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="comment">// S</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="comment">// T</span></span><br><span class="line">                path[i][j] = path[i][j<span class="number">-1</span>] + (t[i<span class="number">-1</span>] == s[j<span class="number">-1</span>] ? path[i<span class="number">-1</span>][j<span class="number">-1</span>] : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> path[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="116-完全二叉树中把每个节点指向他这一层的右面的节点"><a href="#116-完全二叉树中把每个节点指向他这一层的右面的节点" class="headerlink" title="116 完全二叉树中把每个节点指向他这一层的右面的节点"></a>116 完全二叉树中把每个节点指向他这一层的右面的节点</h2><p>显然左节点的下一个节点是父节点的右节点，右节点的下一个节点是父节点下一个节点的左节点。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">connect</span><span class="params">(<span class="keyword">struct</span> TreeLinkNode *root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        root-&gt;right-&gt;next = root-&gt;next ? root-&gt;next-&gt;left : <span class="literal">NULL</span>;</span><br><span class="line">    connect(root-&gt;left);</span><br><span class="line">    connect(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="117-同上题，但是是任意的🌲"><a href="#117-同上题，但是是任意的🌲" class="headerlink" title="117 同上题，但是是任意的🌲"></a>117 同上题，但是是任意的🌲</h2><p>通过上一层已经被连接的 next 指针，顺序层序访问，从而连接下一层。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">connect</span><span class="params">(<span class="keyword">struct</span> TreeLinkNode *root)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span>* <span class="title">head</span> =</span> root, * prev = <span class="literal">NULL</span>, *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123; <span class="comment">// head 是每层的开始</span></span><br><span class="line">        p = head;</span><br><span class="line">        prev = head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev)</span><br><span class="line">                    prev-&gt;next = p-&gt;left;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    head = p-&gt;left;</span><br><span class="line">                prev = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev)</span><br><span class="line">                    prev-&gt;next = p-&gt;right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    head = p-&gt;right;</span><br><span class="line">                prev = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118 杨辉三角"></a>118 杨辉三角</h2><p>注意坐标关系，不要被骗了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">result</span>(n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result[i].<span class="built_in">resize</span>(i+<span class="number">1</span>);</span><br><span class="line">        result[i][<span class="number">0</span>] = result[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            result[i][j] = result[i<span class="number">-1</span>][j<span class="number">-1</span>] + result[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="119-返回杨辉三角的第-k-行"><a href="#119-返回杨辉三角的第-k-行" class="headerlink" title="119 返回杨辉三角的第 k 行"></a>119 返回杨辉三角的第 k 行</h2><p>要求只能使用 O(k) 的额外空间，比较蛋疼的是这里的 k 是从 0 计数的。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">    rowIndex++;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; row;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rowIndex; i++) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newRow</span><span class="params">(i+<span class="number">1</span>)</span></span>;</span><br><span class="line">        newRow[<span class="number">0</span>] = newRow[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            newRow[j] = row[j<span class="number">-1</span>] + row[j];</span><br><span class="line">        <span class="built_in">swap</span>(row, newRow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="120-给定一个类似杨辉三角形状的数组，求从顶部到底部的最短路径"><a href="#120-给定一个类似杨辉三角形状的数组，求从顶部到底部的最短路径" class="headerlink" title="120 给定一个类似杨辉三角形状的数组，求从顶部到底部的最短路径"></a>120 给定一个类似杨辉三角形状的数组，求从顶部到底部的最短路径</h2><p>显然是使用 DP，但是有一个问题，如果是 top down 的话，最后还需要遍历一下，而如果是 bottom up 就只需要返回 dp[0] 就好了。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(triangle.back())</span></span>; <span class="comment">// 复制最后一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> layer = triangle.<span class="built_in">size</span>() - <span class="number">2</span>; layer &gt;= <span class="number">0</span>; layer--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= layer; i++)</span><br><span class="line">            dp[i] = triangle[layer][i] + <span class="built_in">min</span>(dp[i], dp[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="121-买卖股票最佳时机，只能交易一次"><a href="#121-买卖股票最佳时机，只能交易一次" class="headerlink" title="121 买卖股票最佳时机，只能交易一次"></a>121 买卖股票最佳时机，只能交易一次</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pricesSize &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> profit = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 从前到后依次遍历，如果有更好的收益更新，或者更新 min，限制条件是先出现最小值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pricesSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; min) &#123;</span><br><span class="line">                profit = max(profit, prices[i] - min);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            min = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="122-买卖股票的最佳时机，可以做任意多比交易"><a href="#122-买卖股票的最佳时机，可以做任意多比交易" class="headerlink" title="122 买卖股票的最佳时机，可以做任意多比交易"></a>122 买卖股票的最佳时机，可以做任意多比交易</h2><p>有两种解法，一种是不断做交易，完全不考虑交易次数，这种做法不符合实际情况。<br>另一种做法是模拟交易，这样会生成最少的交易次数，结果也是对的。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span></span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; pricesSize<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (prices[i+<span class="number">1</span>]&gt;prices[i])</span><br><span class="line">            total += prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!prices) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> profit = <span class="number">0</span>;<span class="type">bool</span> buy = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> min = prices[<span class="number">0</span>], max = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pricesSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; min &amp;&amp; buy) &#123;</span><br><span class="line">            min = prices[i];</span><br><span class="line">            max = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; min &amp;&amp; buy)</span><br><span class="line">            buy = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; max &amp;&amp; !buy)</span><br><span class="line">            max = prices[i];</span><br><span class="line">        <span class="keyword">if</span> ((prices[i] &lt; max || i == pricesSize - <span class="number">1</span>) &amp;&amp; !buy)&#123;</span><br><span class="line">            profit += max - min;</span><br><span class="line">            min = prices[i];</span><br><span class="line">            max = prices[i];</span><br><span class="line">            buy = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="123-股票交易，限制只能交易两股"><a href="#123-股票交易，限制只能交易两股" class="headerlink" title="123 股票交易，限制只能交易两股"></a>123 股票交易，限制只能交易两股</h2><p>每次求解的是：卖出两股以后的最大值，刚刚买入第二股的最大值，卖出第一股时候的最大值，买入第一股时候的最大值。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> hold1 = INT_MIN, hold2 = INT_MIN;</span><br><span class="line">    <span class="type">int</span> release1 = <span class="number">0</span>, release2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : prices) &#123;</span><br><span class="line">        release2 = <span class="built_in">max</span>(release2, hold2 + i);</span><br><span class="line">        hold2 = <span class="built_in">max</span>(hold2, release1 - i);</span><br><span class="line">        release1 = <span class="built_in">max</span>(release1, hold1 + i);</span><br><span class="line">        hold1 = <span class="built_in">max</span>(hold1, -i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> release2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="124-二叉树路径最大和，路径可以从任意一个节点开始到任意一个节点结束"><a href="#124-二叉树路径最大和，路径可以从任意一个节点开始到任意一个节点结束" class="headerlink" title="124 二叉树路径最大和，路径可以从任意一个节点开始到任意一个节点结束"></a>124 二叉树路径最大和，路径可以从任意一个节点开始到任意一个节点结束</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">doSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* sum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = max(<span class="number">0</span>, doSum(root-&gt;left, sum));</span><br><span class="line">    <span class="type">int</span> right = max(<span class="number">0</span>, doSum(root-&gt;right, sum));</span><br><span class="line">    *sum = max(*sum, left+right+root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> max(left, right) + root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = INT_MIN;</span><br><span class="line">    doSum(root, &amp;sum);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>这道题是把最终答案放在了全局变量中，并采用了辅助函数的方法。全局变量中存储两条路径的和，<br>而返回值中存储当前子树中最长的单边。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.ans = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_maxPathSum</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 注意这里要取 max，以防添加了负路径</span></span><br><span class="line">        left = <span class="built_in">max</span>(<span class="number">0</span>, self._maxPathSum(root.left))</span><br><span class="line">        right = <span class="built_in">max</span>(<span class="number">0</span>, self._maxPathSum(root.right))</span><br><span class="line">        self.ans = <span class="built_in">max</span>(self.ans, left + right + root.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + root.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPathSum</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        self._maxPathSum(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
</details>



<h2 id="125-给定一个字符串，只考虑字母和数字，忽略大小写，判断是否是回文字符串"><a href="#125-给定一个字符串，只考虑字母和数字，忽略大小写，判断是否是回文字符串" class="headerlink" title="125 给定一个字符串，只考虑字母和数字，忽略大小写，判断是否是回文字符串"></a>125 给定一个字符串，只考虑字母和数字，忽略大小写，判断是否是回文字符串</h2><p>太简单了，没啥可说的</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">char</span> l = s[left], r = s[right];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalnum</span>(l) &amp;&amp; <span class="built_in">isalnum</span>(r)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(l) != <span class="built_in">tolower</span>(r))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            left++, right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(l))</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(r))</span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="127-单词梯子"><a href="#127-单词梯子" class="headerlink" title="127 单词梯子"></a>127 单词梯子</h2><p>给定梯子，和开始单词和结束单词，最少需要多少个中间单词，才能变化过去，每次只能变化一个字母</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, unordered_set&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;string&gt; beginSet, endSet, *set1, * set2;</span><br><span class="line">    beginSet.<span class="built_in">insert</span>(beginWord);</span><br><span class="line">    endSet.<span class="built_in">insert</span>(endWord);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dist = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (!beginSet.<span class="built_in">empty</span>() &amp;&amp; !endSet.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beginSet.<span class="built_in">size</span>() &lt; endSet.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            set1 = &amp;beginSet;</span><br><span class="line">            set2 = &amp;endSet;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set1 = &amp;endSet;</span><br><span class="line">            set2 = &amp;beginSet;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;string&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word : *set1) &#123; <span class="comment">// notice word in not ref</span></span><br><span class="line">            wordList.<span class="built_in">erase</span>(word);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; letter : word) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                    <span class="type">char</span> oldLetter = letter;</span><br><span class="line">                    letter = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">                    <span class="keyword">if</span> (set2-&gt;<span class="built_in">find</span>(word) != set2-&gt;<span class="built_in">end</span>())</span><br><span class="line">                        <span class="keyword">return</span> dist;</span><br><span class="line">                    <span class="keyword">if</span> (wordList.<span class="built_in">find</span>(word) != wordList.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        temp.<span class="built_in">insert</span>(word);</span><br><span class="line">                        wordList.<span class="built_in">erase</span>(word);</span><br><span class="line">                    &#125;</span><br><span class="line">                    letter = oldLetter;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dist++;</span><br><span class="line">        <span class="built_in">swap</span>(*set1, temp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="128-最长递增子序列"><a href="#128-最长递增子序列" class="headerlink" title="128 最长递增子序列"></a>128 最长递增子序列</h2><p>使用动态规划</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash; <span class="comment">// 每个元素和它们所在序列的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">find</span>(n) == hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 查找两边的元素，如果找到，把新元素合并进去</span></span><br><span class="line">            <span class="type">int</span> left = hash.<span class="built_in">find</span>(n<span class="number">-1</span>) != hash.<span class="built_in">end</span>() ? hash[n<span class="number">-1</span>] : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> right = hash.<span class="built_in">find</span>(n+<span class="number">1</span>) != hash.<span class="built_in">end</span>() ? hash[n+<span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = left + right + <span class="number">1</span>;</span><br><span class="line">            hash[n] = hash[n-left] = hash[n+right] = sum; <span class="comment">// 注意此处的更新，并不需要更新区间内的每个值，只需要更新边界即可</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="129-二叉树中只有-0-9-找出所有根节点到子节点的和"><a href="#129-二叉树中只有-0-9-找出所有根节点到子节点的和" class="headerlink" title="129 二叉树中只有 0-9 找出所有根节点到子节点的和"></a>129 二叉树中只有 0-9 找出所有根节点到子节点的和</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">10</span> + root-&gt;val;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        val += sum(root-&gt;left, x * <span class="number">10</span> + root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        val += sum(root-&gt;right, x * <span class="number">10</span> + root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> sum(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="130-把所有被包围的-O-置为-X"><a href="#130-把所有被包围的-O-置为-X" class="headerlink" title="130 把所有被包围的 O 置为 X"></a>130 把所有被包围的 O 置为 X</h2><p>使用并查集</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; m_father, m_rank;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n): <span class="built_in">m_father</span>(n), <span class="built_in">m_rank</span>(n, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_father.<span class="built_in">size</span>(); i++)</span><br><span class="line">            m_father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != m_father[x])</span><br><span class="line">            m_father[x] = <span class="built_in">find</span>(m_father[x]);</span><br><span class="line">        <span class="keyword">return</span> m_father[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_rank[x] &gt; m_rank[y]) &#123;</span><br><span class="line">            m_father[y] = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_rank[x] == m_rank[y])</span><br><span class="line">                m_rank[y]++;</span><br><span class="line">            m_father[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(n*m+<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i == <span class="number">0</span> || j == <span class="number">0</span> || i == n<span class="number">-1</span> || j == m<span class="number">-1</span>) &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                    uf.<span class="built_in">unionify</span>(i * m + j, n * m);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (board[i<span class="number">-1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.<span class="built_in">unionify</span>(i * m + j, (i - <span class="number">1</span>) * m + j);</span><br><span class="line">                    <span class="keyword">if</span> (board[i+<span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.<span class="built_in">unionify</span>(i*m+j, (i+<span class="number">1</span>)*m+j);</span><br><span class="line">                    <span class="keyword">if</span> (board[i][j<span class="number">-1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.<span class="built_in">unionify</span>(i*m+j, i*m+j<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (board[i][j+<span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.<span class="built_in">unionify</span>(i*m+j, i*m+j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (uf.<span class="built_in">find</span>(i*m+j) != uf.<span class="built_in">find</span>(n*m))</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="131-对字符串分组，是的每个字串都是回文，返回所有可能的分组"><a href="#131-对字符串分组，是的每个字串都是回文，返回所有可能的分组" class="headerlink" title="131 对字符串分组，是的每个字串都是回文，返回所有可能的分组"></a>131 对字符串分组，是的每个字串都是回文，返回所有可能的分组</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    vector&lt;string&gt; group;</span><br><span class="line">    <span class="built_in">dfs</span>(result, s, group, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; result, <span class="type">const</span> string&amp; s, vector&lt;string&gt;&amp; group, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(group);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, start, i)) &#123;</span><br><span class="line">            group.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(start, i - start + <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">dfs</span>(result, s, group, i + <span class="number">1</span>);</span><br><span class="line">            group.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[left++] != s[right--])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="132-如上题，找出最少需要分组几次"><a href="#132-如上题，找出最少需要分组几次" class="headerlink" title="132 如上题，找出最少需要分组几次"></a>132 如上题，找出最少需要分组几次</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCut</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cut</span><span class="params">(s.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>() + <span class="number">1</span>; i++)</span><br><span class="line">        cut[i] = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; i - j &gt;= <span class="number">0</span> &amp;&amp; i + j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i+j] == s[i-j]; j++)</span><br><span class="line">            cut[i+j+<span class="number">1</span>] = <span class="built_in">min</span>(cut[i+j+<span class="number">1</span>], cut[i-j] + <span class="number">1</span>); <span class="comment">// i-j -&gt; i+j 是 palindrome，所以只需要 cut[i-j] 在加上这一段就好了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; i - j + <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i + j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i+j] == s[i-j+<span class="number">1</span>]; j++)</span><br><span class="line">            cut[i+j+<span class="number">1</span>] = <span class="built_in">min</span>(cut[i+j+<span class="number">1</span>], cut[i - j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cut[s.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="133-复制有向图"><a href="#133-复制有向图" class="headerlink" title="133 复制有向图"></a>133 复制有向图</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; hash; <span class="comment">// old -&gt; new pair</span></span><br><span class="line"><span class="function">UndirectedGraphNode *<span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (hash.<span class="built_in">find</span>(node) == hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        hash[node] = <span class="keyword">new</span> <span class="built_in">UndirectedGraphNode</span>(node-&gt;label);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : node-&gt;neighbors)</span><br><span class="line">            hash[node]-&gt;neighbors.<span class="built_in">push_back</span>(<span class="built_in">cloneGraph</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134 加油站"></a>134 加油站</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>* gas, <span class="type">int</span> gasSize, <span class="type">int</span>* cost, <span class="type">int</span> costSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; gasSize; ++i) &#123;</span><br><span class="line">        sum += gas[i] - cost[i]; <span class="comment">// 从此处经过能够净增多少汽油</span></span><br><span class="line">        total += gas[i] - cost[i]; <span class="comment">// 记录总的汽油量是否是正的</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123; <span class="comment">// 如果当前汽油量已经小于 0，说明之前的节点都是不行的，到下一个节点</span></span><br><span class="line">            j = i;</span><br><span class="line">            sum = <span class="number">0</span>; <span class="comment">// 同时重新开始计数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total &gt;= <span class="number">0</span> ? j + <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="135-糖块，成绩高的需要比他身边成绩低的获得更多的糖"><a href="#135-糖块，成绩高的需要比他身边成绩低的获得更多的糖" class="headerlink" title="135 糖块，成绩高的需要比他身边成绩低的获得更多的糖"></a>135 糖块，成绩高的需要比他身边成绩低的获得更多的糖</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = ratings.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candies</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i<span class="number">-1</span>])</span><br><span class="line">            candies[i] = candies[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (ratings[i<span class="number">-1</span>] &gt; ratings[i])</span><br><span class="line">            candies[i<span class="number">-1</span>] = <span class="built_in">max</span>(candies[i] + <span class="number">1</span>, candies[i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : candies)</span><br><span class="line">        result += i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="136-找出数组中只出现一次的数字"><a href="#136-找出数组中只出现一次的数字" class="headerlink" title="136 找出数组中只出现一次的数字"></a>136 找出数组中只出现一次的数字</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++)</span><br><span class="line">        result ^= nums[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="137-一个数组中，所有数字都出现三次，除了一个数字以外，找出这个数字"><a href="#137-一个数组中，所有数字都出现三次，除了一个数字以外，找出这个数字" class="headerlink" title="137 一个数组中，所有数字都出现三次，除了一个数字以外，找出这个数字"></a>137 一个数组中，所有数字都出现三次，除了一个数字以外，找出这个数字</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用二进制计算</span></span><br><span class="line"><span class="comment">// 00-&gt;10-&gt;01-&gt;00(0-&gt;1-&gt;2-&gt;3/0)</span></span><br><span class="line"><span class="comment">// ones = ones ^ A[i]; if (twos == 1) then ones = 0</span></span><br><span class="line"><span class="comment">// twos = twos ^ A[i]; if (ones* == 1) then twos = 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        ones = (ones ^ nums[i]) &amp; ~twos;</span><br><span class="line">        twos = (twos ^ nums[i]) &amp; ~ones;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="138-复制复杂结构链表"><a href="#138-复制复杂结构链表" class="headerlink" title="138 复制复杂结构链表"></a>138 复制复杂结构链表</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     struct RandomListNode *next;</span></span><br><span class="line"><span class="comment"> *     struct RandomListNode *random;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> RandomListNode *<span class="title function_">copyRandomList</span><span class="params">(<span class="keyword">struct</span> RandomListNode *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RandomListNode</span>* <span class="title">p</span>;</span></span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">RandomListNode</span>* <span class="title">node</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> RandomListNode));</span><br><span class="line">        node-&gt;next = node-&gt;random = <span class="literal">NULL</span>; <span class="comment">// spicial notice to struct initialization in c</span></span><br><span class="line">        node-&gt;label = p-&gt;label;</span><br><span class="line">        node-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = node;</span><br><span class="line">        p = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;random)</span><br><span class="line">            p-&gt;next-&gt;random = p-&gt;random-&gt;next;</span><br><span class="line">        p = p-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RandomListNode</span> <span class="title">dummy</span>, *<span class="title">q</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = dummy.random = <span class="literal">NULL</span>;</span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        q-&gt;next = p-&gt;next;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="139-查找单词是否能组成句子"><a href="#139-查找单词是否能组成句子" class="headerlink" title="139 查找单词是否能组成句子"></a>139 查找单词是否能组成句子</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, unordered_set&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wordDict.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 动态规划，假设前 i 个字符已经匹配到了，尝试匹配 i 到 i+j，如果找到了，就匹配到了 i+j</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j]) &#123;</span><br><span class="line">                string word = s.<span class="built_in">substr</span>(j, i-j);</span><br><span class="line">                <span class="keyword">if</span> (wordDict.<span class="built_in">find</span>(word) != wordDict.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="141-列表是否有环"><a href="#141-列表是否有环" class="headerlink" title="141 列表是否有环"></a>141 列表是否有环</h2><p>slow 每次走一步，而 fast 每次走两步，因此在进入环之后，两者一定会相遇</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">hasCycle</span><span class="params">(<span class="keyword">struct</span> ListNode *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head, * fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="142-列表是否有环？如果有找到环的开始"><a href="#142-列表是否有环？如果有找到环的开始" class="headerlink" title="142 列表是否有环？如果有找到环的开始"></a>142 列表是否有环？如果有找到环的开始</h2><p>从两者出发，到两者相遇，slow 指针走了 p 步，而 fast 指针走了 2p 步，显然 fast 多走了一圈（或者多圈）。<br>设 p &#x3D; k + x, 2p &#x3D; k + x + loop -&gt; 2k + 2x &#x3D; k + x + loop -&gt; k + x &#x3D; loop -&gt; k &#x3D; loop - x，剩下的长度正好也是 k。<br>假设入口处距离起点的距离是 k，那么发生碰撞的点距离环的入口处距离也是 k，所以两个指针分别从开始和碰撞点出发匀速一定会在环的入口相遇。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">detectCycle</span><span class="params">(<span class="keyword">struct</span> ListNode *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head, * fast = head, *entry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!found &amp;&amp; fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!found) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="144-前序遍历"><a href="#144-前序遍历" class="headerlink" title="144 前序遍历"></a>144 前序遍历</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    stk.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node  = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145 二叉树的后序遍历"></a>145 二叉树的后序遍历</h2><p>参见<a href="tree.md">树的遍历</a></p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    stack&lt;TreeNode*&gt; stk, output;</span><br><span class="line">    stk.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> node = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        output.<span class="built_in">push</span>(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!output.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(output.<span class="built_in">top</span>()-&gt;val);</span><br><span class="line">        output.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146 LRU 缓存"></a>146 LRU 缓存</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> unordered_map&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;::iterator&gt;&gt; <span class="type">cache_t</span>; <span class="comment">// k: v, iter</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : <span class="built_in">m_capacity</span>(capacity) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m_cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == m_cache.<span class="built_in">end</span>())</span><br><span class="line">             <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">touch</span>(it);</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second.first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m_cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it != m_cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="built_in">touch</span>(it);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_cache.<span class="built_in">size</span>() == m_capacity) &#123;</span><br><span class="line">                m_cache.<span class="built_in">erase</span>(m_used.<span class="built_in">back</span>());</span><br><span class="line">                m_used.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            m_used.<span class="built_in">push_front</span>(key);</span><br><span class="line">        &#125;</span><br><span class="line">        m_cache[key] = &#123;value, m_used.<span class="built_in">begin</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">touch</span><span class="params">(<span class="type">cache_t</span>::iterator it)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> key = it-&gt;first;</span><br><span class="line">        m_used.<span class="built_in">erase</span>(it-&gt;second.second);</span><br><span class="line">        m_used.<span class="built_in">push_front</span>(key);</span><br><span class="line">        it-&gt;second.second = m_used.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">cache_t</span> m_cache;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; m_used;</span><br><span class="line">    <span class="type">int</span> m_capacity;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="147-链表插入排序"><a href="#147-链表插入排序" class="headerlink" title="147 链表插入排序"></a>147 链表插入排序</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">insertionSortList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> head;</span><br><span class="line">    dummy.val = INT_MIN;</span><br><span class="line">    dummy.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">iter</span> =</span> &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span> (iter-&gt;next &amp;&amp; iter-&gt;next-&gt;val &lt; p-&gt;val)</span><br><span class="line">            iter = iter-&gt;next;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pnext</span> =</span> p-&gt;next;</span><br><span class="line">        p-&gt;next = iter-&gt;next;</span><br><span class="line">        iter-&gt;next = p;</span><br><span class="line">        p = pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="148-排序链表，要求达到-O-nlogn-时间复杂度"><a href="#148-排序链表，要求达到-O-nlogn-时间复杂度" class="headerlink" title="148 排序链表，要求达到 O(nlogn) 时间复杂度"></a>148 排序链表，要求达到 O(nlogn) 时间复杂度</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">split</span><span class="params">(<span class="keyword">struct</span> ListNode* source, <span class="keyword">struct</span> ListNode** frontptr, <span class="keyword">struct</span> ListNode** backptr)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span>, * <span class="title">slow</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!source || !source-&gt;next)</span><br><span class="line">        *backptr = source;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        slow = source;</span><br><span class="line">        fast = source-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *backptr = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *frontptr = source;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">merge</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span></span><br><span class="line">    dummy.next == <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1)</span><br><span class="line">        p-&gt;next = l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l2)</span><br><span class="line">        p-&gt;next = l2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge sort</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">sortList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">front</span>, * <span class="title">back</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">    split(head, &amp;front, &amp;back);</span><br><span class="line">    front = sortList(front);</span><br><span class="line">    back = sortList(back);</span><br><span class="line">    head = merge(front, back);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="149-在同一条线上的点最多的线"><a href="#149-在同一条线上的点最多的线" class="headerlink" title="149 在同一条线上的点最多的线"></a>149 在同一条线上的点最多的线</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxPoints</span><span class="params">(vector&lt;Point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于每一个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 经过该点的直线，使用分数作为斜率，避免使用浮点数</span></span><br><span class="line">        map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; lines;</span><br><span class="line">        <span class="type">int</span> localMax = <span class="number">0</span>, overlap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; points.<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 避免重复计算</span></span><br><span class="line">            <span class="keyword">if</span> (points[j].x == points[i].x &amp;&amp; points[j].y == points[i].y) &#123;</span><br><span class="line">                overlap++; <span class="comment">// 同一个点</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> x = points[j].x - points[i].x;</span><br><span class="line">                <span class="type">int</span> y = points[j].y - points[i].y;</span><br><span class="line">                <span class="type">int</span> g = <span class="built_in">gcd</span>(x, y);</span><br><span class="line">                x /= g, y /= g; <span class="comment">// verticle case: x == 0 -&gt; (0, 1)</span></span><br><span class="line">                lines[<span class="built_in">make_pair</span>(x, y)]++;</span><br><span class="line">                localMax = <span class="built_in">max</span>(localMax, lines[<span class="built_in">make_pair</span>(x, y)]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// overlap 算在任意条线上</span></span><br><span class="line">        result = <span class="built_in">max</span>(result, localMax + overlap + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="150-后缀表达式求值"><a href="#150-后缀表达式求值" class="headerlink" title="150 后缀表达式求值"></a>150 后缀表达式求值</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_operator</span><span class="params">(<span class="type">char</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t == <span class="string">&#x27;+&#x27;</span> || t == <span class="string">&#x27;-&#x27;</span> || t == <span class="string">&#x27;*&#x27;</span> || t == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> left, <span class="type">char</span> op, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> left + right;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> left - right;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> left * right;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> left / right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; token : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_operator</span>(token[<span class="number">0</span>]) &amp;&amp; token.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> op = token[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> right_num = nums.<span class="built_in">top</span>();</span><br><span class="line">            nums.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> left_num = nums.<span class="built_in">top</span>();</span><br><span class="line">            nums.<span class="built_in">pop</span>();</span><br><span class="line">            nums.<span class="built_in">push</span>(<span class="built_in">calc</span>(left_num, op, right_num));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums.<span class="built_in">push</span>(<span class="built_in">stoi</span>(token));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="151-反转句子中的单词顺序"><a href="#151-反转句子中的单词顺序" class="headerlink" title="151 反转句子中的单词顺序"></a>151 反转句子中的单词顺序</h2><p>一般面试的时候会假定没有多余字符的，解法是</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LeetCode 需要处理多余空格：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;C 解答&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">char</span> tmp = *a; *a = *b; *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>* start, <span class="type">char</span>* end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end)</span><br><span class="line">        swap(start++, end--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trim</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* fast, *slow;</span><br><span class="line">    <span class="keyword">for</span> (fast = s; *fast !=<span class="string">&#x27;\0&#x27;</span>; fast++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(*fast)) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isspace</span>(*(fast + <span class="number">1</span>)) &amp;&amp; *(fast + <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                fast++;</span><br><span class="line">            <span class="keyword">if</span>(*(fast+<span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(slow == s)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(fast, slow++);</span><br><span class="line">    &#125;</span><br><span class="line">    *slow = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseWords</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    trim(s);</span><br><span class="line">    len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    reverse(s, s + len - <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span>* head = s, * tail =s ;</span><br><span class="line">    <span class="keyword">while</span> (*(tail + <span class="number">1</span>) != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        tail = head;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isspace</span>(*(tail + <span class="number">1</span>)) &amp;&amp; *(tail + <span class="number">1</span>) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            tail++;</span><br><span class="line">        reverse(head, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="152-最大子序列乘积"><a href="#152-最大子序列乘积" class="headerlink" title="152 最大子序列乘积"></a>152 最大子序列乘积</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; A)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = A.size();</span><br><span class="line">    <span class="type">int</span> r = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, imax = r, imin = r; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; <span class="number">0</span>)</span><br><span class="line">            swap(imax, imin);</span><br><span class="line"></span><br><span class="line">        imax = max(A[i], imax * A[i]);</span><br><span class="line">        imin = min(A[i], imin * A[i]);</span><br><span class="line"></span><br><span class="line">        r = max(r, imax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="153-在旋转数组中查找最小值"><a href="#153-在旋转数组中查找最小值" class="headerlink" title="153 在旋转数组中查找最小值"></a>153 在旋转数组中查找最小值</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>; <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[left] &gt; A[mid])</span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[right] &lt; A[mid])</span><br><span class="line">            left = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[left] &lt; A[right] ? A[left] : A[right];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="154-在旋转数组中查找最小值，可能有重复"><a href="#154-在旋转数组中查找最小值，可能有重复" class="headerlink" title="154 在旋转数组中查找最小值，可能有重复"></a>154 在旋转数组中查找最小值，可能有重复</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] &gt; A[right]) &#123; <span class="comment">// 当需要找的是 left，也就是较小的数字，使用 right 比较不需要等于号</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[right] &lt; A[mid]) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="155-设计一个栈，在普通栈的基础上支持-getmin-操作"><a href="#155-设计一个栈，在普通栈的基础上支持-getmin-操作" class="headerlink" title="155 设计一个栈，在普通栈的基础上支持 getmin 操作"></a>155 设计一个栈，在普通栈的基础上支持 getmin 操作</h2><p>解法 1: 使用额外的栈，每个值都记录一个当前最小值，浪费空间</p>
<p>解法 2: 也是使用额外的栈，但是惰性记录，只有当需要更新的时候才去记录</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; m_stk;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; m_min;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="built_in">getMin</span>())</span><br><span class="line">            m_min.<span class="built_in">push</span>(x);</span><br><span class="line">        m_stk.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_stk.<span class="built_in">top</span>() == <span class="built_in">getMin</span>())</span><br><span class="line">            m_min.<span class="built_in">pop</span>();</span><br><span class="line">        m_stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_min.<span class="built_in">empty</span>() ? INT_MAX : m_min.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<p>156-159 Locked</p>
<h2 id="160-求两个链表的交叉点"><a href="#160-求两个链表的交叉点" class="headerlink" title="160 求两个链表的交叉点"></a>160 求两个链表的交叉点</h2><p>分析题目可知，如果有一个交叉点，那么在这之后的所有点都是交叉的。这里有一个非常巧妙<br>的做法。使用两个指针，如果到达结尾就指向另一个链表，会产生一下三种情况：</p>
<ol>
<li>如果交叉点前面的节点数目相同，显然会返回正确节点。</li>
<li>如果不同假设 A 的节点为 a + c，B 的节点为 b + c，则在下一次遍历时：<br> a + c + b &#x3D;&#x3D; b + c + a，恰好到达相同部分的第一个顶点 C1</li>
<li>如果两个列表不相交，那么经过 a + b, b + a 距离后，恰好都等于 NULL</li>
</ol>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">getIntersectionNode</span><span class="params">(<span class="keyword">struct</span> ListNode *headA, <span class="keyword">struct</span> ListNode *headB)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!headA || !headB) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p1</span> =</span> headA, *p2=headB;</span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        <span class="comment">// 两个列表手尾相接，如果有一个点相同，一定会返回</span></span><br><span class="line">        <span class="comment">// a + c + b == b + c + a   --&gt; C1</span></span><br><span class="line">        <span class="comment">// a + b == b + a    --&gt; NULL</span></span><br><span class="line">        p1 = p1 ? p1-&gt;next : headB;</span><br><span class="line">        p2 = p2 ? p2-&gt;next : headA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>161 Locked</p>
<h2 id="162-找到极大值，给定一个数组，可能有多个极大值，找到任意一个即可，给定数组中-A-i-x3D-A-i-1"><a href="#162-找到极大值，给定一个数组，可能有多个极大值，找到任意一个即可，给定数组中-A-i-x3D-A-i-1" class="headerlink" title="162  找到极大值，给定一个数组，可能有多个极大值，找到任意一个即可，给定数组中 A[i] !&#x3D; A[i+1]"></a>162  找到极大值，给定一个数组，可能有多个极大值，找到任意一个即可，给定数组中 A[i] !&#x3D; A[i+1]</h2><p>题目要求在对数时间内做出来，二分搜索，如果中间的数在左半部分，就向右找。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; nums[mid + <span class="number">1</span>]) <span class="comment">// mid in left part of summit</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>                           <span class="comment">// mid in right part of summit</span></span><br><span class="line">            right= mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>163 Locked</p>
<h2 id="164-未排序数组中相差最大的两个数之间的差"><a href="#164-未排序数组中相差最大的两个数之间的差" class="headerlink" title="164 未排序数组中相差最大的两个数之间的差"></a>164 未排序数组中相差最大的两个数之间的差</h2><p>根据抽屉原理，最大差不可能小于 (max - min) &#x2F; (n - 1)。证明：如果小于，那么整个数组的大小就会小于 max - min。<br>因此我们把</p>
<h2 id="165-比较版本号大小"><a href="#165-比较版本号大小" class="headerlink" title="165 比较版本号大小"></a>165 比较版本号大小</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ver</span><span class="params">(<span class="type">const</span> string&amp; version)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : version) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(num);</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于所有这种分割符中读取数字的都需要注意最后一个</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(num); <span class="comment">// notice here</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> v1 = <span class="built_in">ver</span>(version1);</span><br><span class="line">    <span class="keyword">auto</span> v2 = <span class="built_in">ver</span>(version2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>() || i &lt; v2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> a = i &lt; v1.<span class="built_in">size</span>() ? v1[i] : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b = i &lt; v2.<span class="built_in">size</span>() ? v2[i] : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">            <span class="keyword">return</span> a &gt; b ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="166-分数生成小数"><a href="#166-分数生成小数" class="headerlink" title="166 分数生成小数"></a>166 分数生成小数</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">fractionToDecimal</span><span class="params">(<span class="type">long</span> numerator, <span class="type">long</span> denominator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numerator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    string result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 符号</span></span><br><span class="line">    <span class="keyword">if</span> (numerator &lt; <span class="number">0</span> ^ denominator &lt; <span class="number">0</span>)</span><br><span class="line">        result += <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    <span class="type">long</span> n = <span class="built_in">abs</span>(numerator), d = <span class="built_in">abs</span>(denominator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数部分</span></span><br><span class="line">    result += <span class="built_in">to_string</span>(n / d);</span><br><span class="line">    <span class="keyword">if</span> (n % d == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小数部分</span></span><br><span class="line">    result+= <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> r = n % d; r != <span class="number">0</span>; r %= d) &#123; <span class="comment">// 模拟手工除法</span></span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">count</span>(r) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.<span class="built_in">insert</span>(map[r], <span class="number">1</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            result += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map[r] = result.<span class="built_in">size</span>(); <span class="comment">// 记录对应的位置，以便插入括号</span></span><br><span class="line">        r *= <span class="number">10</span>; <span class="comment">// 从上借位</span></span><br><span class="line">        result += <span class="built_in">to_string</span>(r / d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>167 Locked</p>
<h2 id="168-生成-Excel-表格标题"><a href="#168-生成-Excel-表格标题" class="headerlink" title="168 生成 Excel 表格标题"></a>168 生成 Excel 表格标题</h2><p>注意 A 对应的是 1 而不是 0，而且数字也是从 1 开始的</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    string title;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="type">char</span> c = (n<span class="number">-1</span>) % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        n = (n<span class="number">-1</span>) / <span class="number">26</span>;</span><br><span class="line">        title = c + title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="169-给定一个数组，有一个数字的出现频率超过了一半，找出这个数字"><a href="#169-给定一个数组，有一个数字的出现频率超过了一半，找出这个数字" class="headerlink" title="169 给定一个数组，有一个数字的出现频率超过了一半，找出这个数字"></a>169 给定一个数组，有一个数字的出现频率超过了一半，找出这个数字</h2><p>非常经典的一道题，首先我们假设拿到的数字就是目标，并记录他出现的次数，如果下一个<br>数字和他不一样，那么我们减一，当次数为 0 的时候，我们知道这个数字在已经遍历过的数字<br>中出现小于一半了，这时候我们换下一个数字，最后剩下的一定是超过一半的数字。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> candidate, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span> || candidate == i) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            candidate = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>170 Locked</p>
<h2 id="171-Excel-标题转换为数字"><a href="#171-Excel-标题转换为数字" class="headerlink" title="171 Excel 标题转换为数字"></a>171 Excel 标题转换为数字</h2><p>同样，我们需要注意 A 对应的是 1，而不是 0</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">titleToNumber</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*s)</span><br><span class="line">        result = result * <span class="number">26</span> + *s++ - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="172-阶乘中能有几个-0"><a href="#172-阶乘中能有几个-0" class="headerlink" title="172 阶乘中能有几个 0"></a>172 阶乘中能有几个 0</h2><p>显然先算出阶乘数字是会溢出的，而有 0 的话，就是需要 10，也就是就需要 2 和 5，<br>显然 2 是比 5 多的。那么我们只要考虑 5 的个数就行了， 这时候需要注意，5&#x2F;15 等是算一个 5，<br>而 25&#x2F;75 包含了两个 5，所以我们计算的时候，数一遍包含 5 的（这时 25 等也被计算了），<br>然后再数一遍包含 25 的就像当于数了两次了。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> fives = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; n / i &gt; <span class="number">0</span>; i *= <span class="number">5</span>)</span><br><span class="line">        fives += n / i;</span><br><span class="line">    <span class="keyword">return</span> fives;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="173-二叉树中序遍历迭代器"><a href="#173-二叉树中序遍历迭代器" class="headerlink" title="173 二叉树中序遍历迭代器"></a>173 二叉树中序遍历迭代器</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    BSTIterator(TreeNode *root) &#123;</span><br><span class="line">        pushAll(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !m_stack.empty();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        TreeNode* temp = m_stack.top();</span><br><span class="line">        m_stack.pop();</span><br><span class="line">        pushAll(temp-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> temp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; m_stack;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">pushAll</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            m_stack.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator will be called like this:</span></span><br><span class="line"><span class="comment"> * BSTIterator i = BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174 地下城游戏"></a>174 地下城游戏</h2><p>王子在格子的左上角，需要到右下角去救公主，在过程中王子不能死掉，和机器人走路一样，使用动态规划</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculateMinimumHP</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dungeon)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> row = dungeon.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> col = dungeon[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">bloods</span>(row + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (col + <span class="number">1</span>, INT_MAX));</span><br><span class="line">    bloods[row][col<span class="number">-1</span>] = bloods[row<span class="number">-1</span>][col] = <span class="number">1</span>; <span class="comment">// 公主的两边</span></span><br><span class="line">    <span class="comment">// 从公主那里逆向推</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = col<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">             <span class="type">int</span> need = <span class="built_in">min</span>(bloods[i+<span class="number">1</span>][j], bloods[i][j+<span class="number">1</span>]) - dungeon[i][j]; <span class="comment">// 缺乏的血量 = 到达下一步最少的血量 - 这一步消耗的血量</span></span><br><span class="line">             bloods[i][j] = need &gt; <span class="number">0</span> ? need : <span class="number">1</span>; <span class="comment">// 王子的血量至少为 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bloods[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="175-178-Missing"><a href="#175-178-Missing" class="headerlink" title="175-178 Missing"></a>175-178 Missing</h2><h2 id="179-最大的数字"><a href="#179-最大的数字" class="headerlink" title="179 最大的数字"></a>179 最大的数字</h2><p>神奇的排序方法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">largestNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">num_strings</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        num_strings[i] = <span class="built_in">to_string</span>(nums[i]);</span><br><span class="line">    <span class="keyword">auto</span> comparator = [] (string&amp; s1, string&amp; s2) &#123;</span><br><span class="line">        <span class="keyword">return</span> s1 + s2 &gt; s2 + s1;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(num_strings.<span class="built_in">begin</span>(), num_strings.<span class="built_in">end</span>(), comparator);</span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num_string: num_strings)</span><br><span class="line">        result += num_string;</span><br><span class="line">    <span class="type">int</span> start = result.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (start == string::npos) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">substr</span>(start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="180-185-Missing"><a href="#180-185-Missing" class="headerlink" title="180-185 Missing"></a>180-185 Missing</h2><p>186 Locked</p>
<h2 id="187-找到所有-10-个字母唱的重复-DNA-序列"><a href="#187-找到所有-10-个字母唱的重复-DNA-序列" class="headerlink" title="187 找到所有 10 个字母唱的重复 DNA 序列"></a>187 找到所有 10 个字母唱的重复 DNA 序列</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// naive 的做法从前往后，记录字符串</span></span><br><span class="line"><span class="comment">// 观察 ATCG 四个字符的特征，并把他们编码为一个 int</span></span><br><span class="line"><span class="comment">// 十个字符正好编码在 32bit 的 int 中</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="comment">// 左移弹出老元素，求交为了只使用 30bit，求或添加新元素。</span></span><br><span class="line">        <span class="keyword">if</span> (hash[t = t &lt;&lt; <span class="number">3</span> &amp; <span class="number">0x3FFFFFFF</span> | s[i] &amp; <span class="number">0b111</span>]++ == <span class="number">1</span>) <span class="comment">// 等于 1 为了避免重复</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i - <span class="number">9</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="189-翻转树组"><a href="#189-翻转树组" class="headerlink" title="189 翻转树组"></a>189 翻转树组</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> temp = nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= numsSize) k %= numsSize;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    reverse(nums, <span class="number">0</span>, numsSize - k - <span class="number">1</span>);</span><br><span class="line">    reverse(nums, numsSize - k, numsSize - <span class="number">1</span>);</span><br><span class="line">    reverse(nums, <span class="number">0</span>, numsSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="190-翻转二进制表示"><a href="#190-翻转二进制表示" class="headerlink" title="190 翻转二进制表示"></a>190 翻转二进制表示</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(n) * <span class="number">8</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123; <span class="comment">// 31 times shift</span></span><br><span class="line">        r |= n &amp; <span class="number">0x1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        r &lt;&lt;= <span class="number">1</span>; <span class="comment">// only shift 31 times</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r |= n &amp; <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="191-数字二进制表示中-1-的个数"><a href="#191-数字二进制表示中-1-的个数" class="headerlink" title="191 数字二进制表示中 1 的个数"></a>191 数字二进制表示中 1 的个数</h2><p>我们知道 n&amp;(n-1) 会把 n 中的最后一个 1 去掉，所以循环直到 n 为 0 即可</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        n &amp;= n - <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>还可以采用查表法，对于表我们可以预先构造，或者利用上一个方法生成，对于长度过大的，我们可以分块查表。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> counts[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _get_count(n) &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        n &amp;= n<span class="number">-1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_counts</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        counts[i] = _get_count(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_count</span><span class="params">(n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="type">int</span> index = n &amp; <span class="number">0xF</span>;</span><br><span class="line">        count += counts[index];</span><br><span class="line">        n &gt;&gt;= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    init_counts();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>, _get_count(i), get_count(i));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>192-197 Missing</p>
<h2 id="198-有一排房子，每个房子中都有一定财产，但是不能偷相邻的两个房子，求能偷到的最大值"><a href="#198-有一排房子，每个房子中都有一定财产，但是不能偷相邻的两个房子，求能偷到的最大值" class="headerlink" title="198  有一排房子，每个房子中都有一定财产，但是不能偷相邻的两个房子，求能偷到的最大值"></a>198  有一排房子，每个房子中都有一定财产，但是不能偷相邻的两个房子，求能偷到的最大值</h2><p>使用 DP，对于每个房子，可以选择不偷或者前 i-1 个房子加上偷当前房子，即<code>dp[i+1] = max(dp[i], dp[i-1] + A[i])</code></p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 因为不能相邻，所以可以从相隔一个的取值</span></span><br><span class="line">    <span class="comment">// dp[n] = max(dp[n-1], dp[n-2] + A[n])</span></span><br><span class="line">    <span class="type">int</span> temp, m = <span class="number">0</span>, n = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        temp = n;</span><br><span class="line">        <span class="keyword">if</span> (m + nums[i] &gt; n)</span><br><span class="line">            n = m + nums[i];</span><br><span class="line">        m = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="199-从右边看二叉树的效果"><a href="#199-从右边看二叉树的效果" class="headerlink" title="199 从右边看二叉树的效果"></a>199 从右边看二叉树的效果</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// level order 遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node;</span><br><span class="line">        <span class="type">int</span> len = q.<span class="built_in">size</span>(); <span class="comment">// 保存为了获得最后一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">// 当前数组的最后一个元素就是最右边的元素</span></span><br><span class="line">            node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="200-找出小岛的数量"><a href="#200-找出小岛的数量" class="headerlink" title="200 找出小岛的数量"></a>200 找出小岛的数量</h2><p>采用并查集，找到最后集合的数量</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; m_father, m_rank;</span><br><span class="line">    <span class="type">int</span> m_count; <span class="comment">// sets count</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n): <span class="built_in">m_father</span>(n), <span class="built_in">m_rank</span>(n, <span class="number">0</span>), <span class="built_in">m_count</span>(n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_father.<span class="built_in">size</span>(); i++)</span><br><span class="line">            m_father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != m_father[x])</span><br><span class="line">            m_father[x] = <span class="built_in">find</span>(m_father[x]);</span><br><span class="line">        <span class="keyword">return</span> m_father[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_rank[x] &gt; m_rank[y]) &#123;</span><br><span class="line">            m_father[y] = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_rank[x] == m_rank[y])</span><br><span class="line">                m_rank[y]++;</span><br><span class="line">            m_father[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">        m_count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">char</span> LAND = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">char</span> WATER = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.<span class="built_in">empty</span>() || grid[<span class="number">0</span>].<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = grid.<span class="built_in">size</span>(), c = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(r * c + <span class="number">1</span>)</span></span>; <span class="comment">// extra element is for water</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == LAND) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != r - <span class="number">1</span> &amp;&amp; grid[i+<span class="number">1</span>][j] == LAND)</span><br><span class="line">                         uf.<span class="built_in">unionify</span>(i*c+j, (i+<span class="number">1</span>)*c+j);</span><br><span class="line">                    <span class="keyword">if</span> (j != c - <span class="number">1</span> &amp;&amp; grid[i][j+<span class="number">1</span>] == LAND)</span><br><span class="line">                         uf .<span class="built_in">unionify</span>(i*c+j, i*c+j+<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    uf.<span class="built_in">unionify</span>(i*c+j, c*r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.<span class="built_in">getCount</span>() - <span class="number">1</span>; <span class="comment">// islands + water - 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, count</span>):</span><br><span class="line">        self.count = count</span><br><span class="line">        self.parents = <span class="built_in">list</span>(<span class="built_in">range</span>(count))  <span class="comment"># 初始化时 parent 指针指向自己</span></span><br><span class="line">        self.ranks = [<span class="number">1</span>] * count  <span class="comment"># 记录每棵树的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;把 p, q 两个节点连通起来&quot;&quot;&quot;</span></span><br><span class="line">        p_root = self.find(p)</span><br><span class="line">        q_root = self.find(q)</span><br><span class="line">        <span class="keyword">if</span> p_root == q_root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.ranks[p_root] &gt; self.ranks[q_root]:</span><br><span class="line">            self.parents[q_root] = p_root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.ranks[p_root] == self.ranks[q_root]:</span><br><span class="line">                self.ranks[q_root] += <span class="number">1</span></span><br><span class="line">            self.parents[p_root] = q_root</span><br><span class="line">        self.count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;找到 p 节点的根节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> self.parents[p] != p:</span><br><span class="line">            <span class="comment"># 神奇的路径压缩</span></span><br><span class="line">            self.parents[p] = self.parents[self.parents[p]]</span><br><span class="line">            p = self.parents[p]</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_connected</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        p_root = self.find(p)</span><br><span class="line">        q_root = self.find(q)</span><br><span class="line">        <span class="keyword">return</span> p_root == q_root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        uf = UnionFind(m * n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    up = <span class="built_in">max</span>(i - <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">if</span> grid[up][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                        uf.union(i * n + j, up * n + j)</span><br><span class="line">                    left = <span class="built_in">max</span>(j - <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">if</span> grid[i][j - <span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                        uf.union(i * n + j, i * n + left)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    uf.union(i * n + j, m * n)</span><br><span class="line">        <span class="keyword">return</span> uf.count - <span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="201-给定区间内，所有数字-AND-的结果"><a href="#201-给定区间内，所有数字-AND-的结果" class="headerlink" title="201 给定区间内，所有数字 AND 的结果"></a>201 给定区间内，所有数字 AND 的结果</h2><p>显然直接过一遍是会超时的，那么分析可知</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果两个数不相等，一定是有不同的位，那么这一位一定为 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m != n) &#123;</span><br><span class="line">        t++;</span><br><span class="line">        m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m &lt;&lt; t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="202-快乐数字，各位数字平方相加得到下一个数字，如果最后等于-1"><a href="#202-快乐数字，各位数字平方相加得到下一个数字，如果最后等于-1" class="headerlink" title="202 快乐数字，各位数字平方相加得到下一个数字，如果最后等于 1"></a>202 快乐数字，各位数字平方相加得到下一个数字，如果最后等于 1</h2><p>没啥，一直算就可以了。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="type">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            next += (n%<span class="number">10</span>) * (n%<span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="203-删除链表中给定的值"><a href="#203-删除链表中给定的值" class="headerlink" title="203 删除链表中给定的值"></a>203 删除链表中给定的值</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;val == val) &#123; <span class="comment">// not forward here</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> p-&gt;next;</span><br><span class="line">            p-&gt;next = next-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="204-找出素数"><a href="#204-找出素数" class="headerlink" title="204 找出素数"></a>204 找出素数</h2><p>什么筛子，忘了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">primes</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    primes[<span class="number">0</span>] = primes[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt; n; i++) <span class="comment">// 注意，只到 sqrt(n)</span></span><br><span class="line">        <span class="keyword">if</span> (primes[i])</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt; n; j += i) <span class="comment">// 从 i * i 开始，因为 i* i-- 已经被杀过了</span></span><br><span class="line">                primes[j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (primes[i])</span><br><span class="line">            count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="205-同构字符串，可以看作-word-pattern-的简化"><a href="#205-同构字符串，可以看作-word-pattern-的简化" class="headerlink" title="205 同构字符串，可以看作 word pattern 的简化"></a>205 同构字符串，可以看作 word pattern 的简化</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isIsomorphic</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ss[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> ts[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(s) != <span class="built_in">strlen</span>(t))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ss[s[i]] != ts[t[i]])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ss[s[i]] = ts[t[i]] = i + <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206 反转链表"></a>206 反转链表</h2><p>tags: #pointers</p>
<p>最最基础的指针操作题目了</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="built_in">next</span> = curr.<span class="built_in">next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> prev  <span class="comment"># 关键在这里</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>, *cur = head, *next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        next = cur-&gt;next; <span class="comment">// cache</span></span><br><span class="line">        cur-&gt;next = p; <span class="comment">// reverse pointing</span></span><br><span class="line">        p = cur; <span class="comment">// moves forwards</span></span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// recursive</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="207-标准的拓扑排序"><a href="#207-标准的拓扑排序" class="headerlink" title="207 标准的拓扑排序"></a>207 标准的拓扑排序</h2><p>给定边这种方法表示图也是醉了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123; <span class="comment">// next -&gt; before</span></span><br><span class="line">    vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses); <span class="comment">// 每条边和他的下一步，临接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : prerequisites)</span><br><span class="line">        graph[p.second].<span class="built_in">insert</span>(p.first);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">// in degree</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; nexts : graph)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> next : nexts)</span><br><span class="line">            d[next]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nondep; <span class="comment">// in degree == 0</span></span><br><span class="line">        <span class="keyword">for</span> (nondep = <span class="number">0</span>; nondep &lt; numCourses &amp;&amp; d[nondep] != <span class="number">0</span>; nondep++)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">if</span> (nondep == numCourses)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        d[nondep] = <span class="number">-1</span>; <span class="comment">// remove</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> next : graph[nondep]) <span class="comment">// 所有下一步都 －1</span></span><br><span class="line">            d[next]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="208-实现前缀树"><a href="#208-实现前缀树" class="headerlink" title="208 实现前缀树"></a>208 实现前缀树</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> branchCount = <span class="number">26</span>;</span><br><span class="line">    <span class="type">bool</span> isWord;</span><br><span class="line">    TrieNode* next[branchCount];</span><br><span class="line">    <span class="comment">// Initialize your data structure here.</span></span><br><span class="line">    <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; branchCount; i++)</span><br><span class="line">            next[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        location-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!location)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> location-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : prefix) &#123;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!location)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Trie trie;</span></span><br><span class="line"><span class="comment">// trie.insert(&quot;somestring&quot;);</span></span><br><span class="line"><span class="comment">// trie.search(&quot;key&quot;);</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="209-最短子数组使得和大于某个数"><a href="#209-最短子数组使得和大于某个数" class="headerlink" title="209 最短子数组使得和大于某个数"></a>209 最短子数组使得和大于某个数</h2><p>双指针，超过和之后再尝试从开始处减去元素</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, sum = <span class="number">0</span>, len = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">            len = <span class="built_in">min</span>(len, i - start + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[start++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len == INT_MAX? <span class="number">0</span> : len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="210-Course-Schedule-II"><a href="#210-Course-Schedule-II" class="headerlink" title="210 Course Schedule II"></a>210 Course Schedule II</h2><p>BFS</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; graph = <span class="built_in">make_graph</span>(numCourses, prerequisites);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; degrees = <span class="built_in">compute_indegree</span>(graph);</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; zeros;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">            <span class="keyword">if</span> (!degrees[i]) zeros.<span class="built_in">push</span>(i);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; toposort;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (zeros.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            <span class="type">int</span> zero = zeros.<span class="built_in">front</span>();</span><br><span class="line">            zeros.<span class="built_in">pop</span>();</span><br><span class="line">            toposort.<span class="built_in">push_back</span>(zero);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neigh : graph[zero]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!--degrees[neigh])</span><br><span class="line">                    zeros.<span class="built_in">push</span>(neigh);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toposort;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">make_graph</span>(<span class="type">int</span> numCourses, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> pre : prerequisites)</span><br><span class="line">            graph[pre.second].<span class="built_in">insert</span>(pre.first);</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">compute_indegree</span><span class="params">(vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degrees</span><span class="params">(graph.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> neighbors : graph)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neigh : neighbors)</span><br><span class="line">                degrees[neigh]++;</span><br><span class="line">        <span class="keyword">return</span> degrees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="211-添加和搜索字符串"><a href="#211-添加和搜索字符串" class="headerlink" title="211 添加和搜索字符串"></a>211 添加和搜索字符串</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> branchCount = <span class="number">26</span>;</span><br><span class="line">    <span class="type">bool</span> isWord;</span><br><span class="line">    TrieNode* next[branchCount];</span><br><span class="line">    <span class="comment">// Initialize your data structure here.</span></span><br><span class="line">    <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; branchCount; i++)</span><br><span class="line">            next[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        location-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!location)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> location-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : prefix) &#123;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!location)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TrieNode* <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> : <span class="keyword">public</span> Trie&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WordDictionary</span>() : <span class="built_in">Trie</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adds a word into the data structure.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the data structure. A word could</span></span><br><span class="line">    <span class="comment">// contain the dot character &#x27;.&#x27; to represent any one letter.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(word.<span class="built_in">c_str</span>(), <span class="built_in">getRoot</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* word, TrieNode* root)</span> </span>&#123;</span><br><span class="line">        TrieNode* run = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (run &amp;&amp; word[i] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                run = run-&gt;next[word[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (run &amp;&amp; word[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// skip checking this char</span></span><br><span class="line">                TrieNode* tmp = run;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                    run = tmp-&gt;next[j];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">search</span>(word + i + <span class="number">1</span>, run))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> run &amp;&amp; run-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// WordDictionary wordDictionary;</span></span><br><span class="line"><span class="comment">// wordDictionary.addWord(&quot;word&quot;);</span></span><br><span class="line"><span class="comment">// wordDictionary.search(&quot;pattern&quot;);</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="212-单词搜索"><a href="#212-单词搜索" class="headerlink" title="212 单词搜索"></a>212 单词搜索</h2><p>Trie 结构见前面，注意要记录 visited，还有边界的问题，另外集合的使用</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie m_trie;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; word : words)</span><br><span class="line">            m_trie.<span class="built_in">insert</span>(word);</span><br><span class="line">        <span class="type">int</span> row = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> col = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;string&gt; result_set;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(row, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(col, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">                <span class="built_in">find</span>(result_set, board, visited, <span class="string">&quot;&quot;</span>, i, j);</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : result_set)</span><br><span class="line">            result.<span class="built_in">push_back</span>(r);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(unordered_set&lt;string&gt;&amp; r, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, string word, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || visited[i][j])</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        word += board[i][j];</span><br><span class="line">        <span class="keyword">if</span> (!m_trie.<span class="built_in">startsWith</span>(word))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (m_trie.<span class="built_in">search</span>(word))</span><br><span class="line">            r.<span class="built_in">insert</span>(word);</span><br><span class="line"></span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">find</span>(r, board, visited, word, i<span class="number">-1</span>, j);</span><br><span class="line">        <span class="built_in">find</span>(r, board, visited, word, i+<span class="number">1</span>, j);</span><br><span class="line">        <span class="built_in">find</span>(r, board, visited, word, i, j<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">find</span>(r, board, visited, word, i, j+<span class="number">1</span>);</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="213-小偷偷环状数组"><a href="#213-小偷偷环状数组" class="headerlink" title="213 小偷偷环状数组"></a>213 小偷偷环状数组</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">robNonCyclic</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 因为不能相邻，所以可以从相隔一个的取值</span></span><br><span class="line">    <span class="comment">// dp[n] = max(dp[n-1], dp[n-2] + A[n])</span></span><br><span class="line">    <span class="type">int</span> temp, m = <span class="number">0</span>, n = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        temp = n;</span><br><span class="line">        <span class="keyword">if</span> (m + nums[i] &gt; n)</span><br><span class="line">            n = m + nums[i];</span><br><span class="line">        m = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> max(robNonCyclic(nums, numsSize - <span class="number">1</span>), robNonCyclic(nums + <span class="number">1</span>, numsSize - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="214-最短回文字符串，给指定的字符串添加字母获得回文"><a href="#214-最短回文字符串，给指定的字符串添加字母获得回文" class="headerlink" title="214 最短回文字符串，给指定的字符串添加字母获得回文"></a>214 最短回文字符串，给指定的字符串添加字母获得回文</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// based on kmp next array</span></span><br><span class="line"><span class="function">string <span class="title">shortestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string rev_s = s;</span><br><span class="line">    <span class="built_in">reverse</span>(rev_s.<span class="built_in">begin</span>(), rev_s.<span class="built_in">end</span>());</span><br><span class="line">    string l = s + <span class="string">&quot;#&quot;</span> + rev_s;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(l.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; l.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = p[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; l[i] != l[j])</span><br><span class="line">            j = p[j - <span class="number">1</span>];</span><br><span class="line">        p[i] = (j += l[i] == l[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rev_s.<span class="built_in">substr</span>(<span class="number">0</span>, s.<span class="built_in">size</span>() - p[l.<span class="built_in">size</span>() - <span class="number">1</span>]) + s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="215-数组中第-k-大的数字"><a href="#215-数组中第-k-大的数字" class="headerlink" title="215 数组中第 k 大的数字"></a>215 数组中第 k 大的数字</h2><p>实际上这道题更可能的题目是找到前 k 大的所有数字。<br>首先，设计到数组排序的问题一定向面试官要问清楚数据量的大小，这影响到接下来的实现，<br>同时和面试官探讨数据量大小对实现的影响，有助于更好的把握局面。</p>
<p>我们先假设数据量是比较小的，也就是能够放到内存中。</p>
<ol start="0">
<li>使用排序就实在是 naive 了，不过面试官非要问的话，当然是使用选择排序更好了。</li>
<li>使用快排中的 partition 算法，时间复杂度 O(n*logk)。</li>
<li>使用 size 为 k 的堆，时间复杂度也是 O(n*logk)，不管数字多大，都只需要遍历一遍。</li>
<li>使用类似插入排序的方法，保持数组大小不变，这样的时间复杂度是 O(n*k)。</li>
<li>数据的范围有限时候，使用计数排序。</li>
</ol>
<p>当数据过大的时候，我们可以想通过哈希取模之后把文件分组，找出每个文件中最大的 k 个数字</p>
<p>如果数字中有重复呢？使用计数排序，计数强制按一算<br>如果既有重复又是浮点数呢？</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> small = start - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pivot = nums[end];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; end; i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; pivot)</span><br><span class="line">            swap(&amp;nums[++small], &amp;nums[i]);</span><br><span class="line">    swap(&amp;nums[++small], &amp;nums[end]);</span><br><span class="line">    <span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> index = partition(nums, left, right);</span><br><span class="line">        <span class="keyword">if</span> (index == numsSize - k)</span><br><span class="line">            <span class="keyword">return</span> nums[index];</span><br><span class="line">        <span class="keyword">if</span> (index &gt; numsSize - k)</span><br><span class="line">            right = index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="216-找到-k-个数字-1…9-，使得他们的和是-n"><a href="#216-找到-k-个数字-1…9-，使得他们的和是-n" class="headerlink" title="216 找到 k 个数字 [1…9]，使得他们的和是 n"></a>216 找到 k 个数字 [1…9]，使得他们的和是 n</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">dfs</span>(result, &#123;&#125;, n, k);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt; combination, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (combination.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            result.<span class="built_in">push_back</span>(combination);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = combination.<span class="built_in">empty</span>() ? <span class="number">1</span> : combination.<span class="built_in">back</span>() + <span class="number">1</span>; <span class="comment">// 保证不重复切实递增序列</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n &amp;&amp; i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        combination.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">dfs</span>(result, combination, n-i, k);</span><br><span class="line">        combination.<span class="built_in">pop_back</span>();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="217-包含重复数字"><a href="#217-包含重复数字" class="headerlink" title="217 包含重复数字"></a>217 包含重复数字</h2><p>这道题太简单了，也没有什么精妙的解法，可以使用排序，Hash 等多种解法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; n : nums)</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">find</span>(n) != s.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s.<span class="built_in">insert</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="218-获得矩形重合部分的拐点"><a href="#218-获得矩形重合部分的拐点" class="headerlink" title="218 获得矩形重合部分的拐点"></a>218 获得矩形重合部分的拐点</h2><p>抄过来的，还没仔细研究</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">getSkyline</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; buildings) &#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">0</span>, cur_X, cur_H =<span class="number">-1</span>,  len = buildings.<span class="built_in">size</span>();</span><br><span class="line">    priority_queue&lt; pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; liveBlg; <span class="comment">// first: height, second, end time</span></span><br><span class="line">    <span class="keyword">while</span>(cur&lt;len || !liveBlg.<span class="built_in">empty</span>()) &#123; <span class="comment">// if either some new building is not processed or live building queue is not empty</span></span><br><span class="line">        cur_X = liveBlg.<span class="built_in">empty</span>()? buildings[cur][<span class="number">0</span>]:liveBlg.<span class="built_in">top</span>().second; <span class="comment">// next timing point to process</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur&gt;=len || buildings[cur][<span class="number">0</span>] &gt; cur_X) &#123; <span class="comment">//first check if the current tallest building will end before the next timing point</span></span><br><span class="line">              <span class="comment">// pop up the processed buildings, i.e. those  have height no larger than cur_H and end before the top one</span></span><br><span class="line">            <span class="keyword">while</span>(!liveBlg.<span class="built_in">empty</span>() &amp;&amp; ( liveBlg.<span class="built_in">top</span>().second &lt;= cur_X) ) liveBlg.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// if the next new building starts before the top one ends, process the new building in the vector</span></span><br><span class="line">            cur_X = buildings[cur][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">while</span>(cur&lt;len &amp;&amp; buildings[cur][<span class="number">0</span>]== cur_X)  <span class="comment">// go through all the new buildings that starts at the same point</span></span><br><span class="line">            &#123;  <span class="comment">// just push them in the queue</span></span><br><span class="line">                liveBlg.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(buildings[cur][<span class="number">2</span>], buildings[cur][<span class="number">1</span>]));</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_H = liveBlg.<span class="built_in">empty</span>()?<span class="number">0</span>:liveBlg.<span class="built_in">top</span>().first; <span class="comment">// outut the top one</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">empty</span>() || (res.<span class="built_in">back</span>().second != cur_H) ) res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(cur_X, cur_H));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="219-包含重复数字，并且两个的坐标不超过-k"><a href="#219-包含重复数字，并且两个的坐标不超过-k" class="headerlink" title="219 包含重复数字，并且两个的坐标不超过 k"></a>219 包含重复数字，并且两个的坐标不超过 k</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口保存前 k 个值，如果有重复的就返回</span></span><br><span class="line"><span class="comment">// num[i-k] num[i-1]，如果滑过了，就删除该元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= nums.<span class="built_in">size</span>()) <span class="comment">// notice here</span></span><br><span class="line">        k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k)</span><br><span class="line">            s.<span class="built_in">erase</span>(nums[i - k - <span class="number">1</span>]); <span class="comment">// delete first note</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">find</span>(nums[i]) != s.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        s.<span class="built_in">insert</span>(nums[i]); <span class="comment">// insert</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="220-同上一题，同时保证两个数字之间小于-t"><a href="#220-同上一题，同时保证两个数字之间小于-t" class="headerlink" title="220 同上一题，同时保证两个数字之间小于 t"></a>220 同上一题，同时保证两个数字之间小于 t</h2><p>保证两个数字之差小于 t</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; window; <span class="comment">// 注意不能使用 unordered</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= nums.<span class="built_in">size</span>()) <span class="comment">// notice here</span></span><br><span class="line">        k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k)</span><br><span class="line">            window.<span class="built_in">erase</span>(nums[i - k - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">auto</span> pos = window.<span class="built_in">lower_bound</span>(nums[i] - t); <span class="comment">// notice set.lower_bound</span></span><br><span class="line">        <span class="keyword">if</span> (pos != window.<span class="built_in">end</span>() &amp;&amp; *pos - nums[i] &lt;= t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        window.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="221-找到最大的正方形"><a href="#221-找到最大的正方形" class="headerlink" title="221 找到最大的正方形"></a>221 找到最大的正方形</h2><p>使用动态规划 <a href="https://leetcode.com/discuss/38489/easy-solution-with-detailed-explanations-8ms-time-and-space">https://leetcode.com/discuss/38489/easy-solution-with-detailed-explanations-8ms-time-and-space</a></p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> maxsize = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// 每一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123; <span class="comment">// notice i range</span></span><br><span class="line">            <span class="type">int</span> temp = dp[i];</span><br><span class="line">            <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], <span class="built_in">min</span>(dp[i - <span class="number">1</span>], pre)) + <span class="number">1</span>;</span><br><span class="line">                maxsize = <span class="built_in">max</span>(maxsize, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dp[i] = <span class="number">0</span>;</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsize * maxsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="222-给定一个完全树，计算节点的数量。"><a href="#222-给定一个完全树，计算节点的数量。" class="headerlink" title="222 给定一个完全树，计算节点的数量。"></a>222 给定一个完全树，计算节点的数量。</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left_height = <span class="number">0</span>, right_height = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* left = root, *right = root;</span><br><span class="line">    <span class="keyword">while</span> (left) &#123;</span><br><span class="line">        left = left-&gt;left;</span><br><span class="line">        left_height++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right) &#123;</span><br><span class="line">        right = right-&gt;right;</span><br><span class="line">        right_height++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left_height == right_height) <span class="comment">// 满树 2^h - 1</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; left_height) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="223-找出两个长方形覆盖的面积"><a href="#223-找出两个长方形覆盖的面积" class="headerlink" title="223 找出两个长方形覆盖的面积"></a>223 找出两个长方形覆盖的面积</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">computeArea</span><span class="params">(<span class="type">int</span> left1, <span class="type">int</span> down1, <span class="type">int</span> right1, <span class="type">int</span> up1, <span class="type">int</span> left2, <span class="type">int</span> down2, <span class="type">int</span> right2, <span class="type">int</span> up2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = max(left1, left2); <span class="comment">// 靠右的</span></span><br><span class="line">    <span class="type">int</span> right = max(min(right1, right2), left);<span class="comment">// 靠左的，但是比左边大</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> down = max(down1, down2);</span><br><span class="line">    <span class="type">int</span> up = max(min(up1, up2), down);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不小心写反了。</span></span><br><span class="line">    <span class="keyword">return</span> -((left1 - right1) * (up1 - down1) + (left2 - right2) * (up2 - down2) - (left - right) * (up - down));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="224-给定一个字符串，包含加减和括号，计算值"><a href="#224-给定一个字符串，包含加减和括号，计算值" class="headerlink" title="224 给定一个字符串，包含加减和括号，计算值"></a>224 给定一个字符串，包含加减和括号，计算值</h2><p>难点是对括号的处理，注意每次都要和 signs.top() 相乘</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; signs; <span class="comment">// signs before braces</span></span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    signs.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">            num = <span class="number">10</span> * num + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            result += signs.<span class="built_in">top</span>() * sign * num;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            signs.<span class="built_in">push</span>(sign * signs.<span class="built_in">top</span>()); <span class="comment">// tricky</span></span><br><span class="line">            sign = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            result += signs.<span class="built_in">top</span>() * sign * num;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            signs.<span class="built_in">pop</span>();</span><br><span class="line">            sign = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result += signs.<span class="built_in">top</span>() * sign * num; <span class="comment">// tricky</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="225-使用队列模拟栈"><a href="#225-使用队列模拟栈" class="headerlink" title="225 使用队列模拟栈"></a>225 使用队列模拟栈</h2><p>其实有两种做法，一种是在 push 的时候，把队列清空，把 x 放到最底下。<br>另一种是在 pop 的时候，把队列清空到 1，然后弹出。应当询问面试官究竟是 push 居多还是 pop 居多</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Push element x onto stack.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!nums.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            temp.<span class="built_in">push</span>(nums.<span class="built_in">front</span>());</span><br><span class="line">            nums.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        nums.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (!temp.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            nums.<span class="built_in">push</span>(temp.<span class="built_in">front</span>());</span><br><span class="line">            temp.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes the element on top of the stack.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nums.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the top element.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return whether the stack is empty.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="226-反转二叉树"><a href="#226-反转二叉树" class="headerlink" title="226 反转二叉树"></a>226 反转二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">invertTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">temp</span> =</span> root-&gt;left;</span><br><span class="line">    root-&gt;left = invertTree(root-&gt;right);</span><br><span class="line">    root-&gt;right = invertTree(temp);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="227-给定一个字符串包含-计算他的值"><a href="#227-给定一个字符串包含-计算他的值" class="headerlink" title="227 给定一个字符串包含 +-*/ 计算他的值"></a>227 给定一个字符串包含 <code>+-*/</code> 计算他的值</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; stk; <span class="comment">// 使用 vector 便于统计最后的值</span></span><br><span class="line">    <span class="type">char</span> token = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">            num = num * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 这里不是 else if</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;*&#x27;</span> || s[i] == <span class="string">&#x27;/&#x27;</span> || i == s.<span class="built_in">size</span>() - <span class="number">1</span>) &#123; <span class="comment">// 注意最后一步还需要把最后的值计算</span></span><br><span class="line">            <span class="type">int</span> a;</span><br><span class="line">            <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                stk.<span class="built_in">push_back</span>(num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                stk.<span class="built_in">push_back</span>(-num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                a = stk.<span class="built_in">back</span>();</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                stk.<span class="built_in">push_back</span>(a * num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                a = stk.<span class="built_in">back</span>();</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                stk.<span class="built_in">push_back</span>(a / num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            token = s[i];</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : stk)</span><br><span class="line">        result += i;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="228-聚合区间，给定一排序数组，把相邻的数字用区间表示"><a href="#228-聚合区间，给定一排序数组，把相邻的数字用区间表示" class="headerlink" title="228 聚合区间，给定一排序数组，把相邻的数字用区间表示"></a>228 聚合区间，给定一排序数组，把相邻的数字用区间表示</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">        <span class="type">int</span> start = i, end = i;</span><br><span class="line">        <span class="keyword">while</span> (end + <span class="number">1</span> &lt; n &amp;&amp; nums[end + <span class="number">1</span>] == nums[end] + <span class="number">1</span>)</span><br><span class="line">            end++;</span><br><span class="line">        <span class="keyword">if</span> (end &gt; start)</span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[start]) + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(nums[end]));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[start]));</span><br><span class="line">        i = end + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="229-找出超过三分之一的元素"><a href="#229-找出超过三分之一的元素" class="headerlink" title="229 找出超过三分之一的元素"></a>229 找出超过三分之一的元素</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count1 == <span class="number">0</span> || n == a) &#123;</span><br><span class="line">            count1++;</span><br><span class="line">            a = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count2 == <span class="number">0</span> || n == b) &#123;</span><br><span class="line">            count2++;</span><br><span class="line">            b = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count1--;</span><br><span class="line">            count2--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count1 = count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == a) count1++;</span><br><span class="line">        <span class="keyword">if</span> (n == b) count2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count1 &gt; nums.<span class="built_in">size</span>() / <span class="number">3</span>) <span class="comment">// verify a</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(a);</span><br><span class="line">    <span class="keyword">if</span> (count2 &gt; nums.<span class="built_in">size</span>() / <span class="number">3</span> &amp;&amp; a != b) <span class="comment">// verify b</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(b);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="230-二叉树中第-k-小的数字"><a href="#230-二叉树中第-k-小的数字" class="headerlink" title="230 二叉树中第 k 小的数字"></a>230 二叉树中第 k 小的数字</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传递指针</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* k, <span class="type">int</span>* number)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inorder(root-&gt;left, k, number);</span><br><span class="line">    (*k)--;</span><br><span class="line">    <span class="keyword">if</span> (*k == <span class="number">0</span>) &#123;</span><br><span class="line">        *number = root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root-&gt;right, k, number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    inorder(root, &amp;k, &amp;number);</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="231-2-的次方"><a href="#231-2-的次方" class="headerlink" title="231 2 的次方"></a>231 2 的次方</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_power_of_two</span>(n: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        (n &amp; (n-<span class="number">1</span>)) == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="232-使用栈模拟队列"><a href="#232-使用栈模拟队列" class="headerlink" title="232 使用栈模拟队列"></a>232 使用栈模拟队列</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Push element x to the back of queue.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        in.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes the element from in front of queue.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (out.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="built_in">transfer</span>();</span><br><span class="line">        out.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the front element.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">if</span> (out.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="built_in">transfer</span>();</span><br><span class="line">        <span class="keyword">return</span> out.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return whether the queue is empty.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.<span class="built_in">empty</span>() &amp;&amp; out.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!in.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            out.<span class="built_in">push</span>(in.<span class="built_in">top</span>());</span><br><span class="line">            in.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; in;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; out;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="233-小于-n-的数字中-1-的个数"><a href="#233-小于-n-的数字中-1-的个数" class="headerlink" title="233 小于 n 的数字中 1 的个数"></a>233 小于 n 的数字中 1 的个数</h2><p>对于每一位，有三种情况：</p>
<ol>
<li>当是数字 0 的时候，可能出先 1 的情况完全由高位出现决定，因为这一位不能贡献 1</li>
<li>当是数字 1 的时候，同上，但是这一位和低位一起可以贡献一个 1</li>
<li>当时数字 2-9 的时候，相当于这一位的 1 可以任意出现，因此高位＋1</li>
</ol>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ones = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">1</span>; m &lt;= n; m *= <span class="number">10</span>) &#123; <span class="comment">// m is the factor</span></span><br><span class="line">        <span class="type">int</span> a = n/m, b = n%m;  <span class="comment">// a is left half, b is right half</span></span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">10</span> &gt;= <span class="number">2</span>)</span><br><span class="line">            ones += (a / <span class="number">10</span> + <span class="number">1</span>) * m;</span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">10</span> == <span class="number">1</span>)</span><br><span class="line">            ones += (a / <span class="number">10</span>) * m + b + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">            ones += (a / <span class="number">10</span>) * m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>二进制呢</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countDigitOneBinary</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ones = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">1</span>; m &lt;= n; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> a = n / m, b = n % m;</span><br><span class="line">        <span class="keyword">if</span> (a &amp; <span class="number">0x01</span>)</span><br><span class="line">            ones += (a &gt;&gt; <span class="number">1</span>) * m + b + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ones += (a &gt;&gt; <span class="number">1</span>) * m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>求最大的 countDigitOne(n) &#x3D;&#x3D; n</p>
<pre><code>9    1
99   20
999  300
...
99999999  10000000
</code></pre>
<h2 id="234-判断一个链表是否是回文"><a href="#234-判断一个链表是否是回文" class="headerlink" title="234 判断一个链表是否是回文"></a>234 判断一个链表是否是回文</h2><p>解法 1: 如果链表是可以改变的，不妨反转它的前半部分，然后再与后半部分比较</p>
<p>解法 2: 如果是只读的，复制一份也可以，但是不如使用堆栈</p>
<p>注意对奇数偶数的处理</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode* temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    temp = head;</span><br><span class="line">    <span class="type">int</span> mid = len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (mid--) &#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(temp-&gt;val);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &amp; <span class="number">0x01</span>)</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> a = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b = temp-&gt;val;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="235-二叉搜索树公共祖先"><a href="#235-二叉搜索树公共祖先" class="headerlink" title="235 二叉搜索树公共祖先"></a>235 二叉搜索树公共祖先</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">lowestCommonAncestor</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="236-二叉树公共祖先"><a href="#236-二叉树公共祖先" class="headerlink" title="236 二叉树公共祖先"></a>236 二叉树公共祖先</h2><p>如果二叉树的根就是其中一个节点，那显然是这个。<br>在两颗子树中分别查找，如果找到了，返回一个非 NULL 值，如果都找到了，则这个节点就是 LCA</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">lowestCommonAncestor</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || root == p || root == q)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span> =</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span> =</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!left) <span class="comment">// not in left subtree</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">if</span> (!right)</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// both left and right are found!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="237-删除链表中的元素"><a href="#237-删除链表中的元素" class="headerlink" title="237 删除链表中的元素"></a>237 删除链表中的元素</h2><p>直接将后继节点的值复制到当前节点</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(<span class="keyword">struct</span> ListNode* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node || !node-&gt;next)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> node-&gt;next;</span><br><span class="line">    node-&gt;val = next-&gt;val;</span><br><span class="line">    node-&gt;next = next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="238-数组除了自己以外的乘积，规定不能用除法"><a href="#238-数组除了自己以外的乘积，规定不能用除法" class="headerlink" title="238 数组除了自己以外的乘积，规定不能用除法"></a>238 数组除了自己以外的乘积，规定不能用除法</h2><p>首先从前往后乘，错开一位元素，这样每个元素都乘到了他之前的所有元素，最后一个元素已经是结果了。<br>然后从后往前乘，同样错开一位，这样每个元素又把他之后的元素都得到了。</p>
<h2 id="239-滑动窗口最大值，给定一个滑动窗口，返回它移动过程中的最大值"><a href="#239-滑动窗口最大值，给定一个滑动窗口，返回它移动过程中的最大值" class="headerlink" title="239 滑动窗口最大值，给定一个滑动窗口，返回它移动过程中的最大值"></a>239 滑动窗口最大值，给定一个滑动窗口，返回它移动过程中的最大值</h2><p>单调队列的应用，复杂度是 O(n) 的。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonoQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.q = deque()  <span class="comment"># 实际储存数据</span></span><br><span class="line">        self.m = deque()  <span class="comment"># 维护单调关系，队首元素总是最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.q.append(x)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.m) &gt; <span class="number">0</span> <span class="keyword">and</span> self.m[-<span class="number">1</span>] &lt; x:</span><br><span class="line">            self.m.pop()</span><br><span class="line">        self.m.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        x = self.q.popleft()</span><br><span class="line">        <span class="keyword">if</span> self.m[<span class="number">0</span>] == x:</span><br><span class="line">            self.m.popleft()</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.q)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.m[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        q = MonoQueue()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            q.push(nums[i])</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">            ans.append(q.top())</span><br><span class="line">            q.pop()</span><br><span class="line">            q.push(nums[i])</span><br><span class="line">        ans.append(q.top())</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<p>另一种现在我已经看不懂的做法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目给定 k 一定是有效地</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>() || k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; dq; <span class="comment">// 存储的是索引，front 存储最大值，保证递减</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() &lt; i - k + <span class="number">1</span>) <span class="comment">// 弹出滑过的窗口</span></span><br><span class="line">            dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; nums[dq.<span class="built_in">back</span>()] &lt; nums[i]) <span class="comment">// 弹出小的</span></span><br><span class="line">            dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>)</span><br><span class="line">            result.<span class="built_in">push_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="240-给定一个矩阵，每行从左到右都是增大的，每一列从上到下都是增大的，找出给定数字是否存在"><a href="#240-给定一个矩阵，每行从左到右都是增大的，每一列从上到下都是增大的，找出给定数字是否存在" class="headerlink" title="240 给定一个矩阵，每行从左到右都是增大的，每一列从上到下都是增大的，找出给定数字是否存在"></a>240 给定一个矩阵，每行从左到右都是增大的，每一列从上到下都是增大的，找出给定数字是否存在</h2><p>我们考虑右上角的元素</p>
<ol>
<li>如果这个元素比 taget 大，那么整列都比 target 大，我们可以 c–</li>
<li>如果这个元素比 target 小，那么正行都比 target 小，我们可以 r++</li>
</ol>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>, c = col - <span class="number">1</span>; <span class="comment">// 右上角</span></span><br><span class="line">    <span class="keyword">while</span> (r &lt; row &amp;&amp; c &gt; <span class="number">-1</span>) <span class="comment">// 向左下角</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[r][c] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[r][c] &gt; target)</span><br><span class="line">            c--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="241-添加括号得到不同的结果"><a href="#241-添加括号得到不同的结果" class="headerlink" title="241 添加括号得到不同的结果"></a>241 添加括号得到不同的结果</h2><p>对每一个符号，在他的两边添加括号的好的不同结果再计算。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; output;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> token = input[i];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(token)) <span class="comment">// not digit</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> a : <span class="built_in">diffWaysToCompute</span>(input.<span class="built_in">substr</span>(<span class="number">0</span>, i))) <span class="comment">// 左半部分</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> b : <span class="built_in">diffWaysToCompute</span>(input.<span class="built_in">substr</span>(i+<span class="number">1</span>))) <span class="comment">// 右半部分</span></span><br><span class="line">                    output.<span class="built_in">push_back</span>(token == <span class="string">&#x27;+&#x27;</span> ? a + b : token == <span class="string">&#x27;-&#x27;</span>? a - b: a *b); <span class="comment">// 两半部分之和</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (output.<span class="built_in">empty</span>())</span><br><span class="line">        output.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input));</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="242-一个单词是否能由另一个变幻而来"><a href="#242-一个单词是否能由另一个变幻而来" class="headerlink" title="242 一个单词是否能由另一个变幻而来"></a>242 一个单词是否能由另一个变幻而来</h2><p>还是，对于 ASCII 字符，直接用数组代替字典</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isAnagram</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> &#123;</span><br><span class="line">    <span class="type">char</span> ss[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> ts[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        ss[*s - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        s++;</span><br><span class="line">        ts[*t - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memcmp</span>(ss, ts, <span class="keyword">sizeof</span>(ss)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>243-256 Locked</p>
<h2 id="257-二叉树左右路径"><a href="#257-二叉树左右路径" class="headerlink" title="257 二叉树左右路径"></a>257 二叉树左右路径</h2><p>典型的 DFS，发挥所有从根节点到叶节点的路径</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="built_in">paths</span>(result, <span class="string">&quot;&quot;</span>, root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paths</span><span class="params">(vector&lt;string&gt;&amp; result, string path, TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">empty</span>())</span><br><span class="line">        path += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        path += <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        <span class="built_in">paths</span>(result, path, root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        <span class="built_in">paths</span>(result, path, root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="258-把数字的每一位加起来，直到变成一个一位的数字"><a href="#258-把数字的每一位加起来，直到变成一个一位的数字" class="headerlink" title="258 把数字的每一位加起来，直到变成一个一位的数字"></a>258 把数字的每一位加起来，直到变成一个一位的数字</h2><p>这完全是一道数学题，对于每个进制的数字都有规律 <code>(n - 1) % (x - 1) + 1</code>。实际上是把 10 进制的转化为 9 进制数字</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">addDigits</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>259 Locked</p>
<h2 id="260-给定一个数组，每个数字都是重复的，只有两个数字不是，找出这两个数字"><a href="#260-给定一个数组，每个数字都是重复的，只有两个数字不是，找出这两个数字" class="headerlink" title="260 给定一个数组，每个数字都是重复的，只有两个数字不是，找出这两个数字"></a>260 给定一个数组，每个数字都是重复的，只有两个数字不是，找出这两个数字</h2><p>这道题很奇妙，依然可以使用 XOR 来解，首先遍历一遍，这时候由于有两个数字是不同的，那么一定结果不为 0，那么其中一个 bit 位一定是一个数字有，另一个数字没有。<br>在遍历一遍，同时把数字分两组，一组是有这个 bit 位，一组没有。就得出了结果。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; n : nums)</span><br><span class="line">        r ^= n;</span><br><span class="line">    <span class="type">int</span> bit = r &amp; -r; <span class="comment">// last sig bit</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; n : nums)</span><br><span class="line">        <span class="keyword">if</span> (n &amp; bit)</span><br><span class="line">            result[<span class="number">0</span>] ^= n;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result[<span class="number">1</span>] ^= n;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>261 262 Locked</p>
<h2 id="263-丑陋的数字，质数因子只含有-2-3-5-的数字"><a href="#263-丑陋的数字，质数因子只含有-2-3-5-的数字" class="headerlink" title="263 丑陋的数字，质数因子只含有 2,3,5 的数字"></a>263 丑陋的数字，质数因子只含有 2,3,5 的数字</h2><p>按定义做就好了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isUgly</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="264-找出第-n-个丑陋数字"><a href="#264-找出第-n-个丑陋数字" class="headerlink" title="264 找出第 n 个丑陋数字"></a>264 找出第 n 个丑陋数字</h2><p>使用数列记录 n 个丑陋数字，每一个丑陋数字肯定是之前数字乘以 235 得到的，然后用三个指针分别指向上一个做乘法的数字，每次找出最小的一个</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">6</span>) <span class="comment">// 1..6 恰好都是</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> s2 = <span class="number">0</span>, s3 = <span class="number">0</span>, s5 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* uglies[n];</span><br><span class="line">    uglies[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> c2 = uglies[s2] * <span class="number">2</span>, c3 = uglies[s3] * <span class="number">3</span>, c5 = uglies[s5] * <span class="number">5</span>;</span><br><span class="line">        uglies[i] = MIN(c2, MIN(c3, c5));</span><br><span class="line">        <span class="keyword">if</span> (uglies[i] == c2) s2++;</span><br><span class="line">        <span class="keyword">if</span> (uglies[i] == c3) s3++;</span><br><span class="line">        <span class="keyword">if</span> (uglies[i] == c5) s5++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uglies[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="268-丢失的数字，给定-0…n，丢失了一个，然后放在长度为-n-的数组之中，找出这个数字"><a href="#268-丢失的数字，给定-0…n，丢失了一个，然后放在长度为-n-的数组之中，找出这个数字" class="headerlink" title="268 丢失的数字，给定 0…n，丢失了一个，然后放在长度为 n 的数组之中，找出这个数字"></a>268 丢失的数字，给定 0…n，丢失了一个，然后放在长度为 n 的数组之中，找出这个数字</h2><p>显然还是使用异或，注意 0 ^ x &#x3D;&#x3D; x，所以直接把 0 忽略就行了。把每个数字都和 i 异或，丢失的数字就出来了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        result = result ^ (i + <span class="number">1</span>) ^ nums[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>269-272 Locked</p>
<h2 id="273-数字转换为英语单词"><a href="#273-数字转换为英语单词" class="headerlink" title="273 数字转换为英语单词"></a>273 数字转换为英语单词</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; digits = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Four&quot;</span>, <span class="string">&quot;Five&quot;</span>, <span class="string">&quot;Six&quot;</span>, <span class="string">&quot;Seven&quot;</span>, <span class="string">&quot;Eight&quot;</span>, <span class="string">&quot;Nine&quot;</span>, <span class="string">&quot;Ten&quot;</span>, <span class="string">&quot;Eleven&quot;</span>, <span class="string">&quot;Twelve&quot;</span>, <span class="string">&quot;Thirteen&quot;</span>, <span class="string">&quot;Fourteen&quot;</span>, <span class="string">&quot;Fifteen&quot;</span>, <span class="string">&quot;Sixteen&quot;</span>, <span class="string">&quot;Seventeen&quot;</span>, <span class="string">&quot;Eighteen&quot;</span>, <span class="string">&quot;Nineteen&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; tens = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Twenty&quot;</span>, <span class="string">&quot;Thirty&quot;</span>, <span class="string">&quot;Forty&quot;</span>, <span class="string">&quot;Fifty&quot;</span>, <span class="string">&quot;Sixty&quot;</span>, <span class="string">&quot;Seventy&quot;</span>, <span class="string">&quot;Eighty&quot;</span>, <span class="string">&quot;Ninety&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; seps = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot; Thousand &quot;</span>, <span class="string">&quot; Million &quot;</span>, <span class="string">&quot; Billion &quot;</span>&#125;; <span class="comment">// notice the trailing spaces</span></span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">numberToWords</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Zero&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Negative &quot;</span> + <span class="built_in">numberToWords</span>(-num);</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        string result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">1000</span> != <span class="number">0</span>)</span><br><span class="line">                result = <span class="built_in">s2word</span>(num % <span class="number">1000</span>) + seps[count] + result;</span><br><span class="line">            num /= <span class="number">1000</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// removw unnecessary tailing space</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(result.<span class="built_in">back</span>()))</span><br><span class="line">            result.<span class="built_in">resize</span>(result.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">s2word</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string result;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">            result += digits[num/<span class="number">100</span>] + <span class="string">&quot; Hundred &quot;</span>;</span><br><span class="line">            num %= <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">20</span>) &#123;</span><br><span class="line">            result += tens[num / <span class="number">10</span>] + <span class="string">&quot; &quot;</span>;</span><br><span class="line">            num %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">1</span> &amp;&amp; num &lt;= <span class="number">19</span>)</span><br><span class="line">            result += digits[num];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remove tailing spaces</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(result.<span class="built_in">back</span>()))</span><br><span class="line">            result.<span class="built_in">resize</span>(result.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="274-H-Index"><a href="#274-H-Index" class="headerlink" title="274 H-Index"></a>274 H-Index</h2><p>H-Index 的定义：一个科学家的 N 篇论文 h 个至少有 h 个引用，而且剩下的 N-h 篇论文都没有超过 h 个引用。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>* cites, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> hs[n+<span class="number">1</span>]; <span class="comment">// Hindex 不可能大于 N</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        hs[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cites[i] &gt; n)</span><br><span class="line">            hs[n]++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hs[cites[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n, papers = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 从后往前，如果有符合条件的，那么就是 Hindex</span></span><br><span class="line">        papers += hs[i];</span><br><span class="line">        <span class="keyword">if</span> (papers &gt;= i)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="275-H-index-II，论文已经按照引用数量排序"><a href="#275-H-index-II，论文已经按照引用数量排序" class="headerlink" title="275 H-index II，论文已经按照引用数量排序"></a>275 H-index II，论文已经按照引用数量排序</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>* citations, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 二分查找是小于等于</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (citations[mid] == n - mid)</span><br><span class="line">            <span class="keyword">return</span> citations[mid];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (citations[mid] &lt; n - mid)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - right - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>276-277 Locked</p>
<h2 id="278-第一个坏版本"><a href="#278-第一个坏版本" class="headerlink" title="278 第一个坏版本"></a>278 第一个坏版本</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际上是 lower_bound 函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n; <span class="comment">// 记住 lower_bound 的 right 是 n</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;   <span class="comment">// 使用小于号</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isBadVersion(mid))</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="279-分解为平方数的和"><a href="#279-分解为平方数的和" class="headerlink" title="279 分解为平方数的和"></a>279 分解为平方数的和</h2><p>最多 4 个即可，尝试在三个以内是否可以。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ub = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a=<span class="number">0</span>; a&lt;=ub; ++a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b=a; b&lt;=ub; ++b) &#123;</span><br><span class="line">            <span class="type">int</span> c = <span class="built_in">sqrt</span>(n - a*a - b*b);</span><br><span class="line">            <span class="keyword">if</span> (a*a + b*b + c*c == n)</span><br><span class="line">                <span class="keyword">return</span> !!a + !!b + !!c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="282-添加运算符使得算式成立"><a href="#282-添加运算符使得算式成立" class="headerlink" title="282 添加运算符使得算式成立"></a>282 添加运算符使得算式成立</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">addOperators</span><span class="params">(string num, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (num.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="built_in">dfs</span>(num, target, result, num[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>, num.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string num, <span class="type">int</span> target, vector&lt;string&gt; &amp; v, <span class="type">long</span> <span class="type">long</span> last, string s, <span class="type">int</span> idx, <span class="type">int</span> left)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == num.<span class="built_in">length</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == last*left)</span><br><span class="line">            v.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(last!=<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(num, target,         v, last * <span class="number">10</span> + num[idx] - <span class="string">&#x27;0&#x27;</span>, s + num.<span class="built_in">substr</span>(idx, <span class="number">1</span>), idx + <span class="number">1</span>, left); <span class="comment">// 尝试拼成 10</span></span><br><span class="line">        <span class="built_in">dfs</span>(num, target,             v, num[idx] - <span class="string">&#x27;0&#x27;</span>, s + <span class="string">&#x27;*&#x27;</span> + num.<span class="built_in">substr</span>(idx, <span class="number">1</span>), idx + <span class="number">1</span>, last*left);</span><br><span class="line">        <span class="built_in">dfs</span>(num, target - left*last, v, num[idx] - <span class="string">&#x27;0&#x27;</span>, s + <span class="string">&#x27;+&#x27;</span> + num.<span class="built_in">substr</span>(idx, <span class="number">1</span>), idx + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(num, target - left*last, v, num[idx] - <span class="string">&#x27;0&#x27;</span>, s + <span class="string">&#x27;-&#x27;</span> + num.<span class="built_in">substr</span>(idx, <span class="number">1</span>), idx + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="283-移动-0"><a href="#283-移动-0" class="headerlink" title="283 移动 0"></a>283 移动 0</h2><p>注意 swap 的使用</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">swap</span>(nums[n++], nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="284-Peek-Iterator"><a href="#284-Peek-Iterator" class="headerlink" title="284 Peek Iterator"></a>284 Peek Iterator</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Below is the interface for Iterator, which is already defined for you.</span></span><br><span class="line"><span class="comment">// **DO NOT** modify the interface for Iterator.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Data</span>;</span><br><span class="line">    Data* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Iterator</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums);</span><br><span class="line">    <span class="built_in">Iterator</span>(<span class="type">const</span> Iterator&amp; iter);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Iterator</span>();</span><br><span class="line">    <span class="comment">// Returns the next element in the iteration.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Returns true if the iteration has more elements.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PeekingIterator</span> : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PeekingIterator</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums) : <span class="built_in">Iterator</span>(nums) &#123;</span><br><span class="line">        <span class="comment">// Initialize any member here.</span></span><br><span class="line">        <span class="comment">// **DO NOT** save a copy of nums and manipulate it directly.</span></span><br><span class="line">        <span class="comment">// You should only use the Iterator interface methods.</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the next element in the iteration without advancing the iterator.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Iterator</span>(*<span class="keyword">this</span>).<span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hasNext() and next() should behave the same as in the Iterator interface.</span></span><br><span class="line">    <span class="comment">// Override them if needed.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Iterator::<span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Iterator::<span class="built_in">hasNext</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="285-286-Locked"><a href="#285-286-Locked" class="headerlink" title="285 ~ 286 Locked"></a>285 ~ 286 Locked</h2><h2 id="287-一个-n-的数组包含了-1…n-1-中的这些数字，证明一定存在重复，并找出这个重复"><a href="#287-一个-n-的数组包含了-1…n-1-中的这些数字，证明一定存在重复，并找出这个重复" class="headerlink" title="287 一个 n 的数组包含了 1…n-1 中的这些数字，证明一定存在重复，并找出这个重复"></a>287 一个 n 的数组包含了 1…n-1 中的这些数字，证明一定存在重复，并找出这个重复</h2><p>使用抽屉原理可以证明一定存在重复。据说高纳德解这个问题花了四个小时。</p>
<p>我们把这个数组看做一个变幻方程 <code>f(i) = A[i]</code>，把一些数字变幻到另一些，那么存在一个 <code>i != j s.t. f(i) == f(j)</code>.<br>那么这个问题变成了链表求环的问题。对于链表，我们有 n &#x3D; n-&gt;next 遍历列表，对于这个序列，则是<code> n = f(n)</code></p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 从 n-1 开始</span></span><br><span class="line">    <span class="type">int</span> fast = n - <span class="number">1</span>, slow = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        slow = nums[slow] - <span class="number">1</span>; <span class="comment">// 减一是为了转化为坐标</span></span><br><span class="line">        fast = nums[nums[fast] - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line">    fast = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        slow = nums[slow] - <span class="number">1</span>;</span><br><span class="line">        fast = nums[fast] - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>; <span class="comment">// 从坐标到数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="288-Locked"><a href="#288-Locked" class="headerlink" title="288 Locked"></a>288 Locked</h2><h2 id="289-Conway’s-Game-of-Life"><a href="#289-Conway’s-Game-of-Life" class="headerlink" title="289 Conway’s Game of Life"></a>289 Conway’s Game of Life</h2><p>哈哈，机智，使用没有使用的第二个位存储下一代</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;<span class="keyword">return</span> a &gt; b ? a :b;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;<span class="keyword">return</span> a &lt; b ? a :b;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gameOfLife</span><span class="params">(<span class="type">int</span>** board, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m=max(i<span class="number">-1</span>, <span class="number">0</span>); m&lt;min(i+<span class="number">2</span>, row); m++) <span class="comment">// 这里的 min，max 使用的太屌了</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> n=max(j<span class="number">-1</span>, <span class="number">0</span>); n&lt;min(j+<span class="number">2</span>, col); n++)</span><br><span class="line">                    count += (board[m][n] &amp; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">3</span> || count - board[i][j] == <span class="number">3</span>) <span class="comment">// 当前为 0，周围为 3；or 当前为 1，周围为 2/3 here</span></span><br><span class="line">                board[i][j] |= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            board[i][j] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="290-单词模式，给定一个模式-abba-等，判断单词是否是这个模式的。"><a href="#290-单词模式，给定一个模式-abba-等，判断单词是否是这个模式的。" class="headerlink" title="290 单词模式，给定一个模式 abba 等，判断单词是否是这个模式的。"></a>290 单词模式，给定一个模式 abba 等，判断单词是否是这个模式的。</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wordPattern</span><span class="params">(string pattern, string str)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; chars;  <span class="comment">// 使用两个 map 纪录</span></span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; words;</span><br><span class="line">    <span class="function">istringstream <span class="title">in</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, n = pattern.<span class="built_in">size</span>(); <span class="comment">// `i` is word count</span></span><br><span class="line">    <span class="keyword">for</span> (string word; in &gt;&gt; word; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n || chars[pattern[i]] != words[word]) <span class="comment">// 检查是否相等</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        chars[pattern[i]] = words[word] = i + <span class="number">1</span>; <span class="comment">// distinct non zero</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i == n; <span class="comment">// 检查长度是否相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="291-Locked"><a href="#291-Locked" class="headerlink" title="291 Locked"></a>291 Locked</h2><h2 id="292-Nim-游戏，每个人可以选择丢掉-1，2，3，最后一个操作者获胜"><a href="#292-Nim-游戏，每个人可以选择丢掉-1，2，3，最后一个操作者获胜" class="headerlink" title="292 Nim 游戏，每个人可以选择丢掉 1，2，3，最后一个操作者获胜"></a>292 Nim 游戏，每个人可以选择丢掉 1，2，3，最后一个操作者获胜</h2><p>显然，当我们遇到 4 的时候会输，其他情况都可以赢。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">canWinNim</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300 最长递增子序列"></a>300 最长递增子序列</h2><p>最经典的动态规划题目</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(*dp)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="344-翻转字符串"><a href="#344-翻转字符串" class="headerlink" title="344 翻转字符串"></a>344 翻转字符串</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* start = s;</span><br><span class="line">    <span class="type">char</span>* e = s;</span><br><span class="line">    <span class="keyword">while</span> (*e) ++e;</span><br><span class="line">    e--;</span><br><span class="line">    <span class="type">char</span> t;</span><br><span class="line">    <span class="keyword">while</span> (s &lt; e) &#123;</span><br><span class="line">        t = *s;</span><br><span class="line">        *s = *e;</span><br><span class="line">        *e = t;</span><br><span class="line">        s++;</span><br><span class="line">        e--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="347-出现最多的几个数字"><a href="#347-出现最多的几个数字" class="headerlink" title="347 出现最多的几个数字"></a>347 出现最多的几个数字</h2><p>C 实在缺乏相关的基础数据结构，这道题用 JS 做了</p>
<details>
    <summary>JavaScript 解答</summary>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> topKFrequent = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num <span class="keyword">in</span> counter) &#123;</span><br><span class="line">            counter[num]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counter[num] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> bucket = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">in</span> counter) &#123;</span><br><span class="line">        <span class="keyword">let</span> rev_freq = nums.<span class="property">length</span> - counter[num] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rev_freq <span class="keyword">in</span> bucket) &#123;</span><br><span class="line">            bucket[rev_freq].<span class="title function_">push</span>(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bucket[rev_freq] = [num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> rv = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> bc <span class="keyword">of</span> bucket) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! <span class="title class_">Array</span>.<span class="title function_">isArray</span>(bc)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> bc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rv.<span class="property">length</span> == k)</span><br><span class="line">                <span class="keyword">return</span> rv;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rv.<span class="title function_">push</span>(<span class="built_in">parseInt</span>(num))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="349-两个数组中都出现的元素"><a href="#349-两个数组中都出现的元素" class="headerlink" title="349 两个数组中都出现的元素"></a>349 两个数组中都出现的元素</h2><p>先排序，降低复杂度</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)a - *(<span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* <span class="title function_">intersection</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> m, <span class="type">int</span>* B, <span class="type">int</span> n, <span class="type">int</span>* k)</span> &#123;</span><br><span class="line">    qsort(A, m, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line">    qsort(B, n, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line">    <span class="type">int</span>* C = <span class="built_in">malloc</span>((m + n) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == B[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*k == <span class="number">0</span>)</span><br><span class="line">                C[(*k)++] = A[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (C[*k - <span class="number">1</span>] != A[i])</span><br><span class="line">                C[(*k)++] = A[i];</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[i] &lt; B[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="345-翻转一个字符串里面的元音字母"><a href="#345-翻转一个字符串里面的元音字母" class="headerlink" title="345 翻转一个字符串里面的元音字母"></a>345 翻转一个字符串里面的元音字母</h2><p>使用两个指针，不过需要注意元音字母包括了大小写</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseVowels</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        vowels = <span class="built_in">set</span>(<span class="string">&quot;AEIOUaeiou&quot;</span>)</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> vowels <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> vowels <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            s[i], s[j] = s[j], s[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="371-两个数之和"><a href="#371-两个数之和" class="headerlink" title="371 两个数之和"></a>371 两个数之和</h2><p>这道题要求不用 + 和 - 来计算出两个数之和，显然应该使用位运算，使用异或计算每一位的值，在使用或计算是否需要进位</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> last_bit_of_a = a &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> last_bit_of_b = b &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        rv |= (last_bit_of_a ^ last_bit_of_b ^ carry) &lt;&lt; i;</span><br><span class="line">        carry = (carry &amp; last_bit_of_a) | (carry &amp; last_bit_of_b) | (last_bit_of_a &amp; last_bit_of_b);</span><br><span class="line"></span><br><span class="line">        a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="388"><a href="#388" class="headerlink" title="388"></a>388</h2><p>使用栈的一道简单题目, 其实计算长度部分还可以优化</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthLongestPath</span>(<span class="params">self, <span class="built_in">input</span>: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        path = []</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">input</span>.split(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">            l = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> name:</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">&quot;\t&quot;</span>:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; l:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(path) - l):</span><br><span class="line">                    path.pop()</span><br><span class="line">            path.append(name.strip(<span class="string">&quot;\t&quot;</span>))</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;.&quot;</span> <span class="keyword">in</span> name:</span><br><span class="line">                length = <span class="built_in">sum</span>([<span class="built_in">len</span>(p) <span class="keyword">for</span> p <span class="keyword">in</span> path]) + <span class="built_in">len</span>(path) - <span class="number">1</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, length)</span><br><span class="line">                <span class="built_in">print</span>(path)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435 无重叠区间"></a>435 无重叠区间</h2><p>不要被题目迷惑，从反面开始思考，求去除多少个区间其实就是求最多有多少个有效区间</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eraseOverlapIntervals</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">        max_intervals = <span class="number">0</span></span><br><span class="line">        end = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> interval[<span class="number">0</span>] &gt;= end:</span><br><span class="line">                max_intervals += <span class="number">1</span></span><br><span class="line">                end = interval[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(intervals) - max_intervals</span><br></pre></td></tr></table></figure>
</details>


<h2 id="482-注册码格式化"><a href="#482-注册码格式化" class="headerlink" title="482 注册码格式化"></a>482 注册码格式化</h2><p>要求每 K 个字符添加一个 “-“, 如果不够的话，第一个分组可以不全。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">licenseKeyFormatting</span>(<span class="params">self, S: <span class="built_in">str</span>, K: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        key = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">reversed</span>(S):</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            key.append(c.upper())</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i % K == <span class="number">0</span>:</span><br><span class="line">                key.append(<span class="string">&quot;-&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">and</span> key[-<span class="number">1</span>] == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">            key = key[:-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="built_in">reversed</span>(key))</span><br></pre></td></tr></table></figure>
</details>


<h2 id="547-朋友圈"><a href="#547-朋友圈" class="headerlink" title="547 朋友圈"></a>547 朋友圈</h2><p>UnionFind 的定义见第 200 题</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findCircleNum</span>(<span class="params">self, M: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(M)</span><br><span class="line">        uf = UnionFind(n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> M[i][j] == <span class="number">1</span>:</span><br><span class="line">                    uf.union(i, j)</span><br><span class="line">        <span class="keyword">return</span> uf.count</span><br></pre></td></tr></table></figure>
</details>


<h2 id="739"><a href="#739" class="headerlink" title="739"></a>739</h2><p>单调栈的简单应用</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, T: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = []</span><br><span class="line">        ans = [<span class="number">0</span>] * <span class="built_in">len</span>(T)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(T)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 如果当前温度大于当前最低温度</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> T[i] &gt;= T[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                ans[i] = stack[-<span class="number">1</span>] - i</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<h2 id="864-矩形重叠"><a href="#864-矩形重叠" class="headerlink" title="864 矩形重叠"></a>864 矩形重叠</h2><details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isRectangleOverlap</span>(<span class="params">self, rec1: <span class="type">List</span>[<span class="built_in">int</span>], rec2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 注意要包含等于号</span></span><br><span class="line">        x_overlap = <span class="keyword">not</span>(rec1[<span class="number">0</span>] &gt;= rec2[<span class="number">2</span>] <span class="keyword">or</span> rec1[<span class="number">2</span>] &lt;= rec2[<span class="number">0</span>])</span><br><span class="line">        y_overlap = <span class="keyword">not</span>(rec1[<span class="number">1</span>] &gt;= rec2[<span class="number">3</span>] <span class="keyword">or</span> rec1[<span class="number">3</span>] &lt;= rec2[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> x_overlap <span class="keyword">and</span> y_overlap</span><br></pre></td></tr></table></figure>
</details>



<h2 id="904-找出包含了两个不同数字的最长子序列"><a href="#904-找出包含了两个不同数字的最长子序列" class="headerlink" title="904 找出包含了两个不同数字的最长子序列"></a>904 找出包含了两个不同数字的最长子序列</h2><p>这道题的题目很坑爹，但是翻译过来其实要求很明确。解题思路也很简单，存储一下当前的最长序列<br>就好了。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;Rust 解答&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```Rust</span><br><span class="line">use std::collections::HashMap;</span><br><span class="line">use std::cmp::max;</span><br><span class="line"></span><br><span class="line">impl Solution &#123;</span><br><span class="line">    <span class="function">pub fn <span class="title">total_fruit</span><span class="params">(tree: Vec&lt;i32&gt;)</span> -&gt; i32 </span>&#123;</span><br><span class="line">        let mut i = <span class="number">0</span>;</span><br><span class="line">        let mut res = <span class="number">0</span>;</span><br><span class="line">        let mut counter = HashMap::<span class="built_in">new</span>();</span><br><span class="line">        <span class="keyword">for</span> (j, el) in tree.<span class="built_in">iter</span>().<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">            *counter.<span class="built_in">entry</span>(el).<span class="built_in">or_insert</span>(<span class="number">0</span>) += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> counter.<span class="built_in">len</span>() &gt; <span class="number">2</span> &#123;</span><br><span class="line">                *counter.<span class="built_in">get_mut</span>(&amp;tree[i]).<span class="built_in">unwrap</span>() -= <span class="number">1</span>;</span><br><span class="line">                <span class="function"><span class="keyword">if</span> let <span class="title">Some</span><span class="params">(x)</span> </span>= counter.<span class="built_in">get</span>(&amp;tree[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> *x == <span class="number">0</span> &#123;</span><br><span class="line">                        counter.<span class="built_in">remove</span>(&amp;tree[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res as i32</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="986-区间列表的交集"><a href="#986-区间列表的交集" class="headerlink" title="986 区间列表的交集"></a>986 区间列表的交集</h2><p>tags: #interval</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intervalIntersection</span>(<span class="params">self, A: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], B: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(A) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(B):</span><br><span class="line">            lo = <span class="built_in">max</span>(A[i][<span class="number">0</span>], B[j][<span class="number">0</span>])</span><br><span class="line">            hi = <span class="built_in">min</span>(A[i][<span class="number">1</span>], B[j][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> lo &lt;= hi:</span><br><span class="line">                ans.append((lo, hi))</span><br><span class="line">            <span class="keyword">if</span> A[i][<span class="number">1</span>] &lt; B[j][<span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<h2 id="929-唯一邮件地址"><a href="#929-唯一邮件地址" class="headerlink" title="929 唯一邮件地址"></a>929 唯一邮件地址</h2><p>类似 Gmail 的规则，<code>.</code> 去掉，<code>+</code> 后面的也去掉。但是要注意域名中的 <code>.</code> 不能去掉</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">normalize</span>(<span class="params">self, username: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        username = username.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="comment"># 使用 split 更好，懒得改了</span></span><br><span class="line">        username = re.sub(<span class="string">r&quot;\+.*$&quot;</span>, <span class="string">&quot;&quot;</span>, username)</span><br><span class="line">        <span class="keyword">return</span> username</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numUniqueEmails</span>(<span class="params">self, emails: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        unique_emails = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> email <span class="keyword">in</span> emails:</span><br><span class="line">            username, domain = email.split(<span class="string">&quot;@&quot;</span>)</span><br><span class="line">            username = self.normalize(username)</span><br><span class="line">            <span class="comment"># print(username, domain)</span></span><br><span class="line">            unique_emails.add(<span class="string">f&quot;<span class="subst">&#123;username&#125;</span>@<span class="subst">&#123;domain&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(unique_emails)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="970-强力数字"><a href="#970-强力数字" class="headerlink" title="970 强力数字"></a>970 强力数字</h2><p>暴力解法</p>
<details>
    <summary>python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">powerfulIntegers</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span>, bound: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> bound &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = <span class="built_in">set</span>()</span><br><span class="line">        limit = <span class="built_in">int</span>(math.log2(bound)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(limit):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(limit):</span><br><span class="line">                v = x ** i + y ** j</span><br><span class="line">                <span class="keyword">if</span> v &lt;= bound:</span><br><span class="line">                    ans.add(v)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(ans)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="1272-删除区间"><a href="#1272-删除区间" class="headerlink" title="1272 删除区间"></a>1272 删除区间</h2><details>
    <summary>python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeInterval</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], toBeRemoved: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        lo, hi = toBeRemoved</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> y &lt; lo <span class="keyword">or</span> x &gt; hi:</span><br><span class="line">                ans.append([x, y])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> lo &gt; x:</span><br><span class="line">                    ans.append([x, lo])</span><br><span class="line">                <span class="keyword">if</span> hi &lt; y:</span><br><span class="line">                    ans.append([hi, y])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<h2 id="1317-将整数转换为两个无零整数的和"><a href="#1317-将整数转换为两个无零整数的和" class="headerlink" title="1317 将整数转换为两个无零整数的和"></a>1317 将整数转换为两个无零整数的和</h2><details>
    <summary>python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNoZeroIntegers</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            b = n - a</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;0&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(a) <span class="keyword">and</span> <span class="string">&quot;0&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(b):</span><br><span class="line">                <span class="keyword">return</span> [a, b]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
</details>


<h2 id="1389-按既定顺序创建目标数组"><a href="#1389-按既定顺序创建目标数组" class="headerlink" title="1389 按既定顺序创建目标数组"></a>1389 按既定顺序创建目标数组</h2><details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createTargetArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], index: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        target = []</span><br><span class="line">        <span class="keyword">for</span> n, i <span class="keyword">in</span> <span class="built_in">zip</span>(nums, index):</span><br><span class="line">            target = target[:i] + [n] + target[i:]</span><br><span class="line">        <span class="keyword">return</span> target</span><br></pre></td></tr></table></figure>
</details>


<h2 id="1390-四因数"><a href="#1390-四因数" class="headerlink" title="1390 四因数"></a>1390 四因数</h2><p>解释见注释，这道题还是很坑的。不过其实也很简单，四个因数就是能够分解成两个质数乘积或者是立方数。</p>
<p>比如：</p>
<ol>
<li>21 &#x3D; 3 * 7</li>
<li>8 &#x3D; 2 * 4</li>
</ol>
<details>
    <summary>py 解答</summary>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumFourDivisors</span>(<span class="params">self, nums</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            upper = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            upper = <span class="built_in">max</span>(*nums)</span><br><span class="line">        <span class="comment"># 首先在这里筛选素数</span></span><br><span class="line">        isPrim = [<span class="literal">True</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(upper)]</span><br><span class="line">        i = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> i * i &lt; upper:</span><br><span class="line">            <span class="keyword">if</span> isPrim[i]:</span><br><span class="line">                j = i * i</span><br><span class="line">                <span class="keyword">while</span> j &lt; upper:</span><br><span class="line">                    isPrim[j] = <span class="literal">False</span></span><br><span class="line">                    j += i</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 把素数都提取出来</span></span><br><span class="line">        prims = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, upper) <span class="keyword">if</span> isPrim[i]]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> prim <span class="keyword">in</span> prims:</span><br><span class="line">                <span class="comment"># 已经不可能了，后续不算了</span></span><br><span class="line">                <span class="keyword">if</span> prim * prim &gt; num:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 立方数是符合的，这个比较坑，开始没想到，比如 8</span></span><br><span class="line">                <span class="keyword">if</span> prim * prim * prim == num:</span><br><span class="line">                    ans += (<span class="number">1</span> + num + prim + prim * prim)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 可以分解成两个质数乘积</span></span><br><span class="line">                <span class="keyword">if</span> num % prim == <span class="number">0</span> <span class="keyword">and</span> isPrim[num // prim] <span class="keyword">and</span> prim * prim != num:</span><br><span class="line">                    ans += (<span class="number">1</span> + num + prim + num // prim)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>




<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></h6></h6>]]></content>
      <categories>
        <category>Job Interview</category>
      </categories>
  </entry>
  <entry>
    <title>Reverse Interview</title>
    <url>/Blog/2022/03/05/Reverse-Interview/</url>
    <content><![CDATA[<h6 align="center">编者：艾孜尔江<h6>


<h1 id="反向面试指南"><a href="#反向面试指南" class="headerlink" title="反向面试指南"></a>反向面试指南</h1><p>下面列表里的问题对于参加技术面试的人来说可能有些用。<br>列表里的问题并不一定适用于某个特定的职位或者工作类型，也没有排序。最开始的时候这只是我自己的问题列表，但是慢慢地添加了一些我觉得可能让我对这家公司亮红牌的问题。<br>我也注意到被我面试的人提问我的问题太少了，感觉他们挺浪费机会的。</p>
<h2 id="预期使用方式"><a href="#预期使用方式" class="headerlink" title="预期使用方式"></a>预期使用方式</h2><ul>
<li>检查一下哪些问题你感兴趣</li>
<li>检查一下哪些是你可以自己在网上找到答案的</li>
<li>找不到的话就向面试官提问</li>
</ul>
<p>绝对不要想把这个列表里的每个问题都问一遍。（尊重面试官的时间，而且你可以通过查找已经发布的答案来显示你的主动性）</p>
<p>请记住事情总是灵活的，组织的结构调整也会经常发生。拥有一个 bug 追踪系统并不会保证高效处理 bug。<br>CI&#x2F;CD （持续集成系统） 也不一定保证交付时间会很短。</p>
<h1 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h1><ul>
<li>On-call （电话值班）的计划或者规定是什么？值班或者遇到问题加班时候有加班费吗？</li>
<li>我的日常工作是什么？</li>
<li>有给我设定的特定目标吗？</li>
<li>团队里面初级和高级工程师的比例是多少？（有计划改变吗）</li>
<li>入职培训 (onboarding) 会是什么样的？</li>
<li>每个开发者有多大的自由来做出决定？</li>
<li>在你看来，这个工作做到什么程度算成功？</li>
<li>你期望我在最初的一个月 &#x2F; 三个月能够完成什么？</li>
<li>试用期结束的时候，你会怎么样衡量我的绩效？</li>
<li>自己单独的开发活动和按部就班工作的比例大概是怎样的？</li>
<li>一个典型的一天或者一周的工作是怎样安排的？</li>
<li>对我的申请你有什么疑虑么？</li>
<li>在这份工作上，我将会和谁紧密合作？</li>
<li>我的直接上级他们的上级都是什么样的管理风格？（事无巨细还是着眼宏观）</li>
<li>我在这个岗位上应该如何发展？会有哪些机会？</li>
<li>每天预期 &#x2F; 核心工作时间是多少小时？</li>
<li>我入职的岗位是新增还是接替之前离职的同事？（是否有技术债需要还）？(zh)</li>
<li>入职之后在哪个项目组，项目是新成立还是已有的？(zh)</li>
</ul>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><ul>
<li>公司常用的技术栈是什么？</li>
<li>你们怎么使用源码控制系统？</li>
<li>你们怎么测试代码？</li>
<li>你们怎么追踪 bug?</li>
<li>你们怎样监控项目？</li>
<li>你们怎么集成和部署代码改动？是使用持续集成和持续部署吗 (CI&#x2F;CD)？</li>
<li>你们的基础设施搭建在版本管理系统里吗？或者是代码化的吗？</li>
<li>从计划到完成一项任务的工作流是什么样的？</li>
<li>你们如何准备故障恢复？</li>
<li>有标准的开发环境吗？是强制的吗？</li>
<li>你们需要花费多长时间来给产品搭建一个本地测试环境？（分钟 &#x2F; 小时 &#x2F; 天）</li>
<li>你们需要花费多长时间来响应代码或者依赖中的安全问题？</li>
<li>所有的开发者都可以使用他们电脑的本地管理员权限吗？</li>
<li>介绍一下你们的技术原则或者展望。</li>
<li>你们的代码有开发文档吗？有没有单独的供消费者阅读的文档？</li>
<li>你们有更高层次的文档吗？比如说 ER 图，数据库范式</li>
<li>你们使用静态代码分析吗？</li>
<li>你们如何管理内部和外部的数字资产？</li>
<li>你们如何管理依赖？</li>
<li>公司是否有技术分享交流活动？有的话，多久一次呢？(zh)</li>
<li>你们的数据库是怎么进行版本控制的？(zh)</li>
<li>业务需求有没有文档记录？是如何记录的？(zh)</li>
</ul>
<h1 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h1><ul>
<li>工作是怎么组织的？</li>
<li>团队内 &#x2F; 团队间的交流通常是怎样的？</li>
<li>你们使用什么工具来做项目组织？你的实际体会是什么？</li>
<li>如果遇到不同的意见怎样处理？</li>
<li>谁来设定优先级 &#x2F; 计划？</li>
<li>如果团队没能赶上预期发布日期怎么办？</li>
<li>每周都会开什么类型的会议？</li>
<li>会有定期的和上级的一对一谈话吗？</li>
<li>产品 &#x2F; 服务的规划是什么样的？（n 周一发布 &#x2F; 持续部署 &#x2F; 多个发布流 &#x2F; …)</li>
<li>生产环境发生事故了怎么办？是否有不批评人而分析问题的文化？</li>
<li>有没有一些团队正在经历还尚待解决的挑战？</li>
<li>你们如何跟踪进度？</li>
<li>预期和目标是如何设定的？谁来设定？</li>
<li>Code Review 如何实施？</li>
<li>给我介绍下团队里一个典型的 sprint</li>
<li>你们如何平衡技术和商业目标？</li>
<li>你们如何共享知识？</li>
<li>团队有多大？</li>
<li>公司技术团队的架构和人员组成？(zh)</li>
<li>团队内开发、产品、运营哪一方是需求的主要提出方？哪一方更强势？(zh)</li>
</ul>
<h1 id="问未来的同事"><a href="#问未来的同事" class="headerlink" title="问未来的同事"></a>问未来的同事</h1><ul>
<li>开发者倾向于从哪里学习？</li>
<li>你对在这里工作最满意的地方是？</li>
<li>最不满意的呢？</li>
<li>如果可以的话，你想改变哪里？</li>
<li>团队最老的成员在这里多久了？</li>
<li>在小团队中，有没有出现成员性格互相冲突的情况？最后是如何解决的？</li>
</ul>
<h1 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h1><ul>
<li>公司为什么在招人？（产品发展 &#x2F; 新产品 &#x2F; 波动…)</li>
<li>有没有会议 &#x2F; 旅行预算？使用的规定是什么？</li>
<li>晋升流程是怎样的？要求 &#x2F; 预期是怎样沟通的？</li>
<li>绩效评估流程是怎样的？</li>
<li>技术和管理两条职业路径是分开的吗？</li>
<li>对于多元化招聘的现状或者观点是什么？</li>
<li>有公司级别的学习资源吗？比如电子书订阅或者在线课程？</li>
<li>有获取证书的预算吗？</li>
<li>公司的成熟度如何？（早期寻找方向 &#x2F; 有内容的工作 &#x2F; 维护中 &#x2F; …)</li>
<li>我可以为开源项目做贡献吗？是否需要审批？</li>
<li>你认为公司未来五年或者十年会发展成什么样子？</li>
<li>公司的大多数员工是如何看待整洁代码的？</li>
<li>你上次注意到有人成长是什么时候？他们在哪方面成长了？</li>
<li>在这里成功的定义是什么？如何衡量成功？</li>
<li>有体育活动或者团建么？</li>
<li>有内部的黑客马拉松活动吗？</li>
<li>公司支持开源项目吗？</li>
<li>有竞业限制或者保密协议需要签吗？</li>
<li>你们认为公司文化中的空白是什么？</li>
<li>能够跟我说一公司处于不良情况，以及如何处理的故事吗？</li>
<li>您在这工作了多久了？您觉得体验如何？(zh)</li>
<li>大家为什么会喜欢这里？(zh)</li>
<li>公司的调薪制度是如何的？(zh)</li>
</ul>
<h1 id="社会问题"><a href="#社会问题" class="headerlink" title="社会问题"></a>社会问题</h1><ul>
<li>你们关于多元化招聘什么看法？</li>
<li>你们的公司文化如何？你认为有什么空白么？</li>
<li>这里的工作生活平衡地怎么样？</li>
<li>公司对气候变化有什么态度吗？</li>
</ul>
<h1 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h1><ul>
<li>不同的意见如何处理？</li>
<li>如果被退回了会怎样？（“这个在预计的时间内做不完”）</li>
<li>当团队有压力并且在超负荷工作的时候怎么处理？</li>
<li>如果有人注意到了在流程或者技术等其他方面又改进的地方，怎么办？</li>
<li>当管理层的预期和工程师的绩效之间有差距的时候如何处理？</li>
<li>能给我讲一个公司深处有毒环境以及如何处理的故事吗？</li>
<li>如果在公司内你的同事因涉嫌性侵犯他人而被调查，请问你会如何处理？</li>
<li>假设我自己很不幸是在公司内被性侵的受害者，在公司内部有没有争取合法权益的渠道？</li>
</ul>
<h1 id="商业"><a href="#商业" class="headerlink" title="商业"></a>商业</h1><ul>
<li>你们现在盈利吗？</li>
<li>如果没有的话，还需要多久？</li>
<li>公司的资金来源是什么？谁影响或者制定高层计划或方向？</li>
<li>你们如何挣钱？</li>
<li>什么阻止了你们挣更多的钱？</li>
<li>公司未来一年的增长计划怎样？五年呢？</li>
<li>你们认为什么是你们的竞争优势？</li>
<li>你们的竞争优势是什么？</li>
<li>公司未来的商业规划是怎样的？有上市的计划吗？(zh)</li>
</ul>
<h1 id="远程工作"><a href="#远程工作" class="headerlink" title="远程工作"></a>远程工作</h1><ul>
<li>远程工作和办公室工作的比例是多少？</li>
<li>公司提供硬件吗？更新计划如何？</li>
<li>使用自己的硬件办公可以吗？现在有政策吗？</li>
<li>额外的附件和家具可以通过公司购买吗？这方面是否有预算？</li>
<li>有共享办公或者上网的预算吗？</li>
<li>多久需要去一次办公室？</li>
<li>公司的会议室是否一直是视频会议就绪的？</li>
</ul>
<h1 id="办公室布局"><a href="#办公室布局" class="headerlink" title="办公室布局"></a>办公室布局</h1><ul>
<li>办公室的布局如何？（开放的 &#x2F; 小隔间 &#x2F; 独立办公室）</li>
<li>有没有支持 &#x2F; 市场 &#x2F; 或者其他需要大量打电话的团队在我的团队旁边办公？</li>
</ul>
<h1 id="终极问题"><a href="#终极问题" class="headerlink" title="终极问题"></a>终极问题</h1><ul>
<li>该职位为何会空缺？</li>
<li>公司如何保证人才不流失？</li>
<li>这份工作 &#x2F; 团队 &#x2F; 公司最好和最坏的方面是？</li>
<li>你最开始为什么选择了这家公司？</li>
<li>你为什么留在这家公司？</li>
</ul>
<h1 id="待遇"><a href="#待遇" class="headerlink" title="待遇"></a>待遇</h1><ul>
<li>如果有奖金计划的话，奖金如何分配？</li>
<li>如果有奖金计划的话，过去的几年里通常会发百分之多少的奖金？</li>
<li>有五险一金(zh)&#x2F;401k(us)或者其他退休养老金等福利吗？</li>
<li>五险一金中，补充公积金一般交多少比例？&#x2F;401k一般交多少比例？我可以自己选择这一比例吗？</li>
<li>有什么医疗保险吗？如果有的话何时开始？</li>
<li>有额外商业保险吗？例如人寿保险和额外的养老&#x2F;医疗保险？</li>
<li>更换工作地点，公司付费吗？</li>
</ul>
<h1 id="休假"><a href="#休假" class="headerlink" title="休假"></a>休假</h1><ul>
<li>带薪休假时间有多久？</li>
<li>病假和事假是分开的还是一起算？</li>
<li>我可以提前使用假期时间吗？也就是说应休假期是负的？</li>
<li>假期的更新策略是什么样的？也就是说未休的假期能否滚入下一周期</li>
<li>照顾小孩的政策如何？</li>
<li>无薪休假政策是什么样的？</li>
<li>学术性休假政策是怎么样的？</li>
</ul>
<h1 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h1><p>Find more inspiration for questions in:</p>
<ul>
<li><a href="https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/">The Joel Test: 12 Steps to Better Code</a> by Joel Spolsky</li>
<li><a href="https://jvns.ca/blog/2013/12/30/questions-im-asking-in-interviews/">Questions I’m asking in interviews</a> by Julia Evans</li>
</ul>
<br>
<br>
<br>
<br>
<br>

<hr>
<br>

<h1 id="Reverse-interview"><a href="#Reverse-interview" class="headerlink" title="Reverse interview"></a>Reverse interview</h1><p>This is a list of questions which may be interesting to a tech job applicant.<br>The points are not ordered and many may not apply to a given position, or work type.<br>It was started as my personal list of questions, which grew over time to include both things I’d like to see more of and red flags which I’d like to avoid.<br>I’ve also noticed how few questions were asked by people I interviewed and I think those were missed opportunities.</p>
<h2 id="Expected-usage"><a href="#Expected-usage" class="headerlink" title="Expected usage"></a>Expected usage</h2><ul>
<li>Check which questions are interesting for you specifically</li>
<li>Check which answers you can find yourself online</li>
<li>Otherwise ask</li>
</ul>
<p>Definitely don’t try to ask everything from the list. (Respect the interviewer’s time and show initiative by finding answers on your own if they’re already published)</p>
<p>Remember that things tend to be fluid, re-organizations happens often.<br>Having a bug tracking system doesn’t make bug handling efficient and CI&#x2F;CD doesn’t mean your time to deliver is necessarily short.</p>
<h1 id="The-Role"><a href="#The-Role" class="headerlink" title="The Role"></a>The Role</h1><ul>
<li>What’s the on-call plan&#x2F;schedule? (what’s the pay for standby and call-out)</li>
<li>What are the tasks I would do on a usual day?</li>
<li>Are there any specific goals for me?</li>
<li>What’s the junior&#x2F;senior balance of the team? (and are there plans to change it)</li>
<li>What does the onboarding look like?</li>
<li>How much freedom for decision making do individual developers have?</li>
<li>What are the expected&#x2F;core work hours?</li>
<li>What is your definition of success for this role?</li>
<li>What do you expect me to accomplish in the first 1 month&#x2F;3 months?</li>
<li>How will you evaluate my performance at the end of the trial period?</li>
<li>What does a typical day&#x2F;week look like in this role?</li>
<li>Do you have any concerns about my application?</li>
<li>Tell me about who I would be working most closely with.</li>
<li>What management style does my immediate manager and their manager have? (from micro- to macro-)</li>
<li>How can I develop in my new role &#x2F; what opportunities are offered?</li>
</ul>
<h1 id="Tech"><a href="#Tech" class="headerlink" title="Tech"></a>Tech</h1><ul>
<li>What are the usual stacks used at the company?</li>
<li>How do you use source control?</li>
<li>How do you test code?</li>
<li>How do you track bugs?</li>
<li>How do you monitor projects?</li>
<li>How do you integrate and deploy changes? Is it CI&#x2F;CD?</li>
<li>Is your infrastructure setup under version control &#x2F; available as code?</li>
<li>What’s the workflow from the planning to the finished task?</li>
<li>How do you prepare for disaster recovery?</li>
<li>Is there a standardised development environment? Is it enforced?</li>
<li>How quickly can you setup a new local test environment for the product? (minutes &#x2F; hours &#x2F; days)</li>
<li>How quickly can you respond to security issues in the code or dependencies?</li>
<li>Are all developers allowed to have local admin access of their computers?</li>
<li>Tell me about your technical principles or vision.</li>
<li>Do you have a developer documentation for your code? Do you have a separate documentation for customers?</li>
<li>Do you have some higher level documentation? (ER diagrams, database schema)</li>
<li>Do you employ static code analysis?</li>
<li>How do you manage internal &#x2F; external artifacts?</li>
<li>How do you manage dependencies?</li>
</ul>
<h1 id="The-Team"><a href="#The-Team" class="headerlink" title="The Team"></a>The Team</h1><ul>
<li>How is the work organised?</li>
<li>How does the intra&#x2F;inter-team communication typically work?</li>
<li>Do you use any tools for project organization? What is your experience with them?</li>
<li>How are differences of opinions resolved?</li>
<li>Who sets the priorities &#x2F; schedule?</li>
<li>What happens after pushback? (“this can’t be done in the projected time”)</li>
<li>What happens when the team misses a release target?</li>
<li>What kind of meetings happen every week?</li>
<li>Would there be a regular 1-on-1 with my manager?</li>
<li>What’s the product&#x2F;service schedule? (n-weekly releases &#x2F; continuous deployment &#x2F; multiple release streams &#x2F; …)</li>
<li>What happens after production incidents? Is there a culture of blameless analysis?</li>
<li>What are some ongoing challenges the team is experiencing that you are yet to resolve?</li>
<li>How do you track progress?</li>
<li>How are expectations and goals set, and who does the setting?</li>
<li>What does a code review look like here?</li>
<li>Walk me through a typical sprint on this team</li>
<li>How do you balance technical vs business goals?</li>
<li>How do you share knowledge?</li>
<li>How big are the teams?</li>
</ul>
<h1 id="Your-Potential-Coworkers"><a href="#Your-Potential-Coworkers" class="headerlink" title="Your Potential Coworkers"></a>Your Potential Coworkers</h1><ul>
<li>Who do developers tend to learn from?</li>
<li>What do you like best about working there?</li>
<li>What do you like least?</li>
<li>What would you change if you could?</li>
<li>How long has the longest team member been there?</li>
<li>If it’s a small team, has there been experiences of conflicting personalities and how was this dealt with?</li>
</ul>
<h1 id="The-Company"><a href="#The-Company" class="headerlink" title="The Company"></a>The Company</h1><ul>
<li>Why is the company hiring? (product growth &#x2F; new product &#x2F; fluctuation &#x2F; …)</li>
<li>Is there a conference&#x2F;travel budget and what are the rules to use it?</li>
<li>What’s the promotion process? How are requirements &#x2F; expectations communicated?</li>
<li>What is the performance review process like?</li>
<li>Is there a separate tech and management career path?</li>
<li>Are there any company-wide resources for learning available, like ebooks subscriptions, or online courses?</li>
<li>Is there a budget for getting certifications?</li>
<li>What’s the maturity stage? (early finding direction &#x2F; feature work &#x2F; maintenance &#x2F; …)</li>
<li>Can I contribute to FOSS projects? Are there any approvals needed?</li>
<li>Are there any non-compete or non-disclosure agreements I’ll be asked to sign?</li>
<li>Where do you see the company in the next 5&#x2F;10 years? </li>
<li>What does clean code mean to the majority of developers here?</li>
<li>When is the last time you noticed someone growing here, and in what way were they growing?</li>
<li>What does it mean to be successful here, and how do you measure success?</li>
<li>Is there a Sports &#x2F; Team building Activity?</li>
<li>Are there any Hackathons conducted internally?</li>
<li>Does the company support open-source projects?</li>
<li>What kind of social events does the team&#x2F;company host and are these attended by everyone?</li>
<li>Why did the company decide to hire an outsider over promoting an internal employee?</li>
</ul>
<h1 id="Social-issues"><a href="#Social-issues" class="headerlink" title="Social issues"></a>Social issues</h1><ul>
<li>What’s the status of &#x2F; view on diverse hiring?</li>
<li>What do you think are the gaps in the company culture? (and what is the company culture?)</li>
<li>What does work-life balance mean here?</li>
<li>Does the company have a stance regarding climate change?</li>
</ul>
<h1 id="Conflict"><a href="#Conflict" class="headerlink" title="Conflict"></a>Conflict</h1><ul>
<li>How are differences of opinions resolved?</li>
<li>What happens after pushback? (“this can’t be done in the projected time”)</li>
<li>What happens when the team is under pressure and commits to work over their capacity &#x2F; velocity?</li>
<li>If someone identifies areas of improvement in process &#x2F; technology &#x2F; etc, what happens?</li>
<li>When there is a gap between expectations from management and performance of an engineer or team, what happens?</li>
<li>Could you tell me a story about a toxic situation and how the company dealt with it?</li>
</ul>
<h1 id="The-Business"><a href="#The-Business" class="headerlink" title="The Business"></a>The Business</h1><ul>
<li>Are you profitable?</li>
<li>If not, how long is your runway?</li>
<li>Where does the funding come from and who influences the high level plan&#x2F;direction?</li>
<li>How do you make money?</li>
<li>What’s preventing you from making more money?</li>
<li>What is the company’s growth plan for the next 1 year? 5 years?</li>
<li>What are the big challenges you see coming up?</li>
<li>What have you identified as your competitive advantage?</li>
</ul>
<h1 id="Remote-Work"><a href="#Remote-Work" class="headerlink" title="Remote Work"></a>Remote Work</h1><ul>
<li>What’s the ratio of remote to office workers?</li>
<li>Does the company provide hardware and what’s the refresh schedule?</li>
<li>How do you feel about <a href="https://en.wikipedia.org/wiki/Bring_your_own_device">BYOD</a>? Are there any policies around it already?</li>
<li>Are extra accessories&#x2F;furniture possible to buy through the company? Is there a budget for them?</li>
<li>Is there a budget for co-working space or internet access?</li>
<li>How often are office visits expected?</li>
<li>Are the office meeting rooms always prepared for video conferences?</li>
</ul>
<h1 id="Building-Layout"><a href="#Building-Layout" class="headerlink" title="Building Layout"></a>Building Layout</h1><ul>
<li>What’s the office layout? (open plan &#x2F; cubicles &#x2F; offices)</li>
<li>Is there a support &#x2F; marketing &#x2F; other call-heavy team close to my new team?</li>
</ul>
<h1 id="Catch-all"><a href="#Catch-all" class="headerlink" title="Catch all"></a>Catch all</h1><ul>
<li>What’s the best and what’s the worst aspect of working in this role &#x2F; team &#x2F; company?</li>
<li>What got you to choose to work for the company initially?</li>
<li>What keeps you at the company?</li>
</ul>
<h1 id="Compensation"><a href="#Compensation" class="headerlink" title="Compensation"></a>Compensation</h1><ul>
<li>If you have a bonus scheme, then how are bonuses determined?</li>
<li>If you have a bonus scheme, then what have been the typical bonus percentages over the past few years?</li>
<li>Do you have a 401k or other retirement plan? If so, does the company match additional plan contributions?</li>
<li>Are there medical benefits and if so, when do they start?</li>
<li>Do you pay for relocation?</li>
</ul>
<h1 id="Time-Off"><a href="#Time-Off" class="headerlink" title="Time Off"></a>Time Off</h1><ul>
<li>How much Paid Time Off (PTO) is offered?</li>
<li>Are sick time and vacation time separate or do they come from the same pool?</li>
<li>Can I use vacation time before it’s accrued, effectively going into a negative PTO balance?</li>
<li>What is the roll over policy is there for PTO?</li>
<li>What is the parental leave policy?</li>
<li>What is the policy on unpaid leave?</li>
<li>What is the policy for sabbatical leave?</li>
</ul>
<h1 id="Other-resources"><a href="#Other-resources" class="headerlink" title="Other resources"></a>Other resources</h1><p>Find more inspiration for questions in:</p>
<ul>
<li><a href="https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/">The Joel Test: 12 Steps to Better Code</a> by Joel Spolsky</li>
<li><a href="https://jvns.ca/blog/2013/12/30/questions-im-asking-in-interviews/">Questions I’m asking in interviews</a> by Julia Evans</li>
</ul>
<h1 id="License"><a href="#License" class="headerlink" title="License"></a>License</h1><p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" alt="Creative Commons License"></a></p>
<p>This work is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://github.com/viraptor/reverse-interview">中文翻译来源</a></p>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></h6></h6>]]></content>
      <categories>
        <category>Job Interview</category>
      </categories>
  </entry>
  <entry>
    <title>Test Asset Folder</title>
    <url>/Blog/2022/02/13/Test-Asset-Folder/</url>
    <content><![CDATA[<h1 id="Asset-Folder-Test"><a href="#Asset-Folder-Test" class="headerlink" title="Asset Folder Test"></a>Asset Folder Test</h1><h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><p>The image is placed in the folder with the same name as this document.<br><br></p>
<h4 id="1-Revise-the-code-in-hexo-asset-image-index-js-to-the-code-below"><a href="#1-Revise-the-code-in-hexo-asset-image-index-js-to-the-code-below" class="headerlink" title="1. Revise the code in hexo-asset-image/index.js to the code below:"></a>1. Revise the code in <code>hexo-asset-image/index.js</code> to the code below:</h4><p><em>Pay attention to the codes on 59 line.</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPosition</span>(<span class="params">str, m, i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">split</span>(m, i).<span class="title function_">join</span>(m).<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.<span class="property">config</span>;</span><br><span class="line">  <span class="keyword">if</span>(config.<span class="property">post_asset_folder</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> link = data.<span class="property">permalink</span>;</span><br><span class="line">    <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> appendLink = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">    <span class="comment">// if not with index.html endpos = link.lastIndexOf(&#x27;.&#x27;) + 1 support hexo-abbrlink</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/.*\/index\.html$/</span>.<span class="title function_">test</span>(link)) &#123;</span><br><span class="line">      <span class="comment">// when permalink is end with index.html, for example 2019/02/20/xxtitle/index.html</span></span><br><span class="line">      <span class="comment">// image in xxtitle/ will go to xxtitle/index/</span></span><br><span class="line">      appendLink = <span class="string">&#x27;index/&#x27;</span>;</span><br><span class="line">      <span class="keyword">var</span> endPos = link.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> endPos = link.<span class="property">length</span>-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    link = link.<span class="title function_">substring</span>(beginPos, endPos) + <span class="string">&#x27;/&#x27;</span> + appendLink;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.<span class="title function_">load</span>(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">          <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">          <span class="keyword">var</span> src = $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">          <span class="keyword">if</span>(!(<span class="regexp">/http[s]*.*|\/\/.*/</span>.<span class="title function_">test</span>(src)</span><br><span class="line">            || <span class="regexp">/^\s+\//</span>.<span class="title function_">test</span>(src)</span><br><span class="line">            || <span class="regexp">/^\s*\/uploads|images\//</span>.<span class="title function_">test</span>(src))) &#123;</span><br><span class="line">            <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">            <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">            <span class="keyword">var</span> linkArray = link.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">var</span> srcArray = src.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span>(srcArray.<span class="property">length</span> &gt; <span class="number">1</span>)</span><br><span class="line">            srcArray.<span class="title function_">shift</span>();</span><br><span class="line">            src = srcArray.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// $(this).attr(&#x27;src&#x27;, config.root + link + src); // original code</span></span><br><span class="line">            <span class="comment">// console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span></span><br><span class="line">            $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, data.<span class="property">permalink</span> + src); <span class="comment">// new code</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;update link as:--&gt;&quot;</span> + data.<span class="property">permalink</span> + src);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">          <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>($(<span class="variable language_">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.<span class="title function_">html</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-Place-the-image-you-are-gonna-use-in-your-MD-file-to-the-folder-the-same-as-your-MD-file"><a href="#2-Place-the-image-you-are-gonna-use-in-your-MD-file-to-the-folder-the-same-as-your-MD-file" class="headerlink" title="2. Place the image you are gonna use in your MD file to the folder the same as your MD file."></a>2. Place the image you are gonna use in your MD file to the folder the same as your MD file.</h4><br>

<h4 id="3-Directly-use-the-image-in-your-note-in-MD-file-like-below"><a href="#3-Directly-use-the-image-in-your-note-in-MD-file-like-below" class="headerlink" title="3. Directly use the image in your note in MD file like below."></a>3. Directly use the image in your note in MD file like below.</h4><p><img src="https://ezharjan.github.io/Blog/2022/02/13/Test-Asset-Folder/camel.jpg" alt="Local Image Test"></p>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>]]></content>
      <categories>
        <category>Hexo Intro</category>
      </categories>
  </entry>
</search>
