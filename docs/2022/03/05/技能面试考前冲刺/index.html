<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/Blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/Blog/css/main.css">


<link rel="stylesheet" href="/Blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ezharjan.github.io","root":"/Blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="编者：艾孜尔江    一、编程之美1.2 中国象棋将帅问题123456789struct &amp;#123;    unsigned char a:4;    unsigned char b:4;&amp;#125;;for (i.a &#x3D; 1; i.a &lt;&#x3D; 9; i.a++)    for (i.b &#x3D; 1; i.b &lt;&#x3D; 9; i.b++)        if (i.a % 3 !&#x3D; i.b %">
<meta property="og:type" content="article">
<meta property="og:title" content="技能面试考前冲刺">
<meta property="og:url" content="https://ezharjan.github.io/Blog/2022/03/05/%E6%8A%80%E8%83%BD%E9%9D%A2%E8%AF%95%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BA/index.html">
<meta property="og:site_name">
<meta property="og:description" content="编者：艾孜尔江    一、编程之美1.2 中国象棋将帅问题123456789struct &amp;#123;    unsigned char a:4;    unsigned char b:4;&amp;#125;;for (i.a &#x3D; 1; i.a &lt;&#x3D; 9; i.a++)    for (i.b &#x3D; 1; i.b &lt;&#x3D; 9; i.b++)        if (i.a % 3 !&#x3D; i.b %">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png">
<meta property="article:published_time" content="2022-03-05T14:53:32.000Z">
<meta property="article:modified_time" content="2024-04-06T13:13:07.817Z">
<meta property="article:author" content="Alexander Ezharjan">
<meta property="article:tag" content="Software, Lab, Engineer, Game Engine, Alexander, Ezharjan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png">

<link rel="canonical" href="https://ezharjan.github.io/Blog/2022/03/05/%E6%8A%80%E8%83%BD%E9%9D%A2%E8%AF%95%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BA/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>技能面试考前冲刺 | </title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/Blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title"></h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Blog By Alexander</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/Blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/Blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ezharjan.github.io/Blog/2022/03/05/%E6%8A%80%E8%83%BD%E9%9D%A2%E8%AF%95%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Alexander Ezharjan">
      <meta itemprop="description" content="This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          技能面试考前冲刺
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-05 22:53:32" itemprop="dateCreated datePublished" datetime="2022-03-05T22:53:32+08:00">2022-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-04-06 21:13:07" itemprop="dateModified" datetime="2024-04-06T21:13:07+08:00">2024-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Job-Interview/" itemprop="url" rel="index"><span itemprop="name">Job Interview</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h6 align="center">编者：艾孜尔江<h6>


<hr>
<h1 id="一、编程之美"><a href="#一、编程之美" class="headerlink" title="一、编程之美"></a>一、编程之美</h1><h2 id="1-2-中国象棋将帅问题"><a href="#1-2-中国象棋将帅问题" class="headerlink" title="1.2 中国象棋将帅问题"></a>1.2 中国象棋将帅问题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b:<span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i.a = <span class="number">1</span>; i.a &lt;= <span class="number">9</span>; i.a++)</span><br><span class="line">    <span class="keyword">for</span> (i.b = <span class="number">1</span>; i.b &lt;= <span class="number">9</span>; i.b++)</span><br><span class="line">        <span class="keyword">if</span> (i.a % <span class="number">3</span> != i.b % <span class="number">3</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%u:%u&quot;</span>, i.a, i.b);</span><br></pre></td></tr></table></figure>

<h2 id="1-14-连连看"><a href="#1-14-连连看" class="headerlink" title="1.14 连连看"></a>1.14 连连看</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Grid* preClick = <span class="literal">NULL</span>, * curClick = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// listen user event</span></span><br><span class="line">    <span class="keyword">if</span> (点击格子 xy 非空) &#123;</span><br><span class="line">        preClick = curClick;</span><br><span class="line">        curClick.pos = x, y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preClick &amp;&amp; curClick &amp;&amp; findPath(preClick, curClick)) &#123;</span><br><span class="line">        显示路径</span><br><span class="line">        消去</span><br><span class="line">        preClick = curClick = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-2-6-LeetCode"><a href="#2-1-2-6-LeetCode" class="headerlink" title="2.1 - 2.6 LeetCode"></a>2.1 - 2.6 LeetCode</h2><h2 id="2-7-最大公约数"><a href="#2-7-最大公约数" class="headerlink" title="2.7 最大公约数"></a>2.7 最大公约数</h2><p>辗转相除法，如果一个数能够整除x,y，那么他也能够整除x,x%y。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> gcd(y, x % y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// iterative</span><br><span class="line">int gcd(int x, int y) &#123;</span><br><span class="line">    while (y) &#123;</span><br><span class="line">        int t = x;</span><br><span class="line">        x = y</span><br><span class="line">        y = t % y;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">取模运算开销较大，但如下方法在y比较小时，求解次数过多，容易溢出</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">int gcd(int x, int y) &#123;</span><br><span class="line">    if (x &lt; y)</span><br><span class="line">        return gcd(y, x);</span><br><span class="line">    if (y == 0)</span><br><span class="line">        return x;</span><br><span class="line">    return gcd(x - y, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">        <span class="keyword">return</span> gcd(y, x);</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">0x1</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">0x1</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> gcd(x&gt;&gt;<span class="number">1</span>, y&gt;&gt;<span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> gcd(x &gt;&gt;<span class="number">1</span>, y);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">0x1</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> gcd(x, y&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> gcd(y, x-y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="2-8-看下讲解"><a href="#2-8-看下讲解" class="headerlink" title="2.8 看下讲解"></a>2.8 看下讲解</h2><h2 id="2-9-斐波那契数列"><a href="#2-9-斐波那契数列" class="headerlink" title="2.9 斐波那契数列"></a>2.9 斐波那契数列</h2><p>使用动态规划(Memoization)的算法不在赘述O(n)。</p>
<p>O(logn)的解法</p>
<p>通项公式</p>
<pre><code>f(n), f(n-1) = (f(n-1), f(n-2)) * A

A = |1  1|
    |1  0| 

f(n), f(n-1) = (f(n-1), f(n-2)) * A = ... = (f1, f0) * A^(n-1)
</code></pre>
<p>下面我们计算<code>A^n-1</code>，太简单了，使用<code>A^(2n) = A^n * A^n</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// pesudo code</span><br><span class="line">int fib(int n) &#123;</span><br><span class="line">    Matrix factor = matrixPow(A, n-1);</span><br><span class="line">    return f1*factor + f0*factor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Matrix matrixPow(Matrix m, int n) &#123;</span><br><span class="line">    Matrix result = Matrix::Identity;</span><br><span class="line">    while (n) &#123;</span><br><span class="line">        if (n &amp; 1)</span><br><span class="line">            result *= m;</span><br><span class="line">        m *= m;</span><br><span class="line">        n &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展问题，如果是前三项相加的数列呢，依然可以求出转移矩阵</p>
<h2 id="2-11-最近点对问题"><a href="#2-11-最近点对问题" class="headerlink" title="2.11 最近点对问题"></a>2.11 最近点对问题</h2><h2 id="2-12-2-14-LeetCode-2-15-Cracking-2-16-2-17-LeetCode"><a href="#2-12-2-14-LeetCode-2-15-Cracking-2-16-2-17-LeetCode" class="headerlink" title="2.12-2.14 LeetCode 2.15 Cracking 2.16 2.17 LeetCode"></a>2.12-2.14 LeetCode 2.15 Cracking 2.16 2.17 LeetCode</h2><h2 id="2-18-数组分割"><a href="#2-18-数组分割" class="headerlink" title="2.18 数组分割"></a>2.18 数组分割</h2><h2 id="2-19-LeetCode"><a href="#2-19-LeetCode" class="headerlink" title="2.19 LeetCode"></a>2.19 LeetCode</h2><h2 id="3-1-有时间可以尝试写一下"><a href="#3-1-有时间可以尝试写一下" class="headerlink" title="3.1 有时间可以尝试写一下"></a>3.1 有时间可以尝试写一下</h2><h2 id="3-2-电话号码对应英文单词"><a href="#3-2-电话号码对应英文单词" class="headerlink" title="3.2 电话号码对应英文单词"></a>3.2 电话号码对应英文单词</h2><p>递归写法</p>
<h2 id="3-3-Edit-Distance"><a href="#3-3-Edit-Distance" class="headerlink" title="3.3 Edit Distance"></a>3.3 Edit Distance</h2><h2 id="3-4-删除链表节点"><a href="#3-4-删除链表节点" class="headerlink" title="3.4 删除链表节点"></a>3.4 删除链表节点</h2><h2 id="3-5-最短摘要的生成"><a href="#3-5-最短摘要的生成" class="headerlink" title="3.5 最短摘要的生成"></a>3.5 最短摘要的生成</h2><p>问题转化为，在一个单词词组中，找出包含所有给定单词的最短区间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">abstract</span><span class="params">(vector&lt;string&gt; article, unordered_set&lt;string&gt; keywords)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, range = INT_MAX;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; indecies;</span><br><span class="line">    unordered_set&lt;string&gt; having;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">while</span> (end &lt; article.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; article.<span class="built_in">size</span>() &amp;&amp; !<span class="built_in">isContain</span>(keywords, having)) &#123;</span><br><span class="line">            indecies[articel[end]] = end;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isContain</span>(keywords, having)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end - start + <span class="number">1</span> &lt; range) &#123;</span><br><span class="line">                range = end - start + <span class="number">1</span>;</span><br><span class="line">                result.first = start;</span><br><span class="line">                result.second = end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (indecies[aritcle[start]] == start)</span><br><span class="line">                having.erase[article[start]];</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-判断两个链表是否相交"><a href="#3-6-判断两个链表是否相交" class="headerlink" title="3.6 判断两个链表是否相交"></a>3.6 判断两个链表是否相交</h2><p>如果链表中有环呢？</p>
<h2 id="3-7-队列中取最大值"><a href="#3-7-队列中取最大值" class="headerlink" title="3.7 队列中取最大值"></a>3.7 队列中取最大值</h2><p>使用连个minstack模拟队列</p>
<h2 id="3-8-二叉树中两个节点之间的最远距离"><a href="#3-8-二叉树中两个节点之间的最远距离" class="headerlink" title="3.8 二叉树中两个节点之间的最远距离"></a>3.8 二叉树中两个节点之间的最远距离</h2><p>显然，对一个根节点，最远距离有两种情况：</p>
<ol>
<li>左子树或者右子树中的最远距离</li>
<li>左子树最长路径＋有子树最长路径+1</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> max_distance;</span><br><span class="line">    <span class="type">int</span> max_depth;</span><br><span class="line">&#125; <span class="type">result_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get max distance of two nodes in a tree</span></span><br><span class="line"><span class="type">result_t</span> <span class="title function_">get_max</span><span class="params">(<span class="type">tree_node_t</span>* root)</span> &#123;</span><br><span class="line">    <span class="type">result_t</span> result;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        result.max_distance = <span class="number">0</span>;</span><br><span class="line">        result.max_depth = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">result_t</span> left = get_max(root-&gt;left);</span><br><span class="line">    <span class="type">result_t</span> right = get_max(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    result.max_depth = max(left.max_depth, right.max_depth) + <span class="number">1</span>;</span><br><span class="line">    result.max_distance = max(max(left.max_distance, right.max_distance), left.max_depth + right.max_depth + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于递归问题，书上的心得：</p>
<ol>
<li>在递归的实现中，往往假设后续的调用已经完成，在此基础上，才能实现递归的逻辑。</li>
<li>分析清楚递归体的逻辑。</li>
<li>考虑清楚递归退出的边界条件，也就是return的地方。</li>
</ol>
<h2 id="3-9-重建二叉树"><a href="#3-9-重建二叉树" class="headerlink" title="3.9 重建二叉树"></a>3.9 重建二叉树</h2><p>拓展问题，如何判断前序遍历和中序遍历是合理的？</p>
<p>测试用例：<br>非完全二叉树，退化的二叉树，满二叉树，普通二叉树，空树。。。</p>
<h2 id="3-10-层序遍历"><a href="#3-10-层序遍历" class="headerlink" title="3.10 层序遍历"></a>3.10 层序遍历</h2><p>注意把LeetCode上的ZigZag层序都看一遍。</p>
<p>递归的遍历需要先计算level</p>
<h2 id="3-11-注意问题"><a href="#3-11-注意问题" class="headerlink" title="3.11 注意问题"></a>3.11 注意问题</h2><p>对于询问知识点，要答得<em>正确</em>，<em>有条理</em>。最后写出来的程序已定要是<em>没有严重错误</em>，<em>完整</em>，并尝试用一些测试用例。</p>
<h2 id="4-1-金刚"><a href="#4-1-金刚" class="headerlink" title="4.1 金刚"></a>4.1 金刚</h2><p>询问李博士</p>
<h2 id="4-2-瓷砖覆盖地板"><a href="#4-2-瓷砖覆盖地板" class="headerlink" title="4.2 瓷砖覆盖地板"></a>4.2 瓷砖覆盖地板</h2><p>斐波那契额数列</p>
<p>1x2覆盖8x8？从小到大，先找出2x2有多少种，再找出4x4有多少种，再找出8x8有多少种。还有考虑好多种，注意不要有重复<br>pxq覆盖mxn？</p>
<h2 id="4-3-Catalan数"><a href="#4-3-Catalan数" class="headerlink" title="4.3  Catalan数"></a>4.3  Catalan数</h2><h2 id="4-4-点是否在三角形内部"><a href="#4-4-点是否在三角形内部" class="headerlink" title="4.4 点是否在三角形内部"></a>4.4 点是否在三角形内部</h2><p>给定 ABC，逆时针顺序，判断 D 是否在 ABC 内部</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 利用面积，如果 D 和 ABC 分别构成的三角形的面积小于 ABC 的面积，那么 D 在三角形内部</span><br><span class="line">double area(Point A, Point B, Point, C) &#123;</span><br><span class="line">    double a, b, c;</span><br><span class="line">    b = distance(A, C);</span><br><span class="line">    a = distance(B, C);</span><br><span class="line">    c = distance(A, B);</span><br><span class="line"></span><br><span class="line">    double p = (a + b + c) / 2;</span><br><span class="line">    return sqrt((p-a) * (p-b) * (p-c) * p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isInTriangle(A, B, C, D) &#123;</span><br><span class="line">    return area(A, B, D) + area(A, C, D) + area(B, C, D) &lt;= area(A, B, C);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 根据角度考虑，如果两个向量叉积为正，那么 P3 在P1P2的左边，如果一个点同时在 AB，BC，CA 的左边</span><br><span class="line">double cross(Point A, Point B, Point X) &#123;</span><br><span class="line">    return (B.x - A.x) * (X.y - A.y) - (X.x - A.x) * (B.y - A.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isInTriangle(A, B, C, D) &#123;</span><br><span class="line">    return cross(A, B, D) &gt;= 0 &amp;&amp; cross(B, C, D) &gt;= 0 &amp;&amp; cross(C, A, D) &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-磁带文件存储优化"><a href="#4-5-磁带文件存储优化" class="headerlink" title="4.5 磁带文件存储优化"></a>4.5 磁带文件存储优化</h2><p>只考虑长度，按照文件长度由短到长存放。<br>只考虑访问频率，按照访问频率由高到低存放。<br>综合考虑，按照频率&#x2F;长度由高到低</p>
<h2 id="4-6-桶中取黑白球"><a href="#4-6-桶中取黑白球" class="headerlink" title="4.6 桶中取黑白球"></a>4.6 桶中取黑白球</h2><p>相当于使用 XOR，可以解任意问题</p>
<h2 id="4-7-蚂蚁爬杆"><a href="#4-7-蚂蚁爬杆" class="headerlink" title="4.7 蚂蚁爬杆"></a>4.7 蚂蚁爬杆</h2><p>相当于穿越</p>
<h2 id="4-8-三角形测试用例"><a href="#4-8-三角形测试用例" class="headerlink" title="4.8 三角形测试用例"></a>4.8 三角形测试用例</h2><p><code>int isTriangle(int a, int b, int c);</code></p>
<ol>
<li>用一个字节编码各种情况。</li>
</ol>
<p>用不同的位表示不同的结果，注意要正交</p>
<ol start="2">
<li><p>测试用例</p>
<ol>
<li><p>合法输入，各种三角形的形状，以及不是三角形的，还需要考虑交换不同边的顺序；</p>
</li>
<li><p>非法输入，负数，0，类型错误等等；</p>
</li>
<li><p>边界值，一般程序可能在<code>&lt; &lt;= &gt; &gt;=</code>上犯错误；</p>
</li>
<li><p>很大的数，很小的数，等等。</p>
</li>
</ol>
</li>
</ol>
<p>一般需要给出15-20个用例</p>
<h2 id="4-10-数字哑谜"><a href="#4-10-数字哑谜" class="headerlink" title="4.10 数字哑谜"></a>4.10 数字哑谜</h2><p>列出方程，使用深度优先搜索，注意剪枝</p>
<h2 id="4-11-扫雷游戏的概率"><a href="#4-11-扫雷游戏的概率" class="headerlink" title="4.11 扫雷游戏的概率"></a>4.11 扫雷游戏的概率</h2><br>
<br>
<br>

<h1 id="二、C-x2F-C-基本算法考点"><a href="#二、C-x2F-C-基本算法考点" class="headerlink" title="二、C&#x2F;C++基本算法考点"></a>二、C&#x2F;C++基本算法考点</h1><h2 id="1-1-确定一个字符串中所有数字是否完全不同"><a href="#1-1-确定一个字符串中所有数字是否完全不同" class="headerlink" title="1.1 确定一个字符串中所有数字是否完全不同"></a>1.1 确定一个字符串中所有数字是否完全不同</h2><p>首先应该询问面试官字符集的大小，是ASCII还是Unicode还是GBK，对于ASCII和GBK，<br>因为字符集大小有限，而且都不太大，可以使用一个数组统计，而对于Unicode，<br>显然只能使用Hash统计</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isUniqueChars</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">256</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">charSet</span><span class="params">(<span class="number">256</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">        <span class="keyword">if</span> (charSet[s])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            charSet[c] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：还可以使用位向量提高效率，但是C++的vector<bool>本身就是特质化的。</bool></p>
<h2 id="1-2-实现reverse-char-s"><a href="#1-2-实现reverse-char-s" class="headerlink" title="1.2 实现reverse(char* s)"></a>1.2 实现reverse(char* s)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">char</span>* end = s;</span><br><span class="line">    <span class="keyword">while</span> (*end++) ;</span><br><span class="line">    end--; <span class="comment">// back one</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (s &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> t = *s;</span><br><span class="line">        *s++ = *end;</span><br><span class="line">        *end-- = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-判断两个词是否是变位词-Anagram"><a href="#1-3-判断两个词是否是变位词-Anagram" class="headerlink" title="1.3 判断两个词是否是变位词(Anagram)"></a>1.3 判断两个词是否是变位词(Anagram)</h2><h2 id="1-4-编写一个方法，将字符串中的空格全部替换为-20，假设字符串结尾有足够空间"><a href="#1-4-编写一个方法，将字符串中的空格全部替换为-20，假设字符串结尾有足够空间" class="headerlink" title="1.4 编写一个方法，将字符串中的空格全部替换为%20，假设字符串结尾有足够空间"></a>1.4 编写一个方法，将字符串中的空格全部替换为<code>%20</code>，假设字符串结尾有足够空间</h2><p>对于数组操作的好多题目，尝试从尾部做起一下子就简单多了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">replaceSpaces</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> spaceCount = <span class="number">0</span>, newLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(s[i]))</span><br><span class="line">            newLength++;</span><br><span class="line"></span><br><span class="line">    newLength = len + spaceCount * <span class="number">2</span>;</span><br><span class="line">    s[newLength] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(s[i])) &#123;</span><br><span class="line">            s[--newLength] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            s[--newLength] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            s[--newLength] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s[--newLength] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-压缩字符串-aabcccccaaa-gt-a2b1c5a3如果压缩后变短，返回压缩后的字符串"><a href="#1-5-压缩字符串-aabcccccaaa-gt-a2b1c5a3如果压缩后变短，返回压缩后的字符串" class="headerlink" title="1.5 压缩字符串 aabcccccaaa -&gt; a2b1c5a3如果压缩后变短，返回压缩后的字符串"></a>1.5 压缩字符串 <code>aabcccccaaa -&gt; a2b1c5a3</code>如果压缩后变短，返回压缩后的字符串</h2><p>首先要计算出新的长度，然后比较是否变短，如果变短，则执行压缩，否则返回</p>
<h2 id="1-6-给定一幅由N＊N矩阵表示的图像，顺时针旋转90度"><a href="#1-6-给定一幅由N＊N矩阵表示的图像，顺时针旋转90度" class="headerlink" title="1.6 给定一幅由N＊N矩阵表示的图像，顺时针旋转90度"></a>1.6 给定一幅由N＊N矩阵表示的图像，顺时针旋转90度</h2><h2 id="1-7-若m＊n矩阵中某个元素为0，就把这一行和这一列都清零"><a href="#1-7-若m＊n矩阵中某个元素为0，就把这一行和这一列都清零" class="headerlink" title="1.7 若m＊n矩阵中某个元素为0，就把这一行和这一列都清零"></a>1.7 若m＊n矩阵中某个元素为0，就把这一行和这一列都清零</h2><p>LeetCode 73 注意同样可以使用位向量提高效率</p>
<h2 id="1-8-给定方法isSubstring-，判断s1是不是可以由s2旋转组成"><a href="#1-8-给定方法isSubstring-，判断s1是不是可以由s2旋转组成" class="headerlink" title="1.8 给定方法isSubstring()，判断s1是不是可以由s2旋转组成"></a>1.8 给定方法isSubstring()，判断s1是不是可以由s2旋转组成</h2><p>假设s1 &#x3D; xy, s2 &#x3D; yx，yx一定是xyxy的字串，而且是中间部分。注意先判断长度，提高效率</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isRotation</span><span class="params">(string&amp; s1, string&amp; s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.<span class="built_in">size</span>() != s2.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    string s1s1 = s1 + s1;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isSubstring</span>(s1s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-移除未排序列表中的重复节点"><a href="#2-1-移除未排序列表中的重复节点" class="headerlink" title="2.1 移除未排序列表中的重复节点"></a>2.1 移除未排序列表中的重复节点</h2><p>因为是无序的，所以我们还是需要记录重复节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显然第一个节点是不可能被移除的，所以不用返回新的头部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">    ListNode dummy, *p = dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vals.<span class="built_in">find</span>(p-&gt;next-&gt;val) != vals.<span class="built_in">end</span>())</span><br><span class="line">            ListNode* next = p-&gt;next;</span><br><span class="line">            p-&gt;next = next-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vals.<span class="built_in">insert</span>(p-&gt;next-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不允许使用额外空间，那么这个功能至少需要O(N^2)实现</p>
<h2 id="2-2-实现一个算法，找出链表中倒数第K个元素"><a href="#2-2-实现一个算法，找出链表中倒数第K个元素" class="headerlink" title="2.2 实现一个算法，找出链表中倒数第K个元素"></a>2.2 实现一个算法，找出链表中倒数第K个元素</h2><h2 id="2-3-删除单向链表中的某个节点，假设你只有访问该节点的权限"><a href="#2-3-删除单向链表中的某个节点，假设你只有访问该节点的权限" class="headerlink" title="2.3 删除单向链表中的某个节点，假设你只有访问该节点的权限"></a>2.3 删除单向链表中的某个节点，假设你只有访问该节点的权限</h2><h2 id="2-4-以给定的值x分割列表，使得小于x的元素都排在x的前面"><a href="#2-4-以给定的值x分割列表，使得小于x的元素都排在x的前面" class="headerlink" title="2.4 以给定的值x分割列表，使得小于x的元素都排在x的前面"></a>2.4 以给定的值x分割列表，使得小于x的元素都排在x的前面</h2><p>LeetCode 83</p>
<h2 id="2-5-给定一个链表，每个链表节点存放一位数字，并且是反向存放的，求两个链表的和"><a href="#2-5-给定一个链表，每个链表节点存放一位数字，并且是反向存放的，求两个链表的和" class="headerlink" title="2.5 给定一个链表，每个链表节点存放一位数字，并且是反向存放的，求两个链表的和"></a>2.5 给定一个链表，每个链表节点存放一位数字，并且是反向存放的，求两个链表的和</h2><p>LeetCode 2</p>
<p>如果是正向存放的呢？</p>
<p>先求出两个列表的长度，然后用零填充一个较短的链表，然后在从前往后相加。</p>
<h2 id="2-6-给定一个有环链表，找到环的开头"><a href="#2-6-给定一个有环链表，找到环的开头" class="headerlink" title="2.6 给定一个有环链表，找到环的开头"></a>2.6 给定一个有环链表，找到环的开头</h2><p>LeetCode 141 142</p>
<h2 id="2-7-判断链表是否是回文-Palindrome"><a href="#2-7-判断链表是否是回文-Palindrome" class="headerlink" title="2.7 判断链表是否是回文(Palindrome)"></a>2.7 判断链表是否是回文(Palindrome)</h2><p>LeetCode 234</p>
<h2 id="3-1-如何用一个数组实现3个栈"><a href="#3-1-如何用一个数组实现3个栈" class="headerlink" title="3.1 如何用一个数组实现3个栈"></a>3.1 如何用一个数组实现3个栈</h2><p>如果是实现两个堆栈，可以把两头作为栈底，向中间生长。</p>
<p>解法1: 固定分割，显然这样是不能让面试官满意的。。</p>
<p>解法2: 弹性分割，并把数组看成是环状的！</p>
<h2 id="3-2-设计一个栈，支持min方法，返回栈中的最小值"><a href="#3-2-设计一个栈，支持min方法，返回栈中的最小值" class="headerlink" title="3.2 设计一个栈，支持min方法，返回栈中的最小值"></a>3.2 设计一个栈，支持min方法，返回栈中的最小值</h2><p>LeetCode 155</p>
<h2 id="3-3-实现SetOfStacks，由多个栈组成"><a href="#3-3-实现SetOfStacks，由多个栈组成" class="headerlink" title="3.3 实现SetOfStacks，由多个栈组成"></a>3.3 实现SetOfStacks，由多个栈组成</h2><p>这实际上是一道OOD(面向对象设计)的题目</p>
<h2 id="3-4-汉诺塔"><a href="#3-4-汉诺塔" class="headerlink" title="3.4 汉诺塔"></a>3.4 汉诺塔</h2><p>经典问题了，考虑 n＝2的时候，把上面1块放到中间，然后把下面一块移动完成。那么对于n，我们把n-1块移到中间即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void moveDisks(int n, tower_t origin, tower_t dest, tower_t buffer) &#123;</span><br><span class="line">    if (n &lt;= 0) return;</span><br><span class="line"></span><br><span class="line">    moveDisks(n-1, origin, buffer, dest); // 先把上面的n-1块放到中间</span><br><span class="line">    moveBottom(origin, dest) // 把最底下的盘子直接放过去</span><br><span class="line">    moveDisks(n-1, buffer, dest, origin) // 把中间的再放到最后</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-使用两个栈模拟一个队列"><a href="#3-5-使用两个栈模拟一个队列" class="headerlink" title="3.5 使用两个栈模拟一个队列"></a>3.5 使用两个栈模拟一个队列</h2><h2 id="3-6-对栈进行排序，额外的数据只能使用栈"><a href="#3-6-对栈进行排序，额外的数据只能使用栈" class="headerlink" title="3.6 对栈进行排序，额外的数据只能使用栈"></a>3.6 对栈进行排序，额外的数据只能使用栈</h2><p>使用简单插入排序，在一个新的栈中保存排序好的数据，从unsorted中弹出以后，不断弹出sorted为新元素找到正确位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; <span class="title function_">sortStack</span><span class="params">(<span class="type">const</span> <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;&amp; unsorted)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; sorted;</span><br><span class="line">    <span class="keyword">while</span> (!unsorted.empty()) &#123;</span><br><span class="line">        <span class="type">int</span> temp = unsorted.top(); <span class="comment">// 待插入的新元素</span></span><br><span class="line">        unsorted.pop();</span><br><span class="line">        <span class="keyword">while</span> (!sorted.empty() &amp;&amp; sorted.top() &gt; temp) &#123; <span class="comment">// 不断弹出，找到合适位置</span></span><br><span class="line">            <span class="type">int</span> big = sorted.top(); sorted.pop();</span><br><span class="line">            unsorted.push(big);</span><br><span class="line">        &#125;</span><br><span class="line">        sorted.push(temp); <span class="comment">// 插入新元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sorted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="4-1-检查二叉树是否平衡-任意两个节点之间的高度差不超过1"><a href="#4-1-检查二叉树是否平衡-任意两个节点之间的高度差不超过1" class="headerlink" title="4.1 检查二叉树是否平衡: 任意两个节点之间的高度差不超过1"></a>4.1 检查二叉树是否平衡: 任意两个节点之间的高度差不超过1</h2><h2 id="4-2-给定一个有向图，找出两个节点之间是否存在一条路径"><a href="#4-2-给定一个有向图，找出两个节点之间是否存在一条路径" class="headerlink" title="4.2 给定一个有向图，找出两个节点之间是否存在一条路径"></a>4.2 给定一个有向图，找出两个节点之间是否存在一条路径</h2><blockquote>
<p>碰到这类问题，有必要和面试官探讨一下DFS和BFS之间的利弊，例如，DFS实现起来比较简单，只需要简单的递归即可。BFS适合用来查找最短路径。<br>而DFS在访问临近借点之前可能会深度便利其中一个临近节点</p>
</blockquote>
<p>🌲的遍历一定要注意visited数组或者集合，因为树中可能有几个节点指向同一个节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(Graph* graph, Node* start, Node* end)</span> </span>&#123;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    unordered_set&lt;Node*&gt; visited;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> node = q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> adj : q.<span class="built_in">adjs</span>())</span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">find</span>(adj) == visited.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">if</span> (adj == end)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    q.<span class="built_in">push</span>(adj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-给定一个有序数组，元素各不相同且按升序排列，创建一颗高度最小的二叉查找树"><a href="#4-3-给定一个有序数组，元素各不相同且按升序排列，创建一颗高度最小的二叉查找树" class="headerlink" title="4.3 给定一个有序数组，元素各不相同且按升序排列，创建一颗高度最小的二叉查找树"></a>4.3 给定一个有序数组，元素各不相同且按升序排列，创建一颗高度最小的二叉查找树</h2><p>LeetCode 108</p>
<h2 id="4-4-给定一棵二叉树，创建层序访问的链表"><a href="#4-4-给定一棵二叉树，创建层序访问的链表" class="headerlink" title="4.4 给定一棵二叉树，创建层序访问的链表"></a>4.4 给定一棵二叉树，创建层序访问的链表</h2><p>LeetCode 102</p>
<h2 id="4-5-检查一棵二叉树是否为二叉查找树"><a href="#4-5-检查一棵二叉树是否为二叉查找树" class="headerlink" title="4.5 检查一棵二叉树是否为二叉查找树"></a>4.5 检查一棵二叉树是否为二叉查找树</h2><p>LeetCode 98</p>
<h2 id="4-6-找到二叉查找树指定节点的下一个节点-中序后继-，假设每个节点都有指向父节点的指针"><a href="#4-6-找到二叉查找树指定节点的下一个节点-中序后继-，假设每个节点都有指向父节点的指针" class="headerlink" title="4.6 找到二叉查找树指定节点的下一个节点(中序后继)，假设每个节点都有指向父节点的指针"></a>4.6 找到二叉查找树指定节点的下一个节点(中序后继)，假设每个节点都有指向父节点的指针</h2><p>按照中序遍历，左子树，当前节点，右子树，显然下一个节点应该在右边。也就是右子树中最左边的节点。<br>考虑没有右子树的情况，如果当前节点是左子节点，下一个节点应该是父节点。如果是右节点，我们继续向上，如果到达了root，显然没有更多节点了。</p>
<p>对于树这种可以分情况的最好先把各种情况想好了，在写代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">inorderSucc</span><span class="params">(TreeNode* n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (n-&gt;right) &#123;</span><br><span class="line">        TreeNode* right = n-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (right-&gt;left)</span><br><span class="line">            right = right-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode* q = n, * parent = q.parent;</span><br><span class="line">        <span class="keyword">while</span> (parent &amp;&amp; parent-&gt;left != q) &#123; <span class="comment">// 找到当前节点可以作为左子节点的父节点</span></span><br><span class="line">            q = parent;</span><br><span class="line">            parent = parent-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-7-查找二叉树的公共祖先"><a href="#4-7-查找二叉树的公共祖先" class="headerlink" title="4.7 查找二叉树的公共祖先"></a>4.7 查找二叉树的公共祖先</h2><p>LeetCode 236</p>
<h2 id="4-8-又两棵非常大的二叉树：T1-有几百万个节点，T2，有几百个节点。判断T2是否是T1的子树"><a href="#4-8-又两棵非常大的二叉树：T1-有几百万个节点，T2，有几百个节点。判断T2是否是T1的子树" class="headerlink" title="4.8 又两棵非常大的二叉树：T1 有几百万个节点，T2，有几百个节点。判断T2是否是T1的子树"></a>4.8 又两棵非常大的二叉树：T1 有几百万个节点，T2，有几百个节点。判断T2是否是T1的子树</h2><p>这道题并没有标准解法。值得和面试官探讨，详见树上的讲解（161页）。</p>
<h2 id="4-9-打印节点数值总和为给定值的路径，路径可以从任意节点开始，任意节点结束"><a href="#4-9-打印节点数值总和为给定值的路径，路径可以从任意节点开始，任意节点结束" class="headerlink" title="4.9 打印节点数值总和为给定值的路径，路径可以从任意节点开始，任意节点结束"></a>4.9 打印节点数值总和为给定值的路径，路径可以从任意节点开始，任意节点结束</h2><p>对于一个没有见过的问题，可以先简化，然后在推广。假设路径必须从root开始，那很简单。<br>如果路径可以从任意节点开始，那么我们需要向上检查是否得到了相符的总和，而不能假定root是起点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">findSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="type">int</span> depth = depth(root);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">path</span><span class="params">(depth)</span>;</span><br><span class="line">    findSum(root, sum, path, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">depth</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> max(depth(root-&gt;left), depth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">findSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    path[level] = root-&gt;val;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = level, t= <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        t += path[i];</span><br><span class="line">        <span class="keyword">if</span> (t == sum)</span><br><span class="line">            print(path, i ,level); <span class="comment">// printing out path from i to level</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    findSum(root-&gt;left, sum, path, level + <span class="number">1</span>);</span><br><span class="line">    findSum(root-&gt;right, sum, path, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-1-给定一个数n，和另一个数字m，然后给定区间-i-j-，区间保证可以大于m的二进制长度，把m的二进制表示插入到n的区间内"><a href="#5-1-给定一个数n，和另一个数字m，然后给定区间-i-j-，区间保证可以大于m的二进制长度，把m的二进制表示插入到n的区间内" class="headerlink" title="5.1 给定一个数n，和另一个数字m，然后给定区间(i, j)，区间保证可以大于m的二进制长度，把m的二进制表示插入到n的区间内"></a>5.1 给定一个数n，和另一个数字m，然后给定区间(i, j)，区间保证可以大于m的二进制长度，把m的二进制表示插入到n的区间内</h2><p>示例：n&#x3D;100&#x2F;000&#x2F;00, m &#x3D; 101, i &#x3D; 2, j &#x3D; 4 -&gt; 100&#x2F;101&#x2F;00</p>
<ol>
<li>把n中对应位置清零</li>
<li>把m移动到对应的位置</li>
<li>合并</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left_mask = ~<span class="number">0</span> &lt;&lt; (j+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> right_mask = (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span></span><br><span class="line">    <span class="type">int</span> mask = left_mask | right_mask;</span><br><span class="line"></span><br><span class="line">    n &amp;= mask;</span><br><span class="line">    m &lt;&lt;= i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n | m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-给定一个0和1之间的实数，打印他的二进制表示，如果32位以内无法表示，打印error"><a href="#5-2-给定一个0和1之间的实数，打印他的二进制表示，如果32位以内无法表示，打印error" class="headerlink" title="5.2 给定一个0和1之间的实数，打印他的二进制表示，如果32位以内无法表示，打印error"></a>5.2 给定一个0和1之间的实数，打印他的二进制表示，如果32位以内无法表示，打印error</h2><p>我们知道 (0.101)2 &#x3D; 1 * 2^-1 + 0 * 2^-2 + 1 * 2^-3，我们只要让这个数字不断的乘2，然后看它是否大于1，然后就可以得到第一位是不是1了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">printBinary</span><span class="params">(<span class="type">double</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= <span class="number">1</span> || num &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line"></span><br><span class="line">    string result;</span><br><span class="line">    result += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() &gt;= <span class="number">32</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">        num *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            result += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">            num -= <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-给定一个正整数，找出和其二进制表示中一的数字相同的数字，并且最接近，一共两个"><a href="#5-3-给定一个正整数，找出和其二进制表示中一的数字相同的数字，并且最接近，一共两个" class="headerlink" title="5.3 给定一个正整数，找出和其二进制表示中一的数字相同的数字，并且最接近，一共两个"></a>5.3 给定一个正整数，找出和其二进制表示中一的数字相同的数字，并且最接近，一共两个</h2><p>我们需要把某个0反转为1，把某个1反转为0。<br>0 -&gt; 1在1-&gt;0 左边，数字变大，在右边数字变小。<br>如果想变大，反转的0需要在1的左边。</p>
<p>把p位置1；把0到p之间请0；在添加ending1 - 1个1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = n, ending0 = <span class="number">0</span>, ending1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c &amp; <span class="number">1</span> == <span class="number">0</span>) &amp;&amp; c != <span class="number">0</span>) &#123;</span><br><span class="line">        ending0++;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (c &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        ending1++;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n + (<span class="number">1</span> &lt;&lt; ending0) + (<span class="number">1</span> &lt;&lt; (ending1 - <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把位p值0；把位p右边的位值1，再把0到ending0-1置0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getPrev</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = n, ending0 = <span class="number">0</span>, ending1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (c &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        ending1++;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; c != <span class="number">0</span>) &#123;</span><br><span class="line">        ending0++;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - (<span class="number">1</span> &lt;&lt; ending1) - (<span class="number">1</span> &lt;&lt; (ending0 - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-解释n-amp-n-10-0"><a href="#5-4-解释n-amp-n-10-0" class="headerlink" title="5.4 解释n &amp; (n-10) == 0"></a>5.4 解释<code>n &amp; (n-10) == 0</code></h2><p>LeetCode 231</p>
<h2 id="5-5-A和B之间有多少位不相同-x2F-需要改变多少位，才能把A变成B"><a href="#5-5-A和B之间有多少位不相同-x2F-需要改变多少位，才能把A变成B" class="headerlink" title="5.5 A和B之间有多少位不相同&#x2F;需要改变多少位，才能把A变成B"></a>5.5 A和B之间有多少位不相同&#x2F;需要改变多少位，才能把A变成B</h2><p>使用XOR找出不同的位，然后统计1的个位数。需要注意的是不同的题目</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitSwapRequired</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> diff = a ^ b, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (diff) &#123;</span><br><span class="line">        diff &amp;= diff - <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-6-交换一个整数的奇数位和偶数位"><a href="#5-6-交换一个整数的奇数位和偶数位" class="headerlink" title="5.6 交换一个整数的奇数位和偶数位"></a>5.6 交换一个整数的奇数位和偶数位</h2><p>这道题很有趣，选取特殊的掩码即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 考虑32bit int</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">swapBits</span><span class="params">(<span class="type">int32_t</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> odd_bits = x &amp; <span class="number">0xAAAAAAAA</span>; <span class="comment">// 0xAA as 10101010</span></span><br><span class="line">    <span class="type">int32_t</span> even_bits = x &amp; <span class="number">0x55555555</span>; <span class="comment">// 0x55 as 01010101</span></span><br><span class="line">    <span class="keyword">return</span> (odd_bits &gt;&gt; <span class="number">1</span>) | (even_bits &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-8-单色屏幕存贮在一维字节数组中，每个字节存储八个像素，屏幕宽度为w-px，绘制从x1到达x2的水平线"><a href="#5-8-单色屏幕存贮在一维字节数组中，每个字节存储八个像素，屏幕宽度为w-px，绘制从x1到达x2的水平线" class="headerlink" title="5.8 单色屏幕存贮在一维字节数组中，每个字节存储八个像素，屏幕宽度为w px，绘制从x1到达x2的水平线"></a>5.8 单色屏幕存贮在一维字节数组中，每个字节存储八个像素，屏幕宽度为w px，绘制从x1到达x2的水平线</h2><p>显然可以逐bit设定，然而这样是拿不到offer的。更好的做法是逐字节设定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">drawHorizentalLine</span><span class="params">(<span class="type">uint8_t</span> * screen, <span class="type">int</span> width, <span class="type">int</span> x1, <span class="type">int</span> x2, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start_offset = x1 % <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> start_full_byte = x1 / <span class="number">8</span>; <span class="comment">// x1 所在字节</span></span><br><span class="line">    <span class="keyword">if</span> (start_offset != <span class="number">0</span>)</span><br><span class="line">        start_full_byte++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> end_offset = x2 % <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> end_full_byte = x2 / <span class="number">8</span>; <span class="comment">// x2 所在字节</span></span><br><span class="line">    <span class="keyword">if</span> (end_offset != <span class="number">7</span>)</span><br><span class="line">        end_full_byte--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐字节设定</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start_full_byte; i &lt;= end_full_byte; i++)</span><br><span class="line">        screen[width / <span class="number">8</span> * y + i] = (<span class="type">uint8_t</span>)<span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> start_mask = (<span class="type">uint8_t</span>) (<span class="number">0xff</span> &gt;&gt; start_offset);</span><br><span class="line">    <span class="type">uint8_t</span> end_mast = (<span class="type">uint8_t</span>) ~(<span class="number">0xff</span> &gt;&gt; end_offset + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((x1 / <span class="number">8</span>) == (x2 / <span class="number">8</span>)) &#123;</span><br><span class="line">        <span class="type">uint8_t</span> mask = (<span class="type">uint8_t</span>)(start_mask &amp; end_mask);</span><br><span class="line">        screen[(width / <span class="number">8</span>) * y + x1 / <span class="number">8</span>] |= mask;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start_offset != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> byte_number = (width / <span class="number">8</span>) * y + start_full_byte - <span class="number">1</span>;</span><br><span class="line">            screen[byte_number] |= start_mask;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end_offset != <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="type">int</span> byte_number = (width / <span class="number">8</span>) * y + end_full_byte + <span class="number">1</span>;</span><br><span class="line">            screen[byte_number] |= end_mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6-1-给定直角坐标系的两条线，确定他们会不会相交"><a href="#6-1-给定直角坐标系的两条线，确定他们会不会相交" class="headerlink" title="6.1 给定直角坐标系的两条线，确定他们会不会相交"></a>6.1 给定直角坐标系的两条线，确定他们会不会相交</h2><p>我们知道在二维平面上两条线的关系不外乎：平行，相交，重合。问题是两条线重合算不算相交呢，需要问清楚。<br>对于两条线如何表示，这又是面向对象设计的问题，需要讨论。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> EPSILON;</span><br><span class="line">    <span class="type">double</span> m_slope; <span class="comment">// 斜率</span></span><br><span class="line">    <span class="type">double</span> m_y_intercept; <span class="comment">// y轴交点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Line</span>(<span class="type">double</span> s, <span class="type">double</span> y): <span class="built_in">m_slope</span>(s), <span class="built_in">m_y_intercept</span>(y) &#123;&#125;;</span><br><span class="line">    <span class="comment">// 重合视作相交</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">intersect</span><span class="params">(<span class="type">const</span> Line&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="built_in">slope</span>() - other.<span class="built_in">slope</span>()) &gt; EPSILON || <span class="comment">// 斜率不同</span></span><br><span class="line">            <span class="built_in">abs</span>(<span class="built_in">y_intercept</span>() - other.<span class="built_in">y_intercept</span>()) &lt; EPSILON; <span class="comment">// y轴交点相同</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">slope</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_slope;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">y_intercept</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_y_intercept;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Line::EPSILON = <span class="number">0.00001</span>;</span><br></pre></td></tr></table></figure>

<p>遇到这类问题，务必：</p>
<ol>
<li>多问，面试官可能故意模糊问题</li>
<li>仔细设计数据结构，权衡利弊，和面试官讨论</li>
<li>千万不要用＝＝判定浮点数</li>
</ol>
<h2 id="6-2-只使用加号实现减法和乘除法"><a href="#6-2-只使用加号实现减法和乘除法" class="headerlink" title="6.2 只使用加号实现减法和乘除法"></a>6.2 只使用加号实现减法和乘除法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">neg</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> d = a &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (a) &#123;</span><br><span class="line">        result += d;</span><br><span class="line">        a += d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; <span class="number">0</span> ? a : neg(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">minus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + neg(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sign = (a &gt; <span class="number">0</span>) == (b &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    a = <span class="built_in">abs</span>(a);</span><br><span class="line">    b = <span class="built_in">abs</span>(b);</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b--)</span><br><span class="line">        result += a;</span><br><span class="line">    <span class="keyword">return</span> sign == <span class="number">1</span> ? result : neg(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">devide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="comment">// see leetcode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-找出第k个丑数"><a href="#6-3-找出第k个丑数" class="headerlink" title="6.3 找出第k个丑数"></a>6.3 找出第k个丑数</h2><p>LeetCode 264</p>
<h2 id="7-1-小孩上楼梯，楼梯有n阶，小孩可以一次上1，2，3步，请问一共有多少种方法"><a href="#7-1-小孩上楼梯，楼梯有n阶，小孩可以一次上1，2，3步，请问一共有多少种方法" class="headerlink" title="7.1 小孩上楼梯，楼梯有n阶，小孩可以一次上1，2，3步，请问一共有多少种方法"></a>7.1 小孩上楼梯，楼梯有n阶，小孩可以一次上1，2，3步，请问一共有多少种方法</h2><p> 注意如果只能1或2就是斐波那契数列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countSteps</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> vector&lt;<span class="type">int</span>&gt; <span class="title">steps</span><span class="params">(<span class="number">1000</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span> &amp;&amp; steps[n] == <span class="number">1</span>)</span><br><span class="line">        steps[n] = <span class="built_in">countSteps</span>(n <span class="number">-1</span>) + <span class="built_in">countSteps</span>(n - <span class="number">2</span>) + <span class="built_in">countSteps</span>(n - <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> steps[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">countSteps</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n3 = <span class="number">1</span>; <span class="comment">// starts from n = 0</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">1</span>; <span class="comment">// starts from n = 1</span></span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">2</span>; <span class="comment">// starts from n = 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        steps = n3 + n2 + n1;</span><br><span class="line">        n3 = n2;</span><br><span class="line">        n2 = n1;</span><br><span class="line">        n1 = steps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-1-设计一种算法，机器人只能向右向下移动，从-0-0-移动到-x-y-有几种走法"><a href="#8-1-设计一种算法，机器人只能向右向下移动，从-0-0-移动到-x-y-有几种走法" class="headerlink" title="8.1 设计一种算法，机器人只能向右向下移动，从(0, 0)移动到(x, y)有几种走法"></a>8.1 设计一种算法，机器人只能向右向下移动，从(0, 0)移动到(x, y)有几种走法</h2><p>LeetCode 62 63</p>
<h2 id="9-1-在有序数组A-0…n-1-中存在A-i-x3D-x3D-i，找出该数字。如果存在重复值，又该如何做"><a href="#9-1-在有序数组A-0…n-1-中存在A-i-x3D-x3D-i，找出该数字。如果存在重复值，又该如何做" class="headerlink" title="9.1 在有序数组A[0…n-1]中存在A[i] &#x3D;&#x3D; i，找出该数字。如果存在重复值，又该如何做"></a>9.1 在有序数组A[0…n-1]中存在A[i] &#x3D;&#x3D; i，找出该数字。如果存在重复值，又该如何做</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">magic</span><span class="params">(<span class="type">int</span>* A, n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>; right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] == mid)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &lt; mid)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-2-返回一个集合的所有子集"><a href="#9-2-返回一个集合的所有子集" class="headerlink" title="9.2 返回一个集合的所有子集"></a>9.2 返回一个集合的所有子集</h2><p>LeetCode 78</p>
<h2 id="9-3-全排列"><a href="#9-3-全排列" class="headerlink" title="9.3 全排列"></a>9.3 全排列</h2><p>LeetCode</p>
<h2 id="9-4-生成n对括号的全部有效集合"><a href="#9-4-生成n对括号的全部有效集合" class="headerlink" title="9.4 生成n对括号的全部有效集合"></a>9.4 生成n对括号的全部有效集合</h2><p>LeetCode</p>
<h2 id="9-5-实现填充颜色功能"><a href="#9-5-实现填充颜色功能" class="headerlink" title="9.5 实现填充颜色功能"></a>9.5 实现填充颜色功能</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintFill</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; screen, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (screen[y][x] == color)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">paintFill</span>(screen, <span class="type">int</span> x, <span class="type">int</span> y, screen[y][x], <span class="type">int</span> color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintFill</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; screen, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> start, <span class="type">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= screen[<span class="number">0</span>].<span class="built_in">size</span>() || y &lt; <span class="number">0</span> || y &gt;= screen.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (screen[y][x] == start) &#123;</span><br><span class="line">        screen[y][x] == color;</span><br><span class="line">        <span class="built_in">paintFill</span>(screen, <span class="type">int</span> x<span class="number">-1</span>, <span class="type">int</span> y, start, color);</span><br><span class="line">        <span class="built_in">paintFill</span>(screen, x+<span class="number">1</span>, y, start, color);</span><br><span class="line">        <span class="built_in">paintFill</span>(screen, x, y+<span class="number">1</span>, start, color);</span><br><span class="line">        <span class="built_in">paintFill</span>(screen, x, y<span class="number">-1</span>, start, color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-6-给定数量不限的硬币，编写代码计算有几种表示方法"><a href="#9-6-给定数量不限的硬币，编写代码计算有几种表示方法" class="headerlink" title="9.6 给定数量不限的硬币，编写代码计算有几种表示方法"></a>9.6 给定数量不限的硬币，编写代码计算有几种表示方法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">makeChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; coins, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">solution</span><span class="params">(coins.size(), <span class="number">0</span>)</span></span><br><span class="line">    <span class="title function_">make</span><span class="params">(result, coins, solution, <span class="number">0</span>, target)</span>;</span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">make</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; coins, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; solution, <span class="type">int</span> start, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= <span class="number">0</span> || start &gt;= coins.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)</span><br><span class="line">            result.push_back(solution);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i *coins[start] &lt; target ; i++) &#123;</span><br><span class="line">        solution[start] = i;</span><br><span class="line">        make(result, coins, solution, start + <span class="number">1</span>, target - i * coins[start]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9-7-N-Queen问题"><a href="#9-7-N-Queen问题" class="headerlink" title="9.7 N-Queen问题"></a>9.7 N-Queen问题</h2><p>LeetCode</p>
<h2 id="9-8-给你一堆箱子，上面的箱子的长宽高要求小于下面的箱子，实现一个方法，搭出最高的箱子"><a href="#9-8-给你一堆箱子，上面的箱子的长宽高要求小于下面的箱子，实现一个方法，搭出最高的箱子" class="headerlink" title="9.8 给你一堆箱子，上面的箱子的长宽高要求小于下面的箱子，实现一个方法，搭出最高的箱子"></a>9.8 给你一堆箱子，上面的箱子的长宽高要求小于下面的箱子，实现一个方法，搭出最高的箱子</h2><h2 id="10-1-合并两个有序数组"><a href="#10-1-合并两个有序数组" class="headerlink" title="10.1 合并两个有序数组"></a>10.1 合并两个有序数组</h2><p>LeetCode 88</p>
<h2 id="11-1-对一个字符串数组排序，把变位词-Anagram-放在一起"><a href="#11-1-对一个字符串数组排序，把变位词-Anagram-放在一起" class="headerlink" title="11.1 对一个字符串数组排序，把变位词(Anagram)放在一起"></a>11.1 对一个字符串数组排序，把变位词(Anagram)放在一起</h2><p>LeetCode 49</p>
<h2 id="11-2-在已经被旋转过的排序数组中，查找元素"><a href="#11-2-在已经被旋转过的排序数组中，查找元素" class="headerlink" title="11.2 在已经被旋转过的排序数组中，查找元素"></a>11.2 在已经被旋转过的排序数组中，查找元素</h2><p>LeetCode 81</p>
<h2 id="11-3-有一个20GB的文件，每行一个字符串，如何排序"><a href="#11-3-有一个20GB的文件，每行一个字符串，如何排序" class="headerlink" title="11.3 有一个20GB的文件，每行一个字符串，如何排序"></a>11.3 有一个20GB的文件，每行一个字符串，如何排序</h2><p>20GB暗示无法放入内存中，把文件分块后，分别载入内存中，采用归并排序</p>
<h2 id="12-1-使用-C-写个方法，打印输入文件的最后-K-行"><a href="#12-1-使用-C-写个方法，打印输入文件的最后-K-行" class="headerlink" title="12.1 使用 C++ 写个方法，打印输入文件的最后 K 行"></a>12.1 使用 C++ 写个方法，打印输入文件的最后 K 行</h2><p>使用循环数组，容量设为 K，同时记录当前的最早元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printLastKLines</span><span class="params">(<span class="type">char</span>* filename)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> K = <span class="number">10</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">    string lines[K];</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (file.<span class="built_in">good</span>())</span><br><span class="line">        <span class="built_in">getline</span>(file, lines[size++ % K];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start = size &gt; K ? (size % K) : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">min</span>(K, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) </span><br><span class="line">        cout &lt;&lt; lines[(start + i) % K] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="12-2-编写malloc-aligned"><a href="#12-2-编写malloc-aligned" class="headerlink" title="12.2 编写malloc_aligned"></a>12.2 编写malloc_aligned</h2><h2 id="12-3-malloc2d函数，分配二维数组，返回int-可以通过a-i-j-访问，并且尽量少调用malloc"><a href="#12-3-malloc2d函数，分配二维数组，返回int-可以通过a-i-j-访问，并且尽量少调用malloc" class="headerlink" title="12.3 malloc2d函数，分配二维数组，返回int**可以通过a[i][j]访问，并且尽量少调用malloc"></a>12.3 malloc2d函数，分配二维数组，返回int**可以通过a[i][j]访问，并且尽量少调用malloc</h2><p>前面rows大小的区域用作存储指针，后面存储数据。</p>
<pre><code>hhh|ddddd|ddddd|ddddd
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>** <span class="title function_">malloc2d</span><span class="params">(<span class="type">int</span> rows, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line">    <span class="type">int</span> header = rows * <span class="keyword">sizeof</span>(<span class="type">void</span>*);</span><br><span class="line">    <span class="type">void</span>** ptr = (<span class="type">void</span>**)<span class="built_in">malloc</span>(header + rows * cols);</span><br><span class="line">    <span class="keyword">if</span> (!ptr)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">void</span>* buf = (<span class="type">void</span>*)(rawptr + rows);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">         ptr[i] = buf + i * cols;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free2d</span><span class="params">(<span class="type">void</span>** ptr)</span> &#123;</span><br><span class="line">    <span class="type">void</span>* p = <span class="type">void</span>* p;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="12-4-不用中间变量，直接交换两个数字"><a href="#12-4-不用中间变量，直接交换两个数字" class="headerlink" title="12.4 不用中间变量，直接交换两个数字"></a>12.4 不用中间变量，直接交换两个数字</h2><p>想像把 a 和 b 都放在数轴上，假设 a0，b0分别是初值，那么有 diff &#x3D; a - b。我们把<br>diff 保存在 a 中，然后 b &#x3D; b0 + diff 也就是 a0 ，而再另 a &#x3D; b - diff，也就是 b0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    a = a - b;</span><br><span class="line">    b = b + a;</span><br><span class="line">    a = b - a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更巧妙的是，我们还可以使用异或 XOR 在解。假设 a &#x3D; a0 ^ b0，那么 b &#x3D; a ^ b0 &#x3D; a0 ^ b0 ^ b0 &#x3D; a0，然后 a &#x3D; a ^ b &#x3D; a0 ^ b0 ^ a0 &#x3D; b0。完美解决！<br>值得注意的是，因为使用异或不考虑变量的实际类型，只是粗暴地按 bit 位交换，因此适用于各种类型。不过值得注意的是千万不要用这种方法去交换变量的值，当x&#x3D;&#x3D;y的时候会有灾难性后果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="13-1-n-结尾有多少个零"><a href="#13-1-n-结尾有多少个零" class="headerlink" title="13.1 n! 结尾有多少个零"></a>13.1 n! 结尾有多少个零</h2><p>LeetCode 172</p>
<h2 id="13-2-找出两个数字中较大的一个，但不得使用判断语句"><a href="#13-2-找出两个数字中较大的一个，但不得使用判断语句" class="headerlink" title="13.2 找出两个数字中较大的一个，但不得使用判断语句"></a>13.2 找出两个数字中较大的一个，但不得使用判断语句</h2><p>判断a&gt;b就是判断a-b的正负号，显然我们可以使用bit运算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">flip</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="comment">// flip last bit</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ^ a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sign</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">flip</span>((a &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="13-3-把数字转换为英文单词"><a href="#13-3-把数字转换为英文单词" class="headerlink" title="13.3 把数字转换为英文单词"></a>13.3 把数字转换为英文单词</h2><h2 id="13-4-把数字转换为汉语句子"><a href="#13-4-把数字转换为汉语句子" class="headerlink" title="13.4 把数字转换为汉语句子"></a>13.4 把数字转换为汉语句子</h2><h2 id="13-5-数组最大序列和"><a href="#13-5-数组最大序列和" class="headerlink" title="13.5 数组最大序列和"></a>13.5 数组最大序列和</h2><p>LeetCode 53</p>
<h2 id="13-6-给定产生数字概率相同的rand5-，实现一个方法rand7-，要求产生每个数字的概率相同"><a href="#13-6-给定产生数字概率相同的rand5-，实现一个方法rand7-，要求产生每个数字的概率相同" class="headerlink" title="13.6 给定产生数字概率相同的rand5()，实现一个方法rand7()，要求产生每个数字的概率相同"></a>13.6 给定产生数字概率相同的rand5()，实现一个方法rand7()，要求产生每个数字的概率相同</h2><p>扩大rand5产生随机数的范围，然后对舍去一定范围的数字，对剩下的数字取模，虽然这样会导致调用次数不固定，但实现了效果<br>对于randx，扩大范围的方法是 x * randx() + randx()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rand7</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">5</span> * rand5() + rand5();</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">21</span>)</span><br><span class="line">            <span class="keyword">return</span> num % <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该问题可以拓展到对于 x &lt; y，由randx() 构造 randy()</p>
<h2 id="13-7-在数组中找到两个数字，是的他们的和为指定的数字"><a href="#13-7-在数组中找到两个数字，是的他们的和为指定的数字" class="headerlink" title="13.7 在数组中找到两个数字，是的他们的和为指定的数字"></a>13.7 在数组中找到两个数字，是的他们的和为指定的数字</h2><p>LeetCode 1</p>
<h2 id="13-8-把二叉树转化为双向链表"><a href="#13-8-把二叉树转化为双向链表" class="headerlink" title="13.8 把二叉树转化为双向链表"></a>13.8 把二叉树转化为双向链表</h2><p>先把二叉树变成一个环形链表，然后再从头部解开即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">concat</span><span class="params">(<span class="keyword">struct</span> tree_node* x, <span class="keyword">struct</span> tree_node* y)</span> &#123;</span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tree_node* <span class="title function_">convert_circular</span><span class="params">(<span class="keyword">struct</span> tree_node* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span>* <span class="title">left</span> =</span> convert_circular(root-&gt;left);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span>* <span class="title">right</span> =</span> convert_circular(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!left &amp;&amp; !right) &#123;</span><br><span class="line">        root-&gt;left = root;</span><br><span class="line">        root-&gt;right = root;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span>* <span class="title">tail_right</span> =</span> right ? right-&gt;left : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把左边添加到根部</span></span><br><span class="line">    <span class="keyword">if</span> (!left)</span><br><span class="line">        concat(right-&gt;left, root);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        concat(left-&gt;left, root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把右边添加到根部</span></span><br><span class="line">    <span class="keyword">if</span> (!right)</span><br><span class="line">        concat(root, left);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        concat(root, right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把右边和左边链接</span></span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right)</span><br><span class="line">        concat(tail_right, left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left ? left : root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tree_node* <span class="title function_">convert</span><span class="params">(<span class="keyword">struct</span> tree_node* root)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span>* <span class="title">head</span> =</span> convert_circular(root);</span><br><span class="line">    head-&gt;left-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-2-实现加法"><a href="#14-2-实现加法" class="headerlink" title="14.2 实现加法"></a>14.2 实现加法</h2><p>显然是使用位运算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int add(int a, int b) &#123;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        int sum = a ^ b;</span><br><span class="line">        int carry = (a &amp; b) &lt;&lt; 1;</span><br><span class="line">        a = sum, b = carry;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-2-完美洗牌，使得一副牌中任意一种排列出现的概率都相等"><a href="#15-2-完美洗牌，使得一副牌中任意一种排列出现的概率都相等" class="headerlink" title="15.2 完美洗牌，使得一副牌中任意一种排列出现的概率都相等"></a>15.2 完美洗牌，使得一副牌中任意一种排列出现的概率都相等</h2><p>显然全排列是n!个，那么我们保证每一个全排列都可能出现就好了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> k = rand(i);</span><br><span class="line">        swap(A[k], A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-1-从n个数组中选出m个，要求被选中概率一样"><a href="#16-1-从n个数组中选出m个，要求被选中概率一样" class="headerlink" title="16.1 从n个数组中选出m个，要求被选中概率一样"></a>16.1 从n个数组中选出m个，要求被选中概率一样</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">pink_k</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">result</span><span class="params">(k)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-2-小于-n-的数字中出现2的个数"><a href="#16-2-小于-n-的数字中出现2的个数" class="headerlink" title="16.2 小于 n 的数字中出现2的个数"></a>16.2 小于 n 的数字中出现2的个数</h2><h2 id="16-3-矩阵链乘法问题"><a href="#16-3-矩阵链乘法问题" class="headerlink" title="16.3 矩阵链乘法问题"></a>16.3 矩阵链乘法问题</h2><h2 id="16-4-判断是否是合法地出栈序列"><a href="#16-4-判断是否是合法地出栈序列" class="headerlink" title="16.4 判断是否是合法地出栈序列"></a>16.4 判断是否是合法地出栈序列</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/The_star_is_at/article/details/72790961">参考</a></p>
<h2 id="16-5-二叉树的非递归遍历"><a href="#16-5-二叉树的非递归遍历" class="headerlink" title="16.5 二叉树的非递归遍历"></a>16.5 二叉树的非递归遍历</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/archive/2011/08/25/2153720.html">参考</a></p>
<br>
<br>
<br>
<br>
<br>


<h1 id="三、树的遍历"><a href="#三、树的遍历" class="headerlink" title="三、树的遍历"></a>三、树的遍历</h1><p>树的递归遍历都非常简单，但是非递归遍历有时候不是很简单。一般做题的时候直接写递归版就行了，<br>但是对于三个基础的遍历方法，有时候会要求写迭代版本，基本就是花式用栈就行了。</p>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> [root.val, *self.preorderTraversal(root.left), *self.preorderTraversal(root.right)]</span><br></pre></td></tr></table></figure>

<h3 id="非递归版"><a href="#非递归版" class="headerlink" title="非递归版"></a>非递归版</h3><p>使用栈做了一个顺序的反转。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归版-1"><a href="#递归版-1" class="headerlink" title="递归版"></a>递归版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> [*self.inorderTraversal(root.left), root.val, *self.inorderTraversal(root.right)]</span><br></pre></td></tr></table></figure>

<h3 id="非递归版-1"><a href="#非递归版-1" class="headerlink" title="非递归版"></a>非递归版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">            left = stack.pop()</span><br><span class="line">            ans.append(left.val)</span><br><span class="line">            <span class="keyword">if</span> left.right:</span><br><span class="line">                node = left.right</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">LeetCode 145</a></p>
<h3 id="递归版-2"><a href="#递归版-2" class="headerlink" title="递归版"></a>递归版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> [*self.postorderTraversal(root.left), *self.postorderTraversal(root.right), root.val]</span><br></pre></td></tr></table></figure>

<h3 id="非递归版-2"><a href="#非递归版-2" class="headerlink" title="非递归版"></a>非递归版</h3><p>这个方法还是有点 trick 的，类似于前序遍历，但是把左右子树反过来了，最后再翻转一遍，就变成<br>了后序遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br></pre></td></tr></table></figure>

<p>比如：前序遍历是 123, 现在这种遍历方式是 132, 在翻转一次正好是 231, 也就是后续遍历了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">reversed</span>(ans))</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/</a></li>
</ol>
<br>
<br>
<br>
<br>
<br>






<h1 id="四、LeetCode-突击手册"><a href="#四、LeetCode-突击手册" class="headerlink" title="四、LeetCode 突击手册"></a>四、LeetCode 突击手册</h1><p>一共定义了几个标签，可以通过 Ctrl+F&#x2F;Cmd+F 搜索这些标签还快速浏览相同的题目。</p>
<p>标签：#hash #backtracking #slidewindow #stack #queue #pointers</p>
<h2 id="1-从数组中找出两个数字使得他们的和是给定的数字"><a href="#1-从数组中找出两个数字使得他们的和是给定的数字" class="headerlink" title="1 从数组中找出两个数字使得他们的和是给定的数字"></a>1 从数组中找出两个数字使得他们的和是给定的数字</h2><p>tags: #hash</p>
<p>使用一个散列，存储数字和他对应的索引。然后遍历数组，如果另一半在散列当中，那么返回<br>这两个数的索引，程序结束；如果不在，把当前数字加入到散列中。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> reminder = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">find</span>(reminder) != hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            result[<span class="number">0</span>] = hash[reminder] + <span class="number">1</span>;</span><br><span class="line">            result[<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        hash[nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        seen = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> [seen[target-num], i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                seen[num] = i</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">two_sum</span>(nums: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;, target: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">with_capacity</span>(nums.<span class="title function_ invoke__">len</span>());</span><br><span class="line">        <span class="title function_ invoke__">for</span> (idx, num) <span class="keyword">in</span> nums.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">            <span class="keyword">match</span> map.<span class="title function_ invoke__">get</span>(&amp;(target - num)) &#123;</span><br><span class="line">                <span class="literal">None</span> =&gt; &#123;map.<span class="title function_ invoke__">insert</span>(num, idx);&#125;,</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(sub_idx) =&gt; &#123;<span class="keyword">return</span> <span class="built_in">vec!</span>[*sub_idx <span class="keyword">as</span> <span class="type">i32</span>, idx <span class="keyword">as</span> <span class="type">i32</span>]; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vec!</span> []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>go 解答</summary>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> index, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        last_index, ok := m[num]</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;last_index, index&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m[target - num] = index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>Follow up: 如果数组是已经排序的呢？</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()) <span class="comment">// 假设已经排序，只有一个结果</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> s = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (s == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make_pair</span>(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; sum)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="2-给两个列表，数字在其中按低位到高位存储，求他们的和"><a href="#2-给两个列表，数字在其中按低位到高位存储，求他们的和" class="headerlink" title="2 给两个列表，数字在其中按低位到高位存储，求他们的和"></a>2 给两个列表，数字在其中按低位到高位存储，求他们的和</h2><p>直接迭代遍历数组，考察细节操作。注意 dummy head 的使用。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 注意最后如果有 carry 的话，需要再生成一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">        <span class="type">int</span> v1 = l1 ? l1-&gt;val: <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> v2 = l2 ? l2-&gt;val: <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> v = v1 + v2 + carry;</span><br><span class="line">        p-&gt;next = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        p-&gt;val = v % <span class="number">10</span>;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        carry = v / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        l1 = l1 ? l1-&gt;next: <span class="literal">NULL</span>;</span><br><span class="line">        l2 = l2 ? l2-&gt;next: <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">ListNode *<span class="title">addTwoNumbers</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">            <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">            <span class="type">int</span> shift = <span class="number">0</span>;</span><br><span class="line">            ListNode* result = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">            ListNode* p = result;</span><br><span class="line">            <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> || l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="type">int</span> v1 = l1 != <span class="literal">NULL</span> ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> v2 = l2 != <span class="literal">NULL</span> ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">                newNode-&gt;val = v1 + v2 + shift;</span><br><span class="line">                <span class="keyword">if</span> (newNode-&gt;val &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                    newNode-&gt;val -= <span class="number">10</span>;</span><br><span class="line">                    shift = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    shift = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">                    l1 = l1-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">                    l2 = l2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;next = newNode;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意最后多余的一个进位处理</span></span><br><span class="line">            <span class="keyword">if</span> (shift == <span class="number">1</span>) &#123;</span><br><span class="line">                p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two_numbers</span>(l1: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;ListNode&gt;&gt;, l2: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;ListNode&gt;&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;ListNode&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> l1, <span class="keyword">mut</span> l2) = (l1, l2);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">dummy</span> = <span class="type">Box</span>&lt;ListNode::<span class="title function_ invoke__">new</span>(<span class="number">0</span>)&gt;;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">carry</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">p</span> = dummy;</span><br><span class="line">        <span class="keyword">while</span> l1.<span class="title function_ invoke__">is_some</span>() || l2.<span class="title function_ invoke__">is_some</span>() || carry != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> l1, l2&#123;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(a), <span class="title function_ invoke__">Some</span>(b) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = a + b + carry;</span><br><span class="line">                    l1 = l1.<span class="title function_ invoke__">next</span>();</span><br><span class="line">                    l2 = l2.<span class="title function_ invoke__">next</span>();</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(a), <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = a + carry;</span><br><span class="line">                    l1 = l1.<span class="title function_ invoke__">next</span>();</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="literal">None</span>, <span class="title function_ invoke__">Some</span>(b) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = b + carry;</span><br><span class="line">                    l2 = l2.<span class="title function_ invoke__">next</span>();</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="literal">None</span>, <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p.next = <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>&lt;ListNode::<span class="title function_ invoke__">new</span>(v)&gt;);</span><br><span class="line">            p = p.next;</span><br><span class="line">            p.val = v % <span class="number">10</span>;</span><br><span class="line">            carry = v / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> carry:</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                v1 = l1.val</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                v1 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                v2 = l2.val</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                v2 = <span class="number">0</span></span><br><span class="line">            v = v1 + v2 + carry  <span class="comment"># 别忘了这里</span></span><br><span class="line">            <span class="keyword">if</span> v &gt;= <span class="number">10</span>:</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">                v -= <span class="number">10</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            p.<span class="built_in">next</span> = ListNode(v)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="3-最长不重复子串"><a href="#3-最长不重复子串" class="headerlink" title="3 最长不重复子串"></a>3 最长不重复子串</h2><p>tags: #slidewindow</p>
<p>滑动窗口解决</p>
<p>注意，当字符有限的时候，比如限定为 ASCII 字符，可以使用一个数组代替 Hash。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> indices[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  <span class="comment">// init the array, memset can only be used for char</span></span><br><span class="line">        indices[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> longest = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; s[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        left = max(left, indices[s[i]] + <span class="number">1</span>);   <span class="comment">// 考虑新加入字符后对左边界的影响</span></span><br><span class="line">        indices[s[i]] = i;                     <span class="comment">// 更新元素上次出现位置</span></span><br><span class="line">        longest = max(longest, i - left + <span class="number">1</span>);  <span class="comment">// 应用动态规划</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        last_seen = &#123;&#125;</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            lo = <span class="built_in">max</span>(lo, last_seen.get(c, -<span class="number">1</span>) + <span class="number">1</span>)  <span class="comment"># 更新下边界</span></span><br><span class="line">            last_seen[c] = i</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - lo + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<h2 id="4-找到两个排序数组的中位数"><a href="#4-找到两个排序数组的中位数" class="headerlink" title="4 找到两个排序数组的中位数"></a>4 找到两个排序数组的中位数</h2><p>解法参见<a target="_blank" rel="noopener" href="https://leetcode.com/discuss/15790/share-my-o-log-min-m-n-solution-with-explanation">这里</a></p>
<p>使用两个数字 i 和 j, 分别作为 AB 的分隔元素，把 AB 分成两份，比如<br><code>A[0..i]</code>, <code>B[0..j]</code> 和 <code>A[i, m]</code>, <code>B[j, n]</code>，这样我们只需要下面两个条件就可以了：</p>
<ul>
<li><code>i+j = m-i + n-j</code>, 也就是 <code>i+j = (m+n)/2</code></li>
<li><code>B[j-1] &lt;= A[i] &amp;&amp; A[i-1] &lt;= B[j]</code>,  B 的前一半元素小于 A 的分隔符，A 的前一半元素小于 B 的分隔符</li>
</ul>
<p>这时候我们就得到了 A[i] 就是我们的中位数，或者之一。 i 的初始值在 0 到 m 之间，<br>然后我们二分搜索 <code>i = (imin + imax) / 2, j = mid - i</code>。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> m, <span class="type">int</span>* B, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> findMedianSortedArrays(B, n, A, m);</span><br><span class="line">    <span class="type">int</span> imin = <span class="number">0</span>, imax = m, i, j, num1, mid = (m + n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, num2;</span><br><span class="line">    <span class="keyword">while</span> (imin &lt;= imax) &#123;</span><br><span class="line">        i = (imin + imax) <span class="comment">// 2;</span></span><br><span class="line">        j = mid - i;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; m &amp;&amp; j &gt; <span class="number">0</span> &amp;&amp; B[j<span class="number">-1</span>] &gt; A[i]) &#123;  <span class="comment">// B 中的数字偏大</span></span><br><span class="line">            imin = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; B[j] &lt; A[i<span class="number">-1</span>]) &#123; <span class="comment">// A 中的数字偏大</span></span><br><span class="line">            imax = i - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                num1 = B[j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                num1 = A[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num1 = max(A[i<span class="number">-1</span>],B[j<span class="number">-1</span>]);  <span class="comment">// 普通情况</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((m + n) &amp; <span class="number">0x1</span>) <span class="comment">// odd</span></span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="keyword">if</span> (i == m)</span><br><span class="line">        num2 = B[j];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (j == n)</span><br><span class="line">        num2 = A[i];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        num2 = min(A[i], B[j]); <span class="comment">// 普通情况</span></span><br><span class="line">    <span class="keyword">return</span> (num1 + num2) / <span class="number">2.0</span>; <span class="comment">// 注意整数除法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5 最长回文子串"></a>5 最长回文子串</h2><ol>
<li>以某个元素为中心，向两边展开，注意处理奇数和偶数两种情况</li>
<li>Manacher 算法，参见<a target="_blank" rel="noopener" href="http://taop.marchtea.com/01.05.html">这里</a></li>
</ol>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        ans = <span class="string">&quot;&quot;</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 奇数长度回文子串</span></span><br><span class="line">            <span class="keyword">while</span> i - j &gt;= <span class="number">0</span> <span class="keyword">and</span> i + j &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i-j] == s[i+j]:</span><br><span class="line">                <span class="keyword">if</span> j * <span class="number">2</span> + <span class="number">1</span> &gt; length:</span><br><span class="line">                    length = j * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    ans = s[i-j:i+j+<span class="number">1</span>]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 偶数长度回文子串</span></span><br><span class="line">            <span class="keyword">while</span> i - j &gt;= <span class="number">0</span> <span class="keyword">and</span> i + j + <span class="number">1</span> &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i-j] == s[i+j+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> j * <span class="number">2</span> + <span class="number">2</span> &gt; length:</span><br><span class="line">                    length = j * <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">                    ans = s[i-j:i+j+<span class="number">2</span>]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">longestPalindrome</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>; <span class="comment">// length of the longest palindromic string</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">-1</span>; <span class="comment">// start of the lonest palidromic string</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 奇数长度的回文子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; (i - j &gt;= <span class="number">0</span>) &amp;&amp; (i + j &lt; len); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - j] != s[i + j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (j * <span class="number">2</span> + <span class="number">1</span> &gt; length) &#123;</span><br><span class="line">                length = j * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                start = i - j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偶数长度的回文子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; (i - j &gt;= <span class="number">0</span>) &amp;&amp; (i + j + <span class="number">1</span> &lt; len); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - j] != s[i + j + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (j * <span class="number">2</span> + <span class="number">2</span> &gt; length) &#123;</span><br><span class="line">                length = j * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">                start = i - j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * length + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(result, s + start, length);</span><br><span class="line">    result[length] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="6-ZigZag-字符串，把字符串掰弯，然后再按行输出"><a href="#6-ZigZag-字符串，把字符串掰弯，然后再按行输出" class="headerlink" title="6 ZigZag 字符串，把字符串掰弯，然后再按行输出"></a>6 ZigZag 字符串，把字符串掰弯，然后再按行输出</h2><p>考察数学，找出规律，所以实际上并不是 Z 子形，而是由 V 组成的，然后组合按行号重构后的字符串即可。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法不容易理解，建议看 Python 的</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">convert</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (!s || numRows &lt;= <span class="number">1</span> || len &lt; numRows) <span class="keyword">return</span> s; <span class="comment">// no need to convert</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* zigzag = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; len; j += <span class="number">2</span> * (numRows - <span class="number">1</span>)) &#123; <span class="comment">// 每个 v 字型长度</span></span><br><span class="line">            zigzag[cur++] = s[j];</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != numRows - <span class="number">1</span>) &#123; <span class="comment">// 中间行有斜线</span></span><br><span class="line">                <span class="type">int</span> t = j + <span class="number">2</span> * (numRows - <span class="number">1</span>) - <span class="number">2</span> * i; <span class="comment">// V 的第二笔</span></span><br><span class="line">                <span class="keyword">if</span> (t &lt; len)</span><br><span class="line">                    zigzag[cur++] = s[t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    zigzag[cur] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> zigzag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">self, s: <span class="built_in">str</span>, numRows: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> numRows &lt;= <span class="number">1</span> <span class="keyword">or</span> <span class="built_in">len</span>(s) &lt;= numRows:  <span class="comment"># 没有这个条件会超时</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        interval = <span class="number">2</span> * numRows - <span class="number">2</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># 第一行</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            ans.append(s[j])</span><br><span class="line">            j += interval</span><br><span class="line">        <span class="comment"># 中间行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, numRows-<span class="number">1</span>):</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">if</span> i + j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                    ans.append(s[i+j])</span><br><span class="line">                <span class="keyword">if</span> interval - i + j &lt; <span class="built_in">len</span>(s):  <span class="comment"># 一定要注意这里的索引</span></span><br><span class="line">                    ans.append(s[interval - i + j])</span><br><span class="line">                j += interval</span><br><span class="line">        <span class="comment"># 最后一行</span></span><br><span class="line">        j = numRows - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            ans.append(s[j])</span><br><span class="line">            j += interval</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(ans)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="7-翻转数字，溢出返回-0"><a href="#7-翻转数字，溢出返回-0" class="headerlink" title="7 翻转数字，溢出返回 0"></a>7 翻转数字，溢出返回 0</h2><p>注意溢出</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == INT_MIN) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> -reverse(-x);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        result = result * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result &gt; INT_MAX ? <span class="number">0</span> : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sign = <span class="number">1</span> <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        x *= sign</span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            y = y * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> y &gt; <span class="number">2</span>**<span class="number">31</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> y * sign</span><br></pre></td></tr></table></figure>
</details>


<h2 id="8-实现-atoi"><a href="#8-实现-atoi" class="headerlink" title="8 实现 atoi"></a>8 实现 atoi</h2><p>这道题考察各种细节，注意各种特殊情况：</p>
<ol>
<li>首先过滤空格</li>
<li>判定符号，符号只能出现一次</li>
<li>是否溢出，溢出返回 <code>INT_MAX</code> 或者 <code>INT_MIN</code></li>
</ol>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myAtoi</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = s.lstrip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">            sign = -<span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> s[i] == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i].isdigit():</span><br><span class="line">            ans = ans * <span class="number">10</span> + <span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        ans *= sign</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">min</span>(ans, <span class="number">2</span>**<span class="number">31</span>-<span class="number">1</span>), - <span class="number">2</span> ** <span class="number">31</span>)</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(<span class="type">char</span>* str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// discarding spaces</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isspace</span>(*str))</span><br><span class="line">        str++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// determining sign</span></span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">&#x27;-&#x27;</span> || *str == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">&#x27;-&#x27;</span>) sign = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">&#x27;+&#x27;</span>) sign = <span class="number">1</span>;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructing integer</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(*str)) &#123;</span><br><span class="line">        <span class="comment">// handling overflow</span></span><br><span class="line">        <span class="keyword">if</span> (result &gt; INT_MAX / <span class="number">10</span> || result == INT_MAX / <span class="number">10</span> &amp;&amp; *str - <span class="string">&#x27;0&#x27;</span> &gt; INT_MAX % <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> sign &gt; <span class="number">0</span> ? INT_MAX : INT_MIN;</span><br><span class="line">        result = *str - <span class="string">&#x27;0&#x27;</span> + result * <span class="number">10</span>;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result * sign;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="9-是否是回文数字"><a href="#9-是否是回文数字" class="headerlink" title="9 是否是回文数字"></a>9 是否是回文数字</h2><p>限定不能用额外空间，所以直接把 x 取余得到的数字作为一个反向作为一个新的数字</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> x != <span class="number">0</span> <span class="keyword">and</span> x % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 回文走到一半就行了，没必要完全翻转过来</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; y:</span><br><span class="line">            y = y * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> x == y <span class="keyword">or</span> x == y // <span class="number">10</span></span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tricky here, for x == k * 10^j</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &amp;&amp; (x % <span class="number">10</span> == <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; y) &#123;</span><br><span class="line">        y = y * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x == y || x == y / <span class="number">10</span>; <span class="comment">// 注意 x 可能是奇数长度也可能是偶数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="10-正则表达式"><a href="#10-正则表达式" class="headerlink" title="10 正则表达式"></a>10 正则表达式</h2><p>实现正则表达式，只需要实现<code>.</code>代表任意字符，<code>*</code>代表任意重复。只需要特殊处理<code>*</code>，<br>如果遇到了<code>*</code>，贪婪地向后匹配。和通配符的不同之处在于，正则表达式需要两个字母<br>组成模式，<code>*</code>是对前一个字母的修饰。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isMatch</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* p)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c = *p; c != <span class="number">0</span>; s++, c = *p) &#123;</span><br><span class="line">        <span class="comment">// if next char in pattern is not *</span></span><br><span class="line">        <span class="keyword">if</span> (*(p+<span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            p++;</span><br><span class="line">        <span class="comment">// if we got an *, check if we can skip `.*` or `x*`</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isMatch(s, p + <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s ends or p and s differs</span></span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="number">0</span> || c != <span class="string">&#x27;.&#x27;</span> &amp;&amp; c != *s)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *s == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11 盛最多水的容器"></a>11 盛最多水的容器</h2><p>从左右向中间逼近，如果有更大的就更新。简单的一道双指针题目，别想太多。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        water = <span class="built_in">min</span>(height[left], height[right]) * (right - left)</span><br><span class="line">        result = <span class="built_in">max</span>(result, water);</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right])</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            water = <span class="built_in">min</span>(height[lo], height[hi]) * (hi - lo)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, water)</span><br><span class="line">            <span class="keyword">if</span> height[lo] &lt; height[hi]:</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<h2 id="12-十进制转换为罗马数字"><a href="#12-十进制转换为罗马数字" class="headerlink" title="12 十进制转换为罗马数字"></a>12 十进制转换为罗马数字</h2><p>直接按每位把罗马数字转换出来在拼接就好了，使用 C 的话，拼接字符串很麻烦。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intToRoman</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        thousands = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>]</span><br><span class="line">        hundreds = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>]</span><br><span class="line">        tens = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>]</span><br><span class="line">        ones = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> thousands[x//<span class="number">1000</span>] + hundreds[x%<span class="number">1000</span>//<span class="number">100</span>] + tens[x%<span class="number">100</span>//<span class="number">10</span>] + ones[x%<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// note, the leading empty string is the trick here</span></span><br><span class="line">    string thousands[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>&#125;;</span><br><span class="line">    string handreds[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>&#125;;</span><br><span class="line">    string tens[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>&#125;;</span><br><span class="line">    string ones[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> thousands[num / <span class="number">1000</span>] + handreds[num % <span class="number">1000</span> / <span class="number">100</span>] + tens[num % <span class="number">100</span> / <span class="number">10</span>] + ones[num % <span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> digits[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span>* romans = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="type">char</span>* cursor = romans;</span><br><span class="line">    <span class="comment">// if num = 1234, then</span></span><br><span class="line">    <span class="comment">// digits = &#123;1, 2, 3, 4&#125;;</span></span><br><span class="line">    <span class="type">int</span> base = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        digits[i] = num / base;</span><br><span class="line">        num = num % base;</span><br><span class="line">        base /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    doRoman(digits[<span class="number">0</span>], <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, &amp;cursor); <span class="comment">// &#x27;_&#x27; can be anything</span></span><br><span class="line">    doRoman(digits[<span class="number">1</span>], <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, &amp;cursor);</span><br><span class="line">    doRoman(digits[<span class="number">2</span>], <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, &amp;cursor);</span><br><span class="line">    doRoman(digits[<span class="number">3</span>], <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, &amp;cursor);</span><br><span class="line">    *cursor = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> romans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">doRoman</span><span class="params">(<span class="type">int</span> number, <span class="type">char</span> ten, <span class="type">char</span> five, <span class="type">char</span> one, <span class="type">char</span>** str)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (number) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str)[<span class="number">1</span>] = ten;</span><br><span class="line">            (*str) += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = five;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str)[<span class="number">2</span>] = one;</span><br><span class="line">            (*str)[<span class="number">3</span>] = one;</span><br><span class="line">            (*str) += <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = five;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str)[<span class="number">2</span>] = one;</span><br><span class="line">            (*str) += <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = five;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str) += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = five;</span><br><span class="line">            (*str) += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str)[<span class="number">1</span>] = five;</span><br><span class="line">            (*str) += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str)[<span class="number">2</span>] = one;</span><br><span class="line">            (*str) += <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str) += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str) += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="13-罗马数字转为十进制"><a href="#13-罗马数字转为十进制" class="headerlink" title="13 罗马数字转为十进制"></a>13 罗马数字转为十进制</h2><p>主要是当前一个数字小于后一个数字的时候，需要添加的是后一个数和前一个数字的差。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        vals = &#123;</span><br><span class="line">            <span class="string">&quot;I&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;V&quot;</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">&quot;X&quot;</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">&quot;L&quot;</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="string">&quot;C&quot;</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="string">&quot;D&quot;</span>: <span class="number">500</span>,</span><br><span class="line">            <span class="string">&quot;M&quot;</span>: <span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> i+<span class="number">1</span>&lt;<span class="built_in">len</span>(s) <span class="keyword">and</span> vals[s[i]] &lt; vals[s[i+<span class="number">1</span>]]:</span><br><span class="line">                ans += vals[s[i+<span class="number">1</span>]] - vals[s[i]]</span><br><span class="line">                i += <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += vals[s[i]]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acts like a dict or map</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getVal</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; s[i] != <span class="number">0</span>; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getVal(s[i]) &lt; getVal(s[i+<span class="number">1</span>]))</span><br><span class="line">            result += getVal(s[i+<span class="number">1</span>]) - getVal(s[i]), i += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result += getVal(s[i]), i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14 最长公共前缀"></a>14 最长公共前缀</h2><p>纵向扫描，从头到尾，如果不一致，返回当前子串即可。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">        minlen = <span class="built_in">min</span>([<span class="built_in">len</span>(<span class="built_in">str</span>) <span class="keyword">for</span> <span class="built_in">str</span> <span class="keyword">in</span> strs])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(minlen):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(strs)):</span><br><span class="line">                <span class="keyword">if</span> strs[j][i] != strs[<span class="number">0</span>][i]:</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>][:minlen]</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纵向扫描</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">longestCommonPrefix</span><span class="params">(<span class="type">char</span>** strs, <span class="type">int</span> strsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!strs || !strs[<span class="number">0</span>]) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (strsSize == <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(strs[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; strsSize; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[j][i] != strs[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                strs[<span class="number">0</span>][i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="15-从数组中找出三个数使得他们的和是-0"><a href="#15-从数组中找出三个数使得他们的和是-0" class="headerlink" title="15 从数组中找出三个数使得他们的和是 0"></a>15 从数组中找出三个数使得他们的和是 0</h2><p>首先把数组排序，然后使用类似 two sum 的方法做就好了。做这种数组题的套路就是实在不行排个<br>序。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            k = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                <span class="built_in">sum</span> = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span> &gt; <span class="number">0</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">sum</span> &lt; <span class="number">0</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans.append([nums[i], nums[j], nums[k]])</span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j+<span class="number">1</span>]:</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k-<span class="number">1</span>]:</span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &gt; <span class="number">0</span>)</span><br><span class="line">                k--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span>)</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line">                <span class="comment">// skipping duplicates</span></span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k - <span class="number">1</span>])</span><br><span class="line">                    k--;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j + <span class="number">1</span>])</span><br><span class="line">                    j++;</span><br><span class="line">                k--; <span class="comment">// 别忘了这里，还要继续寻找下一组</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="16-在数组中找到三个数字使得他们得和尽可能的接近给定数字，假设结果唯一"><a href="#16-在数组中找到三个数字使得他们得和尽可能的接近给定数字，假设结果唯一" class="headerlink" title="16 在数组中找到三个数字使得他们得和尽可能的接近给定数字，假设结果唯一"></a>16 在数组中找到三个数字使得他们得和尽可能的接近给定数字，假设结果唯一</h2><p>和上一题解法类似，在 <a target="_blank" rel="noopener" href="http://stackoverflow.com/q/2070359">http://stackoverflow.com/q/2070359</a> 有详尽解释</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            k = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                <span class="built_in">sum</span> = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span> == target:</span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">abs</span>(target-<span class="built_in">sum</span>) &lt; <span class="built_in">abs</span>(target-ans):</span><br><span class="line">                    ans = <span class="built_in">sum</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">sum</span> &gt; target:</span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>





<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *a - *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt;= <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] +nums[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> k = numsSize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            <span class="type">int</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">            <span class="keyword">if</span> (sum == target)</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(target - sum) &lt; <span class="built_in">abs</span>(target - result))</span><br><span class="line">                result = sum;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target)</span><br><span class="line">                k--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="17-生成电话键盘按键数字对应的所有可能的字符串，不限制返回结果的顺序"><a href="#17-生成电话键盘按键数字对应的所有可能的字符串，不限制返回结果的顺序" class="headerlink" title="17 生成电话键盘按键数字对应的所有可能的字符串，不限制返回结果的顺序"></a>17 生成电话键盘按键数字对应的所有可能的字符串，不限制返回结果的顺序</h2><p>tags: #backtracking</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="键盘"></p>
<p>递归：</p>
<p>这道题是一道典型的，最简单的深度优先遍历，生成所有可能解的问题。</p>
<p>迭代：</p>
<p>遍历数字，设当前结果为<code>&#123;a, b, c&#125;</code>, 下一个数字是<code>3</code>, 找出对应的字母<code>&#123;d, e, f&#125;</code>, 则新的结果是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; a + &#123;def&#125;, b + &#123;def&#125;, c + &#123;def&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>然后把新获得的数组作为下一轮的初始数组。最开始时，使用空数组开始。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        c2n = &#123;</span><br><span class="line">            <span class="string">&quot;2&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;3&quot;</span>: <span class="string">&quot;def&quot;</span>,</span><br><span class="line">            <span class="string">&quot;4&quot;</span>: <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">            <span class="string">&quot;5&quot;</span>: <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">            <span class="string">&quot;6&quot;</span>: <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">            <span class="string">&quot;7&quot;</span>: <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">            <span class="string">&quot;8&quot;</span>: <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">            <span class="string">&quot;9&quot;</span>: <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">combination, next_digits</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> next_digits:</span><br><span class="line">                ans.append(combination)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> c2n[next_digits[<span class="number">0</span>]]:</span><br><span class="line">                dfs(combination + char, next_digits[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        dfs(<span class="string">&quot;&quot;</span>, digits)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iterative</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> vector&lt;string&gt; &#123;&#125;;</span><br><span class="line">    string mapping[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">combinations</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;&quot;</span>)</span></span>; <span class="comment">// 注意使用空字符串作为种子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; digits.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> digit = digits[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (mapping[digit].<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vector&lt;string&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : mapping[digit])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; combination : combinations)</span><br><span class="line">                temp.<span class="built_in">push_back</span>(combination + c);</span><br><span class="line">        <span class="built_in">swap</span>(combinations, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> combinations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>还可以使用深度优先的搜索方法</p>
<p>追问：如何通过用户按的数字来查找是否有对应的单词呢</p>
<ol>
<li>通过把所有的单词计算出来，然后查询哪个是合法的，查询可以使用 Trie</li>
<li>通过把已经有的单词字典转换为数字字典，然后通过数字序列查询可能的单词组合。</li>
</ol>
<h2 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18 4Sum"></a>18 4Sum</h2><p>tags: #backtracking</p>
<p>其实可以用 深度优先搜索的方式直接解答 nSum</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">return</span> self.nSum(nums, target, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nSum</span>(<span class="params">self, nums, target, n</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">pos: <span class="built_in">int</span>, cur: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">                j = pos</span><br><span class="line">                k = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                    <span class="built_in">sum</span> = nums[j] + nums[k]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">sum</span> &lt; target:</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> <span class="built_in">sum</span> &gt; target:</span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        solution = cur[:] + [nums[j], nums[k]]</span><br><span class="line">                        ans.append(solution)</span><br><span class="line">                        <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j+<span class="number">1</span>]:</span><br><span class="line">                            j += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k-<span class="number">1</span>]:</span><br><span class="line">                            k -= <span class="number">1</span></span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            i = pos</span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums) - n + <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 剪枝的一种情况</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] * n &gt; target <span class="keyword">or</span> nums[-<span class="number">1</span>] * n &lt; target:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 排除重复数字</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; pos <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                cur.append(nums[i])</span><br><span class="line">                dfs(i+<span class="number">1</span>, cur, n-<span class="number">1</span>, target-nums[i])</span><br><span class="line">                cur.pop()</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        ans = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        dfs(<span class="number">0</span>, [], n, target)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<p>下面的 C++ 解法是一个传统解法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">4</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; hash;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            hash[nums[i]+nums[j]].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(i,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> re = target - nums[i] - nums[j];</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">find</span>(re) != hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> match : hash[re]) &#123;</span><br><span class="line">                    <span class="type">int</span> k = match.first, l = match.second;</span><br><span class="line">                    <span class="keyword">if</span> (k &gt; j) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!result.<span class="built_in">empty</span>()</span><br><span class="line">                            &amp;&amp; result.<span class="built_in">back</span>()[<span class="number">0</span>] == nums[i] &amp;&amp; result.<span class="built_in">back</span>()[<span class="number">1</span>] == nums[j]</span><br><span class="line">                            &amp;&amp; result.<span class="built_in">back</span>()[<span class="number">2</span>] == nums[k] &amp;&amp; result.<span class="built_in">back</span>()[<span class="number">3</span>] == nums[l])</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                        result.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k], nums[l]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="19-删除链表中倒数第-k-的节点"><a href="#19-删除链表中倒数第-k-的节点" class="headerlink" title="19 删除链表中倒数第 k 的节点"></a>19 删除链表中倒数第 k 的节点</h2><p>tags: #pointers</p>
<p>双指针经典题目，一个快指针先走 k 步，另一个慢指针再出发，注意链表长度小于 k 时。</p>
<p>注意：LeetCode 给定的 n 都是有效地，但要求返回头指针，如果头指针被删除需要额外注意，因此采用 dummy head</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        q = dummy</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        q.<span class="built_in">next</span> = q.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">fast</span>, *<span class="title">slow</span>;</span></span><br><span class="line">    dummy.next = fast = head;</span><br><span class="line">    slow = &amp;dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> slow-&gt;next;</span><br><span class="line">    slow-&gt;next = next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(next); <span class="comment">// remeber to free memory</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="20-判定给定的字符串是否是合法的括号序列，可能包括大中小三类"><a href="#20-判定给定的字符串是否是合法的括号序列，可能包括大中小三类" class="headerlink" title="20 判定给定的字符串是否是合法的括号序列，可能包括大中小三类"></a>20 判定给定的字符串是否是合法的括号序列，可能包括大中小三类</h2><p>tags: #stack</p>
<p>使用栈的基础题，注意逻辑简化</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        valid = <span class="literal">True</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">match</span> = &#123;<span class="string">&quot;)&quot;</span>: <span class="string">&quot;(&quot;</span>, <span class="string">&quot;]&quot;</span>: <span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#125;&quot;</span>: <span class="string">&quot;&#123;&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> (<span class="string">&quot;(&quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#123;&quot;</span>):</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> stack[-<span class="number">1</span>] != <span class="keyword">match</span>[c]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">opposite</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span> : <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span> : <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span> : <span class="keyword">return</span> <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            stk.push(c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!stk.empty() &amp;&amp; stk.top() == opposite(c))</span><br><span class="line">            stk.pop();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stk.empty(); <span class="comment">// 注意为空的条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_valid</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stack</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="comment">// let map =</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">ch</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">            <span class="keyword">match</span> ch &#123;</span><br><span class="line">                <span class="string">&#x27;(&#x27;</span> | <span class="string">&#x27;&#123;&#x27;</span> | <span class="string">&#x27;[&#x27;</span> =&gt; stack.<span class="title function_ invoke__">push</span>(ch),</span><br><span class="line">                <span class="string">&#x27;)&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="string">&#x27;(&#x27;</span>) = stack.<span class="title function_ invoke__">pop</span>() &#123;&#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;,</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="string">&#x27;&#123;&#x27;</span>) = stack.<span class="title function_ invoke__">pop</span>() &#123;&#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;,</span><br><span class="line">                <span class="string">&#x27;]&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="string">&#x27;[&#x27;</span>) = stack.<span class="title function_ invoke__">pop</span>() &#123;&#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;,</span><br><span class="line">                _ =&gt; <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="title function_ invoke__">len</span>() == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="21-合并两个已经排序的链表"><a href="#21-合并两个已经排序的链表" class="headerlink" title="21 合并两个已经排序的链表"></a>21 合并两个已经排序的链表</h2><p>tags: #pointers</p>
<p>考察链表的基本操作，很简单</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                p.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            p.<span class="built_in">next</span> = l1</span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            p.<span class="built_in">next</span> = l2</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span></span><br><span class="line">    dummy.next == <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1)</span><br><span class="line">        p-&gt;next = l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l2)</span><br><span class="line">        p-&gt;next = l2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="22-给定数字-n-生成所有合法的-n-个括号组成的序列"><a href="#22-给定数字-n-生成所有合法的-n-个括号组成的序列" class="headerlink" title="22 给定数字 n, 生成所有合法的 n 个括号组成的序列"></a>22 给定数字 n, 生成所有合法的 n 个括号组成的序列</h2><p>tags: #backtracking</p>
<p>一道典型的深度优先搜索题目</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">s, lefts, rights</span>):</span><br><span class="line">            <span class="keyword">if</span> lefts == <span class="number">0</span> <span class="keyword">and</span> rights == <span class="number">0</span>:</span><br><span class="line">                ans.append(s)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> lefts &gt; <span class="number">0</span>:</span><br><span class="line">                dfs(s+<span class="string">&quot;(&quot;</span>, lefts-<span class="number">1</span>, rights)</span><br><span class="line">            <span class="keyword">if</span> (lefts &lt; rights):</span><br><span class="line">                dfs(s+<span class="string">&quot;)&quot;</span>, lefts, rights-<span class="number">1</span>)</span><br><span class="line">        ans = []</span><br><span class="line">        dfs(<span class="string">&quot;&quot;</span>, n, n)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="built_in">gen</span>(result, <span class="string">&quot;&quot;</span>, n, n);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// left 剩下的左括号，right 剩下的右括号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gen</span><span class="params">(vector&lt;string&gt;&amp; result, string s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">gen</span>(result, s + <span class="string">&#x27;(&#x27;</span>, left - <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">        <span class="built_in">gen</span>(result, s + <span class="string">&#x27;)&#x27;</span>, left, right - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="23-合并-K-个排序的列表"><a href="#23-合并-K-个排序的列表" class="headerlink" title="23 合并 K 个排序的列表"></a>23 合并 K 个排序的列表</h2><p>使用优先级队列，复杂度最小。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">把列表看做一个队列，每次拿出两个列表，合并他们后放回到列表中，每次遍历列表的一半，这样每次遍历完一遍，</span><br><span class="line">列表的长度都会减半，直到列表的长度为 <span class="number">1</span>,  合并函数使用 <span class="number">21</span> 题中的合并两个列表的函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;C 解答&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) &#123;</span><br><span class="line">    // see above</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct ListNode* mergeKLists(struct ListNode** lists, <span class="built_in">int</span> listsSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!lists || listsSize &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (listsSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        // listsize <span class="keyword">is</span> halfed</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; listsSize / <span class="number">2</span>; i++)</span><br><span class="line">            // merge i <span class="keyword">and</span> last i <span class="built_in">list</span></span><br><span class="line">            lists[i] = mergeTwoLists(lists[i], lists[listsSize-<span class="number">1</span>-i]);</span><br><span class="line">        listsSize = (listsSize + <span class="number">1</span>) / <span class="number">2</span>; // 注意这里！</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="24-给定一个链表，交换两个相邻节点的值"><a href="#24-给定一个链表，交换两个相邻节点的值" class="headerlink" title="24 给定一个链表，交换两个相邻节点的值"></a>24 给定一个链表，交换两个相邻节点的值</h2><p>最简单的做法显然是直接把前后两个节点的值交换，但是 LeetCode 规定不能改变节点的值。<br>主要考察链表的指针操作，注意各种细节，一定要在纸上先把链表画出来。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> <span class="keyword">and</span> p.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            t = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = t.<span class="built_in">next</span></span><br><span class="line">            t.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span>.<span class="built_in">next</span> = t</span><br><span class="line">            p = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">swapPairs</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">temp</span>, *<span class="title">pnext</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;next) &#123;</span><br><span class="line">        temp = p-&gt;next;</span><br><span class="line">        p-&gt;next = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        p-&gt;next-&gt;next = temp;</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="25-给定一个链表，把相邻的-k-个节点反转"><a href="#25-给定一个链表，把相邻的-k-个节点反转" class="headerlink" title="25 给定一个链表，把相邻的 k 个节点反转"></a>25 给定一个链表，把相邻的 k 个节点反转</h2><p>和上题一样，同样禁止改变节点的值。比较简单地解法是浪费一点空间，使用 Stack, 实现<br>逆转 k 个节点，注意如果 k 较大的话，这种方法是不合适的。另一种方法是直接翻转，空间是<br>O(1) 的，但是时间复杂度是 2N。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head</span>):</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="built_in">next</span> = curr.<span class="built_in">next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> prev</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        p = dummy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            n = k</span><br><span class="line">            q = p</span><br><span class="line">            <span class="comment"># 找到下一组接点的头</span></span><br><span class="line">            <span class="keyword">while</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> q.<span class="built_in">next</span>:</span><br><span class="line">                q = q.<span class="built_in">next</span></span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果节点不够了直接退出</span></span><br><span class="line">            <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 把这段链表先截下来</span></span><br><span class="line">            <span class="built_in">next</span> = q.<span class="built_in">next</span></span><br><span class="line">            q.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            tail = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = self.reverseList(p.<span class="built_in">next</span>)</span><br><span class="line">            p = tail</span><br><span class="line">            p.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>


<p>使用 Stack 的 C++ 解法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    stack&lt;ListNode*&gt; stk;</span><br><span class="line">    <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">-1</span>)</span>, *p </span>= &amp;dummy, *pp;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pp = p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pp-&gt;next) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(pp-&gt;next);</span><br><span class="line">                pp = pp-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">size</span>() &lt; k) <span class="comment">// 剩下的节点不够 k 个了</span></span><br><span class="line">            <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">        pp = stk.<span class="built_in">top</span>()-&gt;next; <span class="comment">// 下一组中的第一个</span></span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            p-&gt;next = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p-&gt;next = pp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26 删除排序数组中的重复项"></a>26 删除排序数组中的重复项</h2><p>tags: #naive</p>
<p>in-place 的删除重复元素，使用两个指针，一个遍历，一个指向当前的结尾。</p>
<p>PS：这个基础题竟然做了半个小时才做对，⊙﹏⊙b 汗，要加强基础啊！</p>
<p>这类数组中去除中间元素的题写的时候还是很容易出错，重点是使用一个 length 变量，<br>然后还是要遍历整个数组。不要想什么双指针了。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 处理 i == 0 的情况也是需要注意的</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> nums[i] != nums[length-<span class="number">1</span>]:</span><br><span class="line">                nums[length] = nums[i]</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt;= <span class="number">1</span>) <span class="keyword">return</span> numsSize;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i] != nums[len - <span class="number">1</span>])</span><br><span class="line">            nums[len++] = nums[i];</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="27-删除元素"><a href="#27-删除元素" class="headerlink" title="27 删除元素"></a>27 删除元素</h2><p>和上一题类似，注意细节</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != val:</span><br><span class="line">                nums[length] = nums[i]</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums || numsSize == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != val)</span><br><span class="line">            nums[len++] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="28-实现-strstr-函数，即查找子串"><a href="#28-实现-strstr-函数，即查找子串" class="headerlink" title="28 实现 strstr 函数，即查找子串"></a>28 实现 strstr 函数，即查找子串</h2><p>使用暴力算法，时间复杂度 O(n)。也可以用 kmp 算法。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kmp 算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="built_in">next</span> = [<span class="number">0</span>]</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 特别注意这里的 1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(needle)):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> needle[i] != needle[j]:</span><br><span class="line">                j = <span class="built_in">next</span>[j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> needle[i] == needle[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="built_in">next</span>.append(j)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(haystack)):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> haystack[i] != needle[j]:</span><br><span class="line">                j = <span class="built_in">next</span>[j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(needle):</span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Brute Force</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strStr</span><span class="params">(<span class="type">char</span>* haystack, <span class="type">char</span>* needle)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="built_in">strlen</span>(haystack);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(needle);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// note h - n + 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h - n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (needle[j] != haystack[i+j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="29-给定连个整数，不使用乘法和除法计算除法。"><a href="#29-给定连个整数，不使用乘法和除法计算除法。" class="headerlink" title="29 给定连个整数，不使用乘法和除法计算除法。"></a>29 给定连个整数，不使用乘法和除法计算除法。</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/discuss/38997/detailed-explained-8ms-c-solution">这里</a> 有一个非常好的算法</p>
<p>计算可以从被除数中减去除数的次数</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> &#123;</span><br><span class="line">    <span class="comment">// abs(INT_MIN) == INT_MAX + 1</span></span><br><span class="line">    <span class="keyword">if</span> (divisor == <span class="number">0</span> || (dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    <span class="type">int</span> sign = (dividend &gt; <span class="number">0</span>) == (divisor &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n = <span class="built_in">labs</span>(dividend);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d = <span class="built_in">labs</span>(divisor);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= d) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> temp = d;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> multi = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;= (temp &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            multi &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n -= temp;</span><br><span class="line">        result += multi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sign * result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="30-包串联所有单词的子串"><a href="#30-包串联所有单词的子串" class="headerlink" title="30 包串联所有单词的子串"></a>30 包串联所有单词的子串</h2><p>tags: #slidewindow</p>
<p>一道诡异的滑动窗口的题目，对这类问题还是不很熟啊。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;C++ 解答&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">vector&lt;<span class="built_in">int</span>&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">    unordered_map&lt;string, <span class="built_in">int</span>&gt; counts;</span><br><span class="line">    <span class="keyword">for</span> (string word : words)</span><br><span class="line">        counts[word]++;</span><br><span class="line">    <span class="built_in">int</span> n = s.length(), num = words.size(), <span class="built_in">len</span> = words[<span class="number">0</span>].size();</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; indexes;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n - num * <span class="built_in">len</span> + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        unordered_map&lt;string, <span class="built_in">int</span>&gt; seen;</span><br><span class="line">        <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; num; j++) &#123;</span><br><span class="line">            string word = s.substr(i + j * <span class="built_in">len</span>, <span class="built_in">len</span>);</span><br><span class="line">            <span class="keyword">if</span> (counts.find(word) != counts.end()) &#123;</span><br><span class="line">                seen[word]++;</span><br><span class="line">                <span class="keyword">if</span> (seen[word] &gt; counts[word])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == num)</span><br><span class="line">            indexes.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> indexes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="31-全排列，下一个"><a href="#31-全排列，下一个" class="headerlink" title="31 全排列，下一个"></a>31 全排列，下一个</h2><p>首先，对于所有的组合，最小的一个一定是按照升序排序的，最大的一定是倒过来，因此</p>
<ol>
<li>如果我们发现是完全倒序的，直接翻转就好了；</li>
<li>如果是一般情况，从后向前遍历，找到逆序的数字的边界，假设是 k。那么后边这段已经是完全<br>逆序的，无法变小了，为了保证生成的数字变大，我们再从后向前找到第一个比 k 大的数字，交<br>换这两个数字，再把后续的逆序数组翻转。</li>
</ol>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextPermutation</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 前后都是闭区间</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">nums, lo, hi</span>):</span><br><span class="line">            <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">                nums[lo], nums[hi] = nums[hi], nums[lo]</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        k = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i + <span class="number">1</span>]:</span><br><span class="line">                k = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> k == -<span class="number">1</span>:</span><br><span class="line">            reverse(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        l = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>, k, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[k]:</span><br><span class="line">                l = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        nums[l], nums[k] = nums[k], nums[l]</span><br><span class="line">        reverse(nums, k+<span class="number">1</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>; <span class="comment">// 升序排列的最后一个数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            k = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完全是逆序的，直接返回第一个，也就是升序排列</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">-1</span>; <span class="comment">// 逆序数字中比 k 大的最小的数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; k; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[k]) &#123;</span><br><span class="line">            l = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[k], nums[l]); <span class="comment">// 保证变大</span></span><br><span class="line">    <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k + <span class="number">1</span>, nums.<span class="built_in">end</span>()); <span class="comment">// 保证是下一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="32-从一个括号构成的字符串中找出最长的合法括号序列"><a href="#32-从一个括号构成的字符串中找出最长的合法括号序列" class="headerlink" title="32 从一个括号构成的字符串中找出最长的合法括号序列"></a>32 从一个括号构成的字符串中找出最长的合法括号序列</h2><p>动态规划的基础题目。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestValidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i-<span class="number">1</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span> i &gt;= <span class="number">2</span>:</span><br><span class="line">                        dp[i] = dp[i-<span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i] = <span class="number">2</span></span><br><span class="line">                <span class="keyword">elif</span> i - dp[i-<span class="number">1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> s[i-dp[i-<span class="number">1</span>]-<span class="number">1</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span> i - dp[i-<span class="number">1</span>] &gt;= <span class="number">2</span>:</span><br><span class="line">                        dp[i] = dp[i-<span class="number">1</span>] + dp[i-dp[i-<span class="number">1</span>]-<span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i] = dp[i-<span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<p>也可以使用栈来解。但是这种方法非常 tricky, 因为要考虑到 <code>()()</code> 的情况。</p>
<h2 id="33-在排序后又被反转的数组中搜索"><a href="#33-在排序后又被反转的数组中搜索" class="headerlink" title="33 在排序后又被反转的数组中搜索"></a>33 在排序后又被反转的数组中搜索</h2><p>既然是部分有序的，自然还是使用二分搜索了，注意终止条件。<br>不同于普通二分搜索的两种情况，我们有了四种情况：</p>
<ol>
<li>前半部分有序，并且在前半部分当中，</li>
<li>前半部分有序，但是不在前半部分</li>
<li>后半部分有序，并且在后半部分</li>
<li>后半部分有序，但是不在后半部分</li>
</ol>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            mi = lo + (hi - lo) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mi] == target:</span><br><span class="line">                <span class="keyword">return</span> mi</span><br><span class="line">            <span class="comment"># 这里为什么要包含等于号呢</span></span><br><span class="line">            <span class="keyword">if</span> nums[lo] &lt;= nums[mi]:</span><br><span class="line">                <span class="keyword">if</span> nums[lo] &lt;= target &lt; nums[mi]:</span><br><span class="line">                    hi = mi - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mi] &lt; target &lt;= nums[hi]:</span><br><span class="line">                    lo = mi + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    hi = mi - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// left half is sorted</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// right half is sorted</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34 在排序数组中查找元素的第一个和最后一个位置"></a>34 在排序数组中查找元素的第一个和最后一个位置</h2><p>在 C++ 的标准库中包含了这两个函数，分别是<code>std::lower_bound</code>和<code>std::upper_bound</code>.</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="function">def <span class="title">searchRange</span><span class="params">(self, nums: List[<span class="type">int</span>], target: <span class="type">int</span>)</span> -&gt; List[<span class="type">int</span>]:</span></span><br><span class="line"><span class="function">        if not nums:</span></span><br><span class="line"><span class="function">            return [<span class="number">-1</span>, <span class="number">-1</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        lo =</span> <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums)</span><br><span class="line">        lower = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = lo + (hi - lo) <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mi] &lt; target:</span><br><span class="line">                lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi</span><br><span class="line">        <span class="keyword">if</span> lo &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[lo] == target:</span><br><span class="line">            lower = lo</span><br><span class="line"></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums)</span><br><span class="line">        upper = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = lo + (hi - lo) <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mi] &lt;= target:</span><br><span class="line">                lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi</span><br><span class="line">        <span class="keyword">if</span> nums[lo<span class="number">-1</span>] == target:</span><br><span class="line">            upper = lo - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [lower, upper]</span><br></pre></td></tr></table></figure>
</details>


<h2 id="35-二分查找数字，如果没有找到，返回应该插入的位置"><a href="#35-二分查找数字，如果没有找到，返回应该插入的位置" class="headerlink" title="35 二分查找数字，如果没有找到，返回应该插入的位置"></a>35 二分查找数字，如果没有找到，返回应该插入的位置</h2><p>就是最基础的二分查找</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = lo + (hi - lo) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mi] == target:</span><br><span class="line">                <span class="keyword">return</span> mi</span><br><span class="line">            <span class="keyword">elif</span> nums[mi] &lt; target:</span><br><span class="line">                lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi</span><br><span class="line">        <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="36-合法数独，给定一个数独表，判定当前是否合法"><a href="#36-合法数独，给定一个数独表，判定当前是否合法" class="headerlink" title="36 合法数独，给定一个数独表，判定当前是否合法"></a>36 合法数独，给定一个数独表，判定当前是否合法</h2><details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        这道题的关键就在于小格子也是可以用 i 和 j 来计算的：</span></span><br><span class="line"><span class="string">        box_index = (row / 3) * 3 + columns / 3</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 特别注意浅拷贝的问题</span></span><br><span class="line">        used_i = [[<span class="number">0</span>] * <span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        used_j = [[<span class="number">0</span>] * <span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        used_k = [[<span class="number">0</span>] * <span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                piece = board[i][j]</span><br><span class="line">                <span class="keyword">if</span> piece == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                n = <span class="built_in">int</span>(piece) - <span class="number">1</span></span><br><span class="line">                k = i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span></span><br><span class="line">                <span class="keyword">if</span> used_i[i][n] <span class="keyword">or</span> used_j[j][n] <span class="keyword">or</span> used_k[k][n]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                used_i[i][n] = used_j[j][n] = used_k[k][n] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有点浪费空间</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>** board, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> used_row[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;, used_col[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;, used_box[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> num = board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> k = i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span> (used_row[i][num] || used_col[j][num] || used_box[k][num])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                used_row[i][num] = used_col[j][num] = used_box[k][num] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="37-求解数独"><a href="#37-求解数独" class="headerlink" title="37 求解数独"></a>37 求解数独</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>(board, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> ind)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ind==<span class="number">81</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> i=ind/<span class="number">9</span>, j=ind%<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span>(board[i][j]!=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">solve</span>(board, ind+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> f = <span class="string">&#x27;1&#x27;</span>; f &lt;= <span class="string">&#x27;9&#x27;</span>; f++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValidFill</span>(board, i, j, f)) &#123;</span><br><span class="line">                board[i][j]= f;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">solve</span>(board, ind+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                board[i][j]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidFill</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span> fill)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">9</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i][k]==fill) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//check the row</span></span><br><span class="line">        <span class="keyword">if</span>(board[k][j]==fill) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//check the column</span></span><br><span class="line">        <span class="type">int</span> r= i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>;   <span class="comment">//select the block</span></span><br><span class="line">        <span class="keyword">if</span>(board[r/<span class="number">3</span>*<span class="number">3</span>+k/<span class="number">3</span>][r%<span class="number">3</span>*<span class="number">3</span>+k%<span class="number">3</span>]==fill) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//check the block</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="38-数数并说出来"><a href="#38-数数并说出来" class="headerlink" title="38 数数并说出来"></a>38 数数并说出来</h2><p>不太理解这道题有什么意义，直接暴力做出来了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    string result = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n <span class="number">-1</span>; i++) &#123;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; result.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j + <span class="number">1</span> &lt; result.<span class="built_in">size</span>() &amp;&amp; result[j+<span class="number">1</span>] == result[j]) &#123;</span><br><span class="line">                j++; count++;</span><br><span class="line">            &#125;</span><br><span class="line">            temp += count + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            temp += result[j];</span><br><span class="line">        &#125;</span><br><span class="line">        result = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="39-给定一个集合，在集合中找出和为-target-的数字，数字可以使用多次，集合中没有重复数字"><a href="#39-给定一个集合，在集合中找出和为-target-的数字，数字可以使用多次，集合中没有重复数字" class="headerlink" title="39 给定一个集合，在集合中找出和为 target 的数字，数字可以使用多次，集合中没有重复数字"></a>39 给定一个集合，在集合中找出和为 target 的数字，数字可以使用多次，集合中没有重复数字</h2><p>典型的深度优先搜索</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">dfs</span>(result, candidates, &#123;&#125;, target);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt;&amp; candidates, vector&lt;<span class="type">int</span>&gt; comb, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(comb);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : candidates) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; target) <span class="keyword">continue</span>; <span class="comment">// 数字太大了</span></span><br><span class="line">        <span class="keyword">if</span> (!comb.<span class="built_in">empty</span>() &amp;&amp; c &lt; comb.<span class="built_in">back</span>()) <span class="keyword">continue</span>; <span class="comment">// 保证不重复且升序</span></span><br><span class="line">        comb.<span class="built_in">push_back</span>(c);</span><br><span class="line">        <span class="built_in">dfs</span>(result, candidates, comb, target - c);</span><br><span class="line">        comb.<span class="built_in">pop_back</span>(); <span class="comment">// 注意此处还需要弹出，因为需要循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="40-同上题一样，但是集合中的数字只能使用一次，并且集合中有重复数字"><a href="#40-同上题一样，但是集合中的数字只能使用一次，并且集合中有重复数字" class="headerlink" title="40 同上题一样，但是集合中的数字只能使用一次，并且集合中有重复数字"></a>40 同上题一样，但是集合中的数字只能使用一次，并且集合中有重复数字</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">dfs</span>(result, candidates, &#123;&#125;, target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt;&amp; candidates, vector&lt;<span class="type">int</span>&gt; comb, <span class="type">int</span> target, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(comb);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidates[i] &gt; target)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i != start &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        comb.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">        <span class="built_in">dfs</span>(result, candidates, comb, target - candidates[i], i + <span class="number">1</span>);</span><br><span class="line">        comb.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="41-给定一个数组，找到第一个缺失的正数"><a href="#41-给定一个数组，找到第一个缺失的正数" class="headerlink" title="41 给定一个数组，找到第一个缺失的正数"></a>41 给定一个数组，找到第一个缺失的正数</h2><p>显然，结果的范围是 [1..n+1]. 而数组的长度为 n 我们把每个位置都放上 i+1,<br>这样如果有位置不是 i+1, 则找到了结果，如果都相等则是 n+1.</p>
<details>
    <summary>c 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *a; *a = *b; *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        <span class="comment">// 注意此处的 while</span></span><br><span class="line">        <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= numsSize &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>])</span><br><span class="line">            swap(&amp;nums[i], &amp;nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numsSize + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="42-给定一个数组表示柱子的高度，求能存贮的雨水的总量"><a href="#42-给定一个数组表示柱子的高度，求能存贮的雨水的总量" class="headerlink" title="42 给定一个数组表示柱子的高度，求能存贮的雨水的总量"></a>42 给定一个数组表示柱子的高度，求能存贮的雨水的总量</h2><p>从两边向中间收拢</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>* height, <span class="type">int</span> heightSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = heightSize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_left = <span class="number">0</span>, max_right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从两侧向中间缩小，可以算作是两个指针吧</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt;= height[right]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[left] &gt;= max_left)</span><br><span class="line">                max_left = height[left];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                water += max_left - height[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[right] &gt;= max_right)</span><br><span class="line">                max_right = height[right];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                water += max_right - height[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> water;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trap</span>(height: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> height.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">left</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">right</span> = height.<span class="title function_ invoke__">len</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">water</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max_left</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max_right</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right &#123;</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt;= height[right] &#123;</span><br><span class="line">                <span class="keyword">if</span> height[left] &gt;= max_left &#123;</span><br><span class="line">                    max_left = height[left];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    water += max_left - height[left];</span><br><span class="line">                &#125;</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> height[right] &gt;= max_right &#123;</span><br><span class="line">                    max_right = height[right];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    water += max_right - height[right];</span><br><span class="line">                &#125;</span><br><span class="line">                right -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        water</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
t

<h2 id="43-给定两个任意长的字符串，返回一个字符串，代表他们相乘的结果"><a href="#43-给定两个任意长的字符串，返回一个字符串，代表他们相乘的结果" class="headerlink" title="43 给定两个任意长的字符串，返回一个字符串，代表他们相乘的结果"></a>43 给定两个任意长的字符串，返回一个字符串，代表他们相乘的结果</h2><p>按整数除法运算即可，重点是下标的表示</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> tonum(c) (c - <span class="string">&#x27;0&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tochar(i) (i + <span class="string">&#x27;0&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">multiply</span><span class="params">(<span class="type">char</span>* num1, <span class="type">char</span>* num2)</span> &#123;</span><br><span class="line">    <span class="comment">// 结果的长度不会超过 m+n,</span></span><br><span class="line">    <span class="comment">// 假设某个数是 n 位的 9, 则结果比另一个数结尾加上 n 个 0 还小</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(num1), m = <span class="built_in">strlen</span>(num2);</span><br><span class="line">    <span class="type">int</span> len = m+n;</span><br><span class="line">    <span class="type">char</span>* result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        result[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    result[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> v = tonum(result[i+j+<span class="number">1</span>]) +  tonum(num1[i]) * tonum(num2[j]) + carry;</span><br><span class="line">            result[i+j+<span class="number">1</span>] = tochar(v % <span class="number">10</span>);</span><br><span class="line">            carry = v / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result[i] += carry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (result[i] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> result+i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="44-通配符匹配，-代表任意一个字符，-代表任意一个或多个字符"><a href="#44-通配符匹配，-代表任意一个字符，-代表任意一个或多个字符" class="headerlink" title="44 通配符匹配，? 代表任意一个字符，*代表任意一个或多个字符"></a>44 通配符匹配，<code>?</code> 代表任意一个字符，<code>*</code>代表任意一个或多个字符</h2><p>注意和正则表达式的区别，要求完全匹配。这道题的关键在于对星号的处理，如果出现星号的时候，我们记录当时的 p 和 s 的值，如果发生了不匹配的话，我们尝试回到该位置的下一个位置开始匹配</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isMatch</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* p)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* star = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>* revert = s;</span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s == *p || *p == <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            s++, p++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            star = p++, revert = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (star)</span><br><span class="line">            p = star + <span class="number">1</span>, s = ++revert;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果剩下了 p, 那应该全都是*才对</span></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p++ != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="45-跳跃游戏，给定一个数组，每个数字是在该位置可以向前移动的距离，返回最少需要多少次才能到达终点"><a href="#45-跳跃游戏，给定一个数组，每个数字是在该位置可以向前移动的距离，返回最少需要多少次才能到达终点" class="headerlink" title="45 跳跃游戏，给定一个数组，每个数字是在该位置可以向前移动的距离，返回最少需要多少次才能到达终点"></a>45 跳跃游戏，给定一个数组，每个数字是在该位置可以向前移动的距离，返回最少需要多少次才能到达终点</h2><p>比较简单，看注释吧</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> last = <span class="number">0</span>; <span class="comment">// last range</span></span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>; <span class="comment">// current range</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="comment">// beyond range, make another jump</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; last)</span><br><span class="line">            last = cur, steps++;</span><br><span class="line">        <span class="comment">// if we could reach longer?</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] + i &gt; cur)</span><br><span class="line">            cur = nums[i] + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="46-生成全排列"><a href="#46-生成全排列" class="headerlink" title="46 生成全排列"></a>46 生成全排列</h2><p>Cracking 上给出了一种解法，通过不断的添加下一个元素到上一组元素的不同位置来生成全排列，这样固然可以，但是大规模的拼接数组或者字符串是很耗费资源的。</p>
<p>在已经有了字符串（或者数组）的初始排列以后，可以通过不断交换的方法生成每一组全排列。<br>比如对于 xyz，我们有全排列为</p>
<pre><code>x + per(yx)
y + per(xz)
z + per(xy)
</code></pre>
<p>那么我们通过把每个元素交换到第一个位置，就把问题规模缩小了，知道把问题规模缩小为 1.</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">per</span>(result, nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">per</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> begin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意是从 begin 开始，这样未改变的才能加入进来</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[begin], nums[i]);</span><br><span class="line">        <span class="built_in">per</span>(result, nums, begin + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">swap</span>(nums[begin], nums[i]); <span class="comment">// 注意因为参数中是传引用，这里需要复原</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">permute</span>(nums: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt; = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">per</span>(&amp;<span class="keyword">mut</span> result, nums, <span class="number">0</span>);</span><br><span class="line">        result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">per</span>(result: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt;, nums: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;, begin: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> begin &gt;= nums.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">            result.<span class="title function_ invoke__">push</span>(nums);</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> begin..nums.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = nums.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">            nums.<span class="title function_ invoke__">swap</span>(begin, i);</span><br><span class="line">            <span class="keyword">Self</span>::<span class="title function_ invoke__">per</span>(result, nums, begin + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="47-全排列，数组中有重复元素"><a href="#47-全排列，数组中有重复元素" class="headerlink" title="47 全排列，数组中有重复元素"></a>47 全排列，数组中有重复元素</h2><p>和上一题基本是一样的，注意跳过重复元素就好了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">per</span>(result, nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">per</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start != i &amp;&amp; nums[start] == nums[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">swap</span>(nums[start], nums[i]);</span><br><span class="line">        <span class="built_in">per</span>(result, nums, start + <span class="number">1</span>); <span class="comment">// 事实证明，传引用反倒会超时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="48-给定一个n-n的图像旋转图像，顺时针旋转-90-度"><a href="#48-给定一个n-n的图像旋转图像，顺时针旋转-90-度" class="headerlink" title="48 给定一个n*n的图像旋转图像，顺时针旋转 90 度"></a>48 给定一个<code>n*n</code>的图像旋转图像，顺时针旋转 90 度</h2><p>做法显然是从里到外，一层一层的旋转，这道题主要考察下标的操作</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> layer = <span class="number">0</span>; layer &lt; n / <span class="number">2</span>; layer++) &#123;</span><br><span class="line">        <span class="type">int</span> first  = layer;</span><br><span class="line">        <span class="type">int</span> last = n - <span class="number">1</span> - layer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = first; i &lt; last; i++) &#123;</span><br><span class="line">            <span class="type">int</span> offset = i - first;</span><br><span class="line">            <span class="type">int</span> top = matrix[first][i];</span><br><span class="line">            <span class="comment">// up &lt;- left</span></span><br><span class="line">            matrix[first][i] = matrix[last-offset][first];</span><br><span class="line">            <span class="comment">// left &lt;- down</span></span><br><span class="line">            matrix[last-offset][first] = matrix[last][last-offset];</span><br><span class="line">            <span class="comment">// down &lt;- right</span></span><br><span class="line">            matrix[last][last-offset] = matrix[i][last];</span><br><span class="line">            <span class="comment">// right &lt;- up</span></span><br><span class="line">            matrix[i][last] = top;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="49-给定字符数组，把他们按照-Anagram-分组"><a href="#49-给定字符数组，把他们按照-Anagram-分组" class="headerlink" title="49 给定字符数组，把他们按照 Anagram 分组"></a>49 给定字符数组，把他们按照 Anagram 分组</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Anagram 分组</span></span><br><span class="line"><span class="comment">// 这道题没什么可做的，只需要统计</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    string temp;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; records;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        temp = strs[i];</span><br><span class="line">        <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">        records[temp].<span class="built_in">push_back</span>(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; record : records) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(record.second.<span class="built_in">begin</span>(), record.second.<span class="built_in">end</span>());</span><br><span class="line">        result.<span class="built_in">push_back</span>(record.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="50-实现-pow-x-n"><a href="#50-实现-pow-x-n" class="headerlink" title="50 实现 pow(x, n)"></a>50 实现 pow(x, n)</h2><p>显然不能直接阶乘过去，分治法</p>
<p>递归做法</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == INT_MIN) <span class="keyword">return</span> myPow(x, n - <span class="number">1</span>) * x;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> / myPow(x, -n);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">double</span> y = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">0x1</span>)</span><br><span class="line">        <span class="keyword">return</span> y * y * x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> y * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>迭代做法</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iteratively</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> p)</span> &#123;</span><br><span class="line">    <span class="type">double</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span> / myPow(x, -p);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            result *= x;</span><br><span class="line">        x *= x;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="51-N-皇后问题"><a href="#51-N-皇后问题" class="headerlink" title="51 N 皇后问题"></a>51 N 皇后问题</h2><p>需要大幅度修改</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N 皇后问题，皇后不能再一条直线，一条竖线，一条斜线上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用深度优先求解，对于 dfs 问题，我们首先把算法的框架写下来，然后确定这个问题的限制条件</span></span><br><span class="line"><span class="comment">// 对于这个问题，限制条件当前行的元素不能在以前的列中出现过，也不能在对角线中出现过</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">x</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, x, n);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> t, vector&lt;<span class="type">int</span>&gt;&amp; x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当新添加一个 Q 到当前解的时候</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) &#123;</span><br><span class="line">        <span class="comment">// result.push_back(make_solution(x));</span></span><br><span class="line">        <span class="comment">// return;</span></span><br><span class="line">        vector&lt;string&gt; solution;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="function">string <span class="title">line</span><span class="params">(n, <span class="string">&#x27;.&#x27;</span>)</span></span>;</span><br><span class="line">            line[x[i]] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            solution.<span class="built_in">push_back</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(solution);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">bool</span> skip = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x[j] == i || <span class="built_in">abs</span>(i - x[j]) == <span class="built_in">abs</span>(t - j)) &#123;</span><br><span class="line">                    skip = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (skip) <span class="keyword">continue</span>;</span><br><span class="line">            x[t] = i;</span><br><span class="line">            <span class="built_in">dfs</span>(t+<span class="number">1</span>, x, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="52-N-皇后一共有多少个解"><a href="#52-N-皇后一共有多少个解" class="headerlink" title="52 N 皇后一共有多少个解"></a>52 N 皇后一共有多少个解</h2><p>不要直接把皇后放好，而是把占用的都记录下来，然后继续深度优先搜索</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; cols, digs1, digs2;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">total</span>(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">total</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> count, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cols.<span class="built_in">find</span>(col) != cols.<span class="built_in">end</span>()</span><br><span class="line">                || digs1.<span class="built_in">find</span>(row - col) != digs1.<span class="built_in">end</span>()</span><br><span class="line">                || digs2.<span class="built_in">find</span>(row + col) != digs2.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (row == n<span class="number">-1</span>)</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cols.<span class="built_in">insert</span>(col);</span><br><span class="line">                digs1.<span class="built_in">insert</span>(row-col);</span><br><span class="line">                digs2.<span class="built_in">insert</span>(row+col);</span><br><span class="line">                count = <span class="built_in">total</span>(row+<span class="number">1</span>, count, n);</span><br><span class="line">                cols.<span class="built_in">erase</span>(col);</span><br><span class="line">                digs1.<span class="built_in">erase</span>(row-col);</span><br><span class="line">                digs2.<span class="built_in">erase</span>(row+col);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="53-最大子序列和"><a href="#53-最大子序列和" class="headerlink" title="53 最大子序列和"></a>53 最大子序列和</h2><p>动态规划经典题目，遍历数组，如果已经当前子序列已经小于 0 了，抛弃并置 sum &#x3D; 0<br>如果比当前和更大，更新。对于一个子序列，要么使得序列和增大，要么减小。</p>
<p><code>dp[n+1] = max(dp[n], dp[n] + A[n+1])</code></p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>; i&lt; numsSize; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; m)</span><br><span class="line">            m = sum;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        current_sum = <span class="number">0</span></span><br><span class="line">        max_value = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            current_sum += i</span><br><span class="line">            max_value = <span class="built_in">max</span>(max_value, current_sum)</span><br><span class="line">            current_sum = <span class="built_in">max</span>(<span class="number">0</span>, current_sum)</span><br><span class="line">        <span class="keyword">return</span> max_value</span><br></pre></td></tr></table></figure>
</details>


<h2 id="54-顺时针螺旋打印矩阵"><a href="#54-顺时针螺旋打印矩阵" class="headerlink" title="54 顺时针螺旋打印矩阵"></a>54 顺时针螺旋打印矩阵</h2><p>一圈一圈地打印就好了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row == <span class="number">0</span> || col == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>, right = col - <span class="number">1</span>, down = row - <span class="number">1</span>, left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * row * col);</span><br><span class="line">    <span class="keyword">while</span> (top &lt;= down &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">            result[index++] = matrix[top][i];</span><br><span class="line">        top++; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = top; i &lt;= down; i++)</span><br><span class="line">            result[index++] = matrix[i][right];</span><br><span class="line">        right--; <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 注意这个 if 语句</span></span><br><span class="line">        <span class="keyword">if</span> (top &lt;= down)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = right; i &gt;= left; i--)</span><br><span class="line">                result[index++] = matrix[down][i];</span><br><span class="line">        down--; <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 注意这个 if 语句</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = down; i &gt;= top; i--)</span><br><span class="line">                result[index++] = matrix[i][left];</span><br><span class="line">        left++; <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="55-给定一个数组，每个数字表示在当前步可以移动的距离，返回是不是能够到达终点"><a href="#55-给定一个数组，每个数字表示在当前步可以移动的距离，返回是不是能够到达终点" class="headerlink" title="55 给定一个数组，每个数字表示在当前步可以移动的距离，返回是不是能够到达终点"></a>55 给定一个数组，每个数字表示在当前步可以移动的距离，返回是不是能够到达终点</h2><p>使用动态规划求解，如果当前距离大于最远距离，更新最远距离，如果已经超过了最远距离，跳出</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> reach = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize &amp;&amp; i &lt;= reach; i++)</span><br><span class="line">            reach = max(reach, nums[i] + i);</span><br><span class="line">    <span class="keyword">return</span> i == numsSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="56-合并序列，给定一组序列，把其中重叠的序列合并"><a href="#56-合并序列，给定一组序列，把其中重叠的序列合并" class="headerlink" title="56 合并序列，给定一组序列，把其中重叠的序列合并"></a>56 合并序列，给定一组序列，把其中重叠的序列合并</h2><p>这道题用 Python 做竟然比用 C++ 还要快</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">class Interval(object):</span></span><br><span class="line"><span class="string">    def __init__(self, start=0, end=0):</span></span><br><span class="line"><span class="string">        self.start = start</span></span><br><span class="line"><span class="string">        self.end= end</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">intervals</span>):</span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x.start)</span><br><span class="line">    combined = []</span><br><span class="line">    <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="keyword">if</span> combined <span class="keyword">and</span> interval.start &lt;= combined[-<span class="number">1</span>].end:</span><br><span class="line">            combined[-<span class="number">1</span>].end = <span class="built_in">max</span>(combined[-<span class="number">1</span>].end, interval.end)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            combined.append(interval)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure>
</details>


<h2 id="57-添加序列，给定一组已经排序的序列，向其中插入一个序列，需要合并的合并"><a href="#57-添加序列，给定一组已经排序的序列，向其中插入一个序列，需要合并的合并" class="headerlink" title="57 添加序列，给定一组已经排序的序列，向其中插入一个序列，需要合并的合并"></a>57 添加序列，给定一组已经排序的序列，向其中插入一个序列，需要合并的合并</h2><p>把剩余的部分都拷贝过来也不失为一种机智的做法。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, intervals, newInterval</span>):</span><br><span class="line">        ans = []</span><br><span class="line">        start, end = newInterval</span><br><span class="line">        remainder = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="comment"># 未重叠</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; y:</span><br><span class="line">                ans.append([x, y])</span><br><span class="line">            <span class="comment"># 进入重叠状态</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> end &lt; x:  <span class="comment"># 当前区间已经不重叠了</span></span><br><span class="line">                    <span class="keyword">break</span>  <span class="comment"># 找到了结尾了</span></span><br><span class="line">                start = <span class="built_in">min</span>(start, x)</span><br><span class="line">                end = <span class="built_in">max</span>(end, y)</span><br><span class="line">            remainder += <span class="number">1</span></span><br><span class="line">        ans.append([start, end])</span><br><span class="line">        ans += intervals[remainder:]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<h2 id="58-给定一个字符串，求其中最后一个单词的长度"><a href="#58-给定一个字符串，求其中最后一个单词的长度" class="headerlink" title="58 给定一个字符串，求其中最后一个单词的长度"></a>58 给定一个字符串，求其中最后一个单词的长度</h2><p>显然这道题可以用 strlen 求出长度然后从后往前数，但是，这样相当于多遍历了一次<br>直接从后往前可以保证只遍历一次</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLastWord</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> inWord = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(*s)) &#123;</span><br><span class="line">            inWord = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!inWord) &#123;</span><br><span class="line">                len = <span class="number">1</span>;</span><br><span class="line">                inWord = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="59-给定-n，把-1-2-3-…-螺旋打印到矩阵中"><a href="#59-给定-n，把-1-2-3-…-螺旋打印到矩阵中" class="headerlink" title="59 给定 n，把 1, 2, 3 … 螺旋打印到矩阵中"></a>59 给定 n，把 1, 2, 3 … 螺旋打印到矩阵中</h2><p>和上一个完全一样的思路，只是这次是打印罢了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays.</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>** <span class="title function_">generateMatrix</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>** matrix = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        matrix[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>, left = <span class="number">0</span>, down = n - <span class="number">1</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (top &lt;= down &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;=right; i++)</span><br><span class="line">            matrix[top][i] = a++;</span><br><span class="line">        top++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = top; i &lt;= down; i++) &#123;</span><br><span class="line">            matrix[i][right] = a++;</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="keyword">if</span> (top &lt;= down)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = right; i &gt;= left; i--)</span><br><span class="line">                matrix[down][i] = a++;</span><br><span class="line">        down--;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = down; i &gt;= top; i--)</span><br><span class="line">                matrix[i][left] = a++;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="60-给定-n-个数字，找出第-k-个-Permutation"><a href="#60-给定-n-个数字，找出第-k-个-Permutation" class="headerlink" title="60 给定 n 个数字，找出第 k 个 Permutation"></a>60 给定 n 个数字，找出第 k 个 Permutation</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*The logic is as follows:</span></span><br><span class="line"><span class="comment">    for n numbers the permutations can be divided to (n-1)! groups,</span></span><br><span class="line"><span class="comment">    thus k/(n-1)! indicates the index of current number,</span></span><br><span class="line"><span class="comment">    and k%(n-1)! denotes remaining sequence (to the right).</span></span><br><span class="line"><span class="comment">    We keep doing this until n reaches 0, then we get n numbers permutations that is kth.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">string <span class="title">getPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">        <span class="function">string <span class="title">s</span><span class="params">(n, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            f *= i;</span><br><span class="line">            s[i<span class="number">-1</span>] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 给定 n, 一共有 n! 个序列，f == n!</span></span><br><span class="line"></span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            f /= n - i; <span class="comment">// f /= n, f /= n - 1 ...</span></span><br><span class="line">            <span class="type">int</span> j = i + k / f;</span><br><span class="line">            <span class="type">char</span> c= s[j];</span><br><span class="line">            <span class="keyword">for</span> (;j &gt; i; j--) <span class="comment">// shift space to put `c`, actually we could use swap</span></span><br><span class="line">                s[j] = s[j<span class="number">-1</span>];</span><br><span class="line">            s[i] = c;</span><br><span class="line">            k %= f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="61-把列表旋转到倒数第-k-位"><a href="#61-把列表旋转到倒数第-k-位" class="headerlink" title="61 把列表旋转到倒数第 k 位"></a>61 把列表旋转到倒数第 k 位</h2><p>需要注意的是 k 大于列表长度的情况，这时候需要取余</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">rotateRight</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">n</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (n-&gt;next) &#123;</span><br><span class="line">        n = n-&gt;next;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n is now the tail!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k &gt;= l) k %= l;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="type">int</span> i = l - k;</span><br><span class="line">    <span class="keyword">while</span> (i--)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">    dummy.next = p-&gt;next;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    n-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="62-给定一个m-n的矩阵，有多少种方法从左上角移动到右下角"><a href="#62-给定一个m-n的矩阵，有多少种方法从左上角移动到右下角" class="headerlink" title="62 给定一个m*n的矩阵，有多少种方法从左上角移动到右下角"></a>62 给定一个<code>m*n</code>的矩阵，有多少种方法从左上角移动到右下角</h2><p>显然可以使用组合数学直接求出来解，但是容易溢出。而且这是一道经典的动态规划题目，对于<br>每个格子，可以从他的上部或者左面移动过来。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            grid[i][j] = grid[i - <span class="number">1</span>][j] + grid[i][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="63-同上题，区别是在一些位置是有障碍物的"><a href="#63-同上题，区别是在一些位置是有障碍物的" class="headerlink" title="63 同上题，区别是在一些位置是有障碍物的"></a>63 同上题，区别是在一些位置是有障碍物的</h2><p>经过分析可知，递推关系是一样的，只需要把有障碍格子的到达方法设定为 0。这个主要是实现上的一些技巧，<br>见注释。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>(), n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 注意设定长宽均 +1，但是初始化为 0，边界就成了障碍</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathes</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    pathes[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 给定一个入口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++)</span><br><span class="line">            <span class="comment">// 注意此处的偏移</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="number">1</span>)</span><br><span class="line">                pathes[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pathes[i][j] = pathes[i<span class="number">-1</span>][j] + pathes[i][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> pathes[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="64-给定一个m-n矩阵，每个数字代表经过该处的耗费，找出一条耗费最小的路径"><a href="#64-给定一个m-n矩阵，每个数字代表经过该处的耗费，找出一条耗费最小的路径" class="headerlink" title="64 给定一个m*n矩阵，每个数字代表经过该处的耗费，找出一条耗费最小的路径"></a>64 给定一个<code>m*n</code>矩阵，每个数字代表经过该处的耗费，找出一条耗费最小的路径</h2><p>依然是动态规划</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if modifying the grid is disallowed, copy it</span></span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>)</span><br><span class="line">                grid[i][j] += grid[i][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                grid[i][j] += grid[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                grid[i][j] += <span class="built_in">min</span>(grid[i<span class="number">-1</span>][j], grid[i][j<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> grid[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="65-判定一个字符串是否是合法的数字，包括了正负号，小数点，e等"><a href="#65-判定一个字符串是否是合法的数字，包括了正负号，小数点，e等" class="headerlink" title="65 判定一个字符串是否是合法的数字，包括了正负号，小数点，e等"></a>65 判定一个字符串是否是合法的数字，包括了正负号，小数点，<code>e</code>等</h2><p>一些例子：</p>
<pre><code>&quot;0&quot; =&gt; true
&quot; 0.1 &quot; =&gt; true
&quot;abc&quot; =&gt; false
&quot;1 a&quot; =&gt; false
&quot;2e10&quot; =&gt; true
</code></pre>
<p>这道题就是细节题，用 C 处理字符串太蛋疼了，直接上 Python 了</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isNumber</span>(<span class="params">self, s</span>):</span><br><span class="line">    BEFORE = <span class="number">0</span> <span class="comment"># before dot</span></span><br><span class="line">    AFTER = <span class="number">1</span> <span class="comment"># after dot</span></span><br><span class="line">    EXP = <span class="number">2</span> <span class="comment"># after e</span></span><br><span class="line">    phase = BEFORE</span><br><span class="line">    allow_sign = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    s = s.strip()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">any</span>([c.isdigit() <span class="keyword">for</span> c <span class="keyword">in</span> s]):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> s[-<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> s == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> <span class="keyword">and</span> s[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> <span class="keyword">and</span> s[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">            allow_sign = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">            allow_sign = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> phase == EXP <span class="keyword">or</span> phase == AFTER:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                phase = AFTER</span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> phase == EXP:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            allow_sign = <span class="literal">True</span></span><br><span class="line">            phase = EXP</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;-&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> allow_sign:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            allow_sign = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> phase == EXP:</span><br><span class="line">        <span class="keyword">return</span> s[-<span class="number">1</span>].isdigit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="66-给定一个字符串代表的数字，返回加-1-后的数字"><a href="#66-给定一个字符串代表的数字，返回加-1-后的数字" class="headerlink" title="66 给定一个字符串代表的数字，返回加 1 后的数字"></a>66 给定一个字符串代表的数字，返回加 1 后的数字</h2><p>乍一看如果需要进位的话，可能需要拷贝整个数组。实际上并不需要，我们知道只有当数字是 999…999 的时候，才会使得数字的长度 +1 变为 1000…000。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = digits.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits[i] == <span class="number">9</span>) &#123;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            digits[i]++;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// trick here, we know that the number is 999...999</span></span><br><span class="line">    digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    digits.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">plus_one</span>(<span class="keyword">mut</span> digits: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">0</span>..digits.<span class="title function_ invoke__">len</span>()).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">            <span class="keyword">match</span> digits[i] &#123;</span><br><span class="line">                <span class="number">9</span> =&gt; digits[i] = <span class="number">0</span>,</span><br><span class="line">                _ =&gt; &#123;digits[i] += <span class="number">1</span>; <span class="keyword">return</span> digits&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        digits.<span class="title function_ invoke__">push</span>(<span class="number">0</span>);</span><br><span class="line">        digits</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="67-给定两个字符串代表的二进制数字，返回他们相加的和"><a href="#67-给定两个字符串代表的二进制数字，返回他们相加的和" class="headerlink" title="67 给定两个字符串代表的二进制数字，返回他们相加的和"></a>67 给定两个字符串代表的二进制数字，返回他们相加的和</h2><p>和上一题一样，按照加法定义做就好了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> tonum(c) (c - <span class="string">&#x27;0&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tochar(i) (i + <span class="string">&#x27;0&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">addBinary</span><span class="params">(<span class="type">char</span>* a, <span class="type">char</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(a), n = <span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="type">int</span> len = (m &gt; n ? m : n) + <span class="number">1</span>; <span class="comment">// strlen(c)</span></span><br><span class="line">    <span class="type">char</span>* c = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * len + <span class="number">1</span>); <span class="comment">// with ending null</span></span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="string">&#x27;0&#x27;</span>, len+<span class="number">1</span>);</span><br><span class="line">    c[len] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">         c[len-i] = tochar((i &lt;= m ? tonum(a[m-i]) : <span class="number">0</span>) ^ (i &lt;= n ? tonum(b[n-i]) : <span class="number">0</span>) ^ carry);</span><br><span class="line">         carry = ((i &lt;= m ? tonum(a[m-i]) : <span class="number">0</span>) + (i &lt;= n ? tonum(b[n-i]) : <span class="number">0</span>) + carry) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> ? c+<span class="number">1</span> : c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="68-文字对齐"><a href="#68-文字对齐" class="headerlink" title="68 文字对齐"></a>68 文字对齐</h2><p>待研究</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">fullJustify</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="type">int</span> L)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, k, l; i &lt; words.<span class="built_in">size</span>(); i += k) &#123;</span><br><span class="line">        <span class="keyword">for</span>(k = l = <span class="number">0</span>; i + k &lt; words.<span class="built_in">size</span>() <span class="keyword">and</span> l + words[i+k].<span class="built_in">size</span>() &lt;= L - k; k++) &#123;</span><br><span class="line">            l += words[i+k].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        string tmp = words[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i + k &gt;= words.<span class="built_in">size</span>()) tmp += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> tmp += <span class="built_in">string</span>((L - l) / (k - <span class="number">1</span>) + (j &lt; (L - l) % (k - <span class="number">1</span>)), <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            tmp += words[i+j+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        tmp += <span class="built_in">string</span>(L - tmp.<span class="built_in">size</span>(), <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="69-给定整数-x，求-sqrt-x"><a href="#69-给定整数-x，求-sqrt-x" class="headerlink" title="69 给定整数 x，求 sqrt(x)"></a>69 给定整数 x，求 sqrt(x)</h2><p>比较坑的是 LeetCode 要求的是 <code>y*y &lt; x</code> 的最大整数</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> EPS = x * <span class="number">0.0001</span>;</span><br><span class="line">    <span class="type">double</span> y = x / <span class="number">2</span>; <span class="comment">// initial guess</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(y * y - x) &gt; EPS) &#123;</span><br><span class="line">        y = (y + x / y) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> z = (<span class="type">long</span>) y;</span><br><span class="line">    <span class="keyword">while</span> (z * z &gt; x) z--;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="70-爬梯子，一次可以爬一步或者两步，有几种方法爬完梯子"><a href="#70-爬梯子，一次可以爬一步或者两步，有几种方法爬完梯子" class="headerlink" title="70 爬梯子，一次可以爬一步或者两步，有几种方法爬完梯子"></a>70 爬梯子，一次可以爬一步或者两步，有几种方法爬完梯子</h2><p>斐波那契数列，也可以理解为动态规划</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        t = b, b += a, a = t;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="71-简化-Unix-路径，需要处理-和多个斜杠等情况"><a href="#71-简化-Unix-路径，需要处理-和多个斜杠等情况" class="headerlink" title="71 简化 Unix 路径，需要处理., .. 和多个斜杠等情况"></a>71 简化 Unix 路径，需要处理<code>.</code>, <code>..</code> 和多个斜杠等情况</h2><p>没有什么需要注意的，主要是使用 stringstream 用作 string.split</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">simplifyPath</span><span class="params">(string&amp; path)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; dirs;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(path)</span></span>;</span><br><span class="line">    string dir;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, dir, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dir == <span class="string">&quot;.&quot;</span> || dir == <span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dir == <span class="string">&quot;..&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dirs.<span class="built_in">empty</span>())</span><br><span class="line">            dirs.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            dirs.<span class="built_in">push_back</span>(dir);</span><br><span class="line">    &#125;</span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; dir : dirs)</span><br><span class="line">        <span class="keyword">if</span> (!dir.<span class="built_in">empty</span>())</span><br><span class="line">            result += <span class="string">&quot;/&quot;</span> + dir;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">size</span>() ? result : <span class="string">&quot;/&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="72-编辑距离，允许替换，删除，插入三种操作"><a href="#72-编辑距离，允许替换，删除，插入三种操作" class="headerlink" title="72 编辑距离，允许替换，删除，插入三种操作"></a>72 编辑距离，允许替换，删除，插入三种操作</h2><p>对于两个字符串比较，往往要使用二维的动态规划。<br>使用 f[i][j] 表示 word1[1..i] 和 word2[1..j] 之间的距离。<br>see <a target="_blank" rel="noopener" href="https://leetcode.com/discuss/43398/20ms-detailed-explained-c-solutions-o-n-space">here</a></p>
<p>那么：</p>
<ol>
<li><p>相等 f[i][j] &#x3D; f[i-1][j-1];</p>
</li>
<li><p>不相等</p>
<ol>
<li>替换：f[i][j] &#x3D; f[i-1][j-1] + 1;  都向前一步</li>
<li>添加：f[i][j] &#x3D; f[i][j-1] + 1; word2 向前一步</li>
<li>删除：f[i][j] &#x3D; f[i-1][j] + 1; word1 向前一步</li>
</ol>
</li>
</ol>
<p>另外使用一维数组表示二维数组还需要了解</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// unoptimized code</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = word1.<span class="built_in">length</span>(), n = word2.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>, <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j] + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// optimized</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = word1.<span class="built_in">length</span>(), n = word2.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cur</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 把剩余的字符删掉的距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        cur[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="type">int</span> pre = cur[<span class="number">0</span>];</span><br><span class="line">        cur[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = cur[i];</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                cur[i] = pre;</span><br><span class="line">            <span class="keyword">else</span> cur[i] = <span class="built_in">min</span>(pre + <span class="number">1</span>, <span class="built_in">min</span>(cur[i] + <span class="number">1</span>, cur[i - <span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive code from beauty of programming</span></span><br><span class="line"><span class="comment">// TLE on LeetCode</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">minDistance</span>(&amp;word1.<span class="built_in">front</span>(), &amp;word1.<span class="built_in">back</span>(), &amp;word2.<span class="built_in">front</span>(), &amp;word2.<span class="built_in">back</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">minDistance</span>(<span class="type">char</span>* start1, <span class="type">char</span>* end1, <span class="type">char</span>* start2, <span class="type">char</span>* end2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (start1 &gt; end1)</span><br><span class="line">        <span class="keyword">return</span> start2 &gt; end2 ? <span class="number">0</span> : end2 - start2 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start2 &gt; end2)</span><br><span class="line">        <span class="keyword">return</span> start1 &gt; end1 ? <span class="number">0</span> : end1 - start1 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*start1 == *start2)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">minDistance</span>(start1 + <span class="number">1</span>, end1, start2 + <span class="number">1</span>, end2);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> t1 = <span class="built_in">minDistance</span>(start1 + <span class="number">1</span>, end1, start2 + <span class="number">1</span>, end2);</span><br><span class="line">        <span class="type">int</span> t2 = <span class="built_in">minDistance</span>(start1 + <span class="number">1</span>, end1, start2, end2);</span><br><span class="line">        <span class="type">int</span> t3 = <span class="built_in">minDistance</span>(start1, end1, start2 + <span class="number">1</span>, end2);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(t1, <span class="built_in">min</span>(t2, t3)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="73-给定一个矩阵，如果某个元素为零，把所在的行和所在的列都设为零"><a href="#73-给定一个矩阵，如果某个元素为零，把所在的行和所在的列都设为零" class="headerlink" title="73 给定一个矩阵，如果某个元素为零，把所在的行和所在的列都设为零"></a>73 给定一个矩阵，如果某个元素为零，把所在的行和所在的列都设为零</h2><p>一种可以接受的方法是使用 O(m+n) 的空间，记录哪行哪列需要设为零</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">row</span><span class="params">(m)</span>, <span class="title">column</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                row[i] = <span class="literal">true</span>, column[j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (row[i] || column[j])</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="74-搜索矩阵，矩阵每行从左到右依次增大，每行都比上一行大"><a href="#74-搜索矩阵，矩阵每行从左到右依次增大，每行都比上一行大" class="headerlink" title="74 搜索矩阵，矩阵每行从左到右依次增大，每行都比上一行大"></a>74 搜索矩阵，矩阵每行从左到右依次增大，每行都比上一行大</h2><p>当做数组直接二分搜索就可以了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = row * col - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix[mid/col][mid%col] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[mid/col][mid%col] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="75-颜色排序，每个物体有颜色属性，把他们按照-RGB-的顺序排序-🇳🇱国旗问题）"><a href="#75-颜色排序，每个物体有颜色属性，把他们按照-RGB-的顺序排序-🇳🇱国旗问题）" class="headerlink" title="75 颜色排序，每个物体有颜色属性，把他们按照 RGB 的顺序排序 (🇳🇱国旗问题）"></a>75 颜色排序，每个物体有颜色属性，把他们按照 RGB 的顺序排序 (🇳🇱国旗问题）</h2><p>一种方法是简单地 2 pass 解法，遍历一遍计数再输出。另一种方法是把红色往前交换，蓝色往后交换</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *a; *a = *b; *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> RED = <span class="number">0</span>, GREEN = <span class="number">1</span>, BLUE = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> reds = <span class="number">0</span>,  blues = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= blues; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] == BLUE &amp;&amp; i &lt; blues) swap(&amp;nums[i], &amp;nums[blues--]);</span><br><span class="line">        <span class="keyword">while</span> (nums[i] == RED &amp;&amp; i &gt; reds) swap(&amp;nums[i], &amp;nums[reds++]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>76 跳过</p>
<h2 id="77-给定数字-n-和-k，生成从-n-中取出-k-个数字的所有情况"><a href="#77-给定数字-n-和-k，生成从-n-中取出-k-个数字的所有情况" class="headerlink" title="77 给定数字 n 和 k，生成从 n 中取出 k 个数字的所有情况"></a>77 给定数字 n 和 k，生成从 n 中取出 k 个数字的所有情况</h2><p>数学上的组合，使用回溯来做，对状态空间进行深度搜索。</p>
<p>回溯方法通常适合对状态空间树的深度优先搜索相结合的，当一个解已经不满足条件时，剪枝；<br>如果满足条件，直到找到完全解未知。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合是不要求顺序的</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; k)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">0</span>, k)</span></span>;</span><br><span class="line">    <span class="built_in">combine</span>(result, temp, <span class="number">0</span>, <span class="number">0</span>, n, k);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">combine</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt;&amp; temp, <span class="type">int</span> start, <span class="type">int</span> count, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 回溯条件，找到了一个解</span></span><br><span class="line">    <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 深度优先搜索</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; n; i++) &#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 只搜索比 i 大的即可</span></span><br><span class="line">        <span class="built_in">combine</span>(result, temp, i+ <span class="number">1</span>, count+<span class="number">1</span>, n, k);</span><br><span class="line">        temp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="78-给定一个集合，找到它的所有子集"><a href="#78-给定一个集合，找到它的所有子集" class="headerlink" title="78 给定一个集合，找到它的所有子集"></a>78 给定一个集合，找到它的所有子集</h2><p>这道题至少有 3 种解法：</p>
<ol>
<li>DFS，我们知道对于 n 个元素的集合，有 2^n 个子集，通过每个元素在不在子集中构造一个状态空间树</li>
<li>类似于电话键盘生成字母，迭代</li>
<li>巧妙的利用 1..2^n 对应</li>
</ol>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use backtracking and do a dfs search</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="built_in">subsets</span>(nums, result, temp, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for each solution, the can be divided into two sub solutions: in or out</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">subsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt; temp, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t = temp;</span><br><span class="line">    <span class="built_in">subsets</span>(nums, result, temp, i + <span class="number">1</span>);</span><br><span class="line">    temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">    <span class="built_in">subsets</span>(nums, result, temp, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iterative</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    result.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, nums[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> size = result.<span class="built_in">size</span>(); <span class="comment">// notice the cached size</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> new_subset = result[j];</span><br><span class="line">            new_subset.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">sort</span>(new_subset.<span class="built_in">begin</span>(), new_subset.<span class="built_in">end</span>());</span><br><span class="line">            result.<span class="built_in">push_back</span>(new_subset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tricky</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="type">int</span> size = (<span class="number">1</span> &lt;&lt; nums.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; subset;</span><br><span class="line">        <span class="type">int</span> k = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &amp; <span class="number">0x1</span>)</span><br><span class="line">                subset.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(subset.<span class="built_in">begin</span>(), subset.<span class="built_in">end</span>());</span><br><span class="line">        result.<span class="built_in">push_back</span>(subset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="79-给定一个二维字符数组，查找一个单词是否能够有连续的字母构成，不能交叉"><a href="#79-给定一个二维字符数组，查找一个单词是否能够有连续的字母构成，不能交叉" class="headerlink" title="79 给定一个二维字符数组，查找一个单词是否能够有连续的字母构成，不能交叉"></a>79 给定一个二维字符数组，查找一个单词是否能够有连续的字母构成，不能交叉</h2><p>也是深度优先的做法，首先找到开始的字母，然后依次向上下左右查找，注意还需要统计有没有访问过</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> row = board.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> col = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(row, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; (col, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">findNext</span>(board, word, visited, i, j, <span class="number">0</span>))</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">findNext</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string&amp; word, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == word.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (m &gt;= board.<span class="built_in">size</span>() || n &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || m &lt; <span class="number">0</span> || n &lt; <span class="number">0</span>|| visited[m][n] || board[m][n] != word[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">char</span> temp = board[m][n];</span><br><span class="line">    board[m][n] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> exist = <span class="built_in">findNext</span>(board, word, visited, m + <span class="number">1</span>, n, i+<span class="number">1</span>) ||</span><br><span class="line">        <span class="built_in">findNext</span>(board, word, visited, m - <span class="number">1</span>, n, i+<span class="number">1</span>) ||</span><br><span class="line">        <span class="built_in">findNext</span>(board, word, visited, m, n+<span class="number">1</span>, i+<span class="number">1</span>) ||</span><br><span class="line">        <span class="built_in">findNext</span>(board, word, visited, m, n<span class="number">-1</span>, i+<span class="number">1</span>);</span><br><span class="line">    board[m][n] = temp;</span><br><span class="line">    <span class="keyword">return</span> exist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="80-从排序数组中删除重复元素，但是允许一个元素重复出现两次"><a href="#80-从排序数组中删除重复元素，但是允许一个元素重复出现两次" class="headerlink" title="80 从排序数组中删除重复元素，但是允许一个元素重复出现两次"></a>80 从排序数组中删除重复元素，但是允许一个元素重复出现两次</h2><p>巧妙地解法，和<code>i-2</code>的元素对比</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums || numsSize &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>, counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span> || nums[i] != nums[len<span class="number">-2</span>])</span><br><span class="line">            nums[len++] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="81-在被翻转的数组中查找元素，可能包含重复元素"><a href="#81-在被翻转的数组中查找元素，可能包含重复元素" class="headerlink" title="81 在被翻转的数组中查找元素，可能包含重复元素"></a>81 在被翻转的数组中查找元素，可能包含重复元素</h2><p>经典题目，还是一个二分查找问题，只是要分很多种情况</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//return m in Search in Rotated Array I</span></span><br><span class="line">        <span class="keyword">if</span> (A[left] &lt; A[mid]) &#123; <span class="comment">//left half is sorted</span></span><br><span class="line">            <span class="keyword">if</span> (A[left] &lt;= key &amp;&amp; key &lt; A[mid])</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[left] &gt; A[mid]) &#123; <span class="comment">//right half is sorted</span></span><br><span class="line">            <span class="keyword">if</span> (A[mid] &lt; key &amp;&amp; key &lt;= A[right])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// A[left] == A[mid]</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="82-从已经排序的链表中删除所有重复过的元素，只留下只出现一次的元素"><a href="#82-从已经排序的链表中删除所有重复过的元素，只留下只出现一次的元素" class="headerlink" title="82 从已经排序的链表中删除所有重复过的元素，只留下只出现一次的元素"></a>82 从已经排序的链表中删除所有重复过的元素，只留下只出现一次的元素</h2><p>考察链表操作</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;next &amp;&amp; p-&gt;next-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next-&gt;val == p-&gt;next-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">distinct</span> =</span> p-&gt;next;</span><br><span class="line">            <span class="type">int</span> dup = p-&gt;next-&gt;val;</span><br><span class="line">            <span class="keyword">while</span> (distinct &amp;&amp; distinct-&gt;val == dup) &#123;</span><br><span class="line">                distinct = distinct-&gt;next; <span class="comment">// <span class="doctag">TODO:</span> fix mem leak</span></span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;next = distinct;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="83-从已经排序的链表中删除所有重复过的元素，但是重复过的也留下一个，即，使新链表不重复"><a href="#83-从已经排序的链表中删除所有重复过的元素，但是重复过的也留下一个，即，使新链表不重复" class="headerlink" title="83 从已经排序的链表中删除所有重复过的元素，但是重复过的也留下一个，即，使新链表不重复"></a>83 从已经排序的链表中删除所有重复过的元素，但是重复过的也留下一个，即，使新链表不重复</h2><p>同样是考察链表基本操作</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy; dummy.next = head; dummy.val = head-&gt;val + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val == p-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="type">int</span> dup = p-&gt;val;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;val == dup)</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next; <span class="comment">// <span class="doctag">TODO:</span> fix mem leak</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="84-在柱状图中查找最大的矩形"><a href="#84-在柱状图中查找最大的矩形" class="headerlink" title="84 在柱状图中查找最大的矩形"></a>84 在柱状图中查找最大的矩形</h2><p>见注释</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    height.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="comment">// dummy end</span></span><br><span class="line">    <span class="type">int</span> result  =<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 总结，对于需要查找上一次最大元素的问题，可以考虑使用栈存储</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); ) &#123;</span><br><span class="line">        <span class="comment">// 当遇到更高的柱子时候，先存入堆栈</span></span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() || height[i] &gt; height[stk.<span class="built_in">top</span>()]) <span class="comment">// meet higher</span></span><br><span class="line">            stk.<span class="built_in">push</span>(i++);</span><br><span class="line">        <span class="comment">// 当遇到低一些的柱子时候，计算这些柱子到上一个更矮的柱子之间的最大举行，如果已经清空，说明之前所有柱子都更低</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// lower</span></span><br><span class="line">            <span class="type">int</span> h = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            result = <span class="built_in">max</span>(result, height[h] * (stk.<span class="built_in">empty</span>() ? i : i - stk.<span class="built_in">top</span>() <span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="85-最大的长方形"><a href="#85-最大的长方形" class="headerlink" title="85 最大的长方形"></a>85 最大的长方形</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>** matrix, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!matrix) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left[col], right[col], height[col];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; col; i++)</span><br><span class="line">        left[i] = <span class="number">0</span>, right[i] = col, height[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="type">int</span> cur_left = <span class="number">0</span>, cur_right = col;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)  <span class="comment">// 在第 j 列的高度</span></span><br><span class="line">                height[j]++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                height[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                left[j] = max(left[j], cur_left);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left[j] = <span class="number">0</span>, cur_left = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = col - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                right[j] = min(right[j], cur_right);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right[j] = col, cur_right = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            area = max(area, (right[j] - left[j]) * height[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="86-链表分区，要求把小于某个值得元素全都放到前面"><a href="#86-链表分区，要求把小于某个值得元素全都放到前面" class="headerlink" title="86 链表分区，要求把小于某个值得元素全都放到前面"></a>86 链表分区，要求把小于某个值得元素全都放到前面</h2><p>对于链表这道题很简单，分两个列表在合并就好了，问题是当我们处理类似的数组问题时，也有一种巧妙地 O(n) 的解法</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">partition</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">small</span>, *<span class="title">psmall</span> =</span> &amp;small; <span class="comment">// double dummy head</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">big</span>, *<span class="title">pbig</span> =</span> &amp;big;</span><br><span class="line">    psmall-&gt;next = pbig-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val &lt; x) &#123;</span><br><span class="line">            psmall-&gt;next = head;</span><br><span class="line">            psmall = psmall-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pbig-&gt;next = head;</span><br><span class="line">            pbig = pbig-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    psmall-&gt;next = big.next;</span><br><span class="line">    pbig-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> small.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="87-把字符串分区后，交换得到的字符串"><a href="#87-把字符串分区后，交换得到的字符串" class="headerlink" title="87 把字符串分区后，交换得到的字符串"></a>87 把字符串分区后，交换得到的字符串</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isScramble</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s1==s2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先判断字符是否一致</span></span><br><span class="line">    <span class="type">int</span> len = s1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> count[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">        count[s1[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        count[s2[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(count[i]!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(<span class="number">0</span>,i), s2.<span class="built_in">substr</span>(<span class="number">0</span>,i)) &amp;&amp; <span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(i), s2.<span class="built_in">substr</span>(i)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(<span class="number">0</span>,i), s2.<span class="built_in">substr</span>(len-i)) &amp;&amp; <span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(i), s2.<span class="built_in">substr</span>(<span class="number">0</span>,len-i)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="88-合并已排序数组，要求合并到其中一个空间较大的数组中"><a href="#88-合并已排序数组，要求合并到其中一个空间较大的数组中" class="headerlink" title="88 合并已排序数组，要求合并到其中一个空间较大的数组中"></a>88 合并已排序数组，要求合并到其中一个空间较大的数组中</h2><p>对于这种要求 in-place 的算法，从后往前往往可以解决</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* nums1, <span class="type">int</span> m, <span class="type">int</span>* nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = m + n - <span class="number">1</span>;</span><br><span class="line">    m--, n--;</span><br><span class="line">    <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[m] &gt; nums2[n]) &#123;</span><br><span class="line">            nums1[len--] = nums1[m--];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[len--] = nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[n] = nums2[n];</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="89-生成格雷码-Gray-Code"><a href="#89-生成格雷码-Gray-Code" class="headerlink" title="89 生成格雷码 (Gray Code)"></a>89 生成格雷码 (Gray Code)</h2><p>记住格雷码的生成规则</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>((i &gt;&gt; <span class="number">1</span>) ^ i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="90-由给定元素生成子集，可能包含重复元素"><a href="#90-由给定元素生成子集，可能包含重复元素" class="headerlink" title="90 由给定元素生成子集，可能包含重复元素"></a>90 由给定元素生成子集，可能包含重复元素</h2><p>使用了和手机键盘生成字符串号码类似的迭代算法，注意其中对重复元素的处理，当然也可以用 DFS 来做</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; sets;</span><br><span class="line">    sets.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 处理包含重复元素的一半需要预排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ) &#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// dup count</span></span><br><span class="line">        <span class="keyword">while</span> (count + i &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[count+i] == nums[i])</span><br><span class="line">            count++;</span><br><span class="line">        <span class="type">int</span> prev_n = sets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; prev_n; j++) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; instance = sets[j];</span><br><span class="line">            <span class="comment">// put dup element `count` times</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; count; k++) &#123;</span><br><span class="line">                instance.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                sets.<span class="built_in">push_back</span>(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i += count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="91-给定一个数组只包含-1-9，可以用-1-26-代表字母，求出从其中能都得到多少字符串"><a href="#91-给定一个数组只包含-1-9，可以用-1-26-代表字母，求出从其中能都得到多少字符串" class="headerlink" title="91 给定一个数组只包含 1-9，可以用 1-26 代表字母，求出从其中能都得到多少字符串"></a>91 给定一个数组只包含 1-9，可以用 1-26 代表字母，求出从其中能都得到多少字符串</h2><p>使用动态规划，但是注意其中 0 的处理，很玄妙</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s || <span class="built_in">strlen</span>(s) == <span class="number">0</span> || s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r1 = <span class="number">1</span>, r2 = <span class="number">1</span>; <span class="comment">// r1: 前一个字符， r2：前两个字符</span></span><br><span class="line">    <span class="type">char</span>* p = s++; <span class="comment">// 上一个字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">             r1 = <span class="number">0</span>; <span class="comment">// 0 不能单独构成字母</span></span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="string">&#x27;1&#x27;</span> || *p == <span class="string">&#x27;2&#x27;</span> &amp;&amp; *s &lt; <span class="string">&#x27;7&#x27;</span>) &#123; <span class="comment">// 形成两种可能</span></span><br><span class="line">            <span class="type">int</span> t = r1;</span><br><span class="line">            r1 = r2 + r1;</span><br><span class="line">            r2 = t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r2 = r1; <span class="comment">// 新加入的数字只能单独构成字母</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="92-在给定区间上翻转数组"><a href="#92-在给定区间上翻转数组" class="headerlink" title="92 在给定区间上翻转数组"></a>92 在给定区间上翻转数组</h2><p>同样是数组操作细节题</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseBetween</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m == n) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy, * small_node, * big_node; <span class="comment">// actually the prev ones</span></span><br><span class="line">    dummy.next = head;</span><br><span class="line">    n -= m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--m) <span class="comment">// m starts from 1, so not m--</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">start</span> =</span> p-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> start-&gt;next;</span><br><span class="line">        start-&gt;next = next-&gt;next;</span><br><span class="line">        next-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="93-恢复-IP-地址，给定一个字符串，适当插入点，一共有多少种方式构成-IP-地址"><a href="#93-恢复-IP-地址，给定一个字符串，适当插入点，一共有多少种方式构成-IP-地址" class="headerlink" title="93 恢复 IP 地址，给定一个字符串，适当插入点，一共有多少种方式构成 IP 地址"></a>93 恢复 IP 地址，给定一个字符串，适当插入点，一共有多少种方式构成 IP 地址</h2><p>又是一道 DFS 的题，注意对于字符串问题如何处理</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="built_in">restore</span>(result, s, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">restore</span><span class="params">(vector&lt;string&gt;&amp; result, string&amp; s, string restored, <span class="type">int</span> start, <span class="type">int</span> dots)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dots &gt; <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (dots == <span class="number">4</span> &amp;&amp; start == s.<span class="built_in">size</span>())</span><br><span class="line">        result.<span class="built_in">push_back</span>(restored);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start + i &gt; s.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        string part = s.<span class="built_in">substr</span>(start, i);</span><br><span class="line">        <span class="keyword">if</span> (part[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; part.<span class="built_in">size</span>() &gt; <span class="number">1</span> || i == <span class="number">3</span> &amp;&amp; <span class="built_in">stoi</span>(part) &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">restore</span>(result, s, restored + part + (dots==<span class="number">3</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;.&quot;</span>), start + i, dots + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="94-中序遍历二叉树"><a href="#94-中序遍历二叉树" class="headerlink" title="94 中序遍历二叉树"></a>94 中序遍历二叉树</h2><p>当然是使用栈了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    TreeNode* current = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() || current) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(current);</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(current-&gt;val);</span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>递归解法</p>
<details>
    <summary>go 解答</summary>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    left := inorderTraversal(root.Left)</span><br><span class="line">    right := inorderTraversal(root.Right)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(<span class="built_in">append</span>(left, root.Val), right...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="95-生成二叉树，同下题一样"><a href="#95-生成二叉树，同下题一样" class="headerlink" title="95 生成二叉树，同下题一样"></a>95 生成二叉树，同下题一样</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gen</span>(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">gen</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    vector&lt;TreeNode*&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> leftTrees = <span class="built_in">gen</span>(start, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> rightTrees = <span class="built_in">gen</span>(i + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; l : leftTrees) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : rightTrees) &#123;</span><br><span class="line">                <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                root-&gt;left = l;</span><br><span class="line">                root-&gt;right = r;</span><br><span class="line">                result.<span class="built_in">push_back</span>(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="96-给定数字-n，从-1-到-n-作为节点有多少种方式生成二叉树"><a href="#96-给定数字-n，从-1-到-n-作为节点有多少种方式生成二叉树" class="headerlink" title="96 给定数字 n，从 1 到 n 作为节点有多少种方式生成二叉树"></a>96 给定数字 n，从 1 到 n 作为节点有多少种方式生成二叉树</h2><p>这道题看似是树，实际上是一个动态规划问题。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* dp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) <span class="comment">// 依次选取第 k 个点作为根</span></span><br><span class="line">            num += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">        dp[i] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="97-给定两个字符串交叉是否能够构成第三个字符串"><a href="#97-给定两个字符串交叉是否能够构成第三个字符串" class="headerlink" title="97 给定两个字符串交叉是否能够构成第三个字符串"></a>97 给定两个字符串交叉是否能够构成第三个字符串</h2><p>这道题是一道二维的 DP 问题，因为需要对于每个字符串的每个位置用另一个字符串尝试匹配</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isInterleave</span><span class="params">(<span class="type">char</span>* s1, <span class="type">char</span>* s2, <span class="type">char</span>* s3)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l1 = <span class="built_in">strlen</span>(s1), l2 = <span class="built_in">strlen</span>(s2), l3 = <span class="built_in">strlen</span>(s3);</span><br><span class="line">    <span class="keyword">if</span> (l1 + l2 != l3) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 在 i+j 位置 s1[i] s2[j] 是否能够构成 s[i+j]</span></span><br><span class="line">    <span class="type">bool</span>** dp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>*) * (l1 + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= l1; i++)</span><br><span class="line">        dp[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * (l2 + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= l1; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= l2; j++)</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = (dp[i][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>]); <span class="comment">// 注意：赋值的优先级更高</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = (dp[i<span class="number">-1</span>][j] &amp;&amp; s1[i<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = (dp[i<span class="number">-1</span>][j] &amp;&amp; s1[i<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>] || dp[i][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[l1][l2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="98-验证二叉搜索树是否合法"><a href="#98-验证二叉搜索树是否合法" class="headerlink" title="98 验证二叉搜索树是否合法"></a>98 验证二叉搜索树是否合法</h2><p>先序遍历即可</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">valid</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">long</span> left, <span class="type">long</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="literal">NULL</span> || root-&gt;val &gt; left &amp;&amp; root-&gt;val &lt; right &amp;&amp;</span><br><span class="line">        valid(root-&gt;left, left, root-&gt;val) &amp;&amp;</span><br><span class="line">        valid(root-&gt;right, root-&gt;val, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValidBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> valid(root, INT_MIN - <span class="number">1l</span>, INT_MAX + <span class="number">1l</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="99-在二叉搜索树中有两个节点被调换了，找出这两个节点，并恢复该二叉树"><a href="#99-在二叉搜索树中有两个节点被调换了，找出这两个节点，并恢复该二叉树" class="headerlink" title="99 在二叉搜索树中有两个节点被调换了，找出这两个节点，并恢复该二叉树"></a>99 在二叉搜索树中有两个节点被调换了，找出这两个节点，并恢复该二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">first</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">second</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    traverse(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (prev &amp;&amp; prev-&gt;val &gt; root-&gt;val) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!first) first = prev;</span><br><span class="line">         second = root;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = root;</span><br><span class="line">    traverse(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recoverTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    prev = first = second = <span class="literal">NULL</span>;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">if</span> (!first) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> temp = first-&gt;val;</span><br><span class="line">    first-&gt;val = second-&gt;val;</span><br><span class="line">    second-&gt;val = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="100-判断是否是相同的树"><a href="#100-判断是否是相同的树" class="headerlink" title="100 判断是否是相同的树"></a>100 判断是否是相同的树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isSameTree</span><span class="params">(<span class="keyword">struct</span> TreeNode *p, <span class="keyword">struct</span> TreeNode *q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p == q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val</span><br><span class="line">            &amp;&amp; isSameTree(p-&gt;left, q-&gt;left)</span><br><span class="line">            &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="101-判断是不是左右对称的树"><a href="#101-判断是不是左右对称的树" class="headerlink" title="101 判断是不是左右对称的树"></a>101 判断是不是左右对称的树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">sym</span><span class="params">(<span class="keyword">struct</span> TreeNode* left, <span class="keyword">struct</span> TreeNode* right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; !right || !left &amp;&amp; right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> !left &amp;&amp; !right ||</span><br><span class="line">        left-&gt;val == right-&gt;val &amp;&amp;</span><br><span class="line">        sym(left-&gt;left, right-&gt;right) &amp;&amp;</span><br><span class="line">        sym(right-&gt;left, left-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSymmetric</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> sym(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="102-二叉树层序遍历"><a href="#102-二叉树层序遍历" class="headerlink" title="102 二叉树层序遍历"></a>102 二叉树层序遍历</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    vector&lt;TreeNode*&gt; current, next;</span><br><span class="line">    current.<span class="built_in">push_back</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!current.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        next.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; current.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;left)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;right)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;right);</span><br><span class="line">            vals.<span class="built_in">push_back</span>(current[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(vals);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="103-二叉树-ZigZag-层序遍历"><a href="#103-二叉树-ZigZag-层序遍历" class="headerlink" title="103 二叉树 ZigZag 层序遍历"></a>103 二叉树 ZigZag 层序遍历</h2><p>这道题更好的做法是使用一个栈，从而使得每行的顺序都是上一行的翻转</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    vector&lt;TreeNode*&gt; current, next;</span><br><span class="line">    current.<span class="built_in">push_back</span>(root);</span><br><span class="line">    <span class="type">bool</span> odd = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!current.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        next.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; current.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;left)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;right)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;right);</span><br><span class="line">            vals.<span class="built_in">push_back</span>(current[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!odd) <span class="built_in">reverse</span>(vals.<span class="built_in">begin</span>(), vals.<span class="built_in">end</span>());</span><br><span class="line">        odd = !odd;</span><br><span class="line">        result.<span class="built_in">push_back</span>(vals);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="104-树的最大深度"><a href="#104-树的最大深度" class="headerlink" title="104 树的最大深度"></a>104 树的最大深度</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = maxDepth(root-&gt;left), right = maxDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> (left &gt; right ?left : right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="105-从前序遍历和中序遍历生成生二叉树"><a href="#105-从前序遍历和中序遍历生成生二叉树" class="headerlink" title="105 从前序遍历和中序遍历生成生二叉树"></a>105 从前序遍历和中序遍历生成生二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">build</span><span class="params">(<span class="type">int</span>* prestart, <span class="type">int</span>* preend, <span class="type">int</span>* instart, <span class="type">int</span>* inend)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    root-&gt;val = *prestart;</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prestart == preend)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* root_inorder = instart;</span><br><span class="line">    <span class="keyword">while</span> (root_inorder &lt;= inend &amp;&amp; *root_inorder != *prestart)</span><br><span class="line">        root_inorder++;</span><br><span class="line">    <span class="type">int</span> left_len = root_inorder - instart;</span><br><span class="line">    <span class="type">int</span> right_len = inend - root_inorder;</span><br><span class="line">    <span class="keyword">if</span> (left_len &gt; <span class="number">0</span>)</span><br><span class="line">        root-&gt;left = build(prestart + <span class="number">1</span>, prestart + left_len, instart, root_inorder - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (right_len &gt; <span class="number">0</span>)</span><br><span class="line">        root-&gt;right = build(prestart + left_len + <span class="number">1</span>, preend, root_inorder + <span class="number">1</span>, inend);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// m always equals n, otherwise it&#x27;s bad input</span></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>* preorder, <span class="type">int</span> m, <span class="type">int</span>* inorder, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> build(preorder, preorder + n - <span class="number">1</span>, inorder, inorder + n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="106-从中序遍历和后序遍历生成二叉树"><a href="#106-从中序遍历和后序遍历生成二叉树" class="headerlink" title="106 从中序遍历和后序遍历生成二叉树"></a>106 从中序遍历和后序遍历生成二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">build</span><span class="params">(<span class="type">int</span>* instart, <span class="type">int</span>* inend, <span class="type">int</span>* poststart, <span class="type">int</span>* postend)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    root-&gt;val = *postend;</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (poststart == postend)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* root_inorder = instart;</span><br><span class="line">    <span class="keyword">while</span> (root_inorder &lt;= inend &amp;&amp; *root_inorder != *postend)</span><br><span class="line">        root_inorder++;</span><br><span class="line">    <span class="type">int</span> left_len = root_inorder - instart;</span><br><span class="line">    <span class="type">int</span> right_len = inend - root_inorder;</span><br><span class="line">    <span class="keyword">if</span> (left_len &gt; <span class="number">0</span>)</span><br><span class="line">        root-&gt;left = build(instart, root_inorder - <span class="number">1</span>, poststart, poststart + left_len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (right_len &gt; <span class="number">0</span>)</span><br><span class="line">        root-&gt;right = build(root_inorder + <span class="number">1</span>, inend, poststart + left_len, postend - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>* inorder, <span class="type">int</span> m, <span class="type">int</span>* postorder, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> build(inorder, inorder + n - <span class="number">1</span>, postorder, postorder +n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="107-二叉树层序遍历，但要生成翻转的遍历序列"><a href="#107-二叉树层序遍历，但要生成翻转的遍历序列" class="headerlink" title="107 二叉树层序遍历，但要生成翻转的遍历序列"></a>107 二叉树层序遍历，但要生成翻转的遍历序列</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    vector&lt;TreeNode*&gt; current, next;</span><br><span class="line">    current.<span class="built_in">push_back</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!current.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        next.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; current.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;left)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;right)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;right);</span><br><span class="line">            vals.<span class="built_in">push_back</span>(current[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(vals);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="108-把排序数组转化为二叉树"><a href="#108-把排序数组转化为二叉树" class="headerlink" title="108 把排序数组转化为二叉树"></a>108 把排序数组转化为二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> TreeNode* <span class="title function_">bst</span><span class="params">(<span class="type">int</span>* left, <span class="type">int</span>* right)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    root-&gt;val = *mid;</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; mid)</span><br><span class="line">        root-&gt;left = bst(left, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; right)</span><br><span class="line">        root-&gt;right = bst(mid+<span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> bst(nums, nums + n <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="109-把排序列表转化为二叉树"><a href="#109-把排序列表转化为二叉树" class="headerlink" title="109 把排序列表转化为二叉树"></a>109 把排序列表转化为二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">list</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">len</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head)</span><br><span class="line">        head = head-&gt;next, l++;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">bst</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    root-&gt;left = bst(n/<span class="number">2</span>);</span><br><span class="line">    root-&gt;val = <span class="built_in">list</span>-&gt;val;</span><br><span class="line">    <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    root-&gt;right = bst(n - n / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">sortedListToBST</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span> = head;</span><br><span class="line">    <span class="keyword">return</span> bst(len(head));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110 平衡二叉树"></a>110 平衡二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">height</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = height(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> right = height(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right + <span class="number">1</span> || right &gt; left + <span class="number">1</span> || left == <span class="number">-1</span> || right == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (left &gt; right ? left : right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isBalanced</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> height(root) != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="111-二叉树最小高度"><a href="#111-二叉树最小高度" class="headerlink" title="111 二叉树最小高度"></a>111 二叉树最小高度</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = minDepth(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> right = minDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (!right) <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!left) <span class="keyword">return</span> right + <span class="number">1</span>; <span class="comment">// tricky here, 当有空节点时，不能返回 0，而是返回另一个值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (left &lt; right ? left : right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="112-二叉树中是否存在和为某个数的路径"><a href="#112-二叉树中是否存在和为某个数的路径" class="headerlink" title="112 二叉树中是否存在和为某个数的路径"></a>112 二叉树中是否存在和为某个数的路径</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">hasPathSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> sum == root-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val) ||</span><br><span class="line">        hasPathSum(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="113-接上题，把这个路径找出来"><a href="#113-接上题，把这个路径找出来" class="headerlink" title="113 接上题，把这个路径找出来"></a>113 接上题，把这个路径找出来</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> sum) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">getPaths</span>(result, path, root, sum);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPaths</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt; path, TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == root-&gt;val) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getPaths</span>(result, path, root-&gt;left, sum - root-&gt;val);</span><br><span class="line">    <span class="built_in">getPaths</span>(result, path, root-&gt;right, sum - root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="114-把二叉树扁平成列表"><a href="#114-把二叉树扁平成列表" class="headerlink" title="114 把二叉树扁平成列表"></a>114 把二叉树扁平成列表</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* prev;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">flatten</span>(root-&gt;right);</span><br><span class="line">    <span class="built_in">flatten</span>(root-&gt;left);</span><br><span class="line">    root-&gt;right = prev;</span><br><span class="line">    root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    prev = root; <span class="comment">// last flattened element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="115-通过删掉一些字母得到子序列，问有多少种方法能够得到子序列呢"><a href="#115-通过删掉一些字母得到子序列，问有多少种方法能够得到子序列呢" class="headerlink" title="115 通过删掉一些字母得到子序列，问有多少种方法能够得到子序列呢"></a>115 通过删掉一些字母得到子序列，问有多少种方法能够得到子序列呢</h2><p>使用 DP，</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution (DP):</span></span><br><span class="line"><span class="comment"> * 我们扫描字符串 s</span></span><br><span class="line"><span class="comment"> * Path[i][j] 代表 T.substr(1...i) 在 S(1...j) 不同的子序列的数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Path[i][j] = Path[i][j-1]            (discard S[j])</span></span><br><span class="line"><span class="comment"> *              +     Path[i-1][j-1]    (S[j] == T[i] and we are going to use S[j])</span></span><br><span class="line"><span class="comment"> *                 or 0                 (S[j] != T[i] so we could not use S[j])</span></span><br><span class="line"><span class="comment"> * while Path[0][j] = 1 and Path[i][0] = 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">path</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            path[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="comment">// S</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="comment">// T</span></span><br><span class="line">                path[i][j] = path[i][j<span class="number">-1</span>] + (t[i<span class="number">-1</span>] == s[j<span class="number">-1</span>] ? path[i<span class="number">-1</span>][j<span class="number">-1</span>] : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> path[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="116-完全二叉树中把每个节点指向他这一层的右面的节点"><a href="#116-完全二叉树中把每个节点指向他这一层的右面的节点" class="headerlink" title="116 完全二叉树中把每个节点指向他这一层的右面的节点"></a>116 完全二叉树中把每个节点指向他这一层的右面的节点</h2><p>显然左节点的下一个节点是父节点的右节点，右节点的下一个节点是父节点下一个节点的左节点。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">connect</span><span class="params">(<span class="keyword">struct</span> TreeLinkNode *root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        root-&gt;right-&gt;next = root-&gt;next ? root-&gt;next-&gt;left : <span class="literal">NULL</span>;</span><br><span class="line">    connect(root-&gt;left);</span><br><span class="line">    connect(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="117-同上题，但是是任意的🌲"><a href="#117-同上题，但是是任意的🌲" class="headerlink" title="117 同上题，但是是任意的🌲"></a>117 同上题，但是是任意的🌲</h2><p>通过上一层已经被连接的 next 指针，顺序层序访问，从而连接下一层。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">connect</span><span class="params">(<span class="keyword">struct</span> TreeLinkNode *root)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span>* <span class="title">head</span> =</span> root, * prev = <span class="literal">NULL</span>, *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123; <span class="comment">// head 是每层的开始</span></span><br><span class="line">        p = head;</span><br><span class="line">        prev = head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev)</span><br><span class="line">                    prev-&gt;next = p-&gt;left;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    head = p-&gt;left;</span><br><span class="line">                prev = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev)</span><br><span class="line">                    prev-&gt;next = p-&gt;right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    head = p-&gt;right;</span><br><span class="line">                prev = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118 杨辉三角"></a>118 杨辉三角</h2><p>注意坐标关系，不要被骗了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">result</span>(n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result[i].<span class="built_in">resize</span>(i+<span class="number">1</span>);</span><br><span class="line">        result[i][<span class="number">0</span>] = result[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            result[i][j] = result[i<span class="number">-1</span>][j<span class="number">-1</span>] + result[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="119-返回杨辉三角的第-k-行"><a href="#119-返回杨辉三角的第-k-行" class="headerlink" title="119 返回杨辉三角的第 k 行"></a>119 返回杨辉三角的第 k 行</h2><p>要求只能使用 O(k) 的额外空间，比较蛋疼的是这里的 k 是从 0 计数的。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">    rowIndex++;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; row;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rowIndex; i++) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newRow</span><span class="params">(i+<span class="number">1</span>)</span></span>;</span><br><span class="line">        newRow[<span class="number">0</span>] = newRow[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            newRow[j] = row[j<span class="number">-1</span>] + row[j];</span><br><span class="line">        <span class="built_in">swap</span>(row, newRow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="120-给定一个类似杨辉三角形状的数组，求从顶部到底部的最短路径"><a href="#120-给定一个类似杨辉三角形状的数组，求从顶部到底部的最短路径" class="headerlink" title="120 给定一个类似杨辉三角形状的数组，求从顶部到底部的最短路径"></a>120 给定一个类似杨辉三角形状的数组，求从顶部到底部的最短路径</h2><p>显然是使用 DP，但是有一个问题，如果是 top down 的话，最后还需要遍历一下，而如果是 bottom up 就只需要返回 dp[0] 就好了。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(triangle.back())</span></span>; <span class="comment">// 复制最后一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> layer = triangle.<span class="built_in">size</span>() - <span class="number">2</span>; layer &gt;= <span class="number">0</span>; layer--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= layer; i++)</span><br><span class="line">            dp[i] = triangle[layer][i] + <span class="built_in">min</span>(dp[i], dp[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="121-买卖股票最佳时机，只能交易一次"><a href="#121-买卖股票最佳时机，只能交易一次" class="headerlink" title="121 买卖股票最佳时机，只能交易一次"></a>121 买卖股票最佳时机，只能交易一次</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pricesSize &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> profit = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 从前到后依次遍历，如果有更好的收益更新，或者更新 min，限制条件是先出现最小值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pricesSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; min) &#123;</span><br><span class="line">                profit = max(profit, prices[i] - min);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            min = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="122-买卖股票的最佳时机，可以做任意多比交易"><a href="#122-买卖股票的最佳时机，可以做任意多比交易" class="headerlink" title="122 买卖股票的最佳时机，可以做任意多比交易"></a>122 买卖股票的最佳时机，可以做任意多比交易</h2><p>有两种解法，一种是不断做交易，完全不考虑交易次数，这种做法不符合实际情况。<br>另一种做法是模拟交易，这样会生成最少的交易次数，结果也是对的。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span></span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; pricesSize<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (prices[i+<span class="number">1</span>]&gt;prices[i])</span><br><span class="line">            total += prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!prices) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> profit = <span class="number">0</span>;<span class="type">bool</span> buy = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> min = prices[<span class="number">0</span>], max = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pricesSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; min &amp;&amp; buy) &#123;</span><br><span class="line">            min = prices[i];</span><br><span class="line">            max = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; min &amp;&amp; buy)</span><br><span class="line">            buy = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; max &amp;&amp; !buy)</span><br><span class="line">            max = prices[i];</span><br><span class="line">        <span class="keyword">if</span> ((prices[i] &lt; max || i == pricesSize - <span class="number">1</span>) &amp;&amp; !buy)&#123;</span><br><span class="line">            profit += max - min;</span><br><span class="line">            min = prices[i];</span><br><span class="line">            max = prices[i];</span><br><span class="line">            buy = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="123-股票交易，限制只能交易两股"><a href="#123-股票交易，限制只能交易两股" class="headerlink" title="123 股票交易，限制只能交易两股"></a>123 股票交易，限制只能交易两股</h2><p>每次求解的是：卖出两股以后的最大值，刚刚买入第二股的最大值，卖出第一股时候的最大值，买入第一股时候的最大值。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> hold1 = INT_MIN, hold2 = INT_MIN;</span><br><span class="line">    <span class="type">int</span> release1 = <span class="number">0</span>, release2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : prices) &#123;</span><br><span class="line">        release2 = <span class="built_in">max</span>(release2, hold2 + i);</span><br><span class="line">        hold2 = <span class="built_in">max</span>(hold2, release1 - i);</span><br><span class="line">        release1 = <span class="built_in">max</span>(release1, hold1 + i);</span><br><span class="line">        hold1 = <span class="built_in">max</span>(hold1, -i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> release2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="124-二叉树路径最大和，路径可以从任意一个节点开始到任意一个节点结束"><a href="#124-二叉树路径最大和，路径可以从任意一个节点开始到任意一个节点结束" class="headerlink" title="124 二叉树路径最大和，路径可以从任意一个节点开始到任意一个节点结束"></a>124 二叉树路径最大和，路径可以从任意一个节点开始到任意一个节点结束</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">doSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* sum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = max(<span class="number">0</span>, doSum(root-&gt;left, sum));</span><br><span class="line">    <span class="type">int</span> right = max(<span class="number">0</span>, doSum(root-&gt;right, sum));</span><br><span class="line">    *sum = max(*sum, left+right+root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> max(left, right) + root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = INT_MIN;</span><br><span class="line">    doSum(root, &amp;sum);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>这道题是把最终答案放在了全局变量中，并采用了辅助函数的方法。全局变量中存储两条路径的和，<br>而返回值中存储当前子树中最长的单边。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.ans = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_maxPathSum</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 注意这里要取 max，以防添加了负路径</span></span><br><span class="line">        left = <span class="built_in">max</span>(<span class="number">0</span>, self._maxPathSum(root.left))</span><br><span class="line">        right = <span class="built_in">max</span>(<span class="number">0</span>, self._maxPathSum(root.right))</span><br><span class="line">        self.ans = <span class="built_in">max</span>(self.ans, left + right + root.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + root.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPathSum</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        self._maxPathSum(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
</details>



<h2 id="125-给定一个字符串，只考虑字母和数字，忽略大小写，判断是否是回文字符串"><a href="#125-给定一个字符串，只考虑字母和数字，忽略大小写，判断是否是回文字符串" class="headerlink" title="125 给定一个字符串，只考虑字母和数字，忽略大小写，判断是否是回文字符串"></a>125 给定一个字符串，只考虑字母和数字，忽略大小写，判断是否是回文字符串</h2><p>太简单了，没啥可说的</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">char</span> l = s[left], r = s[right];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalnum</span>(l) &amp;&amp; <span class="built_in">isalnum</span>(r)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(l) != <span class="built_in">tolower</span>(r))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            left++, right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(l))</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(r))</span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="127-单词梯子"><a href="#127-单词梯子" class="headerlink" title="127 单词梯子"></a>127 单词梯子</h2><p>给定梯子，和开始单词和结束单词，最少需要多少个中间单词，才能变化过去，每次只能变化一个字母</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, unordered_set&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;string&gt; beginSet, endSet, *set1, * set2;</span><br><span class="line">    beginSet.<span class="built_in">insert</span>(beginWord);</span><br><span class="line">    endSet.<span class="built_in">insert</span>(endWord);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dist = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (!beginSet.<span class="built_in">empty</span>() &amp;&amp; !endSet.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beginSet.<span class="built_in">size</span>() &lt; endSet.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            set1 = &amp;beginSet;</span><br><span class="line">            set2 = &amp;endSet;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set1 = &amp;endSet;</span><br><span class="line">            set2 = &amp;beginSet;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;string&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word : *set1) &#123; <span class="comment">// notice word in not ref</span></span><br><span class="line">            wordList.<span class="built_in">erase</span>(word);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; letter : word) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                    <span class="type">char</span> oldLetter = letter;</span><br><span class="line">                    letter = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">                    <span class="keyword">if</span> (set2-&gt;<span class="built_in">find</span>(word) != set2-&gt;<span class="built_in">end</span>())</span><br><span class="line">                        <span class="keyword">return</span> dist;</span><br><span class="line">                    <span class="keyword">if</span> (wordList.<span class="built_in">find</span>(word) != wordList.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        temp.<span class="built_in">insert</span>(word);</span><br><span class="line">                        wordList.<span class="built_in">erase</span>(word);</span><br><span class="line">                    &#125;</span><br><span class="line">                    letter = oldLetter;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dist++;</span><br><span class="line">        <span class="built_in">swap</span>(*set1, temp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="128-最长递增子序列"><a href="#128-最长递增子序列" class="headerlink" title="128 最长递增子序列"></a>128 最长递增子序列</h2><p>使用动态规划</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash; <span class="comment">// 每个元素和它们所在序列的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">find</span>(n) == hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 查找两边的元素，如果找到，把新元素合并进去</span></span><br><span class="line">            <span class="type">int</span> left = hash.<span class="built_in">find</span>(n<span class="number">-1</span>) != hash.<span class="built_in">end</span>() ? hash[n<span class="number">-1</span>] : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> right = hash.<span class="built_in">find</span>(n+<span class="number">1</span>) != hash.<span class="built_in">end</span>() ? hash[n+<span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = left + right + <span class="number">1</span>;</span><br><span class="line">            hash[n] = hash[n-left] = hash[n+right] = sum; <span class="comment">// 注意此处的更新，并不需要更新区间内的每个值，只需要更新边界即可</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="129-二叉树中只有-0-9-找出所有根节点到子节点的和"><a href="#129-二叉树中只有-0-9-找出所有根节点到子节点的和" class="headerlink" title="129 二叉树中只有 0-9 找出所有根节点到子节点的和"></a>129 二叉树中只有 0-9 找出所有根节点到子节点的和</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">10</span> + root-&gt;val;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        val += sum(root-&gt;left, x * <span class="number">10</span> + root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        val += sum(root-&gt;right, x * <span class="number">10</span> + root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> sum(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="130-把所有被包围的-O-置为-X"><a href="#130-把所有被包围的-O-置为-X" class="headerlink" title="130 把所有被包围的 O 置为 X"></a>130 把所有被包围的 O 置为 X</h2><p>使用并查集</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; m_father, m_rank;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n): <span class="built_in">m_father</span>(n), <span class="built_in">m_rank</span>(n, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_father.<span class="built_in">size</span>(); i++)</span><br><span class="line">            m_father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != m_father[x])</span><br><span class="line">            m_father[x] = <span class="built_in">find</span>(m_father[x]);</span><br><span class="line">        <span class="keyword">return</span> m_father[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_rank[x] &gt; m_rank[y]) &#123;</span><br><span class="line">            m_father[y] = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_rank[x] == m_rank[y])</span><br><span class="line">                m_rank[y]++;</span><br><span class="line">            m_father[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(n*m+<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i == <span class="number">0</span> || j == <span class="number">0</span> || i == n<span class="number">-1</span> || j == m<span class="number">-1</span>) &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                    uf.<span class="built_in">unionify</span>(i * m + j, n * m);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (board[i<span class="number">-1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.<span class="built_in">unionify</span>(i * m + j, (i - <span class="number">1</span>) * m + j);</span><br><span class="line">                    <span class="keyword">if</span> (board[i+<span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.<span class="built_in">unionify</span>(i*m+j, (i+<span class="number">1</span>)*m+j);</span><br><span class="line">                    <span class="keyword">if</span> (board[i][j<span class="number">-1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.<span class="built_in">unionify</span>(i*m+j, i*m+j<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (board[i][j+<span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.<span class="built_in">unionify</span>(i*m+j, i*m+j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (uf.<span class="built_in">find</span>(i*m+j) != uf.<span class="built_in">find</span>(n*m))</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="131-对字符串分组，是的每个字串都是回文，返回所有可能的分组"><a href="#131-对字符串分组，是的每个字串都是回文，返回所有可能的分组" class="headerlink" title="131 对字符串分组，是的每个字串都是回文，返回所有可能的分组"></a>131 对字符串分组，是的每个字串都是回文，返回所有可能的分组</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    vector&lt;string&gt; group;</span><br><span class="line">    <span class="built_in">dfs</span>(result, s, group, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; result, <span class="type">const</span> string&amp; s, vector&lt;string&gt;&amp; group, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(group);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, start, i)) &#123;</span><br><span class="line">            group.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(start, i - start + <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">dfs</span>(result, s, group, i + <span class="number">1</span>);</span><br><span class="line">            group.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[left++] != s[right--])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="132-如上题，找出最少需要分组几次"><a href="#132-如上题，找出最少需要分组几次" class="headerlink" title="132 如上题，找出最少需要分组几次"></a>132 如上题，找出最少需要分组几次</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCut</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cut</span><span class="params">(s.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>() + <span class="number">1</span>; i++)</span><br><span class="line">        cut[i] = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; i - j &gt;= <span class="number">0</span> &amp;&amp; i + j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i+j] == s[i-j]; j++)</span><br><span class="line">            cut[i+j+<span class="number">1</span>] = <span class="built_in">min</span>(cut[i+j+<span class="number">1</span>], cut[i-j] + <span class="number">1</span>); <span class="comment">// i-j -&gt; i+j 是 palindrome，所以只需要 cut[i-j] 在加上这一段就好了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; i - j + <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i + j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i+j] == s[i-j+<span class="number">1</span>]; j++)</span><br><span class="line">            cut[i+j+<span class="number">1</span>] = <span class="built_in">min</span>(cut[i+j+<span class="number">1</span>], cut[i - j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cut[s.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="133-复制有向图"><a href="#133-复制有向图" class="headerlink" title="133 复制有向图"></a>133 复制有向图</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; hash; <span class="comment">// old -&gt; new pair</span></span><br><span class="line"><span class="function">UndirectedGraphNode *<span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (hash.<span class="built_in">find</span>(node) == hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        hash[node] = <span class="keyword">new</span> <span class="built_in">UndirectedGraphNode</span>(node-&gt;label);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : node-&gt;neighbors)</span><br><span class="line">            hash[node]-&gt;neighbors.<span class="built_in">push_back</span>(<span class="built_in">cloneGraph</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134 加油站"></a>134 加油站</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>* gas, <span class="type">int</span> gasSize, <span class="type">int</span>* cost, <span class="type">int</span> costSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; gasSize; ++i) &#123;</span><br><span class="line">        sum += gas[i] - cost[i]; <span class="comment">// 从此处经过能够净增多少汽油</span></span><br><span class="line">        total += gas[i] - cost[i]; <span class="comment">// 记录总的汽油量是否是正的</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123; <span class="comment">// 如果当前汽油量已经小于 0，说明之前的节点都是不行的，到下一个节点</span></span><br><span class="line">            j = i;</span><br><span class="line">            sum = <span class="number">0</span>; <span class="comment">// 同时重新开始计数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total &gt;= <span class="number">0</span> ? j + <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="135-糖块，成绩高的需要比他身边成绩低的获得更多的糖"><a href="#135-糖块，成绩高的需要比他身边成绩低的获得更多的糖" class="headerlink" title="135 糖块，成绩高的需要比他身边成绩低的获得更多的糖"></a>135 糖块，成绩高的需要比他身边成绩低的获得更多的糖</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = ratings.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candies</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i<span class="number">-1</span>])</span><br><span class="line">            candies[i] = candies[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (ratings[i<span class="number">-1</span>] &gt; ratings[i])</span><br><span class="line">            candies[i<span class="number">-1</span>] = <span class="built_in">max</span>(candies[i] + <span class="number">1</span>, candies[i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : candies)</span><br><span class="line">        result += i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="136-找出数组中只出现一次的数字"><a href="#136-找出数组中只出现一次的数字" class="headerlink" title="136 找出数组中只出现一次的数字"></a>136 找出数组中只出现一次的数字</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++)</span><br><span class="line">        result ^= nums[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="137-一个数组中，所有数字都出现三次，除了一个数字以外，找出这个数字"><a href="#137-一个数组中，所有数字都出现三次，除了一个数字以外，找出这个数字" class="headerlink" title="137 一个数组中，所有数字都出现三次，除了一个数字以外，找出这个数字"></a>137 一个数组中，所有数字都出现三次，除了一个数字以外，找出这个数字</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用二进制计算</span></span><br><span class="line"><span class="comment">// 00-&gt;10-&gt;01-&gt;00(0-&gt;1-&gt;2-&gt;3/0)</span></span><br><span class="line"><span class="comment">// ones = ones ^ A[i]; if (twos == 1) then ones = 0</span></span><br><span class="line"><span class="comment">// twos = twos ^ A[i]; if (ones* == 1) then twos = 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        ones = (ones ^ nums[i]) &amp; ~twos;</span><br><span class="line">        twos = (twos ^ nums[i]) &amp; ~ones;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="138-复制复杂结构链表"><a href="#138-复制复杂结构链表" class="headerlink" title="138 复制复杂结构链表"></a>138 复制复杂结构链表</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     struct RandomListNode *next;</span></span><br><span class="line"><span class="comment"> *     struct RandomListNode *random;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> RandomListNode *<span class="title function_">copyRandomList</span><span class="params">(<span class="keyword">struct</span> RandomListNode *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RandomListNode</span>* <span class="title">p</span>;</span></span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">RandomListNode</span>* <span class="title">node</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> RandomListNode));</span><br><span class="line">        node-&gt;next = node-&gt;random = <span class="literal">NULL</span>; <span class="comment">// spicial notice to struct initialization in c</span></span><br><span class="line">        node-&gt;label = p-&gt;label;</span><br><span class="line">        node-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = node;</span><br><span class="line">        p = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;random)</span><br><span class="line">            p-&gt;next-&gt;random = p-&gt;random-&gt;next;</span><br><span class="line">        p = p-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RandomListNode</span> <span class="title">dummy</span>, *<span class="title">q</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = dummy.random = <span class="literal">NULL</span>;</span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        q-&gt;next = p-&gt;next;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="139-查找单词是否能组成句子"><a href="#139-查找单词是否能组成句子" class="headerlink" title="139 查找单词是否能组成句子"></a>139 查找单词是否能组成句子</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, unordered_set&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wordDict.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 动态规划，假设前 i 个字符已经匹配到了，尝试匹配 i 到 i+j，如果找到了，就匹配到了 i+j</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j]) &#123;</span><br><span class="line">                string word = s.<span class="built_in">substr</span>(j, i-j);</span><br><span class="line">                <span class="keyword">if</span> (wordDict.<span class="built_in">find</span>(word) != wordDict.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="141-列表是否有环"><a href="#141-列表是否有环" class="headerlink" title="141 列表是否有环"></a>141 列表是否有环</h2><p>slow 每次走一步，而 fast 每次走两步，因此在进入环之后，两者一定会相遇</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">hasCycle</span><span class="params">(<span class="keyword">struct</span> ListNode *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head, * fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="142-列表是否有环？如果有找到环的开始"><a href="#142-列表是否有环？如果有找到环的开始" class="headerlink" title="142 列表是否有环？如果有找到环的开始"></a>142 列表是否有环？如果有找到环的开始</h2><p>从两者出发，到两者相遇，slow 指针走了 p 步，而 fast 指针走了 2p 步，显然 fast 多走了一圈（或者多圈）。<br>设 p &#x3D; k + x, 2p &#x3D; k + x + loop -&gt; 2k + 2x &#x3D; k + x + loop -&gt; k + x &#x3D; loop -&gt; k &#x3D; loop - x，剩下的长度正好也是 k。<br>假设入口处距离起点的距离是 k，那么发生碰撞的点距离环的入口处距离也是 k，所以两个指针分别从开始和碰撞点出发匀速一定会在环的入口相遇。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">detectCycle</span><span class="params">(<span class="keyword">struct</span> ListNode *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head, * fast = head, *entry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!found &amp;&amp; fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!found) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="144-前序遍历"><a href="#144-前序遍历" class="headerlink" title="144 前序遍历"></a>144 前序遍历</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    stk.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node  = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145 二叉树的后序遍历"></a>145 二叉树的后序遍历</h2><p>参见<a href="tree.md">树的遍历</a></p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    stack&lt;TreeNode*&gt; stk, output;</span><br><span class="line">    stk.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> node = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        output.<span class="built_in">push</span>(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!output.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(output.<span class="built_in">top</span>()-&gt;val);</span><br><span class="line">        output.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146 LRU 缓存"></a>146 LRU 缓存</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> unordered_map&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;::iterator&gt;&gt; <span class="type">cache_t</span>; <span class="comment">// k: v, iter</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : <span class="built_in">m_capacity</span>(capacity) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m_cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == m_cache.<span class="built_in">end</span>())</span><br><span class="line">             <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">touch</span>(it);</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second.first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m_cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it != m_cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="built_in">touch</span>(it);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_cache.<span class="built_in">size</span>() == m_capacity) &#123;</span><br><span class="line">                m_cache.<span class="built_in">erase</span>(m_used.<span class="built_in">back</span>());</span><br><span class="line">                m_used.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            m_used.<span class="built_in">push_front</span>(key);</span><br><span class="line">        &#125;</span><br><span class="line">        m_cache[key] = &#123;value, m_used.<span class="built_in">begin</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">touch</span><span class="params">(<span class="type">cache_t</span>::iterator it)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> key = it-&gt;first;</span><br><span class="line">        m_used.<span class="built_in">erase</span>(it-&gt;second.second);</span><br><span class="line">        m_used.<span class="built_in">push_front</span>(key);</span><br><span class="line">        it-&gt;second.second = m_used.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">cache_t</span> m_cache;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; m_used;</span><br><span class="line">    <span class="type">int</span> m_capacity;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="147-链表插入排序"><a href="#147-链表插入排序" class="headerlink" title="147 链表插入排序"></a>147 链表插入排序</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">insertionSortList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> head;</span><br><span class="line">    dummy.val = INT_MIN;</span><br><span class="line">    dummy.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">iter</span> =</span> &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span> (iter-&gt;next &amp;&amp; iter-&gt;next-&gt;val &lt; p-&gt;val)</span><br><span class="line">            iter = iter-&gt;next;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pnext</span> =</span> p-&gt;next;</span><br><span class="line">        p-&gt;next = iter-&gt;next;</span><br><span class="line">        iter-&gt;next = p;</span><br><span class="line">        p = pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="148-排序链表，要求达到-O-nlogn-时间复杂度"><a href="#148-排序链表，要求达到-O-nlogn-时间复杂度" class="headerlink" title="148 排序链表，要求达到 O(nlogn) 时间复杂度"></a>148 排序链表，要求达到 O(nlogn) 时间复杂度</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">split</span><span class="params">(<span class="keyword">struct</span> ListNode* source, <span class="keyword">struct</span> ListNode** frontptr, <span class="keyword">struct</span> ListNode** backptr)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span>, * <span class="title">slow</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!source || !source-&gt;next)</span><br><span class="line">        *backptr = source;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        slow = source;</span><br><span class="line">        fast = source-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *backptr = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *frontptr = source;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">merge</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span></span><br><span class="line">    dummy.next == <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1)</span><br><span class="line">        p-&gt;next = l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l2)</span><br><span class="line">        p-&gt;next = l2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge sort</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">sortList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">front</span>, * <span class="title">back</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">    split(head, &amp;front, &amp;back);</span><br><span class="line">    front = sortList(front);</span><br><span class="line">    back = sortList(back);</span><br><span class="line">    head = merge(front, back);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="149-在同一条线上的点最多的线"><a href="#149-在同一条线上的点最多的线" class="headerlink" title="149 在同一条线上的点最多的线"></a>149 在同一条线上的点最多的线</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxPoints</span><span class="params">(vector&lt;Point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于每一个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 经过该点的直线，使用分数作为斜率，避免使用浮点数</span></span><br><span class="line">        map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; lines;</span><br><span class="line">        <span class="type">int</span> localMax = <span class="number">0</span>, overlap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; points.<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 避免重复计算</span></span><br><span class="line">            <span class="keyword">if</span> (points[j].x == points[i].x &amp;&amp; points[j].y == points[i].y) &#123;</span><br><span class="line">                overlap++; <span class="comment">// 同一个点</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> x = points[j].x - points[i].x;</span><br><span class="line">                <span class="type">int</span> y = points[j].y - points[i].y;</span><br><span class="line">                <span class="type">int</span> g = <span class="built_in">gcd</span>(x, y);</span><br><span class="line">                x /= g, y /= g; <span class="comment">// verticle case: x == 0 -&gt; (0, 1)</span></span><br><span class="line">                lines[<span class="built_in">make_pair</span>(x, y)]++;</span><br><span class="line">                localMax = <span class="built_in">max</span>(localMax, lines[<span class="built_in">make_pair</span>(x, y)]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// overlap 算在任意条线上</span></span><br><span class="line">        result = <span class="built_in">max</span>(result, localMax + overlap + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="150-后缀表达式求值"><a href="#150-后缀表达式求值" class="headerlink" title="150 后缀表达式求值"></a>150 后缀表达式求值</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_operator</span><span class="params">(<span class="type">char</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t == <span class="string">&#x27;+&#x27;</span> || t == <span class="string">&#x27;-&#x27;</span> || t == <span class="string">&#x27;*&#x27;</span> || t == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> left, <span class="type">char</span> op, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> left + right;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> left - right;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> left * right;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> left / right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; token : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_operator</span>(token[<span class="number">0</span>]) &amp;&amp; token.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> op = token[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> right_num = nums.<span class="built_in">top</span>();</span><br><span class="line">            nums.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> left_num = nums.<span class="built_in">top</span>();</span><br><span class="line">            nums.<span class="built_in">pop</span>();</span><br><span class="line">            nums.<span class="built_in">push</span>(<span class="built_in">calc</span>(left_num, op, right_num));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums.<span class="built_in">push</span>(<span class="built_in">stoi</span>(token));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="151-反转句子中的单词顺序"><a href="#151-反转句子中的单词顺序" class="headerlink" title="151 反转句子中的单词顺序"></a>151 反转句子中的单词顺序</h2><p>一般面试的时候会假定没有多余字符的，解法是</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LeetCode 需要处理多余空格：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;C 解答&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">char</span> tmp = *a; *a = *b; *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>* start, <span class="type">char</span>* end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end)</span><br><span class="line">        swap(start++, end--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trim</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* fast, *slow;</span><br><span class="line">    <span class="keyword">for</span> (fast = s; *fast !=<span class="string">&#x27;\0&#x27;</span>; fast++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(*fast)) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isspace</span>(*(fast + <span class="number">1</span>)) &amp;&amp; *(fast + <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                fast++;</span><br><span class="line">            <span class="keyword">if</span>(*(fast+<span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(slow == s)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(fast, slow++);</span><br><span class="line">    &#125;</span><br><span class="line">    *slow = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseWords</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    trim(s);</span><br><span class="line">    len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    reverse(s, s + len - <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span>* head = s, * tail =s ;</span><br><span class="line">    <span class="keyword">while</span> (*(tail + <span class="number">1</span>) != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        tail = head;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isspace</span>(*(tail + <span class="number">1</span>)) &amp;&amp; *(tail + <span class="number">1</span>) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            tail++;</span><br><span class="line">        reverse(head, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="152-最大子序列乘积"><a href="#152-最大子序列乘积" class="headerlink" title="152 最大子序列乘积"></a>152 最大子序列乘积</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; A)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = A.size();</span><br><span class="line">    <span class="type">int</span> r = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, imax = r, imin = r; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; <span class="number">0</span>)</span><br><span class="line">            swap(imax, imin);</span><br><span class="line"></span><br><span class="line">        imax = max(A[i], imax * A[i]);</span><br><span class="line">        imin = min(A[i], imin * A[i]);</span><br><span class="line"></span><br><span class="line">        r = max(r, imax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="153-在旋转数组中查找最小值"><a href="#153-在旋转数组中查找最小值" class="headerlink" title="153 在旋转数组中查找最小值"></a>153 在旋转数组中查找最小值</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>; <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[left] &gt; A[mid])</span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[right] &lt; A[mid])</span><br><span class="line">            left = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[left] &lt; A[right] ? A[left] : A[right];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="154-在旋转数组中查找最小值，可能有重复"><a href="#154-在旋转数组中查找最小值，可能有重复" class="headerlink" title="154 在旋转数组中查找最小值，可能有重复"></a>154 在旋转数组中查找最小值，可能有重复</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] &gt; A[right]) &#123; <span class="comment">// 当需要找的是 left，也就是较小的数字，使用 right 比较不需要等于号</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[right] &lt; A[mid]) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="155-设计一个栈，在普通栈的基础上支持-getmin-操作"><a href="#155-设计一个栈，在普通栈的基础上支持-getmin-操作" class="headerlink" title="155 设计一个栈，在普通栈的基础上支持 getmin 操作"></a>155 设计一个栈，在普通栈的基础上支持 getmin 操作</h2><p>解法 1: 使用额外的栈，每个值都记录一个当前最小值，浪费空间</p>
<p>解法 2: 也是使用额外的栈，但是惰性记录，只有当需要更新的时候才去记录</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; m_stk;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; m_min;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="built_in">getMin</span>())</span><br><span class="line">            m_min.<span class="built_in">push</span>(x);</span><br><span class="line">        m_stk.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_stk.<span class="built_in">top</span>() == <span class="built_in">getMin</span>())</span><br><span class="line">            m_min.<span class="built_in">pop</span>();</span><br><span class="line">        m_stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_min.<span class="built_in">empty</span>() ? INT_MAX : m_min.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<p>156-159 Locked</p>
<h2 id="160-求两个链表的交叉点"><a href="#160-求两个链表的交叉点" class="headerlink" title="160 求两个链表的交叉点"></a>160 求两个链表的交叉点</h2><p>分析题目可知，如果有一个交叉点，那么在这之后的所有点都是交叉的。这里有一个非常巧妙<br>的做法。使用两个指针，如果到达结尾就指向另一个链表，会产生一下三种情况：</p>
<ol>
<li>如果交叉点前面的节点数目相同，显然会返回正确节点。</li>
<li>如果不同假设 A 的节点为 a + c，B 的节点为 b + c，则在下一次遍历时：<br> a + c + b &#x3D;&#x3D; b + c + a，恰好到达相同部分的第一个顶点 C1</li>
<li>如果两个列表不相交，那么经过 a + b, b + a 距离后，恰好都等于 NULL</li>
</ol>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">getIntersectionNode</span><span class="params">(<span class="keyword">struct</span> ListNode *headA, <span class="keyword">struct</span> ListNode *headB)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!headA || !headB) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p1</span> =</span> headA, *p2=headB;</span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        <span class="comment">// 两个列表手尾相接，如果有一个点相同，一定会返回</span></span><br><span class="line">        <span class="comment">// a + c + b == b + c + a   --&gt; C1</span></span><br><span class="line">        <span class="comment">// a + b == b + a    --&gt; NULL</span></span><br><span class="line">        p1 = p1 ? p1-&gt;next : headB;</span><br><span class="line">        p2 = p2 ? p2-&gt;next : headA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>161 Locked</p>
<h2 id="162-找到极大值，给定一个数组，可能有多个极大值，找到任意一个即可，给定数组中-A-i-x3D-A-i-1"><a href="#162-找到极大值，给定一个数组，可能有多个极大值，找到任意一个即可，给定数组中-A-i-x3D-A-i-1" class="headerlink" title="162  找到极大值，给定一个数组，可能有多个极大值，找到任意一个即可，给定数组中 A[i] !&#x3D; A[i+1]"></a>162  找到极大值，给定一个数组，可能有多个极大值，找到任意一个即可，给定数组中 A[i] !&#x3D; A[i+1]</h2><p>题目要求在对数时间内做出来，二分搜索，如果中间的数在左半部分，就向右找。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; nums[mid + <span class="number">1</span>]) <span class="comment">// mid in left part of summit</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>                           <span class="comment">// mid in right part of summit</span></span><br><span class="line">            right= mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>163 Locked</p>
<h2 id="164-未排序数组中相差最大的两个数之间的差"><a href="#164-未排序数组中相差最大的两个数之间的差" class="headerlink" title="164 未排序数组中相差最大的两个数之间的差"></a>164 未排序数组中相差最大的两个数之间的差</h2><p>根据抽屉原理，最大差不可能小于 (max - min) &#x2F; (n - 1)。证明：如果小于，那么整个数组的大小就会小于 max - min。<br>因此我们把</p>
<h2 id="165-比较版本号大小"><a href="#165-比较版本号大小" class="headerlink" title="165 比较版本号大小"></a>165 比较版本号大小</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ver</span><span class="params">(<span class="type">const</span> string&amp; version)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : version) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(num);</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于所有这种分割符中读取数字的都需要注意最后一个</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(num); <span class="comment">// notice here</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> v1 = <span class="built_in">ver</span>(version1);</span><br><span class="line">    <span class="keyword">auto</span> v2 = <span class="built_in">ver</span>(version2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>() || i &lt; v2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> a = i &lt; v1.<span class="built_in">size</span>() ? v1[i] : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b = i &lt; v2.<span class="built_in">size</span>() ? v2[i] : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">            <span class="keyword">return</span> a &gt; b ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="166-分数生成小数"><a href="#166-分数生成小数" class="headerlink" title="166 分数生成小数"></a>166 分数生成小数</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">fractionToDecimal</span><span class="params">(<span class="type">long</span> numerator, <span class="type">long</span> denominator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numerator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    string result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 符号</span></span><br><span class="line">    <span class="keyword">if</span> (numerator &lt; <span class="number">0</span> ^ denominator &lt; <span class="number">0</span>)</span><br><span class="line">        result += <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    <span class="type">long</span> n = <span class="built_in">abs</span>(numerator), d = <span class="built_in">abs</span>(denominator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数部分</span></span><br><span class="line">    result += <span class="built_in">to_string</span>(n / d);</span><br><span class="line">    <span class="keyword">if</span> (n % d == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小数部分</span></span><br><span class="line">    result+= <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> r = n % d; r != <span class="number">0</span>; r %= d) &#123; <span class="comment">// 模拟手工除法</span></span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">count</span>(r) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.<span class="built_in">insert</span>(map[r], <span class="number">1</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            result += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map[r] = result.<span class="built_in">size</span>(); <span class="comment">// 记录对应的位置，以便插入括号</span></span><br><span class="line">        r *= <span class="number">10</span>; <span class="comment">// 从上借位</span></span><br><span class="line">        result += <span class="built_in">to_string</span>(r / d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>167 Locked</p>
<h2 id="168-生成-Excel-表格标题"><a href="#168-生成-Excel-表格标题" class="headerlink" title="168 生成 Excel 表格标题"></a>168 生成 Excel 表格标题</h2><p>注意 A 对应的是 1 而不是 0，而且数字也是从 1 开始的</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    string title;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="type">char</span> c = (n<span class="number">-1</span>) % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        n = (n<span class="number">-1</span>) / <span class="number">26</span>;</span><br><span class="line">        title = c + title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="169-给定一个数组，有一个数字的出现频率超过了一半，找出这个数字"><a href="#169-给定一个数组，有一个数字的出现频率超过了一半，找出这个数字" class="headerlink" title="169 给定一个数组，有一个数字的出现频率超过了一半，找出这个数字"></a>169 给定一个数组，有一个数字的出现频率超过了一半，找出这个数字</h2><p>非常经典的一道题，首先我们假设拿到的数字就是目标，并记录他出现的次数，如果下一个<br>数字和他不一样，那么我们减一，当次数为 0 的时候，我们知道这个数字在已经遍历过的数字<br>中出现小于一半了，这时候我们换下一个数字，最后剩下的一定是超过一半的数字。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> candidate, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span> || candidate == i) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            candidate = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>170 Locked</p>
<h2 id="171-Excel-标题转换为数字"><a href="#171-Excel-标题转换为数字" class="headerlink" title="171 Excel 标题转换为数字"></a>171 Excel 标题转换为数字</h2><p>同样，我们需要注意 A 对应的是 1，而不是 0</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">titleToNumber</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*s)</span><br><span class="line">        result = result * <span class="number">26</span> + *s++ - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="172-阶乘中能有几个-0"><a href="#172-阶乘中能有几个-0" class="headerlink" title="172 阶乘中能有几个 0"></a>172 阶乘中能有几个 0</h2><p>显然先算出阶乘数字是会溢出的，而有 0 的话，就是需要 10，也就是就需要 2 和 5，<br>显然 2 是比 5 多的。那么我们只要考虑 5 的个数就行了， 这时候需要注意，5&#x2F;15 等是算一个 5，<br>而 25&#x2F;75 包含了两个 5，所以我们计算的时候，数一遍包含 5 的（这时 25 等也被计算了），<br>然后再数一遍包含 25 的就像当于数了两次了。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> fives = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; n / i &gt; <span class="number">0</span>; i *= <span class="number">5</span>)</span><br><span class="line">        fives += n / i;</span><br><span class="line">    <span class="keyword">return</span> fives;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="173-二叉树中序遍历迭代器"><a href="#173-二叉树中序遍历迭代器" class="headerlink" title="173 二叉树中序遍历迭代器"></a>173 二叉树中序遍历迭代器</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    BSTIterator(TreeNode *root) &#123;</span><br><span class="line">        pushAll(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !m_stack.empty();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        TreeNode* temp = m_stack.top();</span><br><span class="line">        m_stack.pop();</span><br><span class="line">        pushAll(temp-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> temp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; m_stack;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">pushAll</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            m_stack.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator will be called like this:</span></span><br><span class="line"><span class="comment"> * BSTIterator i = BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174 地下城游戏"></a>174 地下城游戏</h2><p>王子在格子的左上角，需要到右下角去救公主，在过程中王子不能死掉，和机器人走路一样，使用动态规划</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculateMinimumHP</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dungeon)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> row = dungeon.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> col = dungeon[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">bloods</span>(row + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (col + <span class="number">1</span>, INT_MAX));</span><br><span class="line">    bloods[row][col<span class="number">-1</span>] = bloods[row<span class="number">-1</span>][col] = <span class="number">1</span>; <span class="comment">// 公主的两边</span></span><br><span class="line">    <span class="comment">// 从公主那里逆向推</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = col<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">             <span class="type">int</span> need = <span class="built_in">min</span>(bloods[i+<span class="number">1</span>][j], bloods[i][j+<span class="number">1</span>]) - dungeon[i][j]; <span class="comment">// 缺乏的血量 = 到达下一步最少的血量 - 这一步消耗的血量</span></span><br><span class="line">             bloods[i][j] = need &gt; <span class="number">0</span> ? need : <span class="number">1</span>; <span class="comment">// 王子的血量至少为 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bloods[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="175-178-Missing"><a href="#175-178-Missing" class="headerlink" title="175-178 Missing"></a>175-178 Missing</h2><h2 id="179-最大的数字"><a href="#179-最大的数字" class="headerlink" title="179 最大的数字"></a>179 最大的数字</h2><p>神奇的排序方法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">largestNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">num_strings</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        num_strings[i] = <span class="built_in">to_string</span>(nums[i]);</span><br><span class="line">    <span class="keyword">auto</span> comparator = [] (string&amp; s1, string&amp; s2) &#123;</span><br><span class="line">        <span class="keyword">return</span> s1 + s2 &gt; s2 + s1;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(num_strings.<span class="built_in">begin</span>(), num_strings.<span class="built_in">end</span>(), comparator);</span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num_string: num_strings)</span><br><span class="line">        result += num_string;</span><br><span class="line">    <span class="type">int</span> start = result.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (start == string::npos) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">substr</span>(start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="180-185-Missing"><a href="#180-185-Missing" class="headerlink" title="180-185 Missing"></a>180-185 Missing</h2><p>186 Locked</p>
<h2 id="187-找到所有-10-个字母唱的重复-DNA-序列"><a href="#187-找到所有-10-个字母唱的重复-DNA-序列" class="headerlink" title="187 找到所有 10 个字母唱的重复 DNA 序列"></a>187 找到所有 10 个字母唱的重复 DNA 序列</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// naive 的做法从前往后，记录字符串</span></span><br><span class="line"><span class="comment">// 观察 ATCG 四个字符的特征，并把他们编码为一个 int</span></span><br><span class="line"><span class="comment">// 十个字符正好编码在 32bit 的 int 中</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="comment">// 左移弹出老元素，求交为了只使用 30bit，求或添加新元素。</span></span><br><span class="line">        <span class="keyword">if</span> (hash[t = t &lt;&lt; <span class="number">3</span> &amp; <span class="number">0x3FFFFFFF</span> | s[i] &amp; <span class="number">0b111</span>]++ == <span class="number">1</span>) <span class="comment">// 等于 1 为了避免重复</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i - <span class="number">9</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="189-翻转树组"><a href="#189-翻转树组" class="headerlink" title="189 翻转树组"></a>189 翻转树组</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> temp = nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= numsSize) k %= numsSize;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    reverse(nums, <span class="number">0</span>, numsSize - k - <span class="number">1</span>);</span><br><span class="line">    reverse(nums, numsSize - k, numsSize - <span class="number">1</span>);</span><br><span class="line">    reverse(nums, <span class="number">0</span>, numsSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="190-翻转二进制表示"><a href="#190-翻转二进制表示" class="headerlink" title="190 翻转二进制表示"></a>190 翻转二进制表示</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(n) * <span class="number">8</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123; <span class="comment">// 31 times shift</span></span><br><span class="line">        r |= n &amp; <span class="number">0x1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        r &lt;&lt;= <span class="number">1</span>; <span class="comment">// only shift 31 times</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r |= n &amp; <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="191-数字二进制表示中-1-的个数"><a href="#191-数字二进制表示中-1-的个数" class="headerlink" title="191 数字二进制表示中 1 的个数"></a>191 数字二进制表示中 1 的个数</h2><p>我们知道 n&amp;(n-1) 会把 n 中的最后一个 1 去掉，所以循环直到 n 为 0 即可</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        n &amp;= n - <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>还可以采用查表法，对于表我们可以预先构造，或者利用上一个方法生成，对于长度过大的，我们可以分块查表。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> counts[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _get_count(n) &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        n &amp;= n<span class="number">-1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_counts</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        counts[i] = _get_count(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_count</span><span class="params">(n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="type">int</span> index = n &amp; <span class="number">0xF</span>;</span><br><span class="line">        count += counts[index];</span><br><span class="line">        n &gt;&gt;= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    init_counts();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>, _get_count(i), get_count(i));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>192-197 Missing</p>
<h2 id="198-有一排房子，每个房子中都有一定财产，但是不能偷相邻的两个房子，求能偷到的最大值"><a href="#198-有一排房子，每个房子中都有一定财产，但是不能偷相邻的两个房子，求能偷到的最大值" class="headerlink" title="198  有一排房子，每个房子中都有一定财产，但是不能偷相邻的两个房子，求能偷到的最大值"></a>198  有一排房子，每个房子中都有一定财产，但是不能偷相邻的两个房子，求能偷到的最大值</h2><p>使用 DP，对于每个房子，可以选择不偷或者前 i-1 个房子加上偷当前房子，即<code>dp[i+1] = max(dp[i], dp[i-1] + A[i])</code></p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 因为不能相邻，所以可以从相隔一个的取值</span></span><br><span class="line">    <span class="comment">// dp[n] = max(dp[n-1], dp[n-2] + A[n])</span></span><br><span class="line">    <span class="type">int</span> temp, m = <span class="number">0</span>, n = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        temp = n;</span><br><span class="line">        <span class="keyword">if</span> (m + nums[i] &gt; n)</span><br><span class="line">            n = m + nums[i];</span><br><span class="line">        m = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="199-从右边看二叉树的效果"><a href="#199-从右边看二叉树的效果" class="headerlink" title="199 从右边看二叉树的效果"></a>199 从右边看二叉树的效果</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// level order 遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node;</span><br><span class="line">        <span class="type">int</span> len = q.<span class="built_in">size</span>(); <span class="comment">// 保存为了获得最后一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">// 当前数组的最后一个元素就是最右边的元素</span></span><br><span class="line">            node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="200-找出小岛的数量"><a href="#200-找出小岛的数量" class="headerlink" title="200 找出小岛的数量"></a>200 找出小岛的数量</h2><p>采用并查集，找到最后集合的数量</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; m_father, m_rank;</span><br><span class="line">    <span class="type">int</span> m_count; <span class="comment">// sets count</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n): <span class="built_in">m_father</span>(n), <span class="built_in">m_rank</span>(n, <span class="number">0</span>), <span class="built_in">m_count</span>(n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_father.<span class="built_in">size</span>(); i++)</span><br><span class="line">            m_father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != m_father[x])</span><br><span class="line">            m_father[x] = <span class="built_in">find</span>(m_father[x]);</span><br><span class="line">        <span class="keyword">return</span> m_father[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_rank[x] &gt; m_rank[y]) &#123;</span><br><span class="line">            m_father[y] = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_rank[x] == m_rank[y])</span><br><span class="line">                m_rank[y]++;</span><br><span class="line">            m_father[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">        m_count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">char</span> LAND = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">char</span> WATER = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.<span class="built_in">empty</span>() || grid[<span class="number">0</span>].<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = grid.<span class="built_in">size</span>(), c = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(r * c + <span class="number">1</span>)</span></span>; <span class="comment">// extra element is for water</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == LAND) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != r - <span class="number">1</span> &amp;&amp; grid[i+<span class="number">1</span>][j] == LAND)</span><br><span class="line">                         uf.<span class="built_in">unionify</span>(i*c+j, (i+<span class="number">1</span>)*c+j);</span><br><span class="line">                    <span class="keyword">if</span> (j != c - <span class="number">1</span> &amp;&amp; grid[i][j+<span class="number">1</span>] == LAND)</span><br><span class="line">                         uf .<span class="built_in">unionify</span>(i*c+j, i*c+j+<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    uf.<span class="built_in">unionify</span>(i*c+j, c*r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.<span class="built_in">getCount</span>() - <span class="number">1</span>; <span class="comment">// islands + water - 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, count</span>):</span><br><span class="line">        self.count = count</span><br><span class="line">        self.parents = <span class="built_in">list</span>(<span class="built_in">range</span>(count))  <span class="comment"># 初始化时 parent 指针指向自己</span></span><br><span class="line">        self.ranks = [<span class="number">1</span>] * count  <span class="comment"># 记录每棵树的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;把 p, q 两个节点连通起来&quot;&quot;&quot;</span></span><br><span class="line">        p_root = self.find(p)</span><br><span class="line">        q_root = self.find(q)</span><br><span class="line">        <span class="keyword">if</span> p_root == q_root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.ranks[p_root] &gt; self.ranks[q_root]:</span><br><span class="line">            self.parents[q_root] = p_root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.ranks[p_root] == self.ranks[q_root]:</span><br><span class="line">                self.ranks[q_root] += <span class="number">1</span></span><br><span class="line">            self.parents[p_root] = q_root</span><br><span class="line">        self.count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;找到 p 节点的根节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> self.parents[p] != p:</span><br><span class="line">            <span class="comment"># 神奇的路径压缩</span></span><br><span class="line">            self.parents[p] = self.parents[self.parents[p]]</span><br><span class="line">            p = self.parents[p]</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_connected</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        p_root = self.find(p)</span><br><span class="line">        q_root = self.find(q)</span><br><span class="line">        <span class="keyword">return</span> p_root == q_root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        uf = UnionFind(m * n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    up = <span class="built_in">max</span>(i - <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">if</span> grid[up][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                        uf.union(i * n + j, up * n + j)</span><br><span class="line">                    left = <span class="built_in">max</span>(j - <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">if</span> grid[i][j - <span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                        uf.union(i * n + j, i * n + left)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    uf.union(i * n + j, m * n)</span><br><span class="line">        <span class="keyword">return</span> uf.count - <span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="201-给定区间内，所有数字-AND-的结果"><a href="#201-给定区间内，所有数字-AND-的结果" class="headerlink" title="201 给定区间内，所有数字 AND 的结果"></a>201 给定区间内，所有数字 AND 的结果</h2><p>显然直接过一遍是会超时的，那么分析可知</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果两个数不相等，一定是有不同的位，那么这一位一定为 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m != n) &#123;</span><br><span class="line">        t++;</span><br><span class="line">        m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m &lt;&lt; t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="202-快乐数字，各位数字平方相加得到下一个数字，如果最后等于-1"><a href="#202-快乐数字，各位数字平方相加得到下一个数字，如果最后等于-1" class="headerlink" title="202 快乐数字，各位数字平方相加得到下一个数字，如果最后等于 1"></a>202 快乐数字，各位数字平方相加得到下一个数字，如果最后等于 1</h2><p>没啥，一直算就可以了。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="type">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            next += (n%<span class="number">10</span>) * (n%<span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="203-删除链表中给定的值"><a href="#203-删除链表中给定的值" class="headerlink" title="203 删除链表中给定的值"></a>203 删除链表中给定的值</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;val == val) &#123; <span class="comment">// not forward here</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> p-&gt;next;</span><br><span class="line">            p-&gt;next = next-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="204-找出素数"><a href="#204-找出素数" class="headerlink" title="204 找出素数"></a>204 找出素数</h2><p>什么筛子，忘了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">primes</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    primes[<span class="number">0</span>] = primes[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt; n; i++) <span class="comment">// 注意，只到 sqrt(n)</span></span><br><span class="line">        <span class="keyword">if</span> (primes[i])</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt; n; j += i) <span class="comment">// 从 i * i 开始，因为 i* i-- 已经被杀过了</span></span><br><span class="line">                primes[j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (primes[i])</span><br><span class="line">            count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="205-同构字符串，可以看作-word-pattern-的简化"><a href="#205-同构字符串，可以看作-word-pattern-的简化" class="headerlink" title="205 同构字符串，可以看作 word pattern 的简化"></a>205 同构字符串，可以看作 word pattern 的简化</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isIsomorphic</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ss[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> ts[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(s) != <span class="built_in">strlen</span>(t))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ss[s[i]] != ts[t[i]])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ss[s[i]] = ts[t[i]] = i + <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206 反转链表"></a>206 反转链表</h2><p>tags: #pointers</p>
<p>最最基础的指针操作题目了</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="built_in">next</span> = curr.<span class="built_in">next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> prev  <span class="comment"># 关键在这里</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>, *cur = head, *next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        next = cur-&gt;next; <span class="comment">// cache</span></span><br><span class="line">        cur-&gt;next = p; <span class="comment">// reverse pointing</span></span><br><span class="line">        p = cur; <span class="comment">// moves forwards</span></span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="207-标准的拓扑排序"><a href="#207-标准的拓扑排序" class="headerlink" title="207 标准的拓扑排序"></a>207 标准的拓扑排序</h2><p>给定边这种方法表示图也是醉了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123; <span class="comment">// next -&gt; before</span></span><br><span class="line">    vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses); <span class="comment">// 每条边和他的下一步，临接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : prerequisites)</span><br><span class="line">        graph[p.second].<span class="built_in">insert</span>(p.first);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">// in degree</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; nexts : graph)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> next : nexts)</span><br><span class="line">            d[next]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nondep; <span class="comment">// in degree == 0</span></span><br><span class="line">        <span class="keyword">for</span> (nondep = <span class="number">0</span>; nondep &lt; numCourses &amp;&amp; d[nondep] != <span class="number">0</span>; nondep++)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">if</span> (nondep == numCourses)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        d[nondep] = <span class="number">-1</span>; <span class="comment">// remove</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> next : graph[nondep]) <span class="comment">// 所有下一步都 －1</span></span><br><span class="line">            d[next]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="208-实现前缀树"><a href="#208-实现前缀树" class="headerlink" title="208 实现前缀树"></a>208 实现前缀树</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> branchCount = <span class="number">26</span>;</span><br><span class="line">    <span class="type">bool</span> isWord;</span><br><span class="line">    TrieNode* next[branchCount];</span><br><span class="line">    <span class="comment">// Initialize your data structure here.</span></span><br><span class="line">    <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; branchCount; i++)</span><br><span class="line">            next[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        location-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!location)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> location-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : prefix) &#123;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!location)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Trie trie;</span></span><br><span class="line"><span class="comment">// trie.insert(&quot;somestring&quot;);</span></span><br><span class="line"><span class="comment">// trie.search(&quot;key&quot;);</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="209-最短子数组使得和大于某个数"><a href="#209-最短子数组使得和大于某个数" class="headerlink" title="209 最短子数组使得和大于某个数"></a>209 最短子数组使得和大于某个数</h2><p>双指针，超过和之后再尝试从开始处减去元素</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, sum = <span class="number">0</span>, len = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">            len = <span class="built_in">min</span>(len, i - start + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[start++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len == INT_MAX? <span class="number">0</span> : len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="210-Course-Schedule-II"><a href="#210-Course-Schedule-II" class="headerlink" title="210 Course Schedule II"></a>210 Course Schedule II</h2><p>BFS</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; graph = <span class="built_in">make_graph</span>(numCourses, prerequisites);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; degrees = <span class="built_in">compute_indegree</span>(graph);</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; zeros;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">            <span class="keyword">if</span> (!degrees[i]) zeros.<span class="built_in">push</span>(i);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; toposort;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (zeros.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            <span class="type">int</span> zero = zeros.<span class="built_in">front</span>();</span><br><span class="line">            zeros.<span class="built_in">pop</span>();</span><br><span class="line">            toposort.<span class="built_in">push_back</span>(zero);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neigh : graph[zero]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!--degrees[neigh])</span><br><span class="line">                    zeros.<span class="built_in">push</span>(neigh);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toposort;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">make_graph</span>(<span class="type">int</span> numCourses, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> pre : prerequisites)</span><br><span class="line">            graph[pre.second].<span class="built_in">insert</span>(pre.first);</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">compute_indegree</span><span class="params">(vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degrees</span><span class="params">(graph.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> neighbors : graph)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neigh : neighbors)</span><br><span class="line">                degrees[neigh]++;</span><br><span class="line">        <span class="keyword">return</span> degrees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="211-添加和搜索字符串"><a href="#211-添加和搜索字符串" class="headerlink" title="211 添加和搜索字符串"></a>211 添加和搜索字符串</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> branchCount = <span class="number">26</span>;</span><br><span class="line">    <span class="type">bool</span> isWord;</span><br><span class="line">    TrieNode* next[branchCount];</span><br><span class="line">    <span class="comment">// Initialize your data structure here.</span></span><br><span class="line">    <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; branchCount; i++)</span><br><span class="line">            next[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        location-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!location)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> location-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : prefix) &#123;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!location)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TrieNode* <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> : <span class="keyword">public</span> Trie&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WordDictionary</span>() : <span class="built_in">Trie</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adds a word into the data structure.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the data structure. A word could</span></span><br><span class="line">    <span class="comment">// contain the dot character &#x27;.&#x27; to represent any one letter.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(word.<span class="built_in">c_str</span>(), <span class="built_in">getRoot</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* word, TrieNode* root)</span> </span>&#123;</span><br><span class="line">        TrieNode* run = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (run &amp;&amp; word[i] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                run = run-&gt;next[word[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (run &amp;&amp; word[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// skip checking this char</span></span><br><span class="line">                TrieNode* tmp = run;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                    run = tmp-&gt;next[j];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">search</span>(word + i + <span class="number">1</span>, run))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> run &amp;&amp; run-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// WordDictionary wordDictionary;</span></span><br><span class="line"><span class="comment">// wordDictionary.addWord(&quot;word&quot;);</span></span><br><span class="line"><span class="comment">// wordDictionary.search(&quot;pattern&quot;);</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="212-单词搜索"><a href="#212-单词搜索" class="headerlink" title="212 单词搜索"></a>212 单词搜索</h2><p>Trie 结构见前面，注意要记录 visited，还有边界的问题，另外集合的使用</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie m_trie;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; word : words)</span><br><span class="line">            m_trie.<span class="built_in">insert</span>(word);</span><br><span class="line">        <span class="type">int</span> row = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> col = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;string&gt; result_set;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(row, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(col, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">                <span class="built_in">find</span>(result_set, board, visited, <span class="string">&quot;&quot;</span>, i, j);</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : result_set)</span><br><span class="line">            result.<span class="built_in">push_back</span>(r);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(unordered_set&lt;string&gt;&amp; r, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, string word, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || visited[i][j])</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        word += board[i][j];</span><br><span class="line">        <span class="keyword">if</span> (!m_trie.<span class="built_in">startsWith</span>(word))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (m_trie.<span class="built_in">search</span>(word))</span><br><span class="line">            r.<span class="built_in">insert</span>(word);</span><br><span class="line"></span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">find</span>(r, board, visited, word, i<span class="number">-1</span>, j);</span><br><span class="line">        <span class="built_in">find</span>(r, board, visited, word, i+<span class="number">1</span>, j);</span><br><span class="line">        <span class="built_in">find</span>(r, board, visited, word, i, j<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">find</span>(r, board, visited, word, i, j+<span class="number">1</span>);</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="213-小偷偷环状数组"><a href="#213-小偷偷环状数组" class="headerlink" title="213 小偷偷环状数组"></a>213 小偷偷环状数组</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">robNonCyclic</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 因为不能相邻，所以可以从相隔一个的取值</span></span><br><span class="line">    <span class="comment">// dp[n] = max(dp[n-1], dp[n-2] + A[n])</span></span><br><span class="line">    <span class="type">int</span> temp, m = <span class="number">0</span>, n = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        temp = n;</span><br><span class="line">        <span class="keyword">if</span> (m + nums[i] &gt; n)</span><br><span class="line">            n = m + nums[i];</span><br><span class="line">        m = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> max(robNonCyclic(nums, numsSize - <span class="number">1</span>), robNonCyclic(nums + <span class="number">1</span>, numsSize - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="214-最短回文字符串，给指定的字符串添加字母获得回文"><a href="#214-最短回文字符串，给指定的字符串添加字母获得回文" class="headerlink" title="214 最短回文字符串，给指定的字符串添加字母获得回文"></a>214 最短回文字符串，给指定的字符串添加字母获得回文</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// based on kmp next array</span></span><br><span class="line"><span class="function">string <span class="title">shortestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string rev_s = s;</span><br><span class="line">    <span class="built_in">reverse</span>(rev_s.<span class="built_in">begin</span>(), rev_s.<span class="built_in">end</span>());</span><br><span class="line">    string l = s + <span class="string">&quot;#&quot;</span> + rev_s;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(l.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; l.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = p[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; l[i] != l[j])</span><br><span class="line">            j = p[j - <span class="number">1</span>];</span><br><span class="line">        p[i] = (j += l[i] == l[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rev_s.<span class="built_in">substr</span>(<span class="number">0</span>, s.<span class="built_in">size</span>() - p[l.<span class="built_in">size</span>() - <span class="number">1</span>]) + s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="215-数组中第-k-大的数字"><a href="#215-数组中第-k-大的数字" class="headerlink" title="215 数组中第 k 大的数字"></a>215 数组中第 k 大的数字</h2><p>实际上这道题更可能的题目是找到前 k 大的所有数字。<br>首先，设计到数组排序的问题一定向面试官要问清楚数据量的大小，这影响到接下来的实现，<br>同时和面试官探讨数据量大小对实现的影响，有助于更好的把握局面。</p>
<p>我们先假设数据量是比较小的，也就是能够放到内存中。</p>
<ol start="0">
<li>使用排序就实在是 naive 了，不过面试官非要问的话，当然是使用选择排序更好了。</li>
<li>使用快排中的 partition 算法，时间复杂度 O(n*logk)。</li>
<li>使用 size 为 k 的堆，时间复杂度也是 O(n*logk)，不管数字多大，都只需要遍历一遍。</li>
<li>使用类似插入排序的方法，保持数组大小不变，这样的时间复杂度是 O(n*k)。</li>
<li>数据的范围有限时候，使用计数排序。</li>
</ol>
<p>当数据过大的时候，我们可以想通过哈希取模之后把文件分组，找出每个文件中最大的 k 个数字</p>
<p>如果数字中有重复呢？使用计数排序，计数强制按一算<br>如果既有重复又是浮点数呢？</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> small = start - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pivot = nums[end];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; end; i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; pivot)</span><br><span class="line">            swap(&amp;nums[++small], &amp;nums[i]);</span><br><span class="line">    swap(&amp;nums[++small], &amp;nums[end]);</span><br><span class="line">    <span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> index = partition(nums, left, right);</span><br><span class="line">        <span class="keyword">if</span> (index == numsSize - k)</span><br><span class="line">            <span class="keyword">return</span> nums[index];</span><br><span class="line">        <span class="keyword">if</span> (index &gt; numsSize - k)</span><br><span class="line">            right = index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="216-找到-k-个数字-1…9-，使得他们的和是-n"><a href="#216-找到-k-个数字-1…9-，使得他们的和是-n" class="headerlink" title="216 找到 k 个数字 [1…9]，使得他们的和是 n"></a>216 找到 k 个数字 [1…9]，使得他们的和是 n</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">dfs</span>(result, &#123;&#125;, n, k);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt; combination, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (combination.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            result.<span class="built_in">push_back</span>(combination);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = combination.<span class="built_in">empty</span>() ? <span class="number">1</span> : combination.<span class="built_in">back</span>() + <span class="number">1</span>; <span class="comment">// 保证不重复切实递增序列</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n &amp;&amp; i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        combination.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">dfs</span>(result, combination, n-i, k);</span><br><span class="line">        combination.<span class="built_in">pop_back</span>();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="217-包含重复数字"><a href="#217-包含重复数字" class="headerlink" title="217 包含重复数字"></a>217 包含重复数字</h2><p>这道题太简单了，也没有什么精妙的解法，可以使用排序，Hash 等多种解法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; n : nums)</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">find</span>(n) != s.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s.<span class="built_in">insert</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="218-获得矩形重合部分的拐点"><a href="#218-获得矩形重合部分的拐点" class="headerlink" title="218 获得矩形重合部分的拐点"></a>218 获得矩形重合部分的拐点</h2><p>抄过来的，还没仔细研究</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">getSkyline</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; buildings) &#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">0</span>, cur_X, cur_H =<span class="number">-1</span>,  len = buildings.<span class="built_in">size</span>();</span><br><span class="line">    priority_queue&lt; pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; liveBlg; <span class="comment">// first: height, second, end time</span></span><br><span class="line">    <span class="keyword">while</span>(cur&lt;len || !liveBlg.<span class="built_in">empty</span>()) &#123; <span class="comment">// if either some new building is not processed or live building queue is not empty</span></span><br><span class="line">        cur_X = liveBlg.<span class="built_in">empty</span>()? buildings[cur][<span class="number">0</span>]:liveBlg.<span class="built_in">top</span>().second; <span class="comment">// next timing point to process</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur&gt;=len || buildings[cur][<span class="number">0</span>] &gt; cur_X) &#123; <span class="comment">//first check if the current tallest building will end before the next timing point</span></span><br><span class="line">              <span class="comment">// pop up the processed buildings, i.e. those  have height no larger than cur_H and end before the top one</span></span><br><span class="line">            <span class="keyword">while</span>(!liveBlg.<span class="built_in">empty</span>() &amp;&amp; ( liveBlg.<span class="built_in">top</span>().second &lt;= cur_X) ) liveBlg.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// if the next new building starts before the top one ends, process the new building in the vector</span></span><br><span class="line">            cur_X = buildings[cur][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">while</span>(cur&lt;len &amp;&amp; buildings[cur][<span class="number">0</span>]== cur_X)  <span class="comment">// go through all the new buildings that starts at the same point</span></span><br><span class="line">            &#123;  <span class="comment">// just push them in the queue</span></span><br><span class="line">                liveBlg.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(buildings[cur][<span class="number">2</span>], buildings[cur][<span class="number">1</span>]));</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_H = liveBlg.<span class="built_in">empty</span>()?<span class="number">0</span>:liveBlg.<span class="built_in">top</span>().first; <span class="comment">// outut the top one</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">empty</span>() || (res.<span class="built_in">back</span>().second != cur_H) ) res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(cur_X, cur_H));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="219-包含重复数字，并且两个的坐标不超过-k"><a href="#219-包含重复数字，并且两个的坐标不超过-k" class="headerlink" title="219 包含重复数字，并且两个的坐标不超过 k"></a>219 包含重复数字，并且两个的坐标不超过 k</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口保存前 k 个值，如果有重复的就返回</span></span><br><span class="line"><span class="comment">// num[i-k] num[i-1]，如果滑过了，就删除该元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= nums.<span class="built_in">size</span>()) <span class="comment">// notice here</span></span><br><span class="line">        k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k)</span><br><span class="line">            s.<span class="built_in">erase</span>(nums[i - k - <span class="number">1</span>]); <span class="comment">// delete first note</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">find</span>(nums[i]) != s.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        s.<span class="built_in">insert</span>(nums[i]); <span class="comment">// insert</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="220-同上一题，同时保证两个数字之间小于-t"><a href="#220-同上一题，同时保证两个数字之间小于-t" class="headerlink" title="220 同上一题，同时保证两个数字之间小于 t"></a>220 同上一题，同时保证两个数字之间小于 t</h2><p>保证两个数字之差小于 t</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; window; <span class="comment">// 注意不能使用 unordered</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= nums.<span class="built_in">size</span>()) <span class="comment">// notice here</span></span><br><span class="line">        k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k)</span><br><span class="line">            window.<span class="built_in">erase</span>(nums[i - k - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">auto</span> pos = window.<span class="built_in">lower_bound</span>(nums[i] - t); <span class="comment">// notice set.lower_bound</span></span><br><span class="line">        <span class="keyword">if</span> (pos != window.<span class="built_in">end</span>() &amp;&amp; *pos - nums[i] &lt;= t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        window.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="221-找到最大的正方形"><a href="#221-找到最大的正方形" class="headerlink" title="221 找到最大的正方形"></a>221 找到最大的正方形</h2><p>使用动态规划 <a target="_blank" rel="noopener" href="https://leetcode.com/discuss/38489/easy-solution-with-detailed-explanations-8ms-time-and-space">https://leetcode.com/discuss/38489/easy-solution-with-detailed-explanations-8ms-time-and-space</a></p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> maxsize = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// 每一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123; <span class="comment">// notice i range</span></span><br><span class="line">            <span class="type">int</span> temp = dp[i];</span><br><span class="line">            <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], <span class="built_in">min</span>(dp[i - <span class="number">1</span>], pre)) + <span class="number">1</span>;</span><br><span class="line">                maxsize = <span class="built_in">max</span>(maxsize, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dp[i] = <span class="number">0</span>;</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsize * maxsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="222-给定一个完全树，计算节点的数量。"><a href="#222-给定一个完全树，计算节点的数量。" class="headerlink" title="222 给定一个完全树，计算节点的数量。"></a>222 给定一个完全树，计算节点的数量。</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left_height = <span class="number">0</span>, right_height = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* left = root, *right = root;</span><br><span class="line">    <span class="keyword">while</span> (left) &#123;</span><br><span class="line">        left = left-&gt;left;</span><br><span class="line">        left_height++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right) &#123;</span><br><span class="line">        right = right-&gt;right;</span><br><span class="line">        right_height++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left_height == right_height) <span class="comment">// 满树 2^h - 1</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; left_height) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="223-找出两个长方形覆盖的面积"><a href="#223-找出两个长方形覆盖的面积" class="headerlink" title="223 找出两个长方形覆盖的面积"></a>223 找出两个长方形覆盖的面积</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">computeArea</span><span class="params">(<span class="type">int</span> left1, <span class="type">int</span> down1, <span class="type">int</span> right1, <span class="type">int</span> up1, <span class="type">int</span> left2, <span class="type">int</span> down2, <span class="type">int</span> right2, <span class="type">int</span> up2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = max(left1, left2); <span class="comment">// 靠右的</span></span><br><span class="line">    <span class="type">int</span> right = max(min(right1, right2), left);<span class="comment">// 靠左的，但是比左边大</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> down = max(down1, down2);</span><br><span class="line">    <span class="type">int</span> up = max(min(up1, up2), down);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不小心写反了。</span></span><br><span class="line">    <span class="keyword">return</span> -((left1 - right1) * (up1 - down1) + (left2 - right2) * (up2 - down2) - (left - right) * (up - down));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="224-给定一个字符串，包含加减和括号，计算值"><a href="#224-给定一个字符串，包含加减和括号，计算值" class="headerlink" title="224 给定一个字符串，包含加减和括号，计算值"></a>224 给定一个字符串，包含加减和括号，计算值</h2><p>难点是对括号的处理，注意每次都要和 signs.top() 相乘</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; signs; <span class="comment">// signs before braces</span></span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    signs.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">            num = <span class="number">10</span> * num + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            result += signs.<span class="built_in">top</span>() * sign * num;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            signs.<span class="built_in">push</span>(sign * signs.<span class="built_in">top</span>()); <span class="comment">// tricky</span></span><br><span class="line">            sign = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            result += signs.<span class="built_in">top</span>() * sign * num;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            signs.<span class="built_in">pop</span>();</span><br><span class="line">            sign = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result += signs.<span class="built_in">top</span>() * sign * num; <span class="comment">// tricky</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="225-使用队列模拟栈"><a href="#225-使用队列模拟栈" class="headerlink" title="225 使用队列模拟栈"></a>225 使用队列模拟栈</h2><p>其实有两种做法，一种是在 push 的时候，把队列清空，把 x 放到最底下。<br>另一种是在 pop 的时候，把队列清空到 1，然后弹出。应当询问面试官究竟是 push 居多还是 pop 居多</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Push element x onto stack.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!nums.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            temp.<span class="built_in">push</span>(nums.<span class="built_in">front</span>());</span><br><span class="line">            nums.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        nums.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (!temp.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            nums.<span class="built_in">push</span>(temp.<span class="built_in">front</span>());</span><br><span class="line">            temp.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes the element on top of the stack.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nums.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the top element.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return whether the stack is empty.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="226-反转二叉树"><a href="#226-反转二叉树" class="headerlink" title="226 反转二叉树"></a>226 反转二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">invertTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">temp</span> =</span> root-&gt;left;</span><br><span class="line">    root-&gt;left = invertTree(root-&gt;right);</span><br><span class="line">    root-&gt;right = invertTree(temp);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="227-给定一个字符串包含-计算他的值"><a href="#227-给定一个字符串包含-计算他的值" class="headerlink" title="227 给定一个字符串包含 +-*/ 计算他的值"></a>227 给定一个字符串包含 <code>+-*/</code> 计算他的值</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; stk; <span class="comment">// 使用 vector 便于统计最后的值</span></span><br><span class="line">    <span class="type">char</span> token = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">            num = num * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 这里不是 else if</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;*&#x27;</span> || s[i] == <span class="string">&#x27;/&#x27;</span> || i == s.<span class="built_in">size</span>() - <span class="number">1</span>) &#123; <span class="comment">// 注意最后一步还需要把最后的值计算</span></span><br><span class="line">            <span class="type">int</span> a;</span><br><span class="line">            <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                stk.<span class="built_in">push_back</span>(num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                stk.<span class="built_in">push_back</span>(-num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                a = stk.<span class="built_in">back</span>();</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                stk.<span class="built_in">push_back</span>(a * num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                a = stk.<span class="built_in">back</span>();</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                stk.<span class="built_in">push_back</span>(a / num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            token = s[i];</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : stk)</span><br><span class="line">        result += i;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="228-聚合区间，给定一排序数组，把相邻的数字用区间表示"><a href="#228-聚合区间，给定一排序数组，把相邻的数字用区间表示" class="headerlink" title="228 聚合区间，给定一排序数组，把相邻的数字用区间表示"></a>228 聚合区间，给定一排序数组，把相邻的数字用区间表示</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">        <span class="type">int</span> start = i, end = i;</span><br><span class="line">        <span class="keyword">while</span> (end + <span class="number">1</span> &lt; n &amp;&amp; nums[end + <span class="number">1</span>] == nums[end] + <span class="number">1</span>)</span><br><span class="line">            end++;</span><br><span class="line">        <span class="keyword">if</span> (end &gt; start)</span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[start]) + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(nums[end]));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[start]));</span><br><span class="line">        i = end + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="229-找出超过三分之一的元素"><a href="#229-找出超过三分之一的元素" class="headerlink" title="229 找出超过三分之一的元素"></a>229 找出超过三分之一的元素</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count1 == <span class="number">0</span> || n == a) &#123;</span><br><span class="line">            count1++;</span><br><span class="line">            a = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count2 == <span class="number">0</span> || n == b) &#123;</span><br><span class="line">            count2++;</span><br><span class="line">            b = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count1--;</span><br><span class="line">            count2--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count1 = count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == a) count1++;</span><br><span class="line">        <span class="keyword">if</span> (n == b) count2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count1 &gt; nums.<span class="built_in">size</span>() / <span class="number">3</span>) <span class="comment">// verify a</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(a);</span><br><span class="line">    <span class="keyword">if</span> (count2 &gt; nums.<span class="built_in">size</span>() / <span class="number">3</span> &amp;&amp; a != b) <span class="comment">// verify b</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(b);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="230-二叉树中第-k-小的数字"><a href="#230-二叉树中第-k-小的数字" class="headerlink" title="230 二叉树中第 k 小的数字"></a>230 二叉树中第 k 小的数字</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递指针</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* k, <span class="type">int</span>* number)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inorder(root-&gt;left, k, number);</span><br><span class="line">    (*k)--;</span><br><span class="line">    <span class="keyword">if</span> (*k == <span class="number">0</span>) &#123;</span><br><span class="line">        *number = root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root-&gt;right, k, number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    inorder(root, &amp;k, &amp;number);</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="231-2-的次方"><a href="#231-2-的次方" class="headerlink" title="231 2 的次方"></a>231 2 的次方</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_power_of_two</span>(n: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        (n &amp; (n-<span class="number">1</span>)) == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="232-使用栈模拟队列"><a href="#232-使用栈模拟队列" class="headerlink" title="232 使用栈模拟队列"></a>232 使用栈模拟队列</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Push element x to the back of queue.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        in.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes the element from in front of queue.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (out.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="built_in">transfer</span>();</span><br><span class="line">        out.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the front element.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">if</span> (out.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="built_in">transfer</span>();</span><br><span class="line">        <span class="keyword">return</span> out.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return whether the queue is empty.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.<span class="built_in">empty</span>() &amp;&amp; out.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!in.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            out.<span class="built_in">push</span>(in.<span class="built_in">top</span>());</span><br><span class="line">            in.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; in;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; out;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="233-小于-n-的数字中-1-的个数"><a href="#233-小于-n-的数字中-1-的个数" class="headerlink" title="233 小于 n 的数字中 1 的个数"></a>233 小于 n 的数字中 1 的个数</h2><p>对于每一位，有三种情况：</p>
<ol>
<li>当是数字 0 的时候，可能出先 1 的情况完全由高位出现决定，因为这一位不能贡献 1</li>
<li>当是数字 1 的时候，同上，但是这一位和低位一起可以贡献一个 1</li>
<li>当时数字 2-9 的时候，相当于这一位的 1 可以任意出现，因此高位＋1</li>
</ol>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ones = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">1</span>; m &lt;= n; m *= <span class="number">10</span>) &#123; <span class="comment">// m is the factor</span></span><br><span class="line">        <span class="type">int</span> a = n/m, b = n%m;  <span class="comment">// a is left half, b is right half</span></span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">10</span> &gt;= <span class="number">2</span>)</span><br><span class="line">            ones += (a / <span class="number">10</span> + <span class="number">1</span>) * m;</span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">10</span> == <span class="number">1</span>)</span><br><span class="line">            ones += (a / <span class="number">10</span>) * m + b + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">            ones += (a / <span class="number">10</span>) * m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>二进制呢</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countDigitOneBinary</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ones = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">1</span>; m &lt;= n; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> a = n / m, b = n % m;</span><br><span class="line">        <span class="keyword">if</span> (a &amp; <span class="number">0x01</span>)</span><br><span class="line">            ones += (a &gt;&gt; <span class="number">1</span>) * m + b + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ones += (a &gt;&gt; <span class="number">1</span>) * m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>求最大的 countDigitOne(n) &#x3D;&#x3D; n</p>
<pre><code>9    1
99   20
999  300
...
99999999  10000000
</code></pre>
<h2 id="234-判断一个链表是否是回文"><a href="#234-判断一个链表是否是回文" class="headerlink" title="234 判断一个链表是否是回文"></a>234 判断一个链表是否是回文</h2><p>解法 1: 如果链表是可以改变的，不妨反转它的前半部分，然后再与后半部分比较</p>
<p>解法 2: 如果是只读的，复制一份也可以，但是不如使用堆栈</p>
<p>注意对奇数偶数的处理</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode* temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    temp = head;</span><br><span class="line">    <span class="type">int</span> mid = len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (mid--) &#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(temp-&gt;val);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &amp; <span class="number">0x01</span>)</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> a = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b = temp-&gt;val;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="235-二叉搜索树公共祖先"><a href="#235-二叉搜索树公共祖先" class="headerlink" title="235 二叉搜索树公共祖先"></a>235 二叉搜索树公共祖先</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">lowestCommonAncestor</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="236-二叉树公共祖先"><a href="#236-二叉树公共祖先" class="headerlink" title="236 二叉树公共祖先"></a>236 二叉树公共祖先</h2><p>如果二叉树的根就是其中一个节点，那显然是这个。<br>在两颗子树中分别查找，如果找到了，返回一个非 NULL 值，如果都找到了，则这个节点就是 LCA</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">lowestCommonAncestor</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || root == p || root == q)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span> =</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span> =</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!left) <span class="comment">// not in left subtree</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">if</span> (!right)</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// both left and right are found!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="237-删除链表中的元素"><a href="#237-删除链表中的元素" class="headerlink" title="237 删除链表中的元素"></a>237 删除链表中的元素</h2><p>直接将后继节点的值复制到当前节点</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(<span class="keyword">struct</span> ListNode* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node || !node-&gt;next)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> node-&gt;next;</span><br><span class="line">    node-&gt;val = next-&gt;val;</span><br><span class="line">    node-&gt;next = next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="238-数组除了自己以外的乘积，规定不能用除法"><a href="#238-数组除了自己以外的乘积，规定不能用除法" class="headerlink" title="238 数组除了自己以外的乘积，规定不能用除法"></a>238 数组除了自己以外的乘积，规定不能用除法</h2><p>首先从前往后乘，错开一位元素，这样每个元素都乘到了他之前的所有元素，最后一个元素已经是结果了。<br>然后从后往前乘，同样错开一位，这样每个元素又把他之后的元素都得到了。</p>
<h2 id="239-滑动窗口最大值，给定一个滑动窗口，返回它移动过程中的最大值"><a href="#239-滑动窗口最大值，给定一个滑动窗口，返回它移动过程中的最大值" class="headerlink" title="239 滑动窗口最大值，给定一个滑动窗口，返回它移动过程中的最大值"></a>239 滑动窗口最大值，给定一个滑动窗口，返回它移动过程中的最大值</h2><p>单调队列的应用，复杂度是 O(n) 的。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonoQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.q = deque()  <span class="comment"># 实际储存数据</span></span><br><span class="line">        self.m = deque()  <span class="comment"># 维护单调关系，队首元素总是最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.q.append(x)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.m) &gt; <span class="number">0</span> <span class="keyword">and</span> self.m[-<span class="number">1</span>] &lt; x:</span><br><span class="line">            self.m.pop()</span><br><span class="line">        self.m.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        x = self.q.popleft()</span><br><span class="line">        <span class="keyword">if</span> self.m[<span class="number">0</span>] == x:</span><br><span class="line">            self.m.popleft()</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.q)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.m[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        q = MonoQueue()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            q.push(nums[i])</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">            ans.append(q.top())</span><br><span class="line">            q.pop()</span><br><span class="line">            q.push(nums[i])</span><br><span class="line">        ans.append(q.top())</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<p>另一种现在我已经看不懂的做法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 题目给定 k 一定是有效地</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>() || k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; dq; <span class="comment">// 存储的是索引，front 存储最大值，保证递减</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() &lt; i - k + <span class="number">1</span>) <span class="comment">// 弹出滑过的窗口</span></span><br><span class="line">            dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; nums[dq.<span class="built_in">back</span>()] &lt; nums[i]) <span class="comment">// 弹出小的</span></span><br><span class="line">            dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>)</span><br><span class="line">            result.<span class="built_in">push_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="240-给定一个矩阵，每行从左到右都是增大的，每一列从上到下都是增大的，找出给定数字是否存在"><a href="#240-给定一个矩阵，每行从左到右都是增大的，每一列从上到下都是增大的，找出给定数字是否存在" class="headerlink" title="240 给定一个矩阵，每行从左到右都是增大的，每一列从上到下都是增大的，找出给定数字是否存在"></a>240 给定一个矩阵，每行从左到右都是增大的，每一列从上到下都是增大的，找出给定数字是否存在</h2><p>我们考虑右上角的元素</p>
<ol>
<li>如果这个元素比 taget 大，那么整列都比 target 大，我们可以 c–</li>
<li>如果这个元素比 target 小，那么正行都比 target 小，我们可以 r++</li>
</ol>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>, c = col - <span class="number">1</span>; <span class="comment">// 右上角</span></span><br><span class="line">    <span class="keyword">while</span> (r &lt; row &amp;&amp; c &gt; <span class="number">-1</span>) <span class="comment">// 向左下角</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[r][c] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[r][c] &gt; target)</span><br><span class="line">            c--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="241-添加括号得到不同的结果"><a href="#241-添加括号得到不同的结果" class="headerlink" title="241 添加括号得到不同的结果"></a>241 添加括号得到不同的结果</h2><p>对每一个符号，在他的两边添加括号的好的不同结果再计算。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; output;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> token = input[i];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(token)) <span class="comment">// not digit</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> a : <span class="built_in">diffWaysToCompute</span>(input.<span class="built_in">substr</span>(<span class="number">0</span>, i))) <span class="comment">// 左半部分</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> b : <span class="built_in">diffWaysToCompute</span>(input.<span class="built_in">substr</span>(i+<span class="number">1</span>))) <span class="comment">// 右半部分</span></span><br><span class="line">                    output.<span class="built_in">push_back</span>(token == <span class="string">&#x27;+&#x27;</span> ? a + b : token == <span class="string">&#x27;-&#x27;</span>? a - b: a *b); <span class="comment">// 两半部分之和</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (output.<span class="built_in">empty</span>())</span><br><span class="line">        output.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input));</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="242-一个单词是否能由另一个变幻而来"><a href="#242-一个单词是否能由另一个变幻而来" class="headerlink" title="242 一个单词是否能由另一个变幻而来"></a>242 一个单词是否能由另一个变幻而来</h2><p>还是，对于 ASCII 字符，直接用数组代替字典</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isAnagram</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> &#123;</span><br><span class="line">    <span class="type">char</span> ss[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> ts[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        ss[*s - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        s++;</span><br><span class="line">        ts[*t - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memcmp</span>(ss, ts, <span class="keyword">sizeof</span>(ss)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>243-256 Locked</p>
<h2 id="257-二叉树左右路径"><a href="#257-二叉树左右路径" class="headerlink" title="257 二叉树左右路径"></a>257 二叉树左右路径</h2><p>典型的 DFS，发挥所有从根节点到叶节点的路径</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="built_in">paths</span>(result, <span class="string">&quot;&quot;</span>, root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paths</span><span class="params">(vector&lt;string&gt;&amp; result, string path, TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">empty</span>())</span><br><span class="line">        path += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        path += <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        <span class="built_in">paths</span>(result, path, root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        <span class="built_in">paths</span>(result, path, root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="258-把数字的每一位加起来，直到变成一个一位的数字"><a href="#258-把数字的每一位加起来，直到变成一个一位的数字" class="headerlink" title="258 把数字的每一位加起来，直到变成一个一位的数字"></a>258 把数字的每一位加起来，直到变成一个一位的数字</h2><p>这完全是一道数学题，对于每个进制的数字都有规律 <code>(n - 1) % (x - 1) + 1</code>。实际上是把 10 进制的转化为 9 进制数字</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">addDigits</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>259 Locked</p>
<h2 id="260-给定一个数组，每个数字都是重复的，只有两个数字不是，找出这两个数字"><a href="#260-给定一个数组，每个数字都是重复的，只有两个数字不是，找出这两个数字" class="headerlink" title="260 给定一个数组，每个数字都是重复的，只有两个数字不是，找出这两个数字"></a>260 给定一个数组，每个数字都是重复的，只有两个数字不是，找出这两个数字</h2><p>这道题很奇妙，依然可以使用 XOR 来解，首先遍历一遍，这时候由于有两个数字是不同的，那么一定结果不为 0，那么其中一个 bit 位一定是一个数字有，另一个数字没有。<br>在遍历一遍，同时把数字分两组，一组是有这个 bit 位，一组没有。就得出了结果。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; n : nums)</span><br><span class="line">        r ^= n;</span><br><span class="line">    <span class="type">int</span> bit = r &amp; -r; <span class="comment">// last sig bit</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; n : nums)</span><br><span class="line">        <span class="keyword">if</span> (n &amp; bit)</span><br><span class="line">            result[<span class="number">0</span>] ^= n;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result[<span class="number">1</span>] ^= n;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>261 262 Locked</p>
<h2 id="263-丑陋的数字，质数因子只含有-2-3-5-的数字"><a href="#263-丑陋的数字，质数因子只含有-2-3-5-的数字" class="headerlink" title="263 丑陋的数字，质数因子只含有 2,3,5 的数字"></a>263 丑陋的数字，质数因子只含有 2,3,5 的数字</h2><p>按定义做就好了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isUgly</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="264-找出第-n-个丑陋数字"><a href="#264-找出第-n-个丑陋数字" class="headerlink" title="264 找出第 n 个丑陋数字"></a>264 找出第 n 个丑陋数字</h2><p>使用数列记录 n 个丑陋数字，每一个丑陋数字肯定是之前数字乘以 235 得到的，然后用三个指针分别指向上一个做乘法的数字，每次找出最小的一个</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">6</span>) <span class="comment">// 1..6 恰好都是</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> s2 = <span class="number">0</span>, s3 = <span class="number">0</span>, s5 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* uglies[n];</span><br><span class="line">    uglies[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> c2 = uglies[s2] * <span class="number">2</span>, c3 = uglies[s3] * <span class="number">3</span>, c5 = uglies[s5] * <span class="number">5</span>;</span><br><span class="line">        uglies[i] = MIN(c2, MIN(c3, c5));</span><br><span class="line">        <span class="keyword">if</span> (uglies[i] == c2) s2++;</span><br><span class="line">        <span class="keyword">if</span> (uglies[i] == c3) s3++;</span><br><span class="line">        <span class="keyword">if</span> (uglies[i] == c5) s5++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uglies[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="268-丢失的数字，给定-0…n，丢失了一个，然后放在长度为-n-的数组之中，找出这个数字"><a href="#268-丢失的数字，给定-0…n，丢失了一个，然后放在长度为-n-的数组之中，找出这个数字" class="headerlink" title="268 丢失的数字，给定 0…n，丢失了一个，然后放在长度为 n 的数组之中，找出这个数字"></a>268 丢失的数字，给定 0…n，丢失了一个，然后放在长度为 n 的数组之中，找出这个数字</h2><p>显然还是使用异或，注意 0 ^ x &#x3D;&#x3D; x，所以直接把 0 忽略就行了。把每个数字都和 i 异或，丢失的数字就出来了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        result = result ^ (i + <span class="number">1</span>) ^ nums[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>269-272 Locked</p>
<h2 id="273-数字转换为英语单词"><a href="#273-数字转换为英语单词" class="headerlink" title="273 数字转换为英语单词"></a>273 数字转换为英语单词</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; digits = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Four&quot;</span>, <span class="string">&quot;Five&quot;</span>, <span class="string">&quot;Six&quot;</span>, <span class="string">&quot;Seven&quot;</span>, <span class="string">&quot;Eight&quot;</span>, <span class="string">&quot;Nine&quot;</span>, <span class="string">&quot;Ten&quot;</span>, <span class="string">&quot;Eleven&quot;</span>, <span class="string">&quot;Twelve&quot;</span>, <span class="string">&quot;Thirteen&quot;</span>, <span class="string">&quot;Fourteen&quot;</span>, <span class="string">&quot;Fifteen&quot;</span>, <span class="string">&quot;Sixteen&quot;</span>, <span class="string">&quot;Seventeen&quot;</span>, <span class="string">&quot;Eighteen&quot;</span>, <span class="string">&quot;Nineteen&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; tens = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Twenty&quot;</span>, <span class="string">&quot;Thirty&quot;</span>, <span class="string">&quot;Forty&quot;</span>, <span class="string">&quot;Fifty&quot;</span>, <span class="string">&quot;Sixty&quot;</span>, <span class="string">&quot;Seventy&quot;</span>, <span class="string">&quot;Eighty&quot;</span>, <span class="string">&quot;Ninety&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; seps = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot; Thousand &quot;</span>, <span class="string">&quot; Million &quot;</span>, <span class="string">&quot; Billion &quot;</span>&#125;; <span class="comment">// notice the trailing spaces</span></span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">numberToWords</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Zero&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Negative &quot;</span> + <span class="built_in">numberToWords</span>(-num);</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        string result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">1000</span> != <span class="number">0</span>)</span><br><span class="line">                result = <span class="built_in">s2word</span>(num % <span class="number">1000</span>) + seps[count] + result;</span><br><span class="line">            num /= <span class="number">1000</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// removw unnecessary tailing space</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(result.<span class="built_in">back</span>()))</span><br><span class="line">            result.<span class="built_in">resize</span>(result.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">s2word</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string result;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">            result += digits[num/<span class="number">100</span>] + <span class="string">&quot; Hundred &quot;</span>;</span><br><span class="line">            num %= <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">20</span>) &#123;</span><br><span class="line">            result += tens[num / <span class="number">10</span>] + <span class="string">&quot; &quot;</span>;</span><br><span class="line">            num %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">1</span> &amp;&amp; num &lt;= <span class="number">19</span>)</span><br><span class="line">            result += digits[num];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remove tailing spaces</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(result.<span class="built_in">back</span>()))</span><br><span class="line">            result.<span class="built_in">resize</span>(result.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="274-H-Index"><a href="#274-H-Index" class="headerlink" title="274 H-Index"></a>274 H-Index</h2><p>H-Index 的定义：一个科学家的 N 篇论文 h 个至少有 h 个引用，而且剩下的 N-h 篇论文都没有超过 h 个引用。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>* cites, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> hs[n+<span class="number">1</span>]; <span class="comment">// Hindex 不可能大于 N</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        hs[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cites[i] &gt; n)</span><br><span class="line">            hs[n]++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hs[cites[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n, papers = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 从后往前，如果有符合条件的，那么就是 Hindex</span></span><br><span class="line">        papers += hs[i];</span><br><span class="line">        <span class="keyword">if</span> (papers &gt;= i)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="275-H-index-II，论文已经按照引用数量排序"><a href="#275-H-index-II，论文已经按照引用数量排序" class="headerlink" title="275 H-index II，论文已经按照引用数量排序"></a>275 H-index II，论文已经按照引用数量排序</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>* citations, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 二分查找是小于等于</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (citations[mid] == n - mid)</span><br><span class="line">            <span class="keyword">return</span> citations[mid];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (citations[mid] &lt; n - mid)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - right - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>276-277 Locked</p>
<h2 id="278-第一个坏版本"><a href="#278-第一个坏版本" class="headerlink" title="278 第一个坏版本"></a>278 第一个坏版本</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际上是 lower_bound 函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n; <span class="comment">// 记住 lower_bound 的 right 是 n</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;   <span class="comment">// 使用小于号</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isBadVersion(mid))</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="279-分解为平方数的和"><a href="#279-分解为平方数的和" class="headerlink" title="279 分解为平方数的和"></a>279 分解为平方数的和</h2><p>最多 4 个即可，尝试在三个以内是否可以。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ub = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a=<span class="number">0</span>; a&lt;=ub; ++a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b=a; b&lt;=ub; ++b) &#123;</span><br><span class="line">            <span class="type">int</span> c = <span class="built_in">sqrt</span>(n - a*a - b*b);</span><br><span class="line">            <span class="keyword">if</span> (a*a + b*b + c*c == n)</span><br><span class="line">                <span class="keyword">return</span> !!a + !!b + !!c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="282-添加运算符使得算式成立"><a href="#282-添加运算符使得算式成立" class="headerlink" title="282 添加运算符使得算式成立"></a>282 添加运算符使得算式成立</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">addOperators</span><span class="params">(string num, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (num.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="built_in">dfs</span>(num, target, result, num[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>, num.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string num, <span class="type">int</span> target, vector&lt;string&gt; &amp; v, <span class="type">long</span> <span class="type">long</span> last, string s, <span class="type">int</span> idx, <span class="type">int</span> left)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == num.<span class="built_in">length</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == last*left)</span><br><span class="line">            v.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(last!=<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(num, target,         v, last * <span class="number">10</span> + num[idx] - <span class="string">&#x27;0&#x27;</span>, s + num.<span class="built_in">substr</span>(idx, <span class="number">1</span>), idx + <span class="number">1</span>, left); <span class="comment">// 尝试拼成 10</span></span><br><span class="line">        <span class="built_in">dfs</span>(num, target,             v, num[idx] - <span class="string">&#x27;0&#x27;</span>, s + <span class="string">&#x27;*&#x27;</span> + num.<span class="built_in">substr</span>(idx, <span class="number">1</span>), idx + <span class="number">1</span>, last*left);</span><br><span class="line">        <span class="built_in">dfs</span>(num, target - left*last, v, num[idx] - <span class="string">&#x27;0&#x27;</span>, s + <span class="string">&#x27;+&#x27;</span> + num.<span class="built_in">substr</span>(idx, <span class="number">1</span>), idx + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(num, target - left*last, v, num[idx] - <span class="string">&#x27;0&#x27;</span>, s + <span class="string">&#x27;-&#x27;</span> + num.<span class="built_in">substr</span>(idx, <span class="number">1</span>), idx + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="283-移动-0"><a href="#283-移动-0" class="headerlink" title="283 移动 0"></a>283 移动 0</h2><p>注意 swap 的使用</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">swap</span>(nums[n++], nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="284-Peek-Iterator"><a href="#284-Peek-Iterator" class="headerlink" title="284 Peek Iterator"></a>284 Peek Iterator</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Below is the interface for Iterator, which is already defined for you.</span></span><br><span class="line"><span class="comment">// **DO NOT** modify the interface for Iterator.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Data</span>;</span><br><span class="line">    Data* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Iterator</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums);</span><br><span class="line">    <span class="built_in">Iterator</span>(<span class="type">const</span> Iterator&amp; iter);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Iterator</span>();</span><br><span class="line">    <span class="comment">// Returns the next element in the iteration.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Returns true if the iteration has more elements.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PeekingIterator</span> : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PeekingIterator</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums) : <span class="built_in">Iterator</span>(nums) &#123;</span><br><span class="line">        <span class="comment">// Initialize any member here.</span></span><br><span class="line">        <span class="comment">// **DO NOT** save a copy of nums and manipulate it directly.</span></span><br><span class="line">        <span class="comment">// You should only use the Iterator interface methods.</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the next element in the iteration without advancing the iterator.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Iterator</span>(*<span class="keyword">this</span>).<span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hasNext() and next() should behave the same as in the Iterator interface.</span></span><br><span class="line">    <span class="comment">// Override them if needed.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Iterator::<span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Iterator::<span class="built_in">hasNext</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="285-286-Locked"><a href="#285-286-Locked" class="headerlink" title="285 ~ 286 Locked"></a>285 ~ 286 Locked</h2><h2 id="287-一个-n-的数组包含了-1…n-1-中的这些数字，证明一定存在重复，并找出这个重复"><a href="#287-一个-n-的数组包含了-1…n-1-中的这些数字，证明一定存在重复，并找出这个重复" class="headerlink" title="287 一个 n 的数组包含了 1…n-1 中的这些数字，证明一定存在重复，并找出这个重复"></a>287 一个 n 的数组包含了 1…n-1 中的这些数字，证明一定存在重复，并找出这个重复</h2><p>使用抽屉原理可以证明一定存在重复。据说高纳德解这个问题花了四个小时。</p>
<p>我们把这个数组看做一个变幻方程 <code>f(i) = A[i]</code>，把一些数字变幻到另一些，那么存在一个 <code>i != j s.t. f(i) == f(j)</code>.<br>那么这个问题变成了链表求环的问题。对于链表，我们有 n &#x3D; n-&gt;next 遍历列表，对于这个序列，则是<code> n = f(n)</code></p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 从 n-1 开始</span></span><br><span class="line">    <span class="type">int</span> fast = n - <span class="number">1</span>, slow = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        slow = nums[slow] - <span class="number">1</span>; <span class="comment">// 减一是为了转化为坐标</span></span><br><span class="line">        fast = nums[nums[fast] - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line">    fast = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        slow = nums[slow] - <span class="number">1</span>;</span><br><span class="line">        fast = nums[fast] - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>; <span class="comment">// 从坐标到数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="288-Locked"><a href="#288-Locked" class="headerlink" title="288 Locked"></a>288 Locked</h2><h2 id="289-Conway’s-Game-of-Life"><a href="#289-Conway’s-Game-of-Life" class="headerlink" title="289 Conway’s Game of Life"></a>289 Conway’s Game of Life</h2><p>哈哈，机智，使用没有使用的第二个位存储下一代</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;<span class="keyword">return</span> a &gt; b ? a :b;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;<span class="keyword">return</span> a &lt; b ? a :b;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gameOfLife</span><span class="params">(<span class="type">int</span>** board, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m=max(i<span class="number">-1</span>, <span class="number">0</span>); m&lt;min(i+<span class="number">2</span>, row); m++) <span class="comment">// 这里的 min，max 使用的太屌了</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> n=max(j<span class="number">-1</span>, <span class="number">0</span>); n&lt;min(j+<span class="number">2</span>, col); n++)</span><br><span class="line">                    count += (board[m][n] &amp; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">3</span> || count - board[i][j] == <span class="number">3</span>) <span class="comment">// 当前为 0，周围为 3；or 当前为 1，周围为 2/3 here</span></span><br><span class="line">                board[i][j] |= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            board[i][j] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="290-单词模式，给定一个模式-abba-等，判断单词是否是这个模式的。"><a href="#290-单词模式，给定一个模式-abba-等，判断单词是否是这个模式的。" class="headerlink" title="290 单词模式，给定一个模式 abba 等，判断单词是否是这个模式的。"></a>290 单词模式，给定一个模式 abba 等，判断单词是否是这个模式的。</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wordPattern</span><span class="params">(string pattern, string str)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; chars;  <span class="comment">// 使用两个 map 纪录</span></span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; words;</span><br><span class="line">    <span class="function">istringstream <span class="title">in</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, n = pattern.<span class="built_in">size</span>(); <span class="comment">// `i` is word count</span></span><br><span class="line">    <span class="keyword">for</span> (string word; in &gt;&gt; word; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n || chars[pattern[i]] != words[word]) <span class="comment">// 检查是否相等</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        chars[pattern[i]] = words[word] = i + <span class="number">1</span>; <span class="comment">// distinct non zero</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i == n; <span class="comment">// 检查长度是否相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="291-Locked"><a href="#291-Locked" class="headerlink" title="291 Locked"></a>291 Locked</h2><h2 id="292-Nim-游戏，每个人可以选择丢掉-1，2，3，最后一个操作者获胜"><a href="#292-Nim-游戏，每个人可以选择丢掉-1，2，3，最后一个操作者获胜" class="headerlink" title="292 Nim 游戏，每个人可以选择丢掉 1，2，3，最后一个操作者获胜"></a>292 Nim 游戏，每个人可以选择丢掉 1，2，3，最后一个操作者获胜</h2><p>显然，当我们遇到 4 的时候会输，其他情况都可以赢。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">canWinNim</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300 最长递增子序列"></a>300 最长递增子序列</h2><p>最经典的动态规划题目</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(*dp)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="344-翻转字符串"><a href="#344-翻转字符串" class="headerlink" title="344 翻转字符串"></a>344 翻转字符串</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* start = s;</span><br><span class="line">    <span class="type">char</span>* e = s;</span><br><span class="line">    <span class="keyword">while</span> (*e) ++e;</span><br><span class="line">    e--;</span><br><span class="line">    <span class="type">char</span> t;</span><br><span class="line">    <span class="keyword">while</span> (s &lt; e) &#123;</span><br><span class="line">        t = *s;</span><br><span class="line">        *s = *e;</span><br><span class="line">        *e = t;</span><br><span class="line">        s++;</span><br><span class="line">        e--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="347-出现最多的几个数字"><a href="#347-出现最多的几个数字" class="headerlink" title="347 出现最多的几个数字"></a>347 出现最多的几个数字</h2><p>C 实在缺乏相关的基础数据结构，这道题用 JS 做了</p>
<details>
    <summary>JavaScript 解答</summary>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> topKFrequent = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num <span class="keyword">in</span> counter) &#123;</span><br><span class="line">            counter[num]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counter[num] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> bucket = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">in</span> counter) &#123;</span><br><span class="line">        <span class="keyword">let</span> rev_freq = nums.<span class="property">length</span> - counter[num] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rev_freq <span class="keyword">in</span> bucket) &#123;</span><br><span class="line">            bucket[rev_freq].<span class="title function_">push</span>(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bucket[rev_freq] = [num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> rv = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> bc <span class="keyword">of</span> bucket) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! <span class="title class_">Array</span>.<span class="title function_">isArray</span>(bc)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> bc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rv.<span class="property">length</span> == k)</span><br><span class="line">                <span class="keyword">return</span> rv;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rv.<span class="title function_">push</span>(<span class="built_in">parseInt</span>(num))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="349-两个数组中都出现的元素"><a href="#349-两个数组中都出现的元素" class="headerlink" title="349 两个数组中都出现的元素"></a>349 两个数组中都出现的元素</h2><p>先排序，降低复杂度</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)a - *(<span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* <span class="title function_">intersection</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> m, <span class="type">int</span>* B, <span class="type">int</span> n, <span class="type">int</span>* k)</span> &#123;</span><br><span class="line">    qsort(A, m, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line">    qsort(B, n, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line">    <span class="type">int</span>* C = <span class="built_in">malloc</span>((m + n) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == B[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*k == <span class="number">0</span>)</span><br><span class="line">                C[(*k)++] = A[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (C[*k - <span class="number">1</span>] != A[i])</span><br><span class="line">                C[(*k)++] = A[i];</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[i] &lt; B[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="345-翻转一个字符串里面的元音字母"><a href="#345-翻转一个字符串里面的元音字母" class="headerlink" title="345 翻转一个字符串里面的元音字母"></a>345 翻转一个字符串里面的元音字母</h2><p>使用两个指针，不过需要注意元音字母包括了大小写</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseVowels</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        vowels = <span class="built_in">set</span>(<span class="string">&quot;AEIOUaeiou&quot;</span>)</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> vowels <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> vowels <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            s[i], s[j] = s[j], s[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="371-两个数之和"><a href="#371-两个数之和" class="headerlink" title="371 两个数之和"></a>371 两个数之和</h2><p>这道题要求不用 + 和 - 来计算出两个数之和，显然应该使用位运算，使用异或计算每一位的值，在使用或计算是否需要进位</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> last_bit_of_a = a &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> last_bit_of_b = b &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        rv |= (last_bit_of_a ^ last_bit_of_b ^ carry) &lt;&lt; i;</span><br><span class="line">        carry = (carry &amp; last_bit_of_a) | (carry &amp; last_bit_of_b) | (last_bit_of_a &amp; last_bit_of_b);</span><br><span class="line"></span><br><span class="line">        a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="388"><a href="#388" class="headerlink" title="388"></a>388</h2><p>使用栈的一道简单题目, 其实计算长度部分还可以优化</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthLongestPath</span>(<span class="params">self, <span class="built_in">input</span>: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        path = []</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">input</span>.split(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">            l = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> name:</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">&quot;\t&quot;</span>:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; l:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(path) - l):</span><br><span class="line">                    path.pop()</span><br><span class="line">            path.append(name.strip(<span class="string">&quot;\t&quot;</span>))</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;.&quot;</span> <span class="keyword">in</span> name:</span><br><span class="line">                length = <span class="built_in">sum</span>([<span class="built_in">len</span>(p) <span class="keyword">for</span> p <span class="keyword">in</span> path]) + <span class="built_in">len</span>(path) - <span class="number">1</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, length)</span><br><span class="line">                <span class="built_in">print</span>(path)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435 无重叠区间"></a>435 无重叠区间</h2><p>不要被题目迷惑，从反面开始思考，求去除多少个区间其实就是求最多有多少个有效区间</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eraseOverlapIntervals</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">        max_intervals = <span class="number">0</span></span><br><span class="line">        end = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> interval[<span class="number">0</span>] &gt;= end:</span><br><span class="line">                max_intervals += <span class="number">1</span></span><br><span class="line">                end = interval[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(intervals) - max_intervals</span><br></pre></td></tr></table></figure>
</details>


<h2 id="482-注册码格式化"><a href="#482-注册码格式化" class="headerlink" title="482 注册码格式化"></a>482 注册码格式化</h2><p>要求每 K 个字符添加一个 “-“, 如果不够的话，第一个分组可以不全。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">licenseKeyFormatting</span>(<span class="params">self, S: <span class="built_in">str</span>, K: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        key = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">reversed</span>(S):</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            key.append(c.upper())</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i % K == <span class="number">0</span>:</span><br><span class="line">                key.append(<span class="string">&quot;-&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">and</span> key[-<span class="number">1</span>] == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">            key = key[:-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="built_in">reversed</span>(key))</span><br></pre></td></tr></table></figure>
</details>


<h2 id="547-朋友圈"><a href="#547-朋友圈" class="headerlink" title="547 朋友圈"></a>547 朋友圈</h2><p>UnionFind 的定义见第 200 题</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findCircleNum</span>(<span class="params">self, M: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(M)</span><br><span class="line">        uf = UnionFind(n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> M[i][j] == <span class="number">1</span>:</span><br><span class="line">                    uf.union(i, j)</span><br><span class="line">        <span class="keyword">return</span> uf.count</span><br></pre></td></tr></table></figure>
</details>


<h2 id="739"><a href="#739" class="headerlink" title="739"></a>739</h2><p>单调栈的简单应用</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, T: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = []</span><br><span class="line">        ans = [<span class="number">0</span>] * <span class="built_in">len</span>(T)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(T)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 如果当前温度大于当前最低温度</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> T[i] &gt;= T[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                ans[i] = stack[-<span class="number">1</span>] - i</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<h2 id="864-矩形重叠"><a href="#864-矩形重叠" class="headerlink" title="864 矩形重叠"></a>864 矩形重叠</h2><details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isRectangleOverlap</span>(<span class="params">self, rec1: <span class="type">List</span>[<span class="built_in">int</span>], rec2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 注意要包含等于号</span></span><br><span class="line">        x_overlap = <span class="keyword">not</span>(rec1[<span class="number">0</span>] &gt;= rec2[<span class="number">2</span>] <span class="keyword">or</span> rec1[<span class="number">2</span>] &lt;= rec2[<span class="number">0</span>])</span><br><span class="line">        y_overlap = <span class="keyword">not</span>(rec1[<span class="number">1</span>] &gt;= rec2[<span class="number">3</span>] <span class="keyword">or</span> rec1[<span class="number">3</span>] &lt;= rec2[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> x_overlap <span class="keyword">and</span> y_overlap</span><br></pre></td></tr></table></figure>
</details>



<h2 id="904-找出包含了两个不同数字的最长子序列"><a href="#904-找出包含了两个不同数字的最长子序列" class="headerlink" title="904 找出包含了两个不同数字的最长子序列"></a>904 找出包含了两个不同数字的最长子序列</h2><p>这道题的题目很坑爹，但是翻译过来其实要求很明确。解题思路也很简单，存储一下当前的最长序列<br>就好了。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;Rust 解答&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```Rust</span><br><span class="line">use std::collections::HashMap;</span><br><span class="line">use std::cmp::max;</span><br><span class="line"></span><br><span class="line">impl Solution &#123;</span><br><span class="line">    <span class="function">pub fn <span class="title">total_fruit</span><span class="params">(tree: Vec&lt;i32&gt;)</span> -&gt; i32 </span>&#123;</span><br><span class="line">        let mut i = <span class="number">0</span>;</span><br><span class="line">        let mut res = <span class="number">0</span>;</span><br><span class="line">        let mut counter = HashMap::<span class="built_in">new</span>();</span><br><span class="line">        <span class="keyword">for</span> (j, el) in tree.<span class="built_in">iter</span>().<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">            *counter.<span class="built_in">entry</span>(el).<span class="built_in">or_insert</span>(<span class="number">0</span>) += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> counter.<span class="built_in">len</span>() &gt; <span class="number">2</span> &#123;</span><br><span class="line">                *counter.<span class="built_in">get_mut</span>(&amp;tree[i]).<span class="built_in">unwrap</span>() -= <span class="number">1</span>;</span><br><span class="line">                <span class="function"><span class="keyword">if</span> let <span class="title">Some</span><span class="params">(x)</span> </span>= counter.<span class="built_in">get</span>(&amp;tree[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> *x == <span class="number">0</span> &#123;</span><br><span class="line">                        counter.<span class="built_in">remove</span>(&amp;tree[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res as i32</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="986-区间列表的交集"><a href="#986-区间列表的交集" class="headerlink" title="986 区间列表的交集"></a>986 区间列表的交集</h2><p>tags: #interval</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intervalIntersection</span>(<span class="params">self, A: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], B: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(A) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(B):</span><br><span class="line">            lo = <span class="built_in">max</span>(A[i][<span class="number">0</span>], B[j][<span class="number">0</span>])</span><br><span class="line">            hi = <span class="built_in">min</span>(A[i][<span class="number">1</span>], B[j][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> lo &lt;= hi:</span><br><span class="line">                ans.append((lo, hi))</span><br><span class="line">            <span class="keyword">if</span> A[i][<span class="number">1</span>] &lt; B[j][<span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<h2 id="929-唯一邮件地址"><a href="#929-唯一邮件地址" class="headerlink" title="929 唯一邮件地址"></a>929 唯一邮件地址</h2><p>类似 Gmail 的规则，<code>.</code> 去掉，<code>+</code> 后面的也去掉。但是要注意域名中的 <code>.</code> 不能去掉</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">normalize</span>(<span class="params">self, username: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        username = username.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="comment"># 使用 split 更好，懒得改了</span></span><br><span class="line">        username = re.sub(<span class="string">r&quot;\+.*$&quot;</span>, <span class="string">&quot;&quot;</span>, username)</span><br><span class="line">        <span class="keyword">return</span> username</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numUniqueEmails</span>(<span class="params">self, emails: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        unique_emails = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> email <span class="keyword">in</span> emails:</span><br><span class="line">            username, domain = email.split(<span class="string">&quot;@&quot;</span>)</span><br><span class="line">            username = self.normalize(username)</span><br><span class="line">            <span class="comment"># print(username, domain)</span></span><br><span class="line">            unique_emails.add(<span class="string">f&quot;<span class="subst">&#123;username&#125;</span>@<span class="subst">&#123;domain&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(unique_emails)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="970-强力数字"><a href="#970-强力数字" class="headerlink" title="970 强力数字"></a>970 强力数字</h2><p>暴力解法</p>
<details>
    <summary>python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">powerfulIntegers</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span>, bound: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> bound &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = <span class="built_in">set</span>()</span><br><span class="line">        limit = <span class="built_in">int</span>(math.log2(bound)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(limit):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(limit):</span><br><span class="line">                v = x ** i + y ** j</span><br><span class="line">                <span class="keyword">if</span> v &lt;= bound:</span><br><span class="line">                    ans.add(v)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(ans)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="1272-删除区间"><a href="#1272-删除区间" class="headerlink" title="1272 删除区间"></a>1272 删除区间</h2><details>
    <summary>python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeInterval</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], toBeRemoved: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        lo, hi = toBeRemoved</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> y &lt; lo <span class="keyword">or</span> x &gt; hi:</span><br><span class="line">                ans.append([x, y])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> lo &gt; x:</span><br><span class="line">                    ans.append([x, lo])</span><br><span class="line">                <span class="keyword">if</span> hi &lt; y:</span><br><span class="line">                    ans.append([hi, y])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<h2 id="1317-将整数转换为两个无零整数的和"><a href="#1317-将整数转换为两个无零整数的和" class="headerlink" title="1317 将整数转换为两个无零整数的和"></a>1317 将整数转换为两个无零整数的和</h2><details>
    <summary>python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNoZeroIntegers</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            b = n - a</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;0&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(a) <span class="keyword">and</span> <span class="string">&quot;0&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(b):</span><br><span class="line">                <span class="keyword">return</span> [a, b]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
</details>


<h2 id="1389-按既定顺序创建目标数组"><a href="#1389-按既定顺序创建目标数组" class="headerlink" title="1389 按既定顺序创建目标数组"></a>1389 按既定顺序创建目标数组</h2><details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createTargetArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], index: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        target = []</span><br><span class="line">        <span class="keyword">for</span> n, i <span class="keyword">in</span> <span class="built_in">zip</span>(nums, index):</span><br><span class="line">            target = target[:i] + [n] + target[i:]</span><br><span class="line">        <span class="keyword">return</span> target</span><br></pre></td></tr></table></figure>
</details>


<h2 id="1390-四因数"><a href="#1390-四因数" class="headerlink" title="1390 四因数"></a>1390 四因数</h2><p>解释见注释，这道题还是很坑的。不过其实也很简单，四个因数就是能够分解成两个质数乘积或者是立方数。</p>
<p>比如：</p>
<ol>
<li>21 &#x3D; 3 * 7</li>
<li>8 &#x3D; 2 * 4</li>
</ol>
<details>
    <summary>py 解答</summary>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumFourDivisors</span>(<span class="params">self, nums</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            upper = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            upper = <span class="built_in">max</span>(*nums)</span><br><span class="line">        <span class="comment"># 首先在这里筛选素数</span></span><br><span class="line">        isPrim = [<span class="literal">True</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(upper)]</span><br><span class="line">        i = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> i * i &lt; upper:</span><br><span class="line">            <span class="keyword">if</span> isPrim[i]:</span><br><span class="line">                j = i * i</span><br><span class="line">                <span class="keyword">while</span> j &lt; upper:</span><br><span class="line">                    isPrim[j] = <span class="literal">False</span></span><br><span class="line">                    j += i</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 把素数都提取出来</span></span><br><span class="line">        prims = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, upper) <span class="keyword">if</span> isPrim[i]]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> prim <span class="keyword">in</span> prims:</span><br><span class="line">                <span class="comment"># 已经不可能了，后续不算了</span></span><br><span class="line">                <span class="keyword">if</span> prim * prim &gt; num:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 立方数是符合的，这个比较坑，开始没想到，比如 8</span></span><br><span class="line">                <span class="keyword">if</span> prim * prim * prim == num:</span><br><span class="line">                    ans += (<span class="number">1</span> + num + prim + prim * prim)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 可以分解成两个质数乘积</span></span><br><span class="line">                <span class="keyword">if</span> num % prim == <span class="number">0</span> <span class="keyword">and</span> isPrim[num // prim] <span class="keyword">and</span> prim * prim != num:</span><br><span class="line">                    ans += (<span class="number">1</span> + num + prim + num // prim)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>




<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></h6></h6>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Blog/2022/03/05/Reverse-Interview/" rel="prev" title="Reverse Interview">
      <i class="fa fa-chevron-left"></i> Reverse Interview
    </a></div>
      <div class="post-nav-item">
    <a href="/Blog/2022/03/12/%E9%9D%9E%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98%E5%9B%9E%E7%AD%94%E6%96%B9%E7%95%A5/" rel="next" title="非技术问题回答方略">
      非技术问题回答方略 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">编者：艾孜尔江



一、编程之美1.2 中国象棋将帅问题123456789struct {    unsigned char a:4;    unsigned char b:4;};for (i.a &#x3D; 1; i.a &lt;&#x3D; 9; i.a++)    for (i.b &#x3D; 1; i.b &lt;&#x3D; 9; i.b++)        if (i.a % 3 !&#x3D; i.b % 3)            printf(&quot;%u:%u&quot;, i.a, i.b);

1.14 连连看1234567891011121314Grid* preClick &#x3D; NULL, * curClick &#x3D; NULL;while(true) {    &#x2F;&#x2F; listen user event    if (点击格子 xy 非空) {        preClick &#x3D; curClick;        curClick.pos &#x3D; x, y;    }    if (preClick &amp;&amp; curClick &amp;&amp; findPath(preClick, curClick)) {        显示路径        消去        preClick &#x3D; curClick &#x3D; NULL;    }}

2.1 - 2.6 LeetCode2.7 最大公约数辗转相除法，如果一个数能够整除x,y，那么他也能够整除x,x%y。
12345int gcd(int x, int y) {    if (y &#x3D;&#x3D; 0)        return x;    return gcd(y, x % y);}

1234567891011121314151617181920&#x2F;&#x2F; iterativeint gcd(int x, int y) {    while (y) {        int t &#x3D; x;        x &#x3D; y        y &#x3D; t % y;    }    return x;}取模运算开销较大，但如下方法在y比较小时，求解次数过多，容易溢出&#96;&#96;&#96;Cint gcd(int x, int y) {    if (x &lt; y)        return gcd(y, x);    if (y &#x3D;&#x3D; 0)        return x;    return gcd(x - y, y);}

12345678910111213141516int gcd(int x, int y) {    if (x &lt; y)        return gcd(y, x);    if (y &#x3D;&#x3D; 0)        return x;    if (x &amp; 0x1 &#x3D;&#x3D; 0)        if (y &amp; 0x1 &#x3D;&#x3D; 0)            return gcd(x&gt;&gt;1, y&gt;&gt;1) &lt;&lt; 1;        else            return gcd(x &gt;&gt;1, y);    else        if (y &amp; 0x1 &#x3D;&#x3D; 0)            return gcd(x, y&gt;&gt;1);        else            return gcd(y, x-y);}




2.8 看下讲解2.9 斐波那契数列使用动态规划(Memoization)的算法不在赘述O(n)。
O(logn)的解法
通项公式
f(n), f(n-1) &#x3D; (f(n-1), f(n-2)) * A

A &#x3D; |1  1|
    |1  0| 

f(n), f(n-1) &#x3D; (f(n-1), f(n-2)) * A &#x3D; ... &#x3D; (f1, f0) * A^(n-1)

下面我们计算A^n-1，太简单了，使用A^(2n) &#x3D; A^n * A^n
12345678910111213141516&#x2F;&#x2F; pesudo codeint fib(int n) {    Matrix factor &#x3D; matrixPow(A, n-1);    return f1*factor + f0*factor;}Matrix matrixPow(Matrix m, int n) {    Matrix result &#x3D; Matrix::Identity;    while (n) {        if (n &amp; 1)            result *&#x3D; m;        m *&#x3D; m;        n &gt;&gt;&#x3D; 1;    }    return result;}

拓展问题，如果是前三项相加的数列呢，依然可以求出转移矩阵
2.11 最近点对问题2.12-2.14 LeetCode 2.15 Cracking 2.16 2.17 LeetCode2.18 数组分割2.19 LeetCode3.1 有时间可以尝试写一下3.2 电话号码对应英文单词递归写法
3.3 Edit Distance3.4 删除链表节点3.5 最短摘要的生成问题转化为，在一个单词词组中，找出包含所有给定单词的最短区间。
1234567891011121314151617181920212223pair&lt;int, int&gt; abstract(vector&lt;string&gt; article, unordered_set&lt;string&gt; keywords) {    int start &#x3D; 0, end &#x3D; 0, range &#x3D; INT_MAX;    unordered_map&lt;string, int&gt; indecies;    unordered_set&lt;string&gt; having;    pair&lt;int, int&gt; result;    while (end &lt; article.size()) {        while (end &lt; article.size() &amp;&amp; !isContain(keywords, having)) {            indecies[articel[end]] &#x3D; end;            end++;        }        while (isContain(keywords, having)) {            if (end - start + 1 &lt; range) {                range &#x3D; end - start + 1;                result.first &#x3D; start;                result.second &#x3D; end;            }            if (indecies[aritcle[start]] &#x3D;&#x3D; start)                having.erase[article[start]];            start++;        }    }    return result;}

3.6 判断两个链表是否相交如果链表中有环呢？
3.7 队列中取最大值使用连个minstack模拟队列
3.8 二叉树中两个节点之间的最远距离显然，对一个根节点，最远距离有两种情况：

左子树或者右子树中的最远距离
左子树最长路径＋有子树最长路径+1

123456789101112131415161718192021typedef struct {    int max_distance;    int max_depth;} result_t;&#x2F;&#x2F; get max distance of two nodes in a treeresult_t get_max(tree_node_t* root) {    result_t result;    if (!root) {        result.max_distance &#x3D; 0;        result.max_depth &#x3D; -1;        return result;    }    result_t left &#x3D; get_max(root-&gt;left);    result_t right &#x3D; get_max(root-&gt;right);    result.max_depth &#x3D; max(left.max_depth, right.max_depth) + 1;    result.max_distance &#x3D; max(max(left.max_distance, right.max_distance), left.max_depth + right.max_depth + 2);    return result;}

对于递归问题，书上的心得：

在递归的实现中，往往假设后续的调用已经完成，在此基础上，才能实现递归的逻辑。
分析清楚递归体的逻辑。
考虑清楚递归退出的边界条件，也就是return的地方。

3.9 重建二叉树拓展问题，如何判断前序遍历和中序遍历是合理的？
测试用例：非完全二叉树，退化的二叉树，满二叉树，普通二叉树，空树。。。
3.10 层序遍历注意把LeetCode上的ZigZag层序都看一遍。
递归的遍历需要先计算level
3.11 注意问题对于询问知识点，要答得正确，有条理。最后写出来的程序已定要是没有严重错误，完整，并尝试用一些测试用例。
4.1 金刚询问李博士
4.2 瓷砖覆盖地板斐波那契额数列
1x2覆盖8x8？从小到大，先找出2x2有多少种，再找出4x4有多少种，再找出8x8有多少种。还有考虑好多种，注意不要有重复pxq覆盖mxn？
4.3  Catalan数4.4 点是否在三角形内部给定 ABC，逆时针顺序，判断 D 是否在 ABC 内部
1234567891011121314&#x2F;&#x2F; 利用面积，如果 D 和 ABC 分别构成的三角形的面积小于 ABC 的面积，那么 D 在三角形内部double area(Point A, Point B, Point, C) {    double a, b, c;    b &#x3D; distance(A, C);    a &#x3D; distance(B, C);    c &#x3D; distance(A, B);    double p &#x3D; (a + b + c) &#x2F; 2;    return sqrt((p-a) * (p-b) * (p-c) * p);}bool isInTriangle(A, B, C, D) {    return area(A, B, D) + area(A, C, D) + area(B, C, D) &lt;&#x3D; area(A, B, C);} 

12345678&#x2F;&#x2F; 根据角度考虑，如果两个向量叉积为正，那么 P3 在P1P2的左边，如果一个点同时在 AB，BC，CA 的左边double cross(Point A, Point B, Point X) {    return (B.x - A.x) * (X.y - A.y) - (X.x - A.x) * (B.y - A.y);}bool isInTriangle(A, B, C, D) {    return cross(A, B, D) &gt;&#x3D; 0 &amp;&amp; cross(B, C, D) &gt;&#x3D; 0 &amp;&amp; cross(C, A, D) &gt;&#x3D; 0;}

4.5 磁带文件存储优化只考虑长度，按照文件长度由短到长存放。只考虑访问频率，按照访问频率由高到低存放。综合考虑，按照频率&#x2F;长度由高到低
4.6 桶中取黑白球相当于使用 XOR，可以解任意问题
4.7 蚂蚁爬杆相当于穿越
4.8 三角形测试用例int isTriangle(int a, int b, int c);

用一个字节编码各种情况。

用不同的位表示不同的结果，注意要正交

测试用例

合法输入，各种三角形的形状，以及不是三角形的，还需要考虑交换不同边的顺序；

非法输入，负数，0，类型错误等等；

边界值，一般程序可能在&lt; &lt;&#x3D; &gt; &gt;&#x3D;上犯错误；

很大的数，很小的数，等等。




一般需要给出15-20个用例
4.10 数字哑谜列出方程，使用深度优先搜索，注意剪枝
4.11 扫雷游戏的概率



二、C&#x2F;C++基本算法考点1.1 确定一个字符串中所有数字是否完全不同首先应该询问面试官字符集的大小，是ASCII还是Unicode还是GBK，对于ASCII和GBK，因为字符集大小有限，而且都不太大，可以使用一个数组统计，而对于Unicode，显然只能使用Hash统计
1234567891011bool isUniqueChars(const string&amp; s) {    if (s.size() &gt; 256) return false;    vector&lt;bool&gt; charSet(256);    for (auto c : s)        if (charSet[s])            return false;        else            charSet[c] &#x3D; true;    return true;}

注意：还可以使用位向量提高效率，但是C++的vector本身就是特质化的。
1.2 实现reverse(char* s)123456789101112void reverse(char* s) {    if (!s) return;    char* end &#x3D; s;    while (*end++) ;    end--; &#x2F;&#x2F; back one    while (s &lt; end) {        char t &#x3D; *s;        *s++ &#x3D; *end;        *end-- &#x3D; t;    }}

1.3 判断两个词是否是变位词(Anagram)1.4 编写一个方法，将字符串中的空格全部替换为%20，假设字符串结尾有足够空间对于数组操作的好多题目，尝试从尾部做起一下子就简单多了。
1234567891011121314151617181920void replaceSpaces(char* s, int len) {    int spaceCount &#x3D; 0, newLength &#x3D; 0;    for (int i &#x3D; 0; i &lt; len; i++)        if (isspace(s[i]))            newLength++;    newLength &#x3D; len + spaceCount * 2;    s[newLength] &#x3D; &#39;\0&#39;;    for (int i &#x3D; len - 1; i &gt;&#x3D; 0; i--) {        if (isspace(s[i])) {            s[--newLength] &#x3D; &#39;0&#39;;            s[--newLength] &#x3D; &#39;2&#39;;            s[--newLength] &#x3D; &#39;%&#39;;        } else {            s[--newLength] &#x3D; s[i];        }    }}

1.5 压缩字符串 aabcccccaaa -&gt; a2b1c5a3如果压缩后变短，返回压缩后的字符串首先要计算出新的长度，然后比较是否变短，如果变短，则执行压缩，否则返回
1.6 给定一幅由N＊N矩阵表示的图像，顺时针旋转90度1.7 若m＊n矩阵中某个元素为0，就把这一行和这一列都清零LeetCode 73 注意同样可以使用位向量提高效率
1.8 给定方法isSubstring()，判断s1是不是可以由s2旋转组成假设s1 &#x3D; xy, s2 &#x3D; yx，yx一定是xyxy的字串，而且是中间部分。注意先判断长度，提高效率
1234567bool isRotation(string&amp; s1, string&amp; s2) {    if (s1.size() !&#x3D; s2.size())        return false;    string s1s1 &#x3D; s1 + s1;    return isSubstring(s1s1, s2);}

2.1 移除未排序列表中的重复节点因为是无序的，所以我们还是需要记录重复节点
123456789101112131415&#x2F;&#x2F; 显然第一个节点是不可能被移除的，所以不用返回新的头部void removeDuplicates(ListNode* head) {    unordered_set&lt;int&gt; vals;    ListNode dummy, *p &#x3D; dummy;    dummy.next &#x3D; head;    while (p-&gt;next) {        if (vals.find(p-&gt;next-&gt;val) !&#x3D; vals.end())            ListNode* next &#x3D; p-&gt;next;            p-&gt;next &#x3D; next-&gt;next;            free(next);        } else {            vals.insert(p-&gt;next-&gt;val);        }    }}

如果不允许使用额外空间，那么这个功能至少需要O(N^2)实现
2.2 实现一个算法，找出链表中倒数第K个元素2.3 删除单向链表中的某个节点，假设你只有访问该节点的权限2.4 以给定的值x分割列表，使得小于x的元素都排在x的前面LeetCode 83
2.5 给定一个链表，每个链表节点存放一位数字，并且是反向存放的，求两个链表的和LeetCode 2
如果是正向存放的呢？
先求出两个列表的长度，然后用零填充一个较短的链表，然后在从前往后相加。
2.6 给定一个有环链表，找到环的开头LeetCode 141 142
2.7 判断链表是否是回文(Palindrome)LeetCode 234
3.1 如何用一个数组实现3个栈如果是实现两个堆栈，可以把两头作为栈底，向中间生长。
解法1: 固定分割，显然这样是不能让面试官满意的。。
解法2: 弹性分割，并把数组看成是环状的！
3.2 设计一个栈，支持min方法，返回栈中的最小值LeetCode 155
3.3 实现SetOfStacks，由多个栈组成这实际上是一道OOD(面向对象设计)的题目
3.4 汉诺塔经典问题了，考虑 n＝2的时候，把上面1块放到中间，然后把下面一块移动完成。那么对于n，我们把n-1块移到中间即可
12345678void moveDisks(int n, tower_t origin, tower_t dest, tower_t buffer) {    if (n &lt;&#x3D; 0) return;    moveDisks(n-1, origin, buffer, dest); &#x2F;&#x2F; 先把上面的n-1块放到中间    moveBottom(origin, dest) &#x2F;&#x2F; 把最底下的盘子直接放过去    moveDisks(n-1, buffer, dest, origin) &#x2F;&#x2F; 把中间的再放到最后}

3.5 使用两个栈模拟一个队列3.6 对栈进行排序，额外的数据只能使用栈使用简单插入排序，在一个新的栈中保存排序好的数据，从unsorted中弹出以后，不断弹出sorted为新元素找到正确位置
12345678910111213stack&lt;int&gt; sortStack(const stack&lt;int&gt;&amp; unsorted) {    stack&lt;int&gt; sorted;    while (!unsorted.empty()) {        int temp &#x3D; unsorted.top(); &#x2F;&#x2F; 待插入的新元素        unsorted.pop();        while (!sorted.empty() &amp;&amp; sorted.top() &gt; temp) { &#x2F;&#x2F; 不断弹出，找到合适位置            int big &#x3D; sorted.top(); sorted.pop();            unsorted.push(big);        }        sorted.push(temp); &#x2F;&#x2F; 插入新元素    }    return sorted;}



4.1 检查二叉树是否平衡: 任意两个节点之间的高度差不超过14.2 给定一个有向图，找出两个节点之间是否存在一条路径
碰到这类问题，有必要和面试官探讨一下DFS和BFS之间的利弊，例如，DFS实现起来比较简单，只需要简单的递归即可。BFS适合用来查找最短路径。而DFS在访问临近借点之前可能会深度便利其中一个临近节点

🌲的遍历一定要注意visited数组或者集合，因为树中可能有几个节点指向同一个节点
123456789101112131415161718bool search(Graph* graph, Node* start, Node* end) {    queue&lt;Node*&gt; q;    unordered_set&lt;Node*&gt; visited;    q.push(start);    while(!q.empty()) {        auto node &#x3D; q.pop();        for (auto adj : q.adjs())            if (visited.find(adj) &#x3D;&#x3D; visited.end())                if (adj &#x3D;&#x3D; end)                   return true;                else                    q.push(adj);    }    return false;}
4.3 给定一个有序数组，元素各不相同且按升序排列，创建一颗高度最小的二叉查找树LeetCode 108
4.4 给定一棵二叉树，创建层序访问的链表LeetCode 102
4.5 检查一棵二叉树是否为二叉查找树LeetCode 98
4.6 找到二叉查找树指定节点的下一个节点(中序后继)，假设每个节点都有指向父节点的指针按照中序遍历，左子树，当前节点，右子树，显然下一个节点应该在右边。也就是右子树中最左边的节点。考虑没有右子树的情况，如果当前节点是左子节点，下一个节点应该是父节点。如果是右节点，我们继续向上，如果到达了root，显然没有更多节点了。
对于树这种可以分情况的最好先把各种情况想好了，在写代码。
12345678910111213141516TreeNode* inorderSucc(TreeNode* n) {    if (!n) return NULL;    if (n-&gt;right) {        TreeNode* right &#x3D; n-&gt;right;        while (right-&gt;left)            right &#x3D; right-&gt;left;        return right;    } else {        TreeNode* q &#x3D; n, * parent &#x3D; q.parent;        while (parent &amp;&amp; parent-&gt;left !&#x3D; q) { &#x2F;&#x2F; 找到当前节点可以作为左子节点的父节点            q &#x3D; parent;            parent &#x3D; parent-&gt;parent;        }        return parent;    }}

4.7 查找二叉树的公共祖先LeetCode 236
4.8 又两棵非常大的二叉树：T1 有几百万个节点，T2，有几百个节点。判断T2是否是T1的子树这道题并没有标准解法。值得和面试官探讨，详见树上的讲解（161页）。
4.9 打印节点数值总和为给定值的路径，路径可以从任意节点开始，任意节点结束对于一个没有见过的问题，可以先简化，然后在推广。假设路径必须从root开始，那很简单。如果路径可以从任意节点开始，那么我们需要向上检查是否得到了相符的总和，而不能假定root是起点
12345678910111213141516171819202122232425void findSum(TreeNode* root, int sum) {    int depth &#x3D; depth(root);    vector&lt;int&gt; path(depth);    findSum(root, sum, path, 0);}void depth(TreeNode* root) {    if (!root) return 0;    return max(depth(root-&gt;left), depth(root-&gt;right)) + 1;}void findSum(TreeNode* root, int sum, vector&lt;int&gt; path, int level) {    if (!root)        return;    path[level] &#x3D; root-&gt;val;    for (int i &#x3D; level, t&#x3D; 0; i &gt;&#x3D; 0; i--) {        t +&#x3D; path[i];        if (t &#x3D;&#x3D; sum)            print(path, i ,level); &#x2F;&#x2F; printing out path from i to level    }    findSum(root-&gt;left, sum, path, level + 1);    findSum(root-&gt;right, sum, path, level + 1);}

5.1 给定一个数n，和另一个数字m，然后给定区间(i, j)，区间保证可以大于m的二进制长度，把m的二进制表示插入到n的区间内示例：n&#x3D;100&#x2F;000&#x2F;00, m &#x3D; 101, i &#x3D; 2, j &#x3D; 4 -&gt; 100&#x2F;101&#x2F;00

把n中对应位置清零
把m移动到对应的位置
合并

12345678910int merge(int n, int m, int i, int j) {    int left_mask &#x3D; ~0 &lt;&lt; (j+1);    int right_mask &#x3D; (1 &lt;&lt; i) - 1    int mask &#x3D; left_mask | right_mask;    n &amp;&#x3D; mask;    m &lt;&lt;&#x3D; i;    return n | m;}

5.2 给定一个0和1之间的实数，打印他的二进制表示，如果32位以内无法表示，打印error我们知道 (0.101)2 &#x3D; 1 * 2^-1 + 0 * 2^-2 + 1 * 2^-3，我们只要让这个数字不断的乘2，然后看它是否大于1，然后就可以得到第一位是不是1了
1234567891011121314151617181920string printBinary(double num) {    if (num &gt;&#x3D; 1 || num &lt;&#x3D; 0)        return &quot;error&quot;;    string result;    result +&#x3D; &quot;.&quot;;    while (num &gt; 0) {        if (result.size() &gt;&#x3D; 32)            return &quot;error&quot;;        num *&#x3D; 2;        if (num &gt;&#x3D; 1) {            result +&#x3D; &quot;1&quot;;            num -&#x3D; 1;        } else {            result +&#x3D; &quot;0&quot;;        }    }    return result;}

5.3 给定一个正整数，找出和其二进制表示中一的数字相同的数字，并且最接近，一共两个我们需要把某个0反转为1，把某个1反转为0。0 -&gt; 1在1-&gt;0 左边，数字变大，在右边数字变小。如果想变大，反转的0需要在1的左边。
把p位置1；把0到p之间请0；在添加ending1 - 1个1。
1234567891011121314int getNext(int n) {    int c &#x3D; n, ending0 &#x3D; 0, ending1 &#x3D; 0;    while ((c &amp; 1 &#x3D;&#x3D; 0) &amp;&amp; c !&#x3D; 0) {        ending0++;        c &gt;&gt;&#x3D; 1;    }    while (c &amp; 1) {        ending1++;        c &gt;&gt;&#x3D; 1;    }    return n + (1 &lt;&lt; ending0) + (1 &lt;&lt; (ending1 - 1)) - 1;}

把位p值0；把位p右边的位值1，再把0到ending0-1置0
12345678910111213int getPrev(int n) {    int c &#x3D; n, ending0 &#x3D; 0, ending1 &#x3D; 0;    while (c &amp; 1) {        ending1++;        c &gt;&gt;&#x3D; 1;    }    if (c &#x3D;&#x3D; 0) return -1;    while ((c &amp; 1) &#x3D;&#x3D; 0 &amp;&amp; c !&#x3D; 0) {        ending0++;        c &gt;&gt;&#x3D; 1;    }    return n - (1 &lt;&lt; ending1) - (1 &lt;&lt; (ending0 - 1)) + 1;}

5.4 解释n &amp; (n-10) &#x3D;&#x3D; 0LeetCode 231
5.5 A和B之间有多少位不相同&#x2F;需要改变多少位，才能把A变成B使用XOR找出不同的位，然后统计1的个位数。需要注意的是不同的题目
12345678int bitSwapRequired(int a, int b) {    int diff &#x3D; a ^ b, count &#x3D; 0;    while (diff) {        diff &amp;&#x3D; diff - 1;        count++;    }    return count;}

5.6 交换一个整数的奇数位和偶数位这道题很有趣，选取特殊的掩码即可
123456&#x2F;&#x2F; 考虑32bit intint32_t swapBits(int32_t x) {    int32_t odd_bits &#x3D; x &amp; 0xAAAAAAAA; &#x2F;&#x2F; 0xAA as 10101010    int32_t even_bits &#x3D; x &amp; 0x55555555; &#x2F;&#x2F; 0x55 as 01010101    return (odd_bits &gt;&gt; 1) | (even_bits &lt;&lt; 1);}

5.8 单色屏幕存贮在一维字节数组中，每个字节存储八个像素，屏幕宽度为w px，绘制从x1到达x2的水平线显然可以逐bit设定，然而这样是拿不到offer的。更好的做法是逐字节设定。
123456789101112131415161718192021222324252627282930313233void drawHorizentalLine(uint8_t * screen, int width, int x1, int x2, int y) {    int start_offset &#x3D; x1 % 8;    int start_full_byte &#x3D; x1 &#x2F; 8; &#x2F;&#x2F; x1 所在字节    if (start_offset !&#x3D; 0)        start_full_byte++;    int end_offset &#x3D; x2 % 8;    int end_full_byte &#x3D; x2 &#x2F; 8; &#x2F;&#x2F; x2 所在字节    if (end_offset !&#x3D; 7)        end_full_byte--;    &#x2F;&#x2F; 逐字节设定    for (int i &#x3D; start_full_byte; i &lt;&#x3D; end_full_byte; i++)        screen[width &#x2F; 8 * y + i] &#x3D; (uint8_t)0xff;    uint8_t start_mask &#x3D; (uint8_t) (0xff &gt;&gt; start_offset);    uint8_t end_mast &#x3D; (uint8_t) ~(0xff &gt;&gt; end_offset + 1);    if ((x1 &#x2F; 8) &#x3D;&#x3D; (x2 &#x2F; 8)) {        uint8_t mask &#x3D; (uint8_t)(start_mask &amp; end_mask);        screen[(width &#x2F; 8) * y + x1 &#x2F; 8] |&#x3D; mask;    } else {        if (start_offset !&#x3D; 0) {            int byte_number &#x3D; (width &#x2F; 8) * y + start_full_byte - 1;            screen[byte_number] |&#x3D; start_mask;        }        if (end_offset !&#x3D; 7) {            int byte_number &#x3D; (width &#x2F; 8) * y + end_full_byte + 1;            screen[byte_number] |&#x3D; end_mask;        }    }



6.1 给定直角坐标系的两条线，确定他们会不会相交我们知道在二维平面上两条线的关系不外乎：平行，相交，重合。问题是两条线重合算不算相交呢，需要问清楚。对于两条线如何表示，这又是面向对象设计的问题，需要讨论。
123456789101112131415161718class Line {private:    static double EPSILON;    double m_slope; &#x2F;&#x2F; 斜率    double m_y_intercept; &#x2F;&#x2F; y轴交点public:    Line(double s, double y): m_slope(s), m_y_intercept(y) {};    &#x2F;&#x2F; 重合视作相交    bool intersect(const Line&amp; other) {        return abs(slope() - other.slope()) &gt; EPSILON || &#x2F;&#x2F; 斜率不同            abs(y_intercept() - other.y_intercept()) &lt; EPSILON; &#x2F;&#x2F; y轴交点相同    }    double slope() {return m_slope;}    double y_intercept() {return m_y_intercept;}};double Line::EPSILON &#x3D; 0.00001;

遇到这类问题，务必：

多问，面试官可能故意模糊问题
仔细设计数据结构，权衡利弊，和面试官讨论
千万不要用＝＝判定浮点数

6.2 只使用加号实现减法和乘除法12345678910111213141516171819202122232425262728293031int neg(int a) {    int result &#x3D; 0;    int d &#x3D; a &lt; 0 ? 1 : -1;    while (a) {        result +&#x3D; d;        a +&#x3D; d;    }    return result;}int abs(int a) {    return a &gt; 0 ? a : neg(a);}int minus(int a, int b) {    return a + neg(b);}int multiply(int a, int b) {    int sign &#x3D; (a &gt; 0) &#x3D;&#x3D; (b &gt; 0) ? 1 : -1;    a &#x3D; abs(a);    b &#x3D; abs(b);    int result &#x3D; 0;    while (b--)        result +&#x3D; a;    return sign &#x3D;&#x3D; 1 ? result : neg(result);}int devide(int a, int b) {    &#x2F;&#x2F; see leetcode}

6.3 找出第k个丑数LeetCode 264
7.1 小孩上楼梯，楼梯有n阶，小孩可以一次上1，2，3步，请问一共有多少种方法 注意如果只能1或2就是斐波那契数列。
123456789&#x2F;&#x2F; 递归int countSteps(int n) {    static vector&lt;int&gt; steps(1000, 1);    if (n &lt; 0)        return 0;    if (n &gt; 1 &amp;&amp; steps[n] &#x3D;&#x3D; 1)        steps[n] &#x3D; countSteps(n -1) + countSteps(n - 2) + countSteps(n - 3);    return steps[n];}

12345678910111213141516171819&#x2F;&#x2F; 迭代int countSteps(int n) {    int n3 &#x3D; 1; &#x2F;&#x2F; starts from n &#x3D; 0    int n2 &#x3D; 1; &#x2F;&#x2F; starts from n &#x3D; 1    int n1 &#x3D; 2; &#x2F;&#x2F; starts from n &#x3D; 2    if (n &lt; 0)        return 0;    if (n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1)        return 1;    int steps &#x3D; 0;    for (int i &#x3D; 3; i &lt;&#x3D; n; i++) {        steps &#x3D; n3 + n2 + n1;        n3 &#x3D; n2;        n2 &#x3D; n1;        n1 &#x3D; steps;    }    return steps;}

8.1 设计一种算法，机器人只能向右向下移动，从(0, 0)移动到(x, y)有几种走法LeetCode 62 63
9.1 在有序数组A[0…n-1]中存在A[i] &#x3D;&#x3D; i，找出该数字。如果存在重复值，又该如何做12345678910111213int magic(int* A, n) {    int left &#x3D; 0; right &#x3D; n - 1;    while (left &lt;&#x3D; right) {        int mid &#x3D; left + (right - left) &#x2F; 2;        if (A[mid] &#x3D;&#x3D; mid)            return mid;        else if (A[mid] &lt; mid)            left &#x3D; mid + 1;        else            right &#x3D; mid - 1;    }    return -1;}

9.2 返回一个集合的所有子集LeetCode 78
9.3 全排列LeetCode
9.4 生成n对括号的全部有效集合LeetCode
9.5 实现填充颜色功能1234567891011121314151617void paintFill(vector&lt;vector&lt;int&gt;&gt; screen, int x, int y, int color) {    if (screen[y][x] &#x3D;&#x3D; color)        return;    paintFill(screen, int x, int y, screen[y][x], int color);}void paintFill(vector&lt;vector&lt;int&gt;&gt; screen, int x, int y, int start, int color) {    if (x &lt; 0 || x &gt;&#x3D; screen[0].size() || y &lt; 0 || y &gt;&#x3D; screen.size())        return;    if (screen[y][x] &#x3D;&#x3D; start) {        screen[y][x] &#x3D;&#x3D; color;        paintFill(screen, int x-1, int y, start, color);        paintFill(screen, x+1, y, start, color);        paintFill(screen, x, y+1, start, color);        paintFill(screen, x, y-1, start, color);    }}

9.6 给定数量不限的硬币，编写代码计算有几种表示方法12345678910111213141516171819vector&lt;int&gt; makeChange(vector&lt;int&gt; coins, int target) {    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; solution(coins.size(), 0)    make(result, coins, solution, 0, target);    return result; }void make(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; coins, vector&lt;int&gt; solution, int start, int target) {    if (target &lt;&#x3D; 0 || start &gt;&#x3D; coins.size()) {        if (target &#x3D;&#x3D; 0)            result.push_back(solution);        return;    }    for (int i &#x3D; 0; i *coins[start] &lt; target ; i++) {        solution[start] &#x3D; i;        make(result, coins, solution, start + 1, target - i * coins[start]);}}

9.7 N-Queen问题LeetCode
9.8 给你一堆箱子，上面的箱子的长宽高要求小于下面的箱子，实现一个方法，搭出最高的箱子10.1 合并两个有序数组LeetCode 88
11.1 对一个字符串数组排序，把变位词(Anagram)放在一起LeetCode 49
11.2 在已经被旋转过的排序数组中，查找元素LeetCode 81
11.3 有一个20GB的文件，每行一个字符串，如何排序20GB暗示无法放入内存中，把文件分块后，分别载入内存中，采用归并排序
12.1 使用 C++ 写个方法，打印输入文件的最后 K 行使用循环数组，容量设为 K，同时记录当前的最早元素
123456789101112131415void printLastKLines(char* filename) {    const int K &#x3D; 10;    ifstream file(filename);    string lines[K];    int size &#x3D; 0;    while (file.good())        getline(file, lines[size++ % K];    int start &#x3D; size &gt; K ? (size % K) : 0;    int count &#x3D; min(K, size);    for (int i &#x3D; 0; i &lt; count; i++)         cout &lt;&lt; lines[(start + i) % K] &lt;&lt; endl;}


12.2 编写malloc_aligned12.3 malloc2d函数，分配二维数组，返回int**可以通过a[i][j]访问，并且尽量少调用malloc前面rows大小的区域用作存储指针，后面存储数据。
hhh|ddddd|ddddd|ddddd

123456789101112131415void** malloc2d(int rows, int cols) {    int header &#x3D; rows * sizeof(void*);    void** ptr &#x3D; (void**)malloc(header + rows * cols);    if (!ptr)        return NULL;    void* buf &#x3D; (void*)(rawptr + rows);    for (int i &#x3D; 0; i &lt; rows; i++)         ptr[i] &#x3D; buf + i * cols;    return ptr;}void free2d(void** ptr) {    void* p &#x3D; void* p;    free(p);}


12.4 不用中间变量，直接交换两个数字想像把 a 和 b 都放在数轴上，假设 a0，b0分别是初值，那么有 diff &#x3D; a - b。我们把diff 保存在 a 中，然后 b &#x3D; b0 + diff 也就是 a0 ，而再另 a &#x3D; b - diff，也就是 b0。
12345void swap(int&amp; a, int&amp; b) {    a &#x3D; a - b;    b &#x3D; b + a;    a &#x3D; b - a;}

更巧妙的是，我们还可以使用异或 XOR 在解。假设 a &#x3D; a0 ^ b0，那么 b &#x3D; a ^ b0 &#x3D; a0 ^ b0 ^ b0 &#x3D; a0，然后 a &#x3D; a ^ b &#x3D; a0 ^ b0 ^ a0 &#x3D; b0。完美解决！值得注意的是，因为使用异或不考虑变量的实际类型，只是粗暴地按 bit 位交换，因此适用于各种类型。不过值得注意的是千万不要用这种方法去交换变量的值，当x&#x3D;&#x3D;y的时候会有灾难性后果。
123456template&lt;typename T&gt;void swap(T&amp; a, T&amp; b) {    a ^&#x3D; b;    b ^&#x3D; a;    a ^&#x3D; b;}




13.1 n! 结尾有多少个零LeetCode 172
13.2 找出两个数字中较大的一个，但不得使用判断语句判断a&gt;b就是判断a-b的正负号，显然我们可以使用bit运算
1234567int flip(int a) { &#x2F;&#x2F; flip last bit    return 1 ^ a;}int sign(int a) {    return flip((a &gt;&gt; 31) &amp; 0x1);}


13.3 把数字转换为英文单词13.4 把数字转换为汉语句子13.5 数组最大序列和LeetCode 53
13.6 给定产生数字概率相同的rand5()，实现一个方法rand7()，要求产生每个数字的概率相同扩大rand5产生随机数的范围，然后对舍去一定范围的数字，对剩下的数字取模，虽然这样会导致调用次数不固定，但实现了效果对于randx，扩大范围的方法是 x * randx() + randx()
1234567int rand7() {    while (1) {        int num &#x3D; 5 * rand5() + rand5();        if (num &lt; 21)            return num % 7;    }}

该问题可以拓展到对于 x &lt; y，由randx() 构造 randy()
13.7 在数组中找到两个数字，是的他们的和为指定的数字LeetCode 1
13.8 把二叉树转化为双向链表先把二叉树变成一个环形链表，然后再从头部解开即可
123456789101112131415161718192021222324252627282930313233343536373839404142434445void concat(struct tree_node* x, struct tree_node* y) {    x-&gt;right &#x3D; y;    y-&gt;left &#x3D; x;}struct tree_node* convert_circular(struct tree_node* root) {    if (!root)        return NULL;    struct tree_node* left &#x3D; convert_circular(root-&gt;left);    struct tree_node* right &#x3D; convert_circular(root-&gt;right);    if (!left &amp;&amp; !right) {        root-&gt;left &#x3D; root;        root-&gt;right &#x3D; root;        return root;    }    struct tree_node* tail_right &#x3D; right ? right-&gt;left : NULL;    &#x2F;&#x2F; 把左边添加到根部    if (!left)        concat(right-&gt;left, root);    else        concat(left-&gt;left, root);    &#x2F;&#x2F; 把右边添加到根部    if (!right)        concat(root, left);    else        concat(root, right);    &#x2F;&#x2F; 把右边和左边链接    if (left &amp;&amp; right)        concat(tail_right, left);    return left ? left : root;}struct tree_node* convert(struct tree_node* root) {    struct tree_node* head &#x3D; convert_circular(root);    head-&gt;left-&gt;right &#x3D; NULL;    head-&gt;left &#x3D; NULL;    return head;}

14.2 实现加法显然是使用位运算。
12345678int add(int a, int b) {    while (b) {        int sum &#x3D; a ^ b;        int carry &#x3D; (a &amp; b) &lt;&lt; 1;        a &#x3D; sum, b &#x3D; carry;    }    return a;}

15.2 完美洗牌，使得一副牌中任意一种排列出现的概率都相等显然全排列是n!个，那么我们保证每一个全排列都可能出现就好了。
123456void shuffle(int* A, int n) {    for (int i &#x3D; 0; i &lt; n; i++) {        int k &#x3D; rand(i);        swap(A[k], A[i]);    }}

16.1 从n个数组中选出m个，要求被选中概率一样1234vector&lt;int&gt; pink_k(vector&lt;int&gt; nums, int k) {    vector&lt;int&gt; result(k);}

16.2 小于 n 的数字中出现2的个数16.3 矩阵链乘法问题16.4 判断是否是合法地出栈序列参考
16.5 二叉树的非递归遍历参考







三、树的遍历树的递归遍历都非常简单，但是非递归遍历有时候不是很简单。一般做题的时候直接写递归版就行了，但是对于三个基础的遍历方法，有时候会要求写迭代版本，基本就是花式用栈就行了。
前序遍历递归版12345class Solution:    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:        if root is None:            return []        return [root.val, *self.preorderTraversal(root.left), *self.preorderTraversal(root.right)]

非递归版使用栈做了一个顺序的反转。
123456789101112131415class Solution:    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:        if not root:            return []        ans &#x3D; []        stack &#x3D; []        stack.append(root)        while stack:            node &#x3D; stack.pop()            ans.append(node.val)            if node.right:                stack.append(node.right)            if node.left:                stack.append(node.left)        return ans

中序遍历递归版12345class Solution:    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:        if root is None:            return []        return [*self.inorderTraversal(root.left), root.val, *self.inorderTraversal(root.right)]

非递归版12345678910111213141516class Solution:    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:        if root is None:            return []        ans &#x3D; []        stack &#x3D; []        node &#x3D; root        while stack or node:            while node:                stack.append(node)                node &#x3D; node.left            left &#x3D; stack.pop()            ans.append(left.val)            if left.right:                node &#x3D; left.right        return ans

后续遍历LeetCode 145
递归版12345class Solution:    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:        if root is None:            return []        return [*self.postorderTraversal(root.left), *self.postorderTraversal(root.right), root.val]

非递归版这个方法还是有点 trick 的，类似于前序遍历，但是把左右子树反过来了，最后再翻转一遍，就变成了后序遍历。
123  1 &#x2F; \2   3

比如：前序遍历是 123, 现在这种遍历方式是 132, 在翻转一次正好是 231, 也就是后续遍历了。
1234567891011121314class Solution:    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:        if root is None:            return []        ans &#x3D; []        stack &#x3D; [root]        while stack:            node &#x3D; stack.pop()            ans.append(node.val)            if node.left:                stack.append(node.left)            if node.right:                stack.append(node.right)        return list(reversed(ans))

参考资料
https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;binary-tree-preorder-traversal&#x2F;solution&#x2F;leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2&#x2F;












四、LeetCode 突击手册一共定义了几个标签，可以通过 Ctrl+F&#x2F;Cmd+F 搜索这些标签还快速浏览相同的题目。
标签：#hash #backtracking #slidewindow #stack #queue #pointers
1 从数组中找出两个数字使得他们的和是给定的数字tags: #hash
使用一个散列，存储数字和他对应的索引。然后遍历数组，如果另一半在散列当中，那么返回这两个数的索引，程序结束；如果不在，把当前数字加入到散列中。

    C++ 解答

1234567891011121314vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {    unordered_map&lt;int, int&gt; hash;    vector&lt;int&gt; result(2);    for (int i &#x3D; 0; i !&#x3D; nums.size(); ++i) {        int reminder &#x3D; target - nums[i];        if (hash.find(reminder) !&#x3D; hash.end()) {            result[0] &#x3D; hash[reminder] + 1;            result[1] &#x3D; i + 1;            return result;        }        hash[nums[i]] &#x3D; i;    }    return result;}





    Python 解答

123456789class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        seen &#x3D; {}        for i, num in enumerate(nums):            if target - num in seen:                return [seen[target-num], i]            else:                seen[num] &#x3D; i        return [-1, -1]





    rust 解答

1234567891011121314use std::collections::HashMap;impl Solution {    pub fn two_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;i32&gt; {        let mut map &#x3D; HashMap::with_capacity(nums.len());        for (idx, num) in nums.iter().enumerate() {            match map.get(&amp;(target - num)) {                None &#x3D;&gt; {map.insert(num, idx);},                Some(sub_idx) &#x3D;&gt; {return vec![*sub_idx as i32, idx as i32]; }            }        }        vec! []    }}





    go 解答

123456789101112func twoSum(nums []int, target int) []int {    m :&#x3D; make(map[int]int)    for index, num :&#x3D; range nums {        last_index, ok :&#x3D; m[num]        if ok {            return []int{last_index, index}        } else {            m[target - num] &#x3D; index        }    }    return []int{-1, -1}}



Follow up: 如果数组是已经排序的呢？

    C++ 解答

12345678910111213sort(nums.begin(), nums.end()) &#x2F;&#x2F; 假设已经排序，只有一个结果pair&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {    int left &#x3D; 0, right &#x3D; nums.size() - 1;    while (left &lt; right) {        int s &#x3D; nums[left] + nums[right];        if (s &#x3D;&#x3D; target)            return make_pair(left, right);        else if (s &lt; sum)            left++;        else            right--;    }}



2 给两个列表，数字在其中按低位到高位存储，求他们的和直接迭代遍历数组，考察细节操作。注意 dummy head 的使用。

    C 解答

12345678910111213141516171819struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {    struct ListNode dummy, *p &#x3D; &amp;dummy;    int carry &#x3D; 0;    &#x2F;&#x2F; 注意最后如果有 carry 的话，需要再生成一个节点    while (l1 || l2 || carry) {        int v1 &#x3D; l1 ? l1-&gt;val: 0;        int v2 &#x3D; l2 ? l2-&gt;val: 0;        int v &#x3D; v1 + v2 + carry;        p-&gt;next &#x3D; malloc(sizeof(struct ListNode));        p &#x3D; p-&gt;next;        p-&gt;val &#x3D; v % 10;        p-&gt;next &#x3D; NULL;        carry &#x3D; v &#x2F; 10;        l1 &#x3D; l1 ? l1-&gt;next: NULL;        l2 &#x3D; l2 ? l2-&gt;next: NULL;    }    return dummy.next;}





    C++ 解答

1234567891011121314151617181920212223242526272829303132333435class Solution {    public:        ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {            if (l1 &#x3D;&#x3D; NULL) return l2;            if (l2 &#x3D;&#x3D; NULL) return l1;            int shift &#x3D; 0;            ListNode* result &#x3D; new ListNode(0);            ListNode* p &#x3D; result;            while (l1 !&#x3D; NULL || l2 !&#x3D; NULL) {                ListNode* newNode &#x3D; new ListNode(0);                int v1 &#x3D; l1 !&#x3D; NULL ? l1-&gt;val : 0;                int v2 &#x3D; l2 !&#x3D; NULL ? l2-&gt;val : 0;                newNode-&gt;val &#x3D; v1 + v2 + shift;                if (newNode-&gt;val &gt; 9) {                    newNode-&gt;val -&#x3D; 10;                    shift &#x3D; 1;                } else {                    shift &#x3D; 0;                }                if (l1) {                    l1 &#x3D; l1-&gt;next;                }                if (l2) {                    l2 &#x3D; l2-&gt;next;                }                p-&gt;next &#x3D; newNode;                p &#x3D; p-&gt;next;            }            &#x2F;&#x2F; 注意最后多余的一个进位处理            if (shift &#x3D;&#x3D; 1) {                p-&gt;next &#x3D; new ListNode(1);            }            return result-&gt;next;        }};





    rust 解答

1234567891011121314151617181920212223242526272829303132impl Solution {    pub fn add_two_numbers(l1: Option&lt;Box&lt;ListNode&gt;&gt;, l2: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {        let (mut l1, mut l2) &#x3D; (l1, l2);        let mut dummy &#x3D; Box&lt;ListNode::new(0)&gt;;        let mut carry &#x3D; 0;        let mut p &#x3D; dummy;        while l1.is_some() || l2.is_some() || carry !&#x3D; 0 {            match l1, l2{                Some(a), Some(b) &#x3D;&gt; {                    let mut v &#x3D; a + b + carry;                    l1 &#x3D; l1.next();                    l2 &#x3D; l2.next();                },                Some(a), None &#x3D;&gt; {                    let mut v &#x3D; a + carry;                    l1 &#x3D; l1.next();                },                None, Some(b) &#x3D;&gt; {                    let mut v &#x3D; b + carry;                    l2 &#x3D; l2.next();                },                None, None &#x3D;&gt; {                }            }            p.next &#x3D; Some(Box&lt;ListNode::new(v)&gt;);            p &#x3D; p.next;            p.val &#x3D; v % 10;            carry &#x3D; v &#x2F; 10;        }        dummy.next    }}





    Python 解答

12345678910111213141516171819202122232425262728293031# Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val &#x3D; x#         self.next &#x3D; Noneclass Solution:    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        dummy &#x3D; ListNode(-1)        p &#x3D; dummy        carry &#x3D; 0        while l1 or l2 or carry:            if l1:                v1 &#x3D; l1.val                l1 &#x3D; l1.next            else:                v1 &#x3D; 0            if l2:                v2 &#x3D; l2.val                l2 &#x3D; l2.next            else:                v2 &#x3D; 0            v &#x3D; v1 + v2 + carry  # 别忘了这里            if v &gt;&#x3D; 10:                carry &#x3D; 1                v -&#x3D; 10            else:                carry &#x3D; 0            p.next &#x3D; ListNode(v)            p &#x3D; p.next        return dummy.next



3 最长不重复子串tags: #slidewindow
滑动窗口解决
注意，当字符有限的时候，比如限定为 ASCII 字符，可以使用一个数组代替 Hash。

    C 解答

1234567891011121314int lengthOfLongestSubstring(char* s) {    int indices[256];    for (int i &#x3D; 0; i &lt; 256; i++)  &#x2F;&#x2F; init the array, memset can only be used for char        indices[i] &#x3D; -1;    int left &#x3D; 0;    int longest &#x3D; 0;    for (int i &#x3D; 0; s[i] !&#x3D; &#39;\0&#39;; i++) {        left &#x3D; max(left, indices[s[i]] + 1);   &#x2F;&#x2F; 考虑新加入字符后对左边界的影响        indices[s[i]] &#x3D; i;                     &#x2F;&#x2F; 更新元素上次出现位置        longest &#x3D; max(longest, i - left + 1);  &#x2F;&#x2F; 应用动态规划    }    return longest;}





    Python 解答

12345678910class Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        last_seen &#x3D; {}        ans &#x3D; 0        lo &#x3D; 0        for i, c in enumerate(s):            lo &#x3D; max(lo, last_seen.get(c, -1) + 1)  # 更新下边界            last_seen[c] &#x3D; i            ans &#x3D; max(ans, i - lo + 1)        return ans




4 找到两个排序数组的中位数解法参见这里
使用两个数字 i 和 j, 分别作为 AB 的分隔元素，把 AB 分成两份，比如A[0..i], B[0..j] 和 A[i, m], B[j, n]，这样我们只需要下面两个条件就可以了：

i+j &#x3D; m-i + n-j, 也就是 i+j &#x3D; (m+n)&#x2F;2
B[j-1] &lt;&#x3D; A[i] &amp;&amp; A[i-1] &lt;&#x3D; B[j],  B 的前一半元素小于 A 的分隔符，A 的前一半元素小于 B 的分隔符

这时候我们就得到了 A[i] 就是我们的中位数，或者之一。 i 的初始值在 0 到 m 之间，然后我们二分搜索 i &#x3D; (imin + imax) &#x2F; 2, j &#x3D; mid - i。

    C 解答

1234567891011121314151617181920212223242526272829303132#define max(a,b) ((a)&gt;(b)?(a):(b))#define min(a,b) ((a)&lt;(b)?(a):(b))double findMedianSortedArrays(int* A, int m, int* B, int n) {    if (m &gt; n) return findMedianSortedArrays(B, n, A, m);    int imin &#x3D; 0, imax &#x3D; m, i, j, num1, mid &#x3D; (m + n + 1) &gt;&gt; 1, num2;    while (imin &lt;&#x3D; imax) {        i &#x3D; (imin + imax) &#x2F;&#x2F; 2;        j &#x3D; mid - i;        if (i &lt; m &amp;&amp; j &gt; 0 &amp;&amp; B[j-1] &gt; A[i]) {  &#x2F;&#x2F; B 中的数字偏大            imin &#x3D; i + 1;        } else if (i &gt; 0 &amp;&amp; j &lt; n &amp;&amp; B[j] &lt; A[i-1]) { &#x2F;&#x2F; A 中的数字偏大            imax &#x3D; i - 1;        } else {            if (i &#x3D;&#x3D; 0)                num1 &#x3D; B[j-1];            else if (j &#x3D;&#x3D; 0)                num1 &#x3D; A[i - 1];            else                num1 &#x3D; max(A[i-1],B[j-1]);  &#x2F;&#x2F; 普通情况            break;        }    }    if ((m + n) &amp; 0x1) &#x2F;&#x2F; odd        return num1;    if (i &#x3D;&#x3D; m)        num2 &#x3D; B[j];    else if (j &#x3D;&#x3D; n)        num2 &#x3D; A[i];    else        num2 &#x3D; min(A[i], B[j]); &#x2F;&#x2F; 普通情况    return (num1 + num2) &#x2F; 2.0; &#x2F;&#x2F; 注意整数除法}



5 最长回文子串
以某个元素为中心，向两边展开，注意处理奇数和偶数两种情况
Manacher 算法，参见这里


    Python 解答

1234567891011121314151617181920class Solution:    def longestPalindrome(self, s: str) -&gt; str:        ans &#x3D; &quot;&quot;        length &#x3D; 0        for i in range(len(s)):            j &#x3D; 0            # 奇数长度回文子串            while i - j &gt;&#x3D; 0 and i + j &lt; len(s) and s[i-j] &#x3D;&#x3D; s[i+j]:                if j * 2 + 1 &gt; length:                    length &#x3D; j * 2 + 1                    ans &#x3D; s[i-j:i+j+1]                j +&#x3D; 1            j &#x3D; 0            # 偶数长度回文子串            while i - j &gt;&#x3D; 0 and i + j + 1 &lt; len(s) and s[i-j] &#x3D;&#x3D; s[i+j+1]:                if j * 2 + 2 &gt; length:                    length &#x3D; j * 2 + 2                    ans &#x3D; s[i-j:i+j+2]                j +&#x3D; 1        return ans





    C 解答

123456789101112131415161718192021222324252627282930313233343536char* longestPalindrome(char* s) {    if (!s) return NULL;    int length &#x3D; 0; &#x2F;&#x2F; length of the longest palindromic string    int start &#x3D; -1; &#x2F;&#x2F; start of the lonest palidromic string    int len &#x3D; strlen(s);    for (int i &#x3D; 0; i &lt; len; i++) {        &#x2F;&#x2F; 奇数长度的回文子串        for (int j &#x3D; 0; (i - j &gt;&#x3D; 0) &amp;&amp; (i + j &lt; len); j++) {            if (s[i - j] !&#x3D; s[i + j])                break;            if (j * 2 + 1 &gt; length) {                length &#x3D; j * 2 + 1;                start &#x3D; i - j;            }        }        &#x2F;&#x2F; 偶数长度的回文子串        for (int j &#x3D; 0; (i - j &gt;&#x3D; 0) &amp;&amp; (i + j + 1 &lt; len); j++) {            if (s[i - j] !&#x3D; s[i + j + 1])                break;            if (j * 2 + 2 &gt; length) {                length &#x3D; j * 2 + 2;                start &#x3D; i - j;            }        }    }    char* result &#x3D; malloc(sizeof(char) * length + 1);    strncpy(result, s + start, length);    result[length] &#x3D; 0;    return result;}



6 ZigZag 字符串，把字符串掰弯，然后再按行输出考察数学，找出规律，所以实际上并不是 Z 子形，而是由 V 组成的，然后组合按行号重构后的字符串即可。

    C 解答

123456789101112131415161718192021&#x2F;&#x2F; 这个方法不容易理解，建议看 Python 的char* convert(char* s, int numRows) {    int len &#x3D; strlen(s);    if (!s || numRows &lt;&#x3D; 1 || len &lt; numRows) return s; &#x2F;&#x2F; no need to convert    char* zigzag &#x3D; malloc(sizeof(char) * (len + 1));    int cur &#x3D; 0;    for (int i &#x3D; 0; i &lt; numRows; i++) {        for (int j &#x3D; i; j &lt; len; j +&#x3D; 2 * (numRows - 1)) { &#x2F;&#x2F; 每个 v 字型长度            zigzag[cur++] &#x3D; s[j];            if (i !&#x3D; 0 &amp;&amp; i !&#x3D; numRows - 1) { &#x2F;&#x2F; 中间行有斜线                int t &#x3D; j + 2 * (numRows - 1) - 2 * i; &#x2F;&#x2F; V 的第二笔                if (t &lt; len)                    zigzag[cur++] &#x3D; s[t];            }        }    }    zigzag[cur] &#x3D; &#39;\0&#39;;    return zigzag;}





    Python 解答

1234567891011121314151617181920212223242526class Solution:    def convert(self, s: str, numRows: int) -&gt; str:        if numRows &lt;&#x3D; 1 or len(s) &lt;&#x3D; numRows:  # 没有这个条件会超时            return s        interval &#x3D; 2 * numRows - 2        ans &#x3D; []        # 第一行        j &#x3D; 0        while j &lt; len(s):            ans.append(s[j])            j +&#x3D; interval        # 中间行        for i in range(1, numRows-1):            j &#x3D; 0            while j &lt; len(s):                if i + j &lt; len(s):                    ans.append(s[i+j])                if interval - i + j &lt; len(s):  # 一定要注意这里的索引                    ans.append(s[interval - i + j])                j +&#x3D; interval        # 最后一行        j &#x3D; numRows - 1        while j &lt; len(s):            ans.append(s[j])            j +&#x3D; interval        return &quot;&quot;.join(ans)



7 翻转数字，溢出返回 0注意溢出

    C 解答

123456789101112int reverse(int x) {    if (x &#x3D;&#x3D; INT_MIN) return 0;    if (x &lt; 0) return -reverse(-x);    long result &#x3D; 0;    while (x) {        result &#x3D; result * 10 + x % 10;        x &#x2F;&#x3D; 10;    }    return result &gt; INT_MAX ? 0 : result;}





    Python 解答

1234567891011class Solution:    def reverse(self, x: int) -&gt; int:        sign &#x3D; 1 if x &gt;&#x3D; 0 else -1        x *&#x3D; sign        y &#x3D; 0        while x &gt; 0:            y &#x3D; y * 10 + x % 10            x &#x2F;&#x2F;&#x3D; 10        if y &gt; 2**31:            return 0        return y * sign



8 实现 atoi这道题考察各种细节，注意各种特殊情况：

首先过滤空格
判定符号，符号只能出现一次
是否溢出，溢出返回 INT_MAX 或者 INT_MIN


    Python 解答

123456789101112131415161718class Solution:    def myAtoi(self, s: str) -&gt; int:        s &#x3D; s.lstrip()        if not s:            return 0        sign &#x3D; 1        ans &#x3D; 0        i &#x3D; 0        if s[i] &#x3D;&#x3D; &quot;-&quot;:            sign &#x3D; -1            i +&#x3D; 1        elif s[i] &#x3D;&#x3D; &quot;+&quot;:            i +&#x3D; 1        while i &lt; len(s) and s[i].isdigit():            ans &#x3D; ans * 10 + ord(s[i]) - ord(&quot;0&quot;)            i +&#x3D; 1        ans *&#x3D; sign        return max(min(ans, 2**31-1), - 2 ** 31)





    C 解答

123456789101112131415161718192021222324252627int myAtoi(char* str) {    if (!str) return 0;    int sign &#x3D; 1;    int result &#x3D; 0;    &#x2F;&#x2F; discarding spaces    while (isspace(*str))        str++;    &#x2F;&#x2F; determining sign    if (*str &#x3D;&#x3D; &#39;-&#39; || *str &#x3D;&#x3D; &#39;+&#39;) {        if (*str &#x3D;&#x3D; &#39;-&#39;) sign &#x3D; -1;        if (*str &#x3D;&#x3D; &#39;+&#39;) sign &#x3D; 1;        str++;    }    &#x2F;&#x2F; constructing integer    while (isdigit(*str)) {        &#x2F;&#x2F; handling overflow        if (result &gt; INT_MAX &#x2F; 10 || result &#x3D;&#x3D; INT_MAX &#x2F; 10 &amp;&amp; *str - &#39;0&#39; &gt; INT_MAX % 10)            return sign &gt; 0 ? INT_MAX : INT_MIN;        result &#x3D; *str - &#39;0&#39; + result * 10;        str++;    }    return result * sign;}



9 是否是回文数字限定不能用额外空间，所以直接把 x 取余得到的数字作为一个反向作为一个新的数字

    Python 解答

123456789101112class Solution:    def isPalindrome(self, x: int) -&gt; bool:        if x &lt; 0:            return False        if x !&#x3D; 0 and x % 10 &#x3D;&#x3D; 0:            return False        y &#x3D; 0        # 回文走到一半就行了，没必要完全翻转过来        while x &gt; y:            y &#x3D; y * 10 + x % 10            x &#x2F;&#x2F;&#x3D; 10        return x &#x3D;&#x3D; y or x &#x3D;&#x3D; y &#x2F;&#x2F; 10






    C 解答

123456789101112bool isPalindrome(int x) {    &#x2F;&#x2F; tricky here, for x &#x3D;&#x3D; k * 10^j    if (x &lt; 0 || x &amp;&amp; (x % 10 &#x3D;&#x3D; 0)) return false;    int y &#x3D; 0;    while (x &gt; y) {        y &#x3D; y * 10 + x % 10;        x &#x2F;&#x3D; 10;    }    return x &#x3D;&#x3D; y || x &#x3D;&#x3D; y &#x2F; 10; &#x2F;&#x2F; 注意 x 可能是奇数长度也可能是偶数}



10 正则表达式实现正则表达式，只需要实现.代表任意字符，*代表任意重复。只需要特殊处理*，如果遇到了*，贪婪地向后匹配。和通配符的不同之处在于，正则表达式需要两个字母组成模式，*是对前一个字母的修饰。

    C 解答

123456789101112131415bool isMatch(char* s, char* p) {    for (char c &#x3D; *p; c !&#x3D; 0; s++, c &#x3D; *p) {        &#x2F;&#x2F; if next char in pattern is not *        if (*(p+1) !&#x3D; &#39;*&#39;)            p++;        &#x2F;&#x2F; if we got an *, check if we can skip &#96;.*&#96; or &#96;x*&#96;        else if (isMatch(s, p + 2))            return true;        &#x2F;&#x2F; s ends or p and s differs        if (*s &#x3D;&#x3D; 0 || c !&#x3D; &#39;.&#39; &amp;&amp; c !&#x3D; *s)            return false;    }    return *s &#x3D;&#x3D; 0;}



11 盛最多水的容器从左右向中间逼近，如果有更大的就更新。简单的一道双指针题目，别想太多。

    C++ 解答

12345678910111213int maxArea(vector&lt;int&gt;&amp; height) {    int left &#x3D; 0, right &#x3D; height.size() - 1;    int result &#x3D; 0;    while (left &lt; right) {        water &#x3D; min(height[left], height[right]) * (right - left)        result &#x3D; max(result, water);        if (height[left] &lt; height[right])            left++;        else            right--;    }    return result;}





    Python 解答

12345678910111213class Solution:    def maxArea(self, height: List[int]) -&gt; int:        lo &#x3D; 0        hi &#x3D; len(height) - 1        ans &#x3D; 0        while lo &lt; hi:            water &#x3D; min(height[lo], height[hi]) * (hi - lo)            ans &#x3D; max(ans, water)            if height[lo] &lt; height[hi]:                lo +&#x3D; 1            else:                hi -&#x3D; 1        return ans




12 十进制转换为罗马数字直接按每位把罗马数字转换出来在拼接就好了，使用 C 的话，拼接字符串很麻烦。

    Python 解答

1234567class Solution:    def intToRoman(self, x: int) -&gt; str:        thousands &#x3D; [&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;]        hundreds &#x3D; [&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;]        tens &#x3D; [&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;]        ones &#x3D; [&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;]        return thousands[x&#x2F;&#x2F;1000] + hundreds[x%1000&#x2F;&#x2F;100] + tens[x%100&#x2F;&#x2F;10] + ones[x%10]






    C++ 解答

12345678string intToRoman(int num) {    &#x2F;&#x2F; note, the leading empty string is the trick here    string thousands[] &#x3D; {&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;};    string handreds[] &#x3D; {&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;};    string tens[] &#x3D; {&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;};    string ones[] &#x3D; {&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;};    return thousands[num &#x2F; 1000] + handreds[num % 1000 &#x2F; 100] + tens[num % 100 &#x2F; 10] + ones[num % 10];}





    C 解答

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475char *intToRoman(int num) {    int digits[4] &#x3D; {0};    char* romans &#x3D; (char*)malloc(sizeof(char));    char* cursor &#x3D; romans;    &#x2F;&#x2F; if num &#x3D; 1234, then    &#x2F;&#x2F; digits &#x3D; {1, 2, 3, 4};    int base &#x3D; 1000;    for (int i &#x3D; 0; i &lt; 4; i++) {        digits[i] &#x3D; num &#x2F; base;        num &#x3D; num % base;        base &#x2F;&#x3D; 10;    }    doRoman(digits[0], &#39;_&#39;, &#39;_&#39;, &#39;M&#39;, &amp;cursor); &#x2F;&#x2F; &#39;_&#39; can be anything    doRoman(digits[1], &#39;M&#39;, &#39;D&#39;, &#39;C&#39;, &amp;cursor);    doRoman(digits[2], &#39;C&#39;, &#39;L&#39;, &#39;X&#39;, &amp;cursor);    doRoman(digits[3], &#39;X&#39;, &#39;V&#39;, &#39;I&#39;, &amp;cursor);    *cursor &#x3D; &#39;\0&#39;;    return romans;}void doRoman(int number, char ten, char five, char one, char** str) {    switch (number) {        case 9:            (*str)[0] &#x3D; one;            (*str)[1] &#x3D; ten;            (*str) +&#x3D; 2;            break;        case 8:            (*str)[0] &#x3D; five;            (*str)[1] &#x3D; one;            (*str)[2] &#x3D; one;            (*str)[3] &#x3D; one;            (*str) +&#x3D; 4;            break;        case 7:            (*str)[0] &#x3D; five;            (*str)[1] &#x3D; one;            (*str)[2] &#x3D; one;            (*str) +&#x3D; 3;            break;        case 6:            (*str)[0] &#x3D; five;            (*str)[1] &#x3D; one;            (*str) +&#x3D; 2;            break;        case 5:            (*str)[0] &#x3D; five;            (*str) +&#x3D; 1;            break;        case 4:            (*str)[0] &#x3D; one;            (*str)[1] &#x3D; five;            (*str) +&#x3D; 2;            break;        case 3:            (*str)[0] &#x3D; one;            (*str)[1] &#x3D; one;            (*str)[2] &#x3D; one;            (*str) +&#x3D; 3;            break;        case 2:            (*str)[0] &#x3D; one;            (*str)[1] &#x3D; one;            (*str) +&#x3D; 2;            break;        case 1:            (*str)[0] &#x3D; one;            (*str) +&#x3D; 1;            break;        case 0:        default:            break;    }}



13 罗马数字转为十进制主要是当前一个数字小于后一个数字的时候，需要添加的是后一个数和前一个数字的差。

    Python 解答

123456789101112131415161718192021class Solution:    def romanToInt(self, s: str) -&gt; int:        vals &#x3D; {            &quot;I&quot;: 1,            &quot;V&quot;: 5,            &quot;X&quot;: 10,            &quot;L&quot;: 50,            &quot;C&quot;: 100,            &quot;D&quot;: 500,            &quot;M&quot;: 1000        }        ans &#x3D; 0        i &#x3D; 0        while i &lt; len(s):            if i+1&lt;len(s) and vals[s[i]] &lt; vals[s[i+1]]:                ans +&#x3D; vals[s[i+1]] - vals[s[i]]                i +&#x3D; 2            else:                ans +&#x3D; vals[s[i]]                i +&#x3D; 1        return ans






    C 解答

1234567891011121314151617181920212223&#x2F;&#x2F; acts like a dict or mapint getVal(char c) {    switch (c) {        case &#39;I&#39;: return 1;        case &#39;V&#39;: return 5;        case &#39;X&#39;: return 10;        case &#39;L&#39;: return 50;        case &#39;C&#39;: return 100;        case &#39;D&#39;: return 500;        case &#39;M&#39;: return 1000;    }}int romanToInt(char* s) {    int result &#x3D; 0;    for (int i &#x3D; 0; s[i] !&#x3D; 0; ) {        if (getVal(s[i]) &lt; getVal(s[i+1]))            result +&#x3D; getVal(s[i+1]) - getVal(s[i]), i +&#x3D; 2;        else            result +&#x3D; getVal(s[i]), i++;    }    return result;}



14 最长公共前缀纵向扫描，从头到尾，如果不一致，返回当前子串即可。

    Python 解答

123456789101112class Solution:    def longestCommonPrefix(self, strs: List[str]) -&gt; str:        if not strs:            return &quot;&quot;        if len(strs) &#x3D;&#x3D; 1:            return strs[0]        minlen &#x3D; min([len(str) for str in strs])        for i in range(minlen):            for j in range(1, len(strs)):                if strs[j][i] !&#x3D; strs[0][i]:                    return strs[0][:i]        return strs[0][:minlen]






    C 解答

12345678910111213141516&#x2F;&#x2F; 纵向扫描char* longestCommonPrefix(char** strs, int strsSize) {    if (!strs || !strs[0]) return &quot;&quot;;    if (strsSize &#x3D;&#x3D; 1) return strs[0];    int len &#x3D; strlen(strs[0]);    for (int i &#x3D; 0; i &lt; len; i++) {        for (int j &#x3D; 1; j &lt; strsSize; j++) {            if (strs[j][i] !&#x3D; strs[0][i]) {                strs[0][i] &#x3D; &#39;\0&#39;;                return strs[0];            }        }    }    return strs[0];}



15 从数组中找出三个数使得他们的和是 0首先把数组排序，然后使用类似 two sum 的方法做就好了。做这种数组题的套路就是实在不行排个序。

    Python 解答

1234567891011121314151617181920212223242526class Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        if len(nums) &lt; 3:            return []        nums.sort()        ans &#x3D; []        for i in range(len(nums)):            if i &gt; 0 and nums[i] &#x3D;&#x3D; nums[i-1]:                continue            k &#x3D; len(nums) - 1            j &#x3D; i + 1            while j &lt; k:                sum &#x3D; nums[i] + nums[j] + nums[k]                if sum &gt; 0:                    k -&#x3D; 1                elif sum &lt; 0:                    j +&#x3D; 1                else:                    ans.append([nums[i], nums[j], nums[k]])                    while j &lt; k and nums[j] &#x3D;&#x3D; nums[j+1]:                        j +&#x3D; 1                    while j &lt; k and nums[k] &#x3D;&#x3D; nums[k-1]:                        k -&#x3D; 1                    j +&#x3D; 1                    k -&#x3D; 1        return ans






    C++ 解答

123456789101112131415161718192021222324252627vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {    sort(nums.begin(), nums.end());    vector&lt;vector&lt;int&gt;&gt; result;    for (int i &#x3D; 0; i &lt; nums.size(); i++) {        if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i-1])            continue;        int k &#x3D; nums.size() - 1;        int j &#x3D; i + 1;        while (j &lt; k) {            if (nums[i] + nums[j] + nums[k] &gt; 0)                k--;            else if (nums[i] + nums[j] + nums[k] &lt; 0)                j++;            else {                result.push_back({nums[i], nums[j], nums[k]});                &#x2F;&#x2F; skipping duplicates                while (j &lt; k &amp;&amp; nums[k] &#x3D;&#x3D; nums[k - 1])                    k--;                while (j &lt; k &amp;&amp; nums[j] &#x3D;&#x3D; nums[j + 1])                    j++;                k--; &#x2F;&#x2F; 别忘了这里，还要继续寻找下一组                j++;            }        }    }    return result;}



16 在数组中找到三个数字使得他们得和尽可能的接近给定数字，假设结果唯一和上一题解法类似，在 http:&#x2F;&#x2F;stackoverflow.com&#x2F;q&#x2F;2070359 有详尽解释

    Python 解答

123456789101112131415161718192021class Solution:    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:        if len(nums) &lt; 3:            return []        nums.sort()        ans &#x3D; nums[0] + nums[1] + nums[2]        for i in range(len(nums)):            j &#x3D; i + 1            k &#x3D; len(nums) - 1            while j &lt; k:                sum &#x3D; nums[i] + nums[j] + nums[k]                if sum &#x3D;&#x3D; target:                    return target                elif abs(target-sum) &lt; abs(target-ans):                    ans &#x3D; sum                else:                    if sum &gt; target:                        k -&#x3D; 1                    else:                        j +&#x3D; 1        return ans







    C 解答

123456789101112131415161718192021222324252627int cmp(int* a, int* b) {    return *a - *b;}int threeSumClosest(int* nums, int numsSize, int target) {    if (numsSize &lt;&#x3D; 3)        return nums[0] + nums[1] + nums[2];    qsort(nums, numsSize, sizeof(int), cmp);    int result &#x3D; nums[0] + nums[1] +nums[2];    for (int i &#x3D; 0; i &lt; numsSize; i++) {        int j &#x3D; i + 1;        int k &#x3D; numsSize - 1;        while (j &lt; k) {            int sum &#x3D; nums[i] + nums[j] + nums[k];            if (sum &#x3D;&#x3D; target)                return target;            if (abs(target - sum) &lt; abs(target - result))                result &#x3D; sum;            if (sum &gt; target)                k--;            else                j++;        }    }    return result;}



17 生成电话键盘按键数字对应的所有可能的字符串，不限制返回结果的顺序tags: #backtracking

递归：
这道题是一道典型的，最简单的深度优先遍历，生成所有可能解的问题。
迭代：
遍历数字，设当前结果为{a, b, c}, 下一个数字是3, 找出对应的字母{d, e, f}, 则新的结果是
1{ a + {def}, b + {def}, c + {def}}

然后把新获得的数组作为下一轮的初始数组。最开始时，使用空数组开始。

    Python 解答

1234567891011121314151617181920212223class Solution:    def letterCombinations(self, digits: str) -&gt; List[str]:        c2n &#x3D; {            &quot;2&quot;: &quot;abc&quot;,            &quot;3&quot;: &quot;def&quot;,            &quot;4&quot;: &quot;ghi&quot;,            &quot;5&quot;: &quot;jkl&quot;,            &quot;6&quot;: &quot;mno&quot;,            &quot;7&quot;: &quot;pqrs&quot;,            &quot;8&quot;: &quot;tuv&quot;,            &quot;9&quot;: &quot;wxyz&quot;        }        def dfs(combination, next_digits):            if not next_digits:                ans.append(combination)                return            for char in c2n[next_digits[0]]:                dfs(combination + char, next_digits[1:])        if not digits:            return []        ans &#x3D; []        dfs(&quot;&quot;, digits)        return ans






    C++ 解答

123456789101112131415161718&#x2F;&#x2F; iterativevector&lt;string&gt; letterCombinations(string digits) {    if (digits.size() &#x3D;&#x3D; 0) return vector&lt;string&gt; {};    string mapping[] &#x3D; {&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};    vector&lt;string&gt; combinations(1, &quot;&quot;); &#x2F;&#x2F; 注意使用空字符串作为种子    for (int i &#x3D; 0; i &lt; digits.size(); i++) {        int digit &#x3D; digits[i] - &#39;0&#39;;        if (mapping[digit].empty())            continue;        vector&lt;string&gt; temp;        for (auto&amp; c : mapping[digit])            for (auto&amp; combination : combinations)                temp.push_back(combination + c);        swap(combinations, temp);    }    return combinations;}



还可以使用深度优先的搜索方法
追问：如何通过用户按的数字来查找是否有对应的单词呢

通过把所有的单词计算出来，然后查询哪个是合法的，查询可以使用 Trie
通过把已经有的单词字典转换为数字字典，然后通过数字序列查询可能的单词组合。

18 4Sumtags: #backtracking
其实可以用 深度优先搜索的方式直接解答 nSum

    Python 解答

123456789101112131415161718192021222324252627282930313233343536373839404142class Solution:    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:        return self.nSum(nums, target, 4)    def nSum(self, nums, target, n):        def dfs(pos: int, cur: List[int], n: int, target: int):            if n &#x3D;&#x3D; 2:                j &#x3D; pos                k &#x3D; len(nums) - 1                while j &lt; k:                    sum &#x3D; nums[j] + nums[k]                    if sum &lt; target:                        j +&#x3D; 1                    elif sum &gt; target:                        k -&#x3D; 1                    else:                        solution &#x3D; cur[:] + [nums[j], nums[k]]                        ans.append(solution)                        while j &lt; k and nums[j] &#x3D;&#x3D; nums[j+1]:                            j +&#x3D; 1                        while j &lt; k and nums[k] &#x3D;&#x3D; nums[k-1]:                            k -&#x3D; 1                        j +&#x3D; 1                        k -&#x3D; 1                return            i &#x3D; pos            while i &lt; len(nums) - n + 1:                # 剪枝的一种情况                if nums[i] * n &gt; target or nums[-1] * n &lt; target:                    break                # 排除重复数字                if i &gt; pos and nums[i] &#x3D;&#x3D; nums[i-1]:                    i +&#x3D; 1                    continue                cur.append(nums[i])                dfs(i+1, cur, n-1, target-nums[i])                cur.pop()                i +&#x3D; 1        ans &#x3D; []        nums.sort()        dfs(0, [], n, target)        return ans




下面的 C++ 解法是一个传统解法

    C++ 解答

12345678910111213141516171819202122232425262728293031323334353637vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {    vector&lt;vector&lt;int&gt;&gt; result;    int n &#x3D; nums.size();    if (n &lt; 4) return result;    sort(nums.begin(), nums.end());    unordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; hash;    for(int i &#x3D; 0; i &lt; n; i++){        for(int j &#x3D; i + 1; j &lt; n; j++){            hash[nums[i]+nums[j]].push_back(make_pair(i,j));        }    }    for (int i &#x3D; 0; i &lt; n; i++) {        if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i-1])            continue;        for (int j &#x3D; i+1; j &lt; n; j++) {            if (j &gt; i + 1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j-1])                continue;            int re &#x3D; target - nums[i] - nums[j];            if (hash.find(re) !&#x3D; hash.end()) {                for (auto match : hash[re]) {                    int k &#x3D; match.first, l &#x3D; match.second;                    if (k &gt; j) {                        if (!result.empty()                            &amp;&amp; result.back()[0] &#x3D;&#x3D; nums[i] &amp;&amp; result.back()[1] &#x3D;&#x3D; nums[j]                            &amp;&amp; result.back()[2] &#x3D;&#x3D; nums[k] &amp;&amp; result.back()[3] &#x3D;&#x3D; nums[l])                        continue;                        result.push_back({nums[i], nums[j], nums[k], nums[l]});                    }                }            }        }    }    return result;}



19 删除链表中倒数第 k 的节点tags: #pointers
双指针经典题目，一个快指针先走 k 步，另一个慢指针再出发，注意链表长度小于 k 时。
注意：LeetCode 给定的 n 都是有效地，但要求返回头指针，如果头指针被删除需要额外注意，因此采用 dummy head

    Python 解答

1234567891011121314class Solution:    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:        dummy &#x3D; ListNode(-1)        dummy.next &#x3D; head        p &#x3D; dummy        while n &gt;&#x3D; 0:            p &#x3D; p.next            n -&#x3D; 1        q &#x3D; dummy        while p:            q &#x3D; q.next            p &#x3D; p.next        q.next &#x3D; q.next.next        return dummy.next





    C 解答

12345678910111213141516struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {    struct ListNode dummy, *fast, *slow;    dummy.next &#x3D; fast &#x3D; head;    slow &#x3D; &amp;dummy;    while (n--)        fast &#x3D; fast-&gt;next;    while (fast) {        fast &#x3D; fast-&gt;next;        slow &#x3D; slow-&gt;next;    }    struct ListNode* next &#x3D; slow-&gt;next;    slow-&gt;next &#x3D; next-&gt;next;    free(next); &#x2F;&#x2F; remeber to free memory    return dummy.next;}




20 判定给定的字符串是否是合法的括号序列，可能包括大中小三类tags: #stack
使用栈的基础题，注意逻辑简化

    Python 解答

123456789101112131415class Solution:    def isValid(self, s: str) -&gt; bool:        valid &#x3D; True        stack &#x3D; []        match &#x3D; {&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;}&quot;: &quot;{&quot;}        for c in s:            if c in (&quot;(&quot;, &quot;[&quot;, &quot;{&quot;):                stack.append(c)            else:                if not stack:                    return False                if stack[-1] !&#x3D; match[c]:                    return False                stack.pop()        return not stack





    C 解答

123456789101112131415161718192021char opposite(char c) {    switch (c) {        case &#39;)&#39; : return &#39;(&#39;;        case &#39;]&#39; : return &#39;[&#39;;        case &#39;}&#39; : return &#39;{&#39;;    }}bool isValid(string s) {    stack&lt;char&gt; stk;    for (auto&amp; c : s) {        if (c &#x3D;&#x3D; &#39;(&#39; || c &#x3D;&#x3D; &#39;[&#39; || c &#x3D;&#x3D; &#39;{&#39;)            stk.push(c);        else if (!stk.empty() &amp;&amp; stk.top() &#x3D;&#x3D; opposite(c))            stk.pop();        else            return false;    }    return stk.empty(); &#x2F;&#x2F; 注意为空的条件}





    Rust 解答

12345678910111213141516impl Solution {    pub fn is_valid(s: String) -&gt; bool {        let mut stack &#x3D; vec![];        &#x2F;&#x2F; let map &#x3D;        for ch in s.chars() {            match ch {                &#39;(&#39; | &#39;{&#39; | &#39;[&#39; &#x3D;&gt; stack.push(ch),                &#39;)&#39; &#x3D;&gt; if let Some(&#39;(&#39;) &#x3D; stack.pop() {} else { return false },                &#39;}&#39; &#x3D;&gt; if let Some(&#39;{&#39;) &#x3D; stack.pop() {} else { return false },                &#39;]&#39; &#x3D;&gt; if let Some(&#39;[&#39;) &#x3D; stack.pop() {} else { return false },                _ &#x3D;&gt; return false            }        }        stack.len() &#x3D;&#x3D; 0    }}



21 合并两个已经排序的链表tags: #pointers
考察链表的基本操作，很简单

    Python 解答

1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val &#x3D; x#         self.next &#x3D; Noneclass Solution:    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        dummy &#x3D; ListNode(-1)        p &#x3D; dummy        while l1 and l2:            if l1.val &lt; l2.val:                p.next &#x3D; l1                l1 &#x3D; l1.next            else:                p.next &#x3D; l2                l2 &#x3D; l2.next            p &#x3D; p.next        if l1:            p.next &#x3D; l1        if l2:            p.next &#x3D; l2        return dummy.next





    C 解答

1234567891011121314151617181920212223242526struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {    if (l1 &#x3D;&#x3D; NULL) return l2;    if (l2 &#x3D;&#x3D; NULL) return l1;    struct ListNode dummy;    dummy.next &#x3D;&#x3D; NULL;    struct ListNode* p &#x3D; &amp;dummy;    while (l1 &amp;&amp; l2) {        if (l1-&gt;val &lt; l2-&gt;val) {            p-&gt;next &#x3D; l1;            l1 &#x3D; l1-&gt;next;        } else {            p-&gt;next &#x3D; l2;            l2 &#x3D; l2-&gt;next;        }        p &#x3D; p-&gt;next;    }    if (l1)        p-&gt;next &#x3D; l1;    if (l2)        p-&gt;next &#x3D; l2;    return dummy.next;}



22 给定数字 n, 生成所有合法的 n 个括号组成的序列tags: #backtracking
一道典型的深度优先搜索题目

    Python 解答

12345678910111213class Solution:    def generateParenthesis(self, n: int) -&gt; List[str]:        def dfs(s, lefts, rights):            if lefts &#x3D;&#x3D; 0 and rights &#x3D;&#x3D; 0:                ans.append(s)                return            if lefts &gt; 0:                dfs(s+&quot;(&quot;, lefts-1, rights)            if (lefts &lt; rights):                dfs(s+&quot;)&quot;, lefts, rights-1)        ans &#x3D; []        dfs(&quot;&quot;, n, n)        return ans





    C++ 解答

1234567891011121314151617vector&lt;string&gt; generateParenthesis(int n) {    vector&lt;string&gt; result;    gen(result, &quot;&quot;, n, n);    return result;}&#x2F;&#x2F; left 剩下的左括号，right 剩下的右括号void gen(vector&lt;string&gt;&amp; result, string s, int left, int right) {    if (left &#x3D;&#x3D; 0 &amp;&amp; right &#x3D;&#x3D; 0) {        result.push_back(s);        return;    }    if (left !&#x3D; 0)        gen(result, s + &#39;(&#39;, left - 1, right);    if (left &lt; right)        gen(result, s + &#39;)&#39;, left, right - 1);}



23 合并 K 个排序的列表使用优先级队列，复杂度最小。

    Python 解答

12345678910111213141516171819202122232425262728293031&#96;&#96;&#96;&lt;&#x2F;details&gt;把列表看做一个队列，每次拿出两个列表，合并他们后放回到列表中，每次遍历列表的一半，这样每次遍历完一遍，列表的长度都会减半，直到列表的长度为 1,  合并函数使用 21 题中的合并两个列表的函数&lt;details&gt;    &lt;summary&gt;C 解答&lt;&#x2F;summary&gt;&#96;&#96;&#96;Cstruct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {    &#x2F;&#x2F; see above}struct ListNode* mergeKLists(struct ListNode** lists, int listsSize) {    if (!lists || listsSize &lt; 1)        return NULL;    while (listsSize &gt; 1) {        &#x2F;&#x2F; listsize is halfed        for (int i &#x3D; 0; i &lt; listsSize &#x2F; 2; i++)            &#x2F;&#x2F; merge i and last i list            lists[i] &#x3D; mergeTwoLists(lists[i], lists[listsSize-1-i]);        listsSize &#x3D; (listsSize + 1) &#x2F; 2; &#x2F;&#x2F; 注意这里！    }    return lists[0];}



24 给定一个链表，交换两个相邻节点的值最简单的做法显然是直接把前后两个节点的值交换，但是 LeetCode 规定不能改变节点的值。主要考察链表的指针操作，注意各种细节，一定要在纸上先把链表画出来。

    Python 解答

123456789101112class Solution:    def swapPairs(self, head: ListNode) -&gt; ListNode:        dummy &#x3D; ListNode(-1)        dummy.next &#x3D; head        p &#x3D; dummy        while p.next and p.next.next:            t &#x3D; p.next            p.next &#x3D; t.next            t.next &#x3D; p.next.next            p.next.next &#x3D; t            p &#x3D; p.next.next        return dummy.next





    C 解答

123456789101112struct ListNode* swapPairs(struct ListNode* head) {    struct ListNode dummy, *temp, *pnext, *p &#x3D; &amp;dummy;    dummy.next &#x3D; head;    while (p-&gt;next &amp;&amp; p-&gt;next-&gt;next) {        temp &#x3D; p-&gt;next;        p-&gt;next &#x3D; temp-&gt;next;        temp-&gt;next &#x3D; p-&gt;next-&gt;next;        p-&gt;next-&gt;next &#x3D; temp;        p &#x3D; temp;    }    return dummy.next;}



25 给定一个链表，把相邻的 k 个节点反转和上题一样，同样禁止改变节点的值。比较简单地解法是浪费一点空间，使用 Stack, 实现逆转 k 个节点，注意如果 k 较大的话，这种方法是不合适的。另一种方法是直接翻转，空间是O(1) 的，但是时间复杂度是 2N。

    Python 解答

1234567891011121314151617181920212223242526272829303132333435class Solution:    def reverseList(self, head):        prev &#x3D; None        curr &#x3D; head        while curr:            next &#x3D; curr.next            curr.next &#x3D; prev            prev &#x3D; curr            curr &#x3D; next        return prev    def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode:        dummy &#x3D; ListNode(-1)        dummy.next &#x3D; head        p &#x3D; dummy        while p.next:            n &#x3D; k            q &#x3D; p            # 找到下一组接点的头            while n &gt; 0 and q.next:                q &#x3D; q.next                n -&#x3D; 1            # 如果节点不够了直接退出            if n &gt; 0:                break            # 把这段链表先截下来            next &#x3D; q.next            q.next &#x3D; None            tail &#x3D; p.next            p.next &#x3D; self.reverseList(p.next)            p &#x3D; tail            p.next &#x3D; next        return dummy.next



使用 Stack 的 C++ 解法

    C++ 解答

12345678910111213141516171819202122232425262728ListNode* reverseKGroup(ListNode* head, int k) {    stack&lt;ListNode*&gt; stk;    ListNode dummy(-1), *p &#x3D; &amp;dummy, *pp;    dummy.next &#x3D; head;    while (1) {        pp &#x3D; p;        for (int i &#x3D; 0; i &lt; k; i++) {            if (pp-&gt;next) {                stk.push(pp-&gt;next);                pp &#x3D; pp-&gt;next;            } else {                break;            }        }        if (stk.size() &lt; k) &#x2F;&#x2F; 剩下的节点不够 k 个了            return dummy.next;        pp &#x3D; stk.top()-&gt;next; &#x2F;&#x2F; 下一组中的第一个        while (!stk.empty()) {            p-&gt;next &#x3D; stk.top();            stk.pop();            p &#x3D; p-&gt;next;        }        p-&gt;next &#x3D; pp;    }}



26 删除排序数组中的重复项tags: #naive
in-place 的删除重复元素，使用两个指针，一个遍历，一个指向当前的结尾。
PS：这个基础题竟然做了半个小时才做对，⊙﹏⊙b 汗，要加强基础啊！
这类数组中去除中间元素的题写的时候还是很容易出错，重点是使用一个 length 变量，然后还是要遍历整个数组。不要想什么双指针了。

    Python 解答

1234567891011class Solution:    def removeDuplicates(self, nums: List[int]) -&gt; int:        if len(nums) &lt; 2:            return len(nums)        length &#x3D; 0        for i in range(len(nums)):            # 处理 i &#x3D;&#x3D; 0 的情况也是需要注意的            if i &#x3D;&#x3D; 0 or nums[i] !&#x3D; nums[length-1]:                nums[length] &#x3D; nums[i]                length +&#x3D; 1        return length





    C 解答

12345678int removeDuplicates(int* nums, int numsSize) {    if (numsSize &lt;&#x3D; 1) return numsSize;    int len &#x3D; 0;    for (int i &#x3D; 0; i &lt; numsSize; i++)        if (i &#x3D;&#x3D; 0 || nums[i] !&#x3D; nums[len - 1])            nums[len++] &#x3D; nums[i];    return len;}



27 删除元素和上一题类似，注意细节

    Python 解答

12345678910class Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        if not nums:            return 0        length &#x3D; 0        for i in range(len(nums)):            if nums[i] !&#x3D; val:                nums[length] &#x3D; nums[i]                length +&#x3D; 1        return length





    C 解答

123456789int removeElement(int* nums, int numsSize, int val) {    if (!nums || numsSize &#x3D;&#x3D; 0) return 0;    int len &#x3D; 0;    for (int i &#x3D; 0; i &lt; numsSize; i++) {        if (nums[i] !&#x3D; val)            nums[len++] &#x3D; nums[i];    }    return len;}



28 实现 strstr 函数，即查找子串使用暴力算法，时间复杂度 O(n)。也可以用 kmp 算法。

    Python 解答

1234567891011121314151617181920212223# kmp 算法class Solution:    def strStr(self, haystack: str, needle: str) -&gt; int:        if not needle:            return 0        next &#x3D; [0]        j &#x3D; 0        # 特别注意这里的 1        for i in range(1, len(needle)):            while j &gt; 0 and needle[i] !&#x3D; needle[j]:                j &#x3D; next[j-1]            if needle[i] &#x3D;&#x3D; needle[j]:                j +&#x3D; 1            next.append(j)        j &#x3D; 0        for i in range(len(haystack)):            while j &gt; 0 and haystack[i] !&#x3D; needle[j]:                j &#x3D; next[j-1]            if haystack[i] &#x3D;&#x3D; needle[j]:                j +&#x3D; 1            if j &#x3D;&#x3D; len(needle):                return i - j + 1        return -1





    C 解答

123456789101112131415161718&#x2F;* * Brute Force *&#x2F;int strStr(char* haystack, char* needle) {    int h &#x3D; strlen(haystack);    int n &#x3D; strlen(needle);    if (n &#x3D;&#x3D; 0) return 0;    &#x2F;&#x2F; note h - n + 1    for (int i &#x3D; 0; i &lt; h - n + 1; i++) {        for (int j &#x3D; 0; j &lt; n; j++) {            if (needle[j] !&#x3D; haystack[i+j])                break;            if (j &#x3D;&#x3D; n - 1)                return i;        }    }    return -1;}




29 给定连个整数，不使用乘法和除法计算除法。这里 有一个非常好的算法
计算可以从被除数中减去除数的次数

    C 解答

12345678910111213141516171819202122int divide(int dividend, int divisor) {    &#x2F;&#x2F; abs(INT_MIN) &#x3D;&#x3D; INT_MAX + 1    if (divisor &#x3D;&#x3D; 0 || (dividend &#x3D;&#x3D; INT_MIN &amp;&amp; divisor &#x3D;&#x3D; -1))        return INT_MAX;    int sign &#x3D; (dividend &gt; 0) &#x3D;&#x3D; (divisor &gt; 0) ? 1 : -1;    long long n &#x3D; labs(dividend);    long long d &#x3D; labs(divisor);    int result &#x3D; 0;    while (n &gt;&#x3D; d) {        long long temp &#x3D; d;        long long multi &#x3D; 1;        while (n &gt;&#x3D; (temp &lt;&lt; 1)) {            temp &lt;&lt;&#x3D; 1;            multi &lt;&lt;&#x3D; 1;        }        n -&#x3D; temp;        result +&#x3D; multi;    }    return sign * result;}



30 包串联所有单词的子串tags: #slidewindow
一道诡异的滑动窗口的题目，对这类问题还是不很熟啊。

    Python 解答

123456789101112131415161718192021222324252627282930313233&#96;&#96;&#96;&lt;&#x2F;details&gt;&lt;details&gt;    &lt;summary&gt;C++ 解答&lt;&#x2F;summary&gt;&#96;&#96;&#96;C++vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {    unordered_map&lt;string, int&gt; counts;    for (string word : words)        counts[word]++;    int n &#x3D; s.length(), num &#x3D; words.size(), len &#x3D; words[0].size();    vector&lt;int&gt; indexes;    for (int i &#x3D; 0; i &lt; n - num * len + 1; i++) {        unordered_map&lt;string, int&gt; seen;        int j &#x3D; 0;        for (; j &lt; num; j++) {            string word &#x3D; s.substr(i + j * len, len);            if (counts.find(word) !&#x3D; counts.end()) {                seen[word]++;                if (seen[word] &gt; counts[word])                    break;            } else {               break;            }        }        if (j &#x3D;&#x3D; num)            indexes.push_back(i);    }    return indexes;}



31 全排列，下一个首先，对于所有的组合，最小的一个一定是按照升序排序的，最大的一定是倒过来，因此

如果我们发现是完全倒序的，直接翻转就好了；
如果是一般情况，从后向前遍历，找到逆序的数字的边界，假设是 k。那么后边这段已经是完全逆序的，无法变小了，为了保证生成的数字变大，我们再从后向前找到第一个比 k 大的数字，交换这两个数字，再把后续的逆序数组翻转。


    Python 解答

1234567891011121314151617181920212223242526272829class Solution:    def nextPermutation(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        # 前后都是闭区间        def reverse(nums, lo, hi):            while lo &lt; hi:                nums[lo], nums[hi] &#x3D; nums[hi], nums[lo]                lo +&#x3D; 1                hi -&#x3D; 1        k &#x3D; -1        for i in range(len(nums)-2, -1, -1):            if nums[i] &lt; nums[i + 1]:                k &#x3D; i                break        if k &#x3D;&#x3D; -1:            reverse(nums, 0, len(nums)-1)            return        l &#x3D; -1        for i in range(len(nums)-1, k, -1):            if nums[i] &gt; nums[k]:                l &#x3D; i                break        nums[l], nums[k] &#x3D; nums[k], nums[l]        reverse(nums, k+1, len(nums)-1)





    C++ 解答

1234567891011121314151617181920212223void nextPermutation(vector&lt;int&gt;&amp; nums) {    int k &#x3D; -1; &#x2F;&#x2F; 升序排列的最后一个数字    for (int i &#x3D; nums.size() - 2; i &gt;&#x3D; 0; i--) {        if (nums[i] &lt; nums[i + 1]) {            k &#x3D; i;            break;        }    }    &#x2F;&#x2F; 完全是逆序的，直接返回第一个，也就是升序排列    if (k &#x3D;&#x3D; -1) {        reverse(nums.begin(), nums.end());        return;    }    int l &#x3D; -1; &#x2F;&#x2F; 逆序数字中比 k 大的最小的数字    for (int i &#x3D; nums.size() - 1; i &gt; k; i--) {        if (nums[i] &gt; nums[k]) {            l &#x3D; i;            break;        }    }    swap(nums[k], nums[l]); &#x2F;&#x2F; 保证变大    reverse(nums.begin() + k + 1, nums.end()); &#x2F;&#x2F; 保证是下一个}



32 从一个括号构成的字符串中找出最长的合法括号序列动态规划的基础题目。

    Python 解答

123456789101112131415161718class Solution:    def longestValidParentheses(self, s: str) -&gt; int:        dp &#x3D; [0] * len(s)        ans &#x3D; 0        for i in range(1, len(s)):            if s[i] &#x3D;&#x3D; &quot;)&quot;:                if s[i-1] &#x3D;&#x3D; &quot;(&quot;:                    if i &gt;&#x3D; 2:                        dp[i] &#x3D; dp[i-2] + 2                    else:                        dp[i] &#x3D; 2                elif i - dp[i-1] &gt; 0 and s[i-dp[i-1]-1] &#x3D;&#x3D; &quot;(&quot;:                    if i - dp[i-1] &gt;&#x3D; 2:                        dp[i] &#x3D; dp[i-1] + dp[i-dp[i-1]-2] + 2                    else:                        dp[i] &#x3D; dp[i-1] + 2                ans &#x3D; max(ans, dp[i])        return ans



也可以使用栈来解。但是这种方法非常 tricky, 因为要考虑到 ()() 的情况。
33 在排序后又被反转的数组中搜索既然是部分有序的，自然还是使用二分搜索了，注意终止条件。不同于普通二分搜索的两种情况，我们有了四种情况：

前半部分有序，并且在前半部分当中，
前半部分有序，但是不在前半部分
后半部分有序，并且在后半部分
后半部分有序，但是不在后半部分


    Python 解答

12345678910111213141516171819202122class Solution:    def search(self, nums: List[int], target: int) -&gt; int:        if not nums:            return -1        lo &#x3D; 0        hi &#x3D; len(nums) - 1        while lo &lt;&#x3D; hi:            mi &#x3D; lo + (hi - lo) &#x2F;&#x2F; 2            if nums[mi] &#x3D;&#x3D; target:                return mi            # 这里为什么要包含等于号呢            if nums[lo] &lt;&#x3D; nums[mi]:                if nums[lo] &lt;&#x3D; target &lt; nums[mi]:                    hi &#x3D; mi - 1                else:                    lo &#x3D; mi + 1            else:                if nums[mi] &lt; target &lt;&#x3D; nums[hi]:                    lo &#x3D; mi + 1                else:                    hi &#x3D; mi - 1        return -1





    C 解答

12345678910111213141516171819202122232425int search(int* nums, int numsSize, int target) {    int left &#x3D; 0, right &#x3D; numsSize - 1;    while (left &lt;&#x3D; right) {        int mid &#x3D; left + (right - left) &#x2F; 2;        if (nums[mid] &#x3D;&#x3D; target)            return mid;        &#x2F;&#x2F; left half is sorted        if (nums[left] &lt;&#x3D; nums[mid]) {            if (nums[left] &lt;&#x3D; target &amp;&amp; target &lt; nums[mid])                right &#x3D; mid - 1;            else                left &#x3D; mid + 1;        &#x2F;&#x2F; right half is sorted        } else {            if (nums[mid] &lt; target &amp;&amp; target &lt;&#x3D; nums[right])                left &#x3D; mid + 1;            else                right &#x3D; mid - 1;        }    }    return -1;}



34 在排序数组中查找元素的第一个和最后一个位置在 C++ 的标准库中包含了这两个函数，分别是std::lower_bound和std::upper_bound.

    C++ 解答

123456789101112131415161718192021222324252627282930class Solution:    def searchRange(self, nums: List[int], target: int) -&gt; List[int]:        if not nums:            return [-1, -1]        lo &#x3D; 0        hi &#x3D; len(nums)        lower &#x3D; -1        while lo &lt; hi:            mi &#x3D; lo + (hi - lo) &#x2F;&#x2F; 2            if nums[mi] &lt; target:                lo &#x3D; mi + 1            else:                hi &#x3D; mi        if lo &lt; len(nums) and nums[lo] &#x3D;&#x3D; target:            lower &#x3D; lo        lo &#x3D; 0        hi &#x3D; len(nums)        upper &#x3D; -1        while lo &lt; hi:            mi &#x3D; lo + (hi - lo) &#x2F;&#x2F; 2            if nums[mi] &lt;&#x3D; target:                lo &#x3D; mi + 1            else:                hi &#x3D; mi        if nums[lo-1] &#x3D;&#x3D; target:            upper &#x3D; lo - 1        return [lower, upper]



35 二分查找数字，如果没有找到，返回应该插入的位置就是最基础的二分查找

    Python 解答

12345678910111213class Solution:    def searchInsert(self, nums: List[int], target: int) -&gt; int:        lo &#x3D; 0        hi &#x3D; len(nums)        while lo &lt; hi:            mi &#x3D; lo + (hi - lo) &#x2F;&#x2F; 2            if nums[mi] &#x3D;&#x3D; target:                return mi            elif nums[mi] &lt; target:                lo &#x3D; mi + 1            else:                hi &#x3D; mi        return lo





    C 解答

12345678910111213int searchInsert(int* nums, int numsSize, int target) {    int left &#x3D; 0, right &#x3D; numsSize - 1;    while (left &lt;&#x3D; right) {        int mid &#x3D; left + (right - left) &#x2F; 2;        if (nums[mid] &#x3D;&#x3D; target)            return mid;        else if (nums[mid] &lt; target)            left &#x3D; mid + 1;        else            right &#x3D; mid - 1;    }    return left;}



36 合法数独，给定一个数独表，判定当前是否合法
    Python 解答

123456789101112131415161718192021class Solution:    def isValidSudoku(self, board: List[List[str]]) -&gt; bool:        &quot;&quot;&quot;        这道题的关键就在于小格子也是可以用 i 和 j 来计算的：        box_index &#x3D; (row &#x2F; 3) * 3 + columns &#x2F; 3        &quot;&quot;&quot;        # 特别注意浅拷贝的问题        used_i &#x3D; [[0] * 9 for _ in range(9)]        used_j &#x3D; [[0] * 9 for _ in range(9)]        used_k &#x3D; [[0] * 9 for _ in range(9)]        for i in range(9):            for j in range(9):                piece &#x3D; board[i][j]                if piece &#x3D;&#x3D; &quot;.&quot;:                    continue                n &#x3D; int(piece) - 1                k &#x3D; i &#x2F;&#x2F; 3 * 3 + j &#x2F;&#x2F; 3                if used_i[i][n] or used_j[j][n] or used_k[k][n]:                    return False                used_i[i][n] &#x3D; used_j[j][n] &#x3D; used_k[k][n] &#x3D; 1        return True





    C 解答

1234567891011121314&#x2F;&#x2F; 有点浪费空间bool isValidSudoku(char** board, int row, int col) {    bool used_row[9][9] &#x3D; {false}, used_col[9][9] &#x3D; {false}, used_box[9][9] &#x3D; {false};    for (int i &#x3D; 0; i &lt; row; i++)        for (int j &#x3D; 0; j &lt; col; j++)            if (board[i][j] !&#x3D; &#39;.&#39;) {                int num &#x3D; board[i][j] - &#39;0&#39; - 1;                int k &#x3D; i &#x2F; 3 * 3 + j &#x2F; 3;                if (used_row[i][num] || used_col[j][num] || used_box[k][num])                    return false;                used_row[i][num] &#x3D; used_col[j][num] &#x3D; used_box[k][num] &#x3D; true;            }    return true;}



37 求解数独
    C++ 解答

12345678910111213141516171819202122232425262728void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {    solve(board, 0);}bool solve(vector&lt;vector&lt;char&gt;&gt;&amp; board, int ind){    if(ind&#x3D;&#x3D;81) return true;    int i&#x3D;ind&#x2F;9, j&#x3D;ind%9;    if(board[i][j]!&#x3D;&#39;.&#39;)        return solve(board, ind+1);    else{        for(char f &#x3D; &#39;1&#39;; f &lt;&#x3D; &#39;9&#39;; f++) {            if(isValidFill(board, i, j, f)) {                board[i][j]&#x3D; f;                if(solve(board, ind+1)) return true;                board[i][j]&#x3D;&#39;.&#39;;            }        }        return false;    }}bool isValidFill(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j, char fill) {    for(int k&#x3D;0; k&lt;9; k++) {        if(board[i][k]&#x3D;&#x3D;fill) return false; &#x2F;&#x2F;check the row        if(board[k][j]&#x3D;&#x3D;fill) return false; &#x2F;&#x2F;check the column        int r&#x3D; i&#x2F;3*3+j&#x2F;3;   &#x2F;&#x2F;select the block        if(board[r&#x2F;3*3+k&#x2F;3][r%3*3+k%3]&#x3D;&#x3D;fill) return false; &#x2F;&#x2F;check the block    }    return true;}



38 数数并说出来不太理解这道题有什么意义，直接暴力做出来了

    C++ 解答

12345678910111213141516string countAndSay(int n) {    string result &#x3D; &quot;1&quot;;    for (int i &#x3D; 0; i &lt; n -1; i++) {        string temp;        for (int j &#x3D; 0; j &lt; result.size(); j++) {            int count &#x3D; 1;            while (j + 1 &lt; result.size() &amp;&amp; result[j+1] &#x3D;&#x3D; result[j]) {                j++; count++;            }            temp +&#x3D; count + &#39;0&#39;;            temp +&#x3D; result[j];        }        result &#x3D; temp;    }    return result;}



39 给定一个集合，在集合中找出和为 target 的数字，数字可以使用多次，集合中没有重复数字典型的深度优先搜索

    C++ 解答

1234567891011121314151617181920vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {    vector&lt;vector&lt;int&gt;&gt; result;    dfs(result, candidates, {}, target);    return result;}void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; candidates, vector&lt;int&gt; comb, int target) {    if (target &#x3D;&#x3D; 0) {        result.push_back(comb);        return;    }    for (auto c : candidates) {        if (c &gt; target) continue; &#x2F;&#x2F; 数字太大了        if (!comb.empty() &amp;&amp; c &lt; comb.back()) continue; &#x2F;&#x2F; 保证不重复且升序        comb.push_back(c);        dfs(result, candidates, comb, target - c);        comb.pop_back(); &#x2F;&#x2F; 注意此处还需要弹出，因为需要循环    }}



40 同上题一样，但是集合中的数字只能使用一次，并且集合中有重复数字
    C++ 解答

1234567891011121314151617181920212223vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {    vector&lt;vector&lt;int&gt;&gt; result;    sort(candidates.begin(), candidates.end());    dfs(result, candidates, {}, target, 0);    return result;}void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; candidates, vector&lt;int&gt; comb, int target, int start) {    if (target &#x3D;&#x3D; 0) {        result.push_back(comb);        return;    }    for (int i &#x3D; start; i &lt; candidates.size(); i++) {        if (candidates[i] &gt; target)            break;        if (i !&#x3D; start &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i-1])            continue;        comb.push_back(candidates[i]);        dfs(result, candidates, comb, target - candidates[i], i + 1);        comb.pop_back();    }}



41 给定一个数组，找到第一个缺失的正数显然，结果的范围是 [1..n+1]. 而数组的长度为 n 我们把每个位置都放上 i+1,这样如果有位置不是 i+1, 则找到了结果，如果都相等则是 n+1.

    c 解答

12345678910111213141516void swap(int* a, int* b) {    int t &#x3D; *a; *a &#x3D; *b; *b &#x3D; t;}int firstMissingPositive(int* nums, int numsSize) {    for (int i &#x3D; 0; i &lt; numsSize; i++)        &#x2F;&#x2F; 注意此处的 while        while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt;&#x3D; numsSize &amp;&amp; nums[i] !&#x3D; nums[nums[i] - 1])            swap(&amp;nums[i], &amp;nums[nums[i] - 1]);    for (int i &#x3D; 0; i &lt; numsSize; i++)        if (nums[i] !&#x3D; i + 1)            return i + 1;    return numsSize + 1;}



42 给定一个数组表示柱子的高度，求能存贮的雨水的总量从两边向中间收拢

    C 解答

1234567891011121314151617181920212223int trap(int* height, int heightSize) {    int left &#x3D; 0, right &#x3D; heightSize - 1;    int water &#x3D; 0;    int max_left &#x3D; 0, max_right &#x3D; 0;    &#x2F;&#x2F; 从两侧向中间缩小，可以算作是两个指针吧    while (left &lt;&#x3D; right) {        if (height[left] &lt;&#x3D; height[right]) {            if (height[left] &gt;&#x3D; max_left)                max_left &#x3D; height[left];            else                water +&#x3D; max_left - height[left];            left++;        } else {            if (height[right] &gt;&#x3D; max_right)                max_right &#x3D; height[right];            else                water +&#x3D; max_right - height[right];            right--;        }    }    return water;}





    Rust 解答

123456789101112131415161718192021222324252627282930313233impl Solution {    pub fn trap(height: Vec&lt;i32&gt;) -&gt; i32 {        if height.is_empty() {            return 0;        }        let mut left &#x3D; 0;        let mut right &#x3D; height.len() - 1;        let mut water &#x3D; 0;        let mut max_left &#x3D; 0;        let mut max_right &#x3D; 0;        while left &lt;&#x3D; right {            if height[left] &lt;&#x3D; height[right] {                if height[left] &gt;&#x3D; max_left {                    max_left &#x3D; height[left];                } else {                    water +&#x3D; max_left - height[left];                }                left +&#x3D; 1;            } else {                if height[right] &gt;&#x3D; max_right {                    max_right &#x3D; height[right];                } else {                    water +&#x3D; max_right - height[right];                }                right -&#x3D; 1;            }        }        water    }}

t

43 给定两个任意长的字符串，返回一个字符串，代表他们相乘的结果按整数除法运算即可，重点是下标的表示

    C 解答

1234567891011121314151617181920212223242526272829#define tonum(c) (c - &#39;0&#39;)#define tochar(i) (i + &#39;0&#39;)char* multiply(char* num1, char* num2) {    &#x2F;&#x2F; 结果的长度不会超过 m+n,    &#x2F;&#x2F; 假设某个数是 n 位的 9, 则结果比另一个数结尾加上 n 个 0 还小    int n &#x3D; strlen(num1), m &#x3D; strlen(num2);    int len &#x3D; m+n;    char* result &#x3D; malloc(sizeof(char) * (len + 1));    for (int i &#x3D; 0; i &lt; len; i++)        result[i] &#x3D; &#39;0&#39;;    result[len] &#x3D; &#39;\0&#39;;    for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) {        int carry &#x3D; 0;        for (int j &#x3D; m - 1; j &gt;&#x3D; 0; j--) {            int v &#x3D; tonum(result[i+j+1]) +  tonum(num1[i]) * tonum(num2[j]) + carry;            result[i+j+1] &#x3D; tochar(v % 10);            carry &#x3D; v &#x2F; 10;        }        result[i] +&#x3D; carry;    }    for (int i &#x3D; 0; i &lt; len; i++)        if (result[i] !&#x3D; &#39;0&#39;)            return result+i;    return &quot;0&quot;;}



44 通配符匹配，? 代表任意一个字符，*代表任意一个或多个字符注意和正则表达式的区别，要求完全匹配。这道题的关键在于对星号的处理，如果出现星号的时候，我们记录当时的 p 和 s 的值，如果发生了不匹配的话，我们尝试回到该位置的下一个位置开始匹配

    C 解答

1234567891011121314151617181920212223bool isMatch(char* s, char* p) {    char* star &#x3D; NULL;    char* revert &#x3D; s;    while (*s) {        if (*s &#x3D;&#x3D; *p || *p &#x3D;&#x3D; &#39;?&#39;)            s++, p++;        else if (*p &#x3D;&#x3D; &#39;*&#39;)            star &#x3D; p++, revert &#x3D; s;        else if (star)            p &#x3D; star + 1, s &#x3D; ++revert;        else            return false;    }    &#x2F;&#x2F; 如果剩下了 p, 那应该全都是*才对    while (*p) {        if (*p++ !&#x3D; &#39;*&#39;)            return false;    }    return true;}



45 跳跃游戏，给定一个数组，每个数字是在该位置可以向前移动的距离，返回最少需要多少次才能到达终点比较简单，看注释吧

    C 解答

123456789101112131415int jump(int* nums, int numsSize) {    int steps &#x3D; 0;    int last &#x3D; 0; &#x2F;&#x2F; last range    int cur &#x3D; 0; &#x2F;&#x2F; current range    for (int i &#x3D; 0; i &lt; numsSize; i++) {        &#x2F;&#x2F; beyond range, make another jump        if (i &gt; last)            last &#x3D; cur, steps++;        &#x2F;&#x2F; if we could reach longer?        if (nums[i] + i &gt; cur)            cur &#x3D; nums[i] + i;    }    return steps;}



46 生成全排列Cracking 上给出了一种解法，通过不断的添加下一个元素到上一组元素的不同位置来生成全排列，这样固然可以，但是大规模的拼接数组或者字符串是很耗费资源的。
在已经有了字符串（或者数组）的初始排列以后，可以通过不断交换的方法生成每一组全排列。比如对于 xyz，我们有全排列为
x + per(yx)
y + per(xz)
z + per(xy)

那么我们通过把每个元素交换到第一个位置，就把问题规模缩小了，知道把问题规模缩小为 1.

    C++ 解答

123456789101112131415161718vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {    vector&lt;vector&lt;int&gt;&gt; result;    per(result, nums, 0);    return result;}void per(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; nums, int begin) {    if (begin &gt;&#x3D; nums.size()) {        result.push_back(nums);        return;    }    for (int i &#x3D; begin; i &lt; nums.size(); i++) { &#x2F;&#x2F; 注意是从 begin 开始，这样未改变的才能加入进来        swap(nums[begin], nums[i]);        per(result, nums, begin + 1);        swap(nums[begin], nums[i]); &#x2F;&#x2F; 注意因为参数中是传引用，这里需要复原    }}





    Rust 解答

12345678910111213141516171819impl Solution {    pub fn permute(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {        let mut result: Vec&lt;Vec&lt;i32&gt;&gt; &#x3D; vec![];        Self::per(&amp;mut result, nums, 0);        result    }    pub fn per(result: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;, nums: Vec&lt;i32&gt;, begin: usize) {        if begin &gt;&#x3D; nums.len() {            result.push(nums);            return        }        for i in begin..nums.len() {            let mut nums &#x3D; nums.clone();            nums.swap(begin, i);            Self::per(result, nums, begin + 1);        }    }}



47 全排列，数组中有重复元素和上一题基本是一样的，注意跳过重复元素就好了

    C++ 解答

1234567891011121314151617181920vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {    sort(nums.begin(), nums.end());    vector&lt;vector&lt;int&gt;&gt; result;    per(result, nums, 0);    return result;}void per(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; nums, int start) {    if (start &gt;&#x3D; nums.size()) {        result.push_back(nums);        return;    }    for (int i &#x3D; start; i &lt; nums.size(); i++) {        if (start !&#x3D; i &amp;&amp; nums[start] &#x3D;&#x3D; nums[i])            continue;        swap(nums[start], nums[i]);        per(result, nums, start + 1); &#x2F;&#x2F; 事实证明，传引用反倒会超时    }}



48 给定一个n*n的图像旋转图像，顺时针旋转 90 度做法显然是从里到外，一层一层的旋转，这道题主要考察下标的操作

    C 解答

123456789101112131415161718void rotate(int** matrix, int m, int n) {    for (int layer &#x3D; 0; layer &lt; n &#x2F; 2; layer++) {        int first  &#x3D; layer;        int last &#x3D; n - 1 - layer;        for (int i &#x3D; first; i &lt; last; i++) {            int offset &#x3D; i - first;            int top &#x3D; matrix[first][i];            &#x2F;&#x2F; up &lt;- left            matrix[first][i] &#x3D; matrix[last-offset][first];            &#x2F;&#x2F; left &lt;- down            matrix[last-offset][first] &#x3D; matrix[last][last-offset];            &#x2F;&#x2F; down &lt;- right            matrix[last][last-offset] &#x3D; matrix[i][last];            &#x2F;&#x2F; right &lt;- up            matrix[i][last] &#x3D; top;        }    }}



49 给定字符数组，把他们按照 Anagram 分组
    C++ 解答

1234567891011121314151617&#x2F;&#x2F; Anagram 分组&#x2F;&#x2F; 这道题没什么可做的，只需要统计vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {    vector&lt;vector&lt;string&gt;&gt; result;    string temp;    unordered_map&lt;string, vector&lt;string&gt;&gt; records;    for (int i &#x3D; 0; i &lt; strs.size(); ++i) {        temp &#x3D; strs[i];        sort(temp.begin(), temp.end());        records[temp].push_back(strs[i]);    }    for (auto&amp; record : records) {        sort(record.second.begin(), record.second.end());        result.push_back(record.second);    }    return result;}



50 实现 pow(x, n)显然不能直接阶乘过去，分治法
递归做法

    C 解答

123456789101112&#x2F;&#x2F; recursivedouble myPow(double x, int n) {    if (n &#x3D;&#x3D; INT_MIN) return myPow(x, n - 1) * x;    if (n &lt; 0) return 1 &#x2F; myPow(x, -n);    if (n &#x3D;&#x3D; 0) return 1;    if (n &#x3D;&#x3D; 1) return x;    double y &#x3D; myPow(x, n &#x2F; 2);    if (n &amp; 0x1)        return y * y * x;    else        return y * y;}



迭代做法

    C 解答

12345678910111213&#x2F;&#x2F; iterativelydouble myPow(double x, long p) {    double result &#x3D; 1;    if (p &lt; 0)         return 1 &#x2F; myPow(x, -p);    while (p) {        if (p &amp; 1)            result *&#x3D; x;        x *&#x3D; x;        p &#x2F;&#x3D; 2;    }    return result;}



51 N 皇后问题需要大幅度修改

    C++ 解答

1234567891011121314151617181920212223242526272829303132333435363738394041&#x2F;&#x2F; N 皇后问题，皇后不能再一条直线，一条竖线，一条斜线上&#x2F;&#x2F; 使用深度优先求解，对于 dfs 问题，我们首先把算法的框架写下来，然后确定这个问题的限制条件&#x2F;&#x2F; 对于这个问题，限制条件当前行的元素不能在以前的列中出现过，也不能在对角线中出现过vector&lt;vector&lt;string&gt;&gt; result;vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {    if (n &lt; 1) return result;    vector&lt;int&gt; x(n);    dfs(0, x, n);    return result;}void dfs(int t, vector&lt;int&gt;&amp; x, int n) {    &#x2F;&#x2F; 当新添加一个 Q 到当前解的时候    if (t &gt;&#x3D; n) {        &#x2F;&#x2F; result.push_back(make_solution(x));        &#x2F;&#x2F; return;        vector&lt;string&gt; solution;        for (int i &#x3D; 0; i &lt; n; i++) {            string line(n, &#39;.&#39;);            line[x[i]] &#x3D; &#39;Q&#39;;            solution.push_back(line);        }        result.push_back(solution);    } else {        for (int i &#x3D; 0; i &lt; n; i++) {            bool skip &#x3D; false;            for (int j &#x3D; 0; j &lt; t; j++) {                if (x[j] &#x3D;&#x3D; i || abs(i - x[j]) &#x3D;&#x3D; abs(t - j)) {                    skip &#x3D; true;                    break;                }            }            if (skip) continue;            x[t] &#x3D; i;            dfs(t+1, x, n);        }    }}



52 N 皇后一共有多少个解不要直接把皇后放好，而是把占用的都记录下来，然后继续深度优先搜索

    C++ 解答

1234567891011121314151617181920212223242526272829class Solution {public:    unordered_set&lt;int&gt; cols, digs1, digs2;    int totalNQueens(int n) {        return total(0, 0, n);    }    int total(int row, int count, int n) {        for (int col &#x3D; 0; col &lt; n; col++) {            if (cols.find(col) !&#x3D; cols.end()                || digs1.find(row - col) !&#x3D; digs1.end()                || digs2.find(row + col) !&#x3D; digs2.end())            continue;            if (row &#x3D;&#x3D; n-1)                count++;            else {                cols.insert(col);                digs1.insert(row-col);                digs2.insert(row+col);                count &#x3D; total(row+1, count, n);                cols.erase(col);                digs1.erase(row-col);                digs2.erase(row+col);            }        }        return count;    }};



53 最大子序列和动态规划经典题目，遍历数组，如果已经当前子序列已经小于 0 了，抛弃并置 sum &#x3D; 0如果比当前和更大，更新。对于一个子序列，要么使得序列和增大，要么减小。
dp[n+1] &#x3D; max(dp[n], dp[n] + A[n+1])

    C 解答

12345678910111213int maxSubArray(int* nums, int numsSize) {    int sum &#x3D; 0;    int m &#x3D; INT_MIN;    for (int i &#x3D;0; i&lt; numsSize; i++) {        sum +&#x3D; nums[i];        if (sum &gt; m)            m &#x3D; sum;        if (sum &lt; 0)            sum &#x3D; 0;    }    return m;}





    Python 解答

123456789class Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        current_sum &#x3D; 0        max_value &#x3D; float(&#39;-inf&#39;)        for i in nums:            current_sum +&#x3D; i            max_value &#x3D; max(max_value, current_sum)            current_sum &#x3D; max(0, current_sum)        return max_value



54 顺时针螺旋打印矩阵一圈一圈地打印就好了

    C 解答

12345678910111213141516171819202122232425int* spiralOrder(int** matrix, int row, int col) {    if (row &#x3D;&#x3D; 0 || col &#x3D;&#x3D; 0) return NULL;    int top &#x3D; 0, right &#x3D; col - 1, down &#x3D; row - 1, left &#x3D; 0;    int index &#x3D; 0;    int* result &#x3D; malloc(sizeof(int) * row * col);    while (top &lt;&#x3D; down &amp;&amp; left &lt;&#x3D; right) {        for (int i &#x3D; left; i &lt;&#x3D; right; i++)            result[index++] &#x3D; matrix[top][i];        top++; &#x2F;&#x2F;        for (int i &#x3D; top; i &lt;&#x3D; down; i++)            result[index++] &#x3D; matrix[i][right];        right--; &#x2F;&#x2F;        &#x2F;&#x2F; 注意这个 if 语句        if (top &lt;&#x3D; down)            for (int i &#x3D; right; i &gt;&#x3D; left; i--)                result[index++] &#x3D; matrix[down][i];        down--; &#x2F;&#x2F;        &#x2F;&#x2F; 注意这个 if 语句        if (left &lt;&#x3D; right)            for (int i &#x3D; down; i &gt;&#x3D; top; i--)                result[index++] &#x3D; matrix[i][left];        left++; &#x2F;&#x2F;    }    return result;}



55 给定一个数组，每个数字表示在当前步可以移动的距离，返回是不是能够到达终点使用动态规划求解，如果当前距离大于最远距离，更新最远距离，如果已经超过了最远距离，跳出

    C 解答

1234567bool canJump(int* nums, int numsSize) {    int i;    int reach &#x3D; 0;    for (i &#x3D; 0; i &lt; numsSize &amp;&amp; i &lt;&#x3D; reach; i++)            reach &#x3D; max(reach, nums[i] + i);    return i &#x3D;&#x3D; numsSize;}



56 合并序列，给定一组序列，把其中重叠的序列合并这道题用 Python 做竟然比用 C++ 还要快

    Python 解答

12345678910111213141516&quot;&quot;&quot;class Interval(object):    def __init__(self, start&#x3D;0, end&#x3D;0):        self.start &#x3D; start        self.end&#x3D; end&quot;&quot;&quot;def merge(intervals):    intervals.sort(key&#x3D;lambda x: x.start)    combined &#x3D; []    for interval in intervals:        if combined and interval.start &lt;&#x3D; combined[-1].end:            combined[-1].end &#x3D; max(combined[-1].end, interval.end)        else:            combined.append(interval)    return combined



57 添加序列，给定一组已经排序的序列，向其中插入一个序列，需要合并的合并把剩余的部分都拷贝过来也不失为一种机智的做法。

    Python 解答

12345678910111213141516171819class Solution:    def insert(self, intervals, newInterval):        ans &#x3D; []        start, end &#x3D; newInterval        remainder &#x3D; 0        for x, y in intervals:            # 未重叠            if start &gt; y:                ans.append([x, y])            # 进入重叠状态            else:                if end &lt; x:  # 当前区间已经不重叠了                    break  # 找到了结尾了                start &#x3D; min(start, x)                end &#x3D; max(end, y)            remainder +&#x3D; 1        ans.append([start, end])        ans +&#x3D; intervals[remainder:]        return ans




58 给定一个字符串，求其中最后一个单词的长度显然这道题可以用 strlen 求出长度然后从后往前数，但是，这样相当于多遍历了一次直接从后往前可以保证只遍历一次

    C 解答

123456789101112131415161718int lengthOfLastWord(char* s) {    int len &#x3D; 0;    bool inWord &#x3D; false;    while (*s) {        if (isspace(*s)) {            inWord &#x3D; false;        } else {            if (!inWord) {                len &#x3D; 1;                inWord &#x3D; true;            } else {                len++;            }        }        s++;    }    return len;}



59 给定 n，把 1, 2, 3 … 螺旋打印到矩阵中和上一个完全一样的思路，只是这次是打印罢了

    C 解答

123456789101112131415161718192021222324252627282930&#x2F;** * Return an array of arrays. * Note: The returned array must be malloced, assume caller calls free(). *&#x2F;int** generateMatrix(int n) {    int** matrix &#x3D; malloc(sizeof(int*) * n);    for (int i &#x3D; 0; i &lt; n; i++)        matrix[i] &#x3D; malloc(sizeof(int) * n);    int top &#x3D; 0, left &#x3D; 0, down &#x3D; n - 1, right &#x3D; n - 1;    int a &#x3D; 1;    while (top &lt;&#x3D; down &amp;&amp; left &lt;&#x3D; right) {        for (int i &#x3D; left; i &lt;&#x3D;right; i++)            matrix[top][i] &#x3D; a++;        top++;        for (int i &#x3D; top; i &lt;&#x3D; down; i++) {            matrix[i][right] &#x3D; a++;        }        right--;        if (top &lt;&#x3D; down)            for (int i &#x3D; right; i &gt;&#x3D; left; i--)                matrix[down][i] &#x3D; a++;        down--;        if (left &lt;&#x3D; right)            for (int i &#x3D; down; i &gt;&#x3D; top; i--)                matrix[i][left] &#x3D; a++;        left++;    }    return matrix;}



60 给定 n 个数字，找出第 k 个 Permutation
    C++ 解答

12345678910111213141516171819202122232425262728293031class Solution {public:    &#x2F;*The logic is as follows:    for n numbers the permutations can be divided to (n-1)! groups,    thus k&#x2F;(n-1)! indicates the index of current number,    and k%(n-1)! denotes remaining sequence (to the right).    We keep doing this until n reaches 0, then we get n numbers permutations that is kth.    *&#x2F;    string getPermutation(int n, int k) {        int f &#x3D; 1;        string s(n, &#39;0&#39;);        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {            f *&#x3D; i;            s[i-1] &#x3D; i + &#39;0&#39;;        }        &#x2F;&#x2F; 给定 n, 一共有 n! 个序列，f &#x3D;&#x3D; n!        k--;        for (int i &#x3D; 0; i &lt; n; i++) {            f &#x2F;&#x3D; n - i; &#x2F;&#x2F; f &#x2F;&#x3D; n, f &#x2F;&#x3D; n - 1 ...            int j &#x3D; i + k &#x2F; f;            char c&#x3D; s[j];            for (;j &gt; i; j--) &#x2F;&#x2F; shift space to put &#96;c&#96;, actually we could use swap                s[j] &#x3D; s[j-1];            s[i] &#x3D; c;            k %&#x3D; f;        }        return s;    }};



61 把列表旋转到倒数第 k 位需要注意的是 k 大于列表长度的情况，这时候需要取余

    C 解答

1234567891011121314151617181920212223242526struct ListNode* rotateRight(struct ListNode* head, int k) {    if (!head || k &lt;&#x3D; 0) return head;    int l &#x3D; 1;    struct ListNode* n &#x3D; head;    while (n-&gt;next) {        n &#x3D; n-&gt;next;        l++;    }    &#x2F;&#x2F; n is now the tail!    if (k &gt;&#x3D; l) k %&#x3D; l;    if (k &#x3D;&#x3D; 0) return head;    struct ListNode dummy, *p &#x3D; &amp;dummy;    dummy.next &#x3D; head;    int i &#x3D; l - k;    while (i--)        p &#x3D; p-&gt;next;    dummy.next &#x3D; p-&gt;next;    p-&gt;next &#x3D; NULL;    n-&gt;next &#x3D; head;    return dummy.next;}



62 给定一个m*n的矩阵，有多少种方法从左上角移动到右下角显然可以使用组合数学直接求出来解，但是容易溢出。而且这是一道经典的动态规划题目，对于每个格子，可以从他的上部或者左面移动过来。

    C++ 解答

1234567int uniquePaths(int m, int n) {    vector&lt;vector&lt;int&gt;&gt; grid(m, vector&lt;int&gt; (n, 1));    for (int i &#x3D; 1; i &lt; m; i++)        for (int j &#x3D; 1; j &lt; n; j++)            grid[i][j] &#x3D; grid[i - 1][j] + grid[i][j - 1];    return grid[m - 1][n - 1];}



63 同上题，区别是在一些位置是有障碍物的经过分析可知，递推关系是一样的，只需要把有障碍格子的到达方法设定为 0。这个主要是实现上的一些技巧，见注释。

    C++ 解答

1234567891011121314int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {    int m &#x3D; obstacleGrid.size(), n &#x3D; obstacleGrid[0].size();    &#x2F;&#x2F; 注意设定长宽均 +1，但是初始化为 0，边界就成了障碍    vector&lt;vector&lt;int&gt;&gt; pathes(m + 1, vector&lt;int&gt; (n + 1, 0));    pathes[0][1] &#x3D; 1; &#x2F;&#x2F; 给定一个入口    for (int i &#x3D; 1; i &lt; m + 1; i++)        for (int j &#x3D; 1; j &lt; n + 1; j++)            &#x2F;&#x2F; 注意此处的偏移            if (obstacleGrid[i-1][j-1] &#x3D;&#x3D; 1)                pathes[i][j] &#x3D; 0;            else                pathes[i][j] &#x3D; pathes[i-1][j] + pathes[i][j-1];    return pathes[m][n];}



64 给定一个m*n矩阵，每个数字代表经过该处的耗费，找出一条耗费最小的路径依然是动态规划

    C++ 解答

123456789101112131415int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {    &#x2F;&#x2F; if modifying the grid is disallowed, copy it    int m &#x3D; grid.size(), n &#x3D; grid[0].size();    for (int i &#x3D; 0; i &lt; m; i++)        for (int j &#x3D; 0; j &lt; n; j++)            if (i &#x3D;&#x3D; 0 &amp;&amp; j &#x3D;&#x3D; 0)                continue;            else if (i &#x3D;&#x3D; 0 &amp;&amp; j !&#x3D; 0)                grid[i][j] +&#x3D; grid[i][j-1];            else if (i !&#x3D; 0 &amp;&amp; j &#x3D;&#x3D; 0)                grid[i][j] +&#x3D; grid[i-1][j];            else                grid[i][j] +&#x3D; min(grid[i-1][j], grid[i][j-1]);    return grid[m-1][n-1];}



65 判定一个字符串是否是合法的数字，包括了正负号，小数点，e等一些例子：
&quot;0&quot; &#x3D;&gt; true
&quot; 0.1 &quot; &#x3D;&gt; true
&quot;abc&quot; &#x3D;&gt; false
&quot;1 a&quot; &#x3D;&gt; false
&quot;2e10&quot; &#x3D;&gt; true

这道题就是细节题，用 C 处理字符串太蛋疼了，直接上 Python 了

    Python 解答

123456789101112131415161718192021222324252627282930313233343536373839404142434445def isNumber(self, s):    BEFORE &#x3D; 0 # before dot    AFTER &#x3D; 1 # after dot    EXP &#x3D; 2 # after e    phase &#x3D; BEFORE    allow_sign &#x3D; True    s &#x3D; s.strip()    if not any([c.isdigit() for c in s]):        return False    if s &#x3D;&#x3D; &#39;&#39; or s[0] &#x3D;&#x3D; &#39;e&#39; or s[-1] &#x3D;&#x3D; &#39;e&#39; or s &#x3D;&#x3D; &#39;.&#39;:        return False    if s[0] &#x3D;&#x3D; &#39;.&#39; and s[1] &#x3D;&#x3D; &#39;e&#39;:        return False    if s[0] &#x3D;&#x3D; &#39;-&#39; and s[1] &#x3D;&#x3D; &#39;e&#39;:        return False    for c in s:        if &#39;0&#39; &lt;&#x3D; c &lt;&#x3D; &#39;9&#39;:            allow_sign &#x3D; False        elif c &#x3D;&#x3D; &#39;.&#39;:            allow_sign &#x3D; False            if phase &#x3D;&#x3D; EXP or phase &#x3D;&#x3D; AFTER:                return False            else:                phase &#x3D; AFTER        elif c &#x3D;&#x3D; &#39;e&#39;:            if phase &#x3D;&#x3D; EXP:                return False            allow_sign &#x3D; True            phase &#x3D; EXP        elif c &#x3D;&#x3D; &#39;-&#39; or c &#x3D;&#x3D; &#39;+&#39;:            if not allow_sign:                return False            allow_sign &#x3D; False        else:            return False    if phase &#x3D;&#x3D; EXP:        return s[-1].isdigit()    return True



66 给定一个字符串代表的数字，返回加 1 后的数字乍一看如果需要进位的话，可能需要拷贝整个数组。实际上并不需要，我们知道只有当数字是 999…999 的时候，才会使得数字的长度 +1 变为 1000…000。

    C++ 解答

1234567891011121314vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) {    int n &#x3D; digits.size();    for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) {        if (digits[i] &#x3D;&#x3D; 9) {            digits[i] &#x3D; 0;        } else {            digits[i]++;            return digits;    }    &#x2F;&#x2F; trick here, we know that the number is 999...999    digits[0] &#x3D; 1;    digits.push_back(0);    return digits;}





    Rust 解答

12345678910111213impl Solution {    pub fn plus_one(mut digits: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {        for i in (0..digits.len()).rev() {            match digits[i] {                9 &#x3D;&gt; digits[i] &#x3D; 0,                _ &#x3D;&gt; {digits[i] +&#x3D; 1; return digits}            }        }        digits[0] &#x3D; 1;        digits.push(0);        digits    }}



67 给定两个字符串代表的二进制数字，返回他们相加的和和上一题一样，按照加法定义做就好了

    C 解答

12345678910111213141516#define tonum(c) (c - &#39;0&#39;)#define tochar(i) (i + &#39;0&#39;)char* addBinary(char* a, char* b) {    int m &#x3D; strlen(a), n &#x3D; strlen(b);    int len &#x3D; (m &gt; n ? m : n) + 1; &#x2F;&#x2F; strlen(c)    char* c &#x3D; malloc(sizeof(char) * len + 1); &#x2F;&#x2F; with ending null    memset(c, &#39;0&#39;, len+1);    c[len] &#x3D; 0;    int carry &#x3D; 0;    for (int i &#x3D; 1; i &lt;&#x3D; len; i++) {         c[len-i] &#x3D; tochar((i &lt;&#x3D; m ? tonum(a[m-i]) : 0) ^ (i &lt;&#x3D; n ? tonum(b[n-i]) : 0) ^ carry);         carry &#x3D; ((i &lt;&#x3D; m ? tonum(a[m-i]) : 0) + (i &lt;&#x3D; n ? tonum(b[n-i]) : 0) + carry) &gt;&gt; 1;    }    return c[0] &#x3D;&#x3D; &#39;0&#39; ? c+1 : c;}



68 文字对齐待研究

    C++ 解答

1234567891011121314151617vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int L) {    vector&lt;string&gt; res;    for(int i &#x3D; 0, k, l; i &lt; words.size(); i +&#x3D; k) {        for(k &#x3D; l &#x3D; 0; i + k &lt; words.size() and l + words[i+k].size() &lt;&#x3D; L - k; k++) {            l +&#x3D; words[i+k].size();        }        string tmp &#x3D; words[i];        for(int j &#x3D; 0; j &lt; k - 1; j++) {            if(i + k &gt;&#x3D; words.size()) tmp +&#x3D; &quot; &quot;;            else tmp +&#x3D; string((L - l) &#x2F; (k - 1) + (j &lt; (L - l) % (k - 1)), &#39; &#39;);            tmp +&#x3D; words[i+j+1];        }        tmp +&#x3D; string(L - tmp.size(), &#39; &#39;);        res.push_back(tmp);    }    return res;}



69 给定整数 x，求 sqrt(x)比较坑的是 LeetCode 要求的是 y*y &lt; x 的最大整数

    C 解答

123456789101112int mySqrt(int x) {    if (x &lt;&#x3D; 1) return x;    const double EPS &#x3D; x * 0.0001;    double y &#x3D; x &#x2F; 2; &#x2F;&#x2F; initial guess    while (fabs(y * y - x) &gt; EPS) {        y &#x3D; (y + x &#x2F; y) &#x2F; 2;    }    long z &#x3D; (long) y;    while (z * z &gt; x) z--;    return z;}



70 爬梯子，一次可以爬一步或者两步，有几种方法爬完梯子斐波那契数列，也可以理解为动态规划

    C 解答

123456int climbStairs(int n) {    int a &#x3D; 1, b &#x3D; 1, t;    for (int i &#x3D; 1; i &lt; n; i++)        t &#x3D; b, b +&#x3D; a, a &#x3D; t;    return b;}



71 简化 Unix 路径，需要处理., .. 和多个斜杠等情况没有什么需要注意的，主要是使用 stringstream 用作 string.split

    C++ 解答

12345678910111213141516171819string simplifyPath(string&amp; path) {    vector&lt;string&gt; dirs;    stringstream ss(path);    string dir;    while (getline(ss, dir, &#39;&#x2F;&#39;)) {        if (dir &#x3D;&#x3D; &quot;.&quot; || dir &#x3D;&#x3D; &quot;&quot;)            continue;        else if (dir &#x3D;&#x3D; &quot;..&quot;) {            if (!dirs.empty())            dirs.pop_back();        } else            dirs.push_back(dir);    }    string result;    for (auto&amp; dir : dirs)        if (!dir.empty())            result +&#x3D; &quot;&#x2F;&quot; + dir;    return result.size() ? result : &quot;&#x2F;&quot;;}



72 编辑距离，允许替换，删除，插入三种操作对于两个字符串比较，往往要使用二维的动态规划。使用 f[i][j] 表示 word1[1..i] 和 word2[1..j] 之间的距离。see here
那么：

相等 f[i][j] &#x3D; f[i-1][j-1];

不相等

替换：f[i][j] &#x3D; f[i-1][j-1] + 1;  都向前一步
添加：f[i][j] &#x3D; f[i][j-1] + 1; word2 向前一步
删除：f[i][j] &#x3D; f[i-1][j] + 1; word1 向前一步



另外使用一维数组表示二维数组还需要了解

    C++ 解答

123456789101112131415161718&#x2F;&#x2F; unoptimized codeint minDistance(string word1, string word2) {    int m &#x3D; word1.length(), n &#x3D; word2.length();    vector&lt;vector&lt;int&gt; &gt; dp(m + 1, vector&lt;int&gt; (n + 1, 0));    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)        dp[i][0] &#x3D; i;    for (int j &#x3D; 1; j &lt;&#x3D; n; j++)        dp[0][j] &#x3D; j;    for (int i &#x3D; 1; i &lt;&#x3D; m; i++) {        for (int j &#x3D; 1; j &lt;&#x3D; n; j++) {            if (word1[i - 1] &#x3D;&#x3D; word2[j - 1])                dp[i][j] &#x3D; dp[i - 1][j - 1];            else dp[i][j] &#x3D; min(dp[i - 1][j - 1] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j] + 1));        }    }    return dp[m][n];}





    C++ 解答

1234567891011121314151617181920&#x2F;&#x2F; optimizedint minDistance(string word1, string word2) {    int m &#x3D; word1.length(), n &#x3D; word2.length();    vector&lt;int&gt; cur(m + 1, 0);    &#x2F;&#x2F; 把剩余的字符删掉的距离    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)        cur[i] &#x3D; i;    for (int j &#x3D; 1; j &lt;&#x3D; n; j++) {        int pre &#x3D; cur[0];        cur[0] &#x3D; j;        for (int i &#x3D; 1; i &lt;&#x3D; m; i++) {            int temp &#x3D; cur[i];            if (word1[i - 1] &#x3D;&#x3D; word2[j - 1])                cur[i] &#x3D; pre;            else cur[i] &#x3D; min(pre + 1, min(cur[i] + 1, cur[i - 1] + 1));            pre &#x3D; temp;        }    }    return cur[m];}





    C++ 解答

12345678910111213141516171819202122&#x2F;&#x2F; recursive code from beauty of programming&#x2F;&#x2F; TLE on LeetCodeint minDistance(string word1, string word2) {    return minDistance(&amp;word1.front(), &amp;word1.back(), &amp;word2.front(), &amp;word2.back())}int minDistance(char* start1, char* end1, char* start2, char* end2) {    if (start1 &gt; end1)        return start2 &gt; end2 ? 0 : end2 - start2 + 1;    if (start2 &gt; end2)        return start1 &gt; end1 ? 0 : end1 - start1 + 1;    if (*start1 &#x3D;&#x3D; *start2)        return minDistance(start1 + 1, end1, start2 + 1, end2);    else {        int t1 &#x3D; minDistance(start1 + 1, end1, start2 + 1, end2);        int t2 &#x3D; minDistance(start1 + 1, end1, start2, end2);        int t3 &#x3D; minDistance(start1, end1, start2 + 1, end2);        return min(t1, min(t2, t3)) + 1;    }}



73 给定一个矩阵，如果某个元素为零，把所在的行和所在的列都设为零一种可以接受的方法是使用 O(m+n) 的空间，记录哪行哪列需要设为零

    C++ 解答

123456789101112131415161718void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {    int m &#x3D; matrix.size();    if (m &#x3D;&#x3D; 0) return;    int n &#x3D; matrix[0].size();    if (n &#x3D;&#x3D; 0) return;    vector&lt;bool&gt; row(m), column(n);    for (int i &#x3D; 0; i &lt; m; ++i)        for (int j &#x3D; 0; j &lt; n; ++j)            if (matrix[i][j] &#x3D;&#x3D; 0)                row[i] &#x3D; true, column[j] &#x3D; true;    for (int i &#x3D; 0; i &lt; m; ++i)        for (int j &#x3D; 0; j &lt; n; ++j)            if (row[i] || column[j])                matrix[i][j] &#x3D; 0;}



74 搜索矩阵，矩阵每行从左到右依次增大，每行都比上一行大当做数组直接二分搜索就可以了

    C++ 解答

12345678910111213bool searchMatrix(int** matrix, int row, int col, int target) {    int left &#x3D; 0, right &#x3D; row * col - 1;    while (left &lt;&#x3D; right) {        int mid &#x3D; left + (right - left) &#x2F; 2;        if (matrix[mid&#x2F;col][mid%col] &lt; target)            left &#x3D; mid + 1;        else if (matrix[mid&#x2F;col][mid%col] &#x3D;&#x3D; target)            return true;        else            right &#x3D; mid - 1;    }    return false;}



75 颜色排序，每个物体有颜色属性，把他们按照 RGB 的顺序排序 (🇳🇱国旗问题）一种方法是简单地 2 pass 解法，遍历一遍计数再输出。另一种方法是把红色往前交换，蓝色往后交换

    C 解答

123456789101112void swap(int* a, int* b) {    int t &#x3D; *a; *a &#x3D; *b; *b &#x3D; t;}void sortColors(int* nums, int numsSize) {    const int RED &#x3D; 0, GREEN &#x3D; 1, BLUE &#x3D; 2;    int reds &#x3D; 0,  blues &#x3D; numsSize - 1;    for (int i &#x3D; 0; i &lt;&#x3D; blues; i++) {        while (nums[i] &#x3D;&#x3D; BLUE &amp;&amp; i &lt; blues) swap(&amp;nums[i], &amp;nums[blues--]);        while (nums[i] &#x3D;&#x3D; RED &amp;&amp; i &gt; reds) swap(&amp;nums[i], &amp;nums[reds++]);    }}



76 跳过
77 给定数字 n 和 k，生成从 n 中取出 k 个数字的所有情况数学上的组合，使用回溯来做，对状态空间进行深度搜索。
回溯方法通常适合对状态空间树的深度优先搜索相结合的，当一个解已经不满足条件时，剪枝；如果满足条件，直到找到完全解未知。

    C++ 解答

123456789101112131415161718192021222324&#x2F;&#x2F; 组合是不要求顺序的vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {    vector&lt;vector&lt;int&gt;&gt; result;    if (n &lt; k)        return result;    vector&lt;int&gt; temp(0, k);    combine(result, temp, 0, 0, n, k);    return result;}void combine(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; temp, int start, int count, int n, int k) {    &#x2F;&#x2F; 1. 回溯条件，找到了一个解    if (count &#x3D;&#x3D; k) {        result.push_back(temp);        return;    }    &#x2F;&#x2F; 2. 深度优先搜索    for (int i &#x3D; start; i &lt; n; i++) {        temp.push_back(i + 1);        &#x2F;&#x2F; 只搜索比 i 大的即可        combine(result, temp, i+ 1, count+1, n, k);        temp.pop_back();    }}



78 给定一个集合，找到它的所有子集这道题至少有 3 种解法：

DFS，我们知道对于 n 个元素的集合，有 2^n 个子集，通过每个元素在不在子集中构造一个状态空间树
类似于电话键盘生成字母，迭代
巧妙的利用 1..2^n 对应


    C++ 解答

1234567891011121314151617181920212223&#x2F;&#x2F; use backtracking and do a dfs searchvector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {    vector&lt;vector&lt;int&gt;&gt; result;    if (nums.empty()) return result;    sort(nums.begin(), nums.end());    vector&lt;int&gt; temp;    subsets(nums, result, temp, 0);    return result;}&#x2F;&#x2F; for each solution, the can be divided into two sub solutions: in or outvoid subsets(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; temp, int i) {    if (i &#x3D;&#x3D; nums.size()) {        result.push_back(temp);        return;    }    vector&lt;int&gt; t &#x3D; temp;    subsets(nums, result, temp, i + 1);    temp.push_back(nums[i]);    subsets(nums, result, temp, i + 1);}





    C++ 解答

123456789101112131415161718&#x2F;&#x2F; iterativevector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {    vector&lt;vector&lt;int&gt;&gt; result;    result.push_back({});    if (nums.empty())        return result;    result.push_back(vector&lt;int&gt;(1, nums[0]));    for (int i &#x3D; 1; i &lt; nums.size(); i++) {        int size &#x3D; result.size(); &#x2F;&#x2F; notice the cached size        for (int j &#x3D; 0; j &lt; size; j++) {            auto new_subset &#x3D; result[j];            new_subset.push_back(nums[i]);            sort(new_subset.begin(), new_subset.end());            result.push_back(new_subset);        }    }    return result;}





    C++ 解答

1234567891011121314151617&#x2F;&#x2F; trickyvector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {    vector&lt;vector&lt;int&gt;&gt; result;    int size &#x3D; (1 &lt;&lt; nums.size());    for (int i &#x3D; 0; i &lt; size; i++) {        vector&lt;int&gt; subset;        int k &#x3D; i;        for (int j &#x3D; 0; j &lt; nums.size(); j++) {            if (k &amp; 0x1)                subset.push_back(nums[j]);            k &gt;&gt;&#x3D; 1;        }        sort(subset.begin(), subset.end());        result.push_back(subset);    }    return result;}



79 给定一个二维字符数组，查找一个单词是否能够有连续的字母构成，不能交叉也是深度优先的做法，首先找到开始的字母，然后依次向上下左右查找，注意还需要统计有没有访问过

    C++ 解答

123456789101112131415161718192021222324252627282930313233bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {    int row &#x3D; board.size();    int col &#x3D; board[0].size();    vector&lt;vector&lt;bool&gt;&gt; visited(row, vector&lt;bool&gt; (col, false));    bool found &#x3D; false;    for (int i &#x3D; 0; i &lt; row; i++) {        for (int j &#x3D; 0; j &lt; col; j++) {            if (board[i][j] &#x3D;&#x3D; word[0]) {                if (findNext(board, word, visited, i, j, 0))                    found &#x3D; true;            }        }    }    return found;}bool findNext(vector&lt;vector&lt;char&gt;&gt;&amp; board, string&amp; word, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int m, int n, int i) {    if (i &#x3D;&#x3D; word.size())        return true;    if (m &gt;&#x3D; board.size() || n &gt;&#x3D; board[0].size() || m &lt; 0 || n &lt; 0|| visited[m][n] || board[m][n] !&#x3D; word[i])        return false;    char temp &#x3D; board[m][n];    board[m][n] &#x3D; -1;    bool exist &#x3D; findNext(board, word, visited, m + 1, n, i+1) ||        findNext(board, word, visited, m - 1, n, i+1) ||        findNext(board, word, visited, m, n+1, i+1) ||        findNext(board, word, visited, m, n-1, i+1);    board[m][n] &#x3D; temp;    return exist;}



80 从排序数组中删除重复元素，但是允许一个元素重复出现两次巧妙地解法，和i-2的元素对比

    C 解答

123456789int removeDuplicates(int* nums, int numsSize) {    if (!nums || numsSize &lt; 1) return 0;    int len &#x3D; 0, counter &#x3D; 0;    for (int i &#x3D; 0; i &lt; numsSize; i++) {        if (len &lt; 2 || nums[i] !&#x3D; nums[len-2])            nums[len++] &#x3D; nums[i];    }    return len;}



81 在被翻转的数组中查找元素，可能包含重复元素经典题目，还是一个二分查找问题，只是要分很多种情况

    C 解答

12345678910111213141516171819202122bool search(int A[], int n, int key) {    int left &#x3D; 0, right &#x3D; n - 1;    while (left &lt;&#x3D; right) {        int mid &#x3D; left + (right - left)&#x2F;2;        if (A[mid] &#x3D;&#x3D; key)            return true; &#x2F;&#x2F;return m in Search in Rotated Array I        if (A[left] &lt; A[mid]) { &#x2F;&#x2F;left half is sorted            if (A[left] &lt;&#x3D; key &amp;&amp; key &lt; A[mid])                right &#x3D; mid - 1;            else                left &#x3D; mid + 1;        } else if (A[left] &gt; A[mid]) { &#x2F;&#x2F;right half is sorted            if (A[mid] &lt; key &amp;&amp; key &lt;&#x3D; A[right])                left &#x3D; mid + 1;            else                right &#x3D; mid - 1;        } else { &#x2F;&#x2F; A[left] &#x3D;&#x3D; A[mid]            left++;        }    }    return false;}



82 从已经排序的链表中删除所有重复过的元素，只留下只出现一次的元素考察链表操作

    C 解答

1234567891011121314151617struct ListNode* deleteDuplicates(struct ListNode* head) {    struct ListNode dummy, *p &#x3D; &amp;dummy;    dummy.next &#x3D; head;    while (p &amp;&amp; p-&gt;next &amp;&amp; p-&gt;next-&gt;next) {        if (p-&gt;next-&gt;val &#x3D;&#x3D; p-&gt;next-&gt;next-&gt;val) {            struct ListNode* distinct &#x3D; p-&gt;next;            int dup &#x3D; p-&gt;next-&gt;val;            while (distinct &amp;&amp; distinct-&gt;val &#x3D;&#x3D; dup) {                distinct &#x3D; distinct-&gt;next; &#x2F;&#x2F; TODO: fix mem leak            }            p-&gt;next &#x3D; distinct;        } else {            p&#x3D;p-&gt;next;        }    }    return dummy.next;}



83 从已经排序的链表中删除所有重复过的元素，但是重复过的也留下一个，即，使新链表不重复同样是考察链表基本操作

    C 解答

123456789101112struct ListNode* deleteDuplicates(struct ListNode* head) {    struct ListNode dummy, *p &#x3D; &amp;dummy; dummy.next &#x3D; head; dummy.val &#x3D; head-&gt;val + 1;    while (p &amp;&amp; p-&gt;next) {        if (p-&gt;val &#x3D;&#x3D; p-&gt;next-&gt;val) {            int dup &#x3D; p-&gt;val;            while (p-&gt;next &amp;&amp; p-&gt;next-&gt;val &#x3D;&#x3D; dup)                p-&gt;next &#x3D; p-&gt;next-&gt;next; &#x2F;&#x2F; TODO: fix mem leak        } else            p &#x3D; p-&gt;next;    }    return dummy.next;}



84 在柱状图中查找最大的矩形见注释

    C++ 解答

123456789101112131415161718int largestRectangleArea(vector&lt;int&gt;&amp; height) {    stack&lt;int&gt; stk;    height.push_back(0); &#x2F;&#x2F; dummy end    int result  &#x3D;0;    &#x2F;&#x2F; 总结，对于需要查找上一次最大元素的问题，可以考虑使用栈存储    for (int i &#x3D; 0; i &lt; height.size(); ) {        &#x2F;&#x2F; 当遇到更高的柱子时候，先存入堆栈        if (stk.empty() || height[i] &gt; height[stk.top()]) &#x2F;&#x2F; meet higher            stk.push(i++);        &#x2F;&#x2F; 当遇到低一些的柱子时候，计算这些柱子到上一个更矮的柱子之间的最大举行，如果已经清空，说明之前所有柱子都更低        else { &#x2F;&#x2F; lower            int h &#x3D; stk.top();            stk.pop();            result &#x3D; max(result, height[h] * (stk.empty() ? i : i - stk.top() -1));        }    }    return result;}



85 最大的长方形
    C 解答

12345678910111213141516171819202122232425262728293031323334353637int max(int a, int b) {    return a &gt; b ? a : b;}int min(int a, int b) {    return a &lt; b ? a : b;}int maximalRectangle(char** matrix, int row, int col) {    if (!matrix) return 0;    int left[col], right[col], height[col];    for (int i &#x3D; 0; i &lt; col; i++)        left[i] &#x3D; 0, right[i] &#x3D; col, height[i] &#x3D; 0;    int area &#x3D; 0;    for (int i &#x3D; 0; i &lt; row; i++) {        int cur_left &#x3D; 0, cur_right &#x3D; col;        for (int j &#x3D; 0; j &lt; col; j++)            if (matrix[i][j] &#x3D;&#x3D; &#39;1&#39;)  &#x2F;&#x2F; 在第 j 列的高度                height[j]++;            else                height[j] &#x3D; 0;        for (int j &#x3D; 0; j &lt; col; j++)            if (matrix[i][j] &#x3D;&#x3D; &#39;1&#39;)                left[j] &#x3D; max(left[j], cur_left);            else                left[j] &#x3D; 0, cur_left &#x3D; j + 1;        for (int j &#x3D; col - 1; j &gt;&#x3D; 0; j--)            if (matrix[i][j] &#x3D;&#x3D; &#39;1&#39;)                right[j] &#x3D; min(right[j], cur_right);            else                right[j] &#x3D; col, cur_right &#x3D; j;        for (int j &#x3D; 0; j &lt; col; j++)            area &#x3D; max(area, (right[j] - left[j]) * height[j]);    }    return area;}



86 链表分区，要求把小于某个值得元素全都放到前面对于链表这道题很简单，分两个列表在合并就好了，问题是当我们处理类似的数组问题时，也有一种巧妙地 O(n) 的解法

    C 解答

12345678910111213141516171819struct ListNode* partition(struct ListNode* head, int x) {    struct ListNode small, *psmall &#x3D; &amp;small; &#x2F;&#x2F; double dummy head    struct ListNode big, *pbig &#x3D; &amp;big;    psmall-&gt;next &#x3D; pbig-&gt;next &#x3D; NULL;    while (head !&#x3D; NULL) {        if (head-&gt;val &lt; x) {            psmall-&gt;next &#x3D; head;            psmall &#x3D; psmall-&gt;next;        } else {            pbig-&gt;next &#x3D; head;            pbig &#x3D; pbig-&gt;next;        }        head &#x3D; head-&gt;next;    }    psmall-&gt;next &#x3D; big.next;    pbig-&gt;next &#x3D; NULL;    return small.next;}



87 把字符串分区后，交换得到的字符串
    C++ 解答

123456789101112131415161718192021222324bool isScramble(string s1, string s2) {    if(s1&#x3D;&#x3D;s2)        return true;    &#x2F;&#x2F; 先判断字符是否一致    int len &#x3D; s1.size();    int count[26] &#x3D; {0};    for(int i&#x3D;0; i&lt;len; i++) {        count[s1[i]-&#39;a&#39;]++;        count[s2[i]-&#39;a&#39;]--;    }    for(int i &#x3D; 0; i &lt; 26; i++)        if(count[i]!&#x3D;0)            return false;    for(int i &#x3D; 1; i &lt; len; i++) {        if( isScramble(s1.substr(0,i), s2.substr(0,i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(i)))            return true;        if( isScramble(s1.substr(0,i), s2.substr(len-i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(0,len-i)))            return true;    }    return false;}



88 合并已排序数组，要求合并到其中一个空间较大的数组中对于这种要求 in-place 的算法，从后往前往往可以解决

    C 解答

12345678910111213141516void merge(int* nums1, int m, int* nums2, int n) {    int len &#x3D; m + n - 1;    m--, n--;    while (m &gt;&#x3D; 0 &amp;&amp; n &gt;&#x3D; 0) {        if (nums1[m] &gt; nums2[n]) {            nums1[len--] &#x3D; nums1[m--];        } else {            nums1[len--] &#x3D; nums2[n--];        }    }    while (n &gt;&#x3D; 0) {        nums1[n] &#x3D; nums2[n];        n--;    }}



89 生成格雷码 (Gray Code)记住格雷码的生成规则

    C++ 解答

1234567vector&lt;int&gt; grayCode(int n) {    vector&lt;int&gt; v;    for (int i &#x3D; 0; i &lt; (1 &lt;&lt; n); i++) {        v.push_back((i &gt;&gt; 1) ^ i);    }    return v;}



90 由给定元素生成子集，可能包含重复元素使用了和手机键盘生成字符串号码类似的迭代算法，注意其中对重复元素的处理，当然也可以用 DFS 来做

    C++ 解答

12345678910111213141516171819202122vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {    vector&lt;vector&lt;int&gt;&gt; sets;    sets.push_back({});    sort(nums.begin(), nums.end()); &#x2F;&#x2F; 处理包含重复元素的一半需要预排序    for (int i &#x3D; 0; i &lt; nums.size(); ) {        int count &#x3D; 0; &#x2F;&#x2F; dup count        while (count + i &lt; nums.size() &amp;&amp; nums[count+i] &#x3D;&#x3D; nums[i])            count++;        int prev_n &#x3D; sets.size();        for (int j &#x3D; 0; j &lt; prev_n; j++) {            vector&lt;int&gt; instance &#x3D; sets[j];            &#x2F;&#x2F; put dup element &#96;count&#96; times            for (int k &#x3D; 0; k &lt; count; k++) {                instance.push_back(nums[i]);                sets.push_back(instance);            }        }        i +&#x3D; count;    }    return sets;}



91 给定一个数组只包含 1-9，可以用 1-26 代表字母，求出从其中能都得到多少字符串使用动态规划，但是注意其中 0 的处理，很玄妙

    C 解答

1234567891011121314151617181920int numDecodings(char* s) {    if (!s || strlen(s) &#x3D;&#x3D; 0 || s[0] &#x3D;&#x3D; &#39;0&#39;) return 0;    int r1 &#x3D; 1, r2 &#x3D; 1; &#x2F;&#x2F; r1: 前一个字符， r2：前两个字符    char* p &#x3D; s++; &#x2F;&#x2F; 上一个字符    while (*s) {        if (*s &#x3D;&#x3D; &#39;0&#39;)             r1 &#x3D; 0; &#x2F;&#x2F; 0 不能单独构成字母        if (*p &#x3D;&#x3D; &#39;1&#39; || *p &#x3D;&#x3D; &#39;2&#39; &amp;&amp; *s &lt; &#39;7&#39;) { &#x2F;&#x2F; 形成两种可能            int t &#x3D; r1;            r1 &#x3D; r2 + r1;            r2 &#x3D; t;        } else {            r2 &#x3D; r1; &#x2F;&#x2F; 新加入的数字只能单独构成字母        }        p &#x3D; s++;    }    return r1;}



92 在给定区间上翻转数组同样是数组操作细节题

    C 解答

123456789101112131415161718struct ListNode* reverseBetween(struct ListNode* head, int m, int n) {    if (m &#x3D;&#x3D; n) return head;    struct ListNode dummy, *p &#x3D; &amp;dummy, * small_node, * big_node; &#x2F;&#x2F; actually the prev ones    dummy.next &#x3D; head;    n -&#x3D; m;    while (--m) &#x2F;&#x2F; m starts from 1, so not m--        p &#x3D; p-&gt;next;    struct ListNode* start &#x3D; p-&gt;next;    while (n--) {        struct ListNode* next &#x3D; start-&gt;next;        start-&gt;next &#x3D; next-&gt;next;        next-&gt;next &#x3D; p-&gt;next;        p-&gt;next &#x3D; next;    }    return dummy.next;}



93 恢复 IP 地址，给定一个字符串，适当插入点，一共有多少种方式构成 IP 地址又是一道 DFS 的题，注意对于字符串问题如何处理

    C++ 解答

123456789101112131415161718192021vector&lt;string&gt; restoreIpAddresses(string s) {    vector&lt;string&gt; result;    restore(result, s, &quot;&quot;, 0, 0);    return result;}void restore(vector&lt;string&gt;&amp; result, string&amp; s, string restored, int start, int dots) {    if (dots &gt; 4) return;    if (dots &#x3D;&#x3D; 4 &amp;&amp; start &#x3D;&#x3D; s.size())        result.push_back(restored);    for (int i &#x3D; 1; i &lt; 4; i++) {        if (start + i &gt; s.size())            break;        string part &#x3D; s.substr(start, i);        if (part[0] &#x3D;&#x3D; &#39;0&#39; &amp;&amp; part.size() &gt; 1 || i &#x3D;&#x3D; 3 &amp;&amp; stoi(part) &gt; 255)            continue;        restore(result, s, restored + part + (dots&#x3D;&#x3D;3 ? &quot;&quot; : &quot;.&quot;), start + i, dots + 1);    }}



94 中序遍历二叉树当然是使用栈了

    C++ 解答

123456789101112131415161718vector&lt;int&gt; inorderTraversal(TreeNode* root) {    vector&lt;int&gt; result;    stack&lt;TreeNode*&gt; stk;    TreeNode* current &#x3D; root;    while (!stk.empty() || current) {        if (current) {            stk.push(current);            current &#x3D; current-&gt;left;        } else {            current &#x3D; stk.top();            stk.pop();            result.push_back(current-&gt;val);            current &#x3D; current-&gt;right;        }    }    return result;}



递归解法

    go 解答

12345678func inorderTraversal(root *TreeNode) []int {    if root &#x3D;&#x3D; nil {        return nil    }    left :&#x3D; inorderTraversal(root.Left)    right :&#x3D; inorderTraversal(root.Right)    return append(append(left, root.Val), right...)}



95 生成二叉树，同下题一样
    C++ 解答

12345678910111213141516171819202122232425vector&lt;TreeNode*&gt; generateTrees(int n) {    return gen(1, n);}vector&lt;TreeNode*&gt; gen(int start, int end) {    vector&lt;TreeNode*&gt; result;    if (start &gt; end) {        result.push_back(NULL);        return result;    }    for (int i &#x3D; start; i &lt;&#x3D; end; i++) {        auto leftTrees &#x3D; gen(start, i - 1);        auto rightTrees &#x3D; gen(i + 1, end);        for (auto&amp; l : leftTrees) {            for (auto&amp; r : rightTrees) {                auto root &#x3D; new TreeNode(i);                root-&gt;left &#x3D; l;                root-&gt;right &#x3D; r;                result.push_back(root);            }        }    }    return result;}



96 给定数字 n，从 1 到 n 作为节点有多少种方式生成二叉树这道题看似是树，实际上是一个动态规划问题。

    C 解答

1234567891011121314int numTrees(int n) {    if (n &#x3D;&#x3D; 0) return 0;    int* dp &#x3D; malloc(sizeof(int) * (n+1));    dp[0] &#x3D; 1;    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {        int num &#x3D; 0;        for (int j &#x3D; 0; j &lt;&#x3D; i; j++) &#x2F;&#x2F; 依次选取第 k 个点作为根            num +&#x3D; dp[j - 1] * dp[i - j];        dp[i] &#x3D; num;    }    return dp[n];}



97 给定两个字符串交叉是否能够构成第三个字符串这道题是一道二维的 DP 问题，因为需要对于每个字符串的每个位置用另一个字符串尝试匹配

    C 解答

1234567891011121314151617181920bool isInterleave(char* s1, char* s2, char* s3) {    int l1 &#x3D; strlen(s1), l2 &#x3D; strlen(s2), l3 &#x3D; strlen(s3);    if (l1 + l2 !&#x3D; l3) return false;    &#x2F;&#x2F; 在 i+j 位置 s1[i] s2[j] 是否能够构成 s[i+j]    bool** dp &#x3D; malloc(sizeof(bool*) * (l1 + 1));    for (int i &#x3D; 0; i &lt;&#x3D; l1; i++)        dp[i] &#x3D; malloc(sizeof(bool) * (l2 + 1));    for (int i &#x3D; 0; i &lt;&#x3D; l1; i++)        for (int j &#x3D; 0; j &lt;&#x3D; l2; j++)            if (i &#x3D;&#x3D; 0 &amp;&amp; j &#x3D;&#x3D; 0)                dp[i][j] &#x3D; true;            else if (i &#x3D;&#x3D; 0)                dp[i][j] &#x3D; (dp[i][j-1] &amp;&amp; s2[j-1] &#x3D;&#x3D; s3[i+j-1]); &#x2F;&#x2F; 注意：赋值的优先级更高            else if (j &#x3D;&#x3D; 0)                dp[i][j] &#x3D; (dp[i-1][j] &amp;&amp; s1[i-1] &#x3D;&#x3D; s3[i+j-1]);            else                dp[i][j] &#x3D; (dp[i-1][j] &amp;&amp; s1[i-1] &#x3D;&#x3D; s3[i+j-1] || dp[i][j-1] &amp;&amp; s2[j-1] &#x3D;&#x3D; s3[i+j-1]);    return dp[l1][l2];}



98 验证二叉搜索树是否合法先序遍历即可

    C 解答

123456789bool valid(struct TreeNode* root, long left, long right) {    return root &#x3D;&#x3D; NULL || root-&gt;val &gt; left &amp;&amp; root-&gt;val &lt; right &amp;&amp;        valid(root-&gt;left, left, root-&gt;val) &amp;&amp;        valid(root-&gt;right, root-&gt;val, right);}bool isValidBST(struct TreeNode* root) {    return valid(root, INT_MIN - 1l, INT_MAX + 1l);}



99 在二叉搜索树中有两个节点被调换了，找出这两个节点，并恢复该二叉树
    C 解答

1234567891011121314151617181920212223struct TreeNode* prev &#x3D; NULL;struct TreeNode* first &#x3D; NULL;struct TreeNode* second &#x3D; NULL;void traverse(struct TreeNode* root) {    if (!root) return;    traverse(root-&gt;left);    if (prev &amp;&amp; prev-&gt;val &gt; root-&gt;val) {         if (!first) first &#x3D; prev;         second &#x3D; root;    }    prev &#x3D; root;    traverse(root-&gt;right);}void recoverTree(struct TreeNode* root) {    prev &#x3D; first &#x3D; second &#x3D; NULL;    traverse(root);    if (!first) return;    int temp &#x3D; first-&gt;val;    first-&gt;val &#x3D; second-&gt;val;    second-&gt;val &#x3D; temp;}



100 判断是否是相同的树
    C 解答

123456789bool isSameTree(struct TreeNode *p, struct TreeNode *q) {    if (p &#x3D;&#x3D; NULL || q &#x3D;&#x3D; NULL) {        return p &#x3D;&#x3D; q;    } else {        return p-&gt;val &#x3D;&#x3D; q-&gt;val            &amp;&amp; isSameTree(p-&gt;left, q-&gt;left)            &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);    }}



101 判断是不是左右对称的树
    C 解答

12345678910111213bool sym(struct TreeNode* left, struct TreeNode* right) {    if (left &amp;&amp; !right || !left &amp;&amp; right)        return false;    return !left &amp;&amp; !right ||        left-&gt;val &#x3D;&#x3D; right-&gt;val &amp;&amp;        sym(left-&gt;left, right-&gt;right) &amp;&amp;        sym(right-&gt;left, left-&gt;right);}bool isSymmetric(struct TreeNode* root) {    if (!root) return true;    return sym(root-&gt;left, root-&gt;right);}



102 二叉树层序遍历
    C++ 解答

1234567891011121314151617181920vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {    vector&lt;vector&lt;int&gt;&gt; result;    if (!root) return result;    vector&lt;TreeNode*&gt; current, next;    current.push_back(root);    while (!current.empty()) {        next.resize(0);        vector&lt;int&gt; vals;        for (int i &#x3D; 0; i &lt; current.size(); i++) {            if (current[i]-&gt;left)                next.push_back(current[i]-&gt;left);            if (current[i]-&gt;right)                next.push_back(current[i]-&gt;right);            vals.push_back(current[i]-&gt;val);        }        result.push_back(vals);        current &#x3D; next;    }    return result;}



103 二叉树 ZigZag 层序遍历这道题更好的做法是使用一个栈，从而使得每行的顺序都是上一行的翻转

    C++ 解答

1234567891011121314151617181920212223vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) {    vector&lt;vector&lt;int&gt;&gt; result;    if (!root) return result;    vector&lt;TreeNode*&gt; current, next;    current.push_back(root);    bool odd &#x3D; true;    while (!current.empty()) {        next.resize(0);        vector&lt;int&gt; vals;        for (int i &#x3D; 0; i &lt; current.size(); i++) {            if (current[i]-&gt;left)                next.push_back(current[i]-&gt;left);            if (current[i]-&gt;right)                next.push_back(current[i]-&gt;right);            vals.push_back(current[i]-&gt;val);        }        if (!odd) reverse(vals.begin(), vals.end());        odd &#x3D; !odd;        result.push_back(vals);        current &#x3D; next;    }    return result;}



104 树的最大深度
    C 解答

12345int maxDepth(struct TreeNode* root) {    if (!root) return 0;    int left &#x3D; maxDepth(root-&gt;left), right &#x3D; maxDepth(root-&gt;right);    return (left &gt; right ?left : right) + 1;}



105 从前序遍历和中序遍历生成生二叉树
    C 解答

123456789101112131415161718192021222324struct TreeNode* build(int* prestart, int* preend, int* instart, int* inend) {    struct TreeNode* root &#x3D; malloc(sizeof(struct TreeNode));    root-&gt;val &#x3D; *prestart;    root-&gt;left &#x3D; root-&gt;right &#x3D; NULL;    if (prestart &#x3D;&#x3D; preend)        return root;    int* root_inorder &#x3D; instart;    while (root_inorder &lt;&#x3D; inend &amp;&amp; *root_inorder !&#x3D; *prestart)        root_inorder++;    int left_len &#x3D; root_inorder - instart;    int right_len &#x3D; inend - root_inorder;    if (left_len &gt; 0)        root-&gt;left &#x3D; build(prestart + 1, prestart + left_len, instart, root_inorder - 1);    if (right_len &gt; 0)        root-&gt;right &#x3D; build(prestart + left_len + 1, preend, root_inorder + 1, inend);    return root;}&#x2F;&#x2F; m always equals n, otherwise it&#39;s bad inputstruct TreeNode* buildTree(int* preorder, int m, int* inorder, int n) {    if (n&#x3D;&#x3D;0) return NULL;    return build(preorder, preorder + n - 1, inorder, inorder + n - 1);}



106 从中序遍历和后序遍历生成二叉树
    C 解答

1234567891011121314151617181920212223struct TreeNode* build(int* instart, int* inend, int* poststart, int* postend) {    struct TreeNode* root &#x3D; malloc(sizeof(struct TreeNode));    root-&gt;val &#x3D; *postend;    root-&gt;left &#x3D; root-&gt;right &#x3D; NULL;    if (poststart &#x3D;&#x3D; postend)        return root;    int* root_inorder &#x3D; instart;    while (root_inorder &lt;&#x3D; inend &amp;&amp; *root_inorder !&#x3D; *postend)        root_inorder++;    int left_len &#x3D; root_inorder - instart;    int right_len &#x3D; inend - root_inorder;    if (left_len &gt; 0)        root-&gt;left &#x3D; build(instart, root_inorder - 1, poststart, poststart + left_len - 1);    if (right_len &gt; 0)        root-&gt;right &#x3D; build(root_inorder + 1, inend, poststart + left_len, postend - 1);    return root;}struct TreeNode* buildTree(int* inorder, int m, int* postorder, int n) {    if (n &#x3D;&#x3D; 0) return NULL;    return build(inorder, inorder + n - 1, postorder, postorder +n - 1);}



107 二叉树层序遍历，但要生成翻转的遍历序列
    C++ 解答

123456789101112131415161718192021vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) {    vector&lt;vector&lt;int&gt;&gt; result;    if (!root) return result;    vector&lt;TreeNode*&gt; current, next;    current.push_back(root);    while (!current.empty()) {        next.resize(0);        vector&lt;int&gt; vals;        for (int i &#x3D; 0; i &lt; current.size(); i++) {            if (current[i]-&gt;left)                next.push_back(current[i]-&gt;left);            if (current[i]-&gt;right)                next.push_back(current[i]-&gt;right);            vals.push_back(current[i]-&gt;val);        }        result.push_back(vals);        current &#x3D; next;    }    reverse(result.begin(), result.end());    return result;}



108 把排序数组转化为二叉树
    C 解答

123456789101112131415 struct TreeNode* bst(int* left, int* right) {    int* mid &#x3D; left + (right - left) &#x2F; 2;    struct TreeNode* root &#x3D; malloc(sizeof(struct TreeNode));    root-&gt;val &#x3D; *mid;    root-&gt;left &#x3D; root-&gt;right &#x3D; NULL;    if (left &lt; mid)        root-&gt;left &#x3D; bst(left, mid-1);    if (mid &lt; right)        root-&gt;right &#x3D; bst(mid+1, right);    return root;}struct TreeNode* sortedArrayToBST(int* nums, int n) {    if (n &#x3D;&#x3D; 0) return NULL;    return bst(nums, nums + n -1);}



109 把排序列表转化为二叉树
    C 解答

12345678910111213141516171819202122struct ListNode* list;int len(struct ListNode* head) {    int l &#x3D; 0;    while (head)        head &#x3D; head-&gt;next, l++;    return l;}struct TreeNode* bst(int n) {    if (n &#x3D;&#x3D; 0) return NULL;    struct TreeNode* root &#x3D; malloc(sizeof(struct TreeNode));    root-&gt;left &#x3D; bst(n&#x2F;2);    root-&gt;val &#x3D; list-&gt;val;    list &#x3D; list-&gt;next;    root-&gt;right &#x3D; bst(n - n &#x2F; 2 - 1);    return root;}struct TreeNode* sortedListToBST(struct ListNode* head) {    if (!head) return 0;    list &#x3D; head;    return bst(len(head));}



110 平衡二叉树
    C 解答

1234567891011int height(struct TreeNode* root) {    if (!root) return 0;    int left &#x3D; height(root-&gt;left);    int right &#x3D; height(root-&gt;right);    if (left &gt; right + 1 || right &gt; left + 1 || left &#x3D;&#x3D; -1 || right &#x3D;&#x3D; -1)        return -1;    return (left &gt; right ? left : right) + 1;}bool isBalanced(struct TreeNode* root) {    return height(root) !&#x3D; -1;}



111 二叉树最小高度
    C 解答

123456789int minDepth(struct TreeNode* root) {    if (!root) return 0;    int left &#x3D; minDepth(root-&gt;left);    int right &#x3D; minDepth(root-&gt;right);    if (!right) return left + 1;    if (!left) return right + 1; &#x2F;&#x2F; tricky here, 当有空节点时，不能返回 0，而是返回另一个值    return (left &lt; right ? left : right) + 1;}



112 二叉树中是否存在和为某个数的路径
    C 解答

123456bool hasPathSum(struct TreeNode* root, int sum) {    if (!root) return false;    if (!root-&gt;left &amp;&amp; !root-&gt;right) return sum &#x3D;&#x3D; root-&gt;val;    return hasPathSum(root-&gt;left, sum - root-&gt;val) ||        hasPathSum(root-&gt;right, sum - root-&gt;val);}



113 接上题，把这个路径找出来
    C++ 解答

12345678910111213141516171819vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) {    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    getPaths(result, path, root, sum);    return result;}void getPaths(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; path, TreeNode* root, int sum) {    if (!root)        return;    path.push_back(root-&gt;val);    if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum &#x3D;&#x3D; root-&gt;val) {        result.push_back(path);        return;    }    getPaths(result, path, root-&gt;left, sum - root-&gt;val);    getPaths(result, path, root-&gt;right, sum - root-&gt;val);}



114 把二叉树扁平成列表
    C++ 解答

123456789TreeNode* prev;void flatten(TreeNode* root) {    if (!root) return;    flatten(root-&gt;right);    flatten(root-&gt;left);    root-&gt;right &#x3D; prev;    root-&gt;left &#x3D; NULL;    prev &#x3D; root; &#x2F;&#x2F; last flattened element}



115 通过删掉一些字母得到子序列，问有多少种方法能够得到子序列呢使用 DP，

    C++ 解答

1234567891011121314151617181920212223242526272829303132&#x2F;** * Solution (DP): * 我们扫描字符串 s * Path[i][j] 代表 T.substr(1...i) 在 S(1...j) 不同的子序列的数量 * * Path[i][j] &#x3D; Path[i][j-1]            (discard S[j]) *              +     Path[i-1][j-1]    (S[j] &#x3D;&#x3D; T[i] and we are going to use S[j]) *                 or 0                 (S[j] !&#x3D; T[i] so we could not use S[j]) * while Path[0][j] &#x3D; 1 and Path[i][0] &#x3D; 0. *&#x2F;class Solution {public:    int numDistinct(string s, string t) {        int m &#x3D; t.size();        int n &#x3D; s.size();        if (m &gt; n)            return 0;        vector&lt;vector&lt;int&gt;&gt; path(m+1, vector&lt;int&gt;(n+1, 0));        for (int i &#x3D; 0; i &lt;&#x3D; n; i++)            path[0][i] &#x3D; 1;        for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#x2F;&#x2F; S            for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#x2F;&#x2F; T                path[i][j] &#x3D; path[i][j-1] + (t[i-1] &#x3D;&#x3D; s[j-1] ? path[i-1][j-1] : 0);        return path[m][n];    }};



116 完全二叉树中把每个节点指向他这一层的右面的节点显然左节点的下一个节点是父节点的右节点，右节点的下一个节点是父节点下一个节点的左节点。

    C 解答

12345678910void connect(struct TreeLinkNode *root) {    if (!root)        return;    if (root-&gt;left)        root-&gt;left-&gt;next &#x3D; root-&gt;right;    if (root-&gt;right)        root-&gt;right-&gt;next &#x3D; root-&gt;next ? root-&gt;next-&gt;left : NULL;    connect(root-&gt;left);    connect(root-&gt;right);}



117 同上题，但是是任意的🌲通过上一层已经被连接的 next 指针，顺序层序访问，从而连接下一层。

    C 解答

1234567891011121314151617181920212223242526void connect(struct TreeLinkNode *root) {    struct TreeLinkNode* head &#x3D; root, * prev &#x3D; NULL, *p &#x3D; NULL;    while (head) { &#x2F;&#x2F; head 是每层的开始        p &#x3D; head;        prev &#x3D; head &#x3D; NULL;        while (p) {            if (p-&gt;left) {                if (prev)                    prev-&gt;next &#x3D; p-&gt;left;                else                    head &#x3D; p-&gt;left;                prev &#x3D; p-&gt;left;            }            if (p-&gt;right) {                if (prev)                    prev-&gt;next &#x3D; p-&gt;right;                else                    head &#x3D; p-&gt;right;                prev &#x3D; p-&gt;right;            }            p &#x3D; p-&gt;next;        }    }}



118 杨辉三角注意坐标关系，不要被骗了

    C++ 解答

123456789101112vector&lt;vector&lt;int&gt;&gt; generate(int n) {    vector&lt;vector&lt;int&gt;&gt; result(n);    for (int i &#x3D; 0; i &lt; n; i++) {        result[i].resize(i+1);        result[i][0] &#x3D; result[i][i] &#x3D; 1;        for (int j &#x3D; 1; j &lt; i; j++)            result[i][j] &#x3D; result[i-1][j-1] + result[i-1][j];    }    return result;}



119 返回杨辉三角的第 k 行要求只能使用 O(k) 的额外空间，比较蛋疼的是这里的 k 是从 0 计数的。

    C++ 解答

123456789101112vector&lt;int&gt; getRow(int rowIndex) {    rowIndex++;    vector&lt;int&gt; row;    for (int i &#x3D; 0; i &lt; rowIndex; i++) {        vector&lt;int&gt; newRow(i+1);        newRow[0] &#x3D; newRow[i] &#x3D; 1;        for (int j &#x3D; 1; j &lt; i; j++)            newRow[j] &#x3D; row[j-1] + row[j];        swap(row, newRow);    }    return row;}



120 给定一个类似杨辉三角形状的数组，求从顶部到底部的最短路径显然是使用 DP，但是有一个问题，如果是 top down 的话，最后还需要遍历一下，而如果是 bottom up 就只需要返回 dp[0] 就好了。

    C++ 解答

1234567int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {    vector&lt;int&gt; dp(triangle.back()); &#x2F;&#x2F; 复制最后一行    for (int layer &#x3D; triangle.size() - 2; layer &gt;&#x3D; 0; layer--)        for (int i &#x3D; 0; i &lt;&#x3D; layer; i++)            dp[i] &#x3D; triangle[layer][i] + min(dp[i], dp[i+1]);    return dp[0];}



121 买卖股票最佳时机，只能交易一次
    C 解答

1234567891011121314int maxProfit(int* prices, int pricesSize) {    if (pricesSize &lt; 2) return 0;    int profit &#x3D; 0;    int min &#x3D; prices[0];    &#x2F;&#x2F; 从前到后依次遍历，如果有更好的收益更新，或者更新 min，限制条件是先出现最小值    for (int i &#x3D; 0; i &lt; pricesSize; i++) {        if (prices[i] &gt; min) {                profit &#x3D; max(profit, prices[i] - min);        } else {            min &#x3D; prices[i];        }    }    return profit;}



122 买卖股票的最佳时机，可以做任意多比交易有两种解法，一种是不断做交易，完全不考虑交易次数，这种做法不符合实际情况。另一种做法是模拟交易，这样会生成最少的交易次数，结果也是对的。

    C 解答

123456789&#x2F;&#x2F; 1int maxProfit(int* prices, int pricesSize)    int total &#x3D; 0;    for (int i&#x3D;0; i&lt; pricesSize-1; i++)        if (prices[i+1]&gt;prices[i])            total +&#x3D; prices[i+1]-prices[i];    return total;}





    C 解答

12345678910111213141516171819202122232425&#x2F;&#x2F; 2int maxProfit(int* prices, int pricesSize) {    if (!prices) return 0;    int profit &#x3D; 0;bool buy &#x3D; true;    int min &#x3D; prices[0], max &#x3D; prices[0];    for (int i &#x3D; 0; i &lt; pricesSize; i++) {        if (prices[i] &lt; min &amp;&amp; buy) {            min &#x3D; prices[i];            max &#x3D; prices[i];        }        if (prices[i] &gt; min &amp;&amp; buy)            buy &#x3D; false;        if (prices[i] &gt; max &amp;&amp; !buy)            max &#x3D; prices[i];        if ((prices[i] &lt; max || i &#x3D;&#x3D; pricesSize - 1) &amp;&amp; !buy){            profit +&#x3D; max - min;            min &#x3D; prices[i];            max &#x3D; prices[i];            buy &#x3D; true;        }    }    return profit;}



123 股票交易，限制只能交易两股每次求解的是：卖出两股以后的最大值，刚刚买入第二股的最大值，卖出第一股时候的最大值，买入第一股时候的最大值。

    C++ 解答

12345678910111213int maxProfit(vector&lt;int&gt;&amp; prices) {    int hold1 &#x3D; INT_MIN, hold2 &#x3D; INT_MIN;    int release1 &#x3D; 0, release2 &#x3D; 0;    for (auto i : prices) {        release2 &#x3D; max(release2, hold2 + i);        hold2 &#x3D; max(hold2, release1 - i);        release1 &#x3D; max(release1, hold1 + i);        hold1 &#x3D; max(hold1, -i);    }    return release2;}



124 二叉树路径最大和，路径可以从任意一个节点开始到任意一个节点结束
    C 解答

12345678910111213141516171819int max(int a, int b) {    return a &gt; b ? a : b;}int doSum(struct TreeNode* root, int* sum) {    if (!root)        return 0;    int left &#x3D; max(0, doSum(root-&gt;left, sum));    int right &#x3D; max(0, doSum(root-&gt;right, sum));    *sum &#x3D; max(*sum, left+right+root-&gt;val);    return max(left, right) + root-&gt;val;}int maxPathSum(struct TreeNode* root) {    int sum &#x3D; INT_MIN;    doSum(root, &amp;sum);    return sum;}



这道题是把最终答案放在了全局变量中，并采用了辅助函数的方法。全局变量中存储两条路径的和，而返回值中存储当前子树中最长的单边。

    Python 解答

1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val &#x3D; x#         self.left &#x3D; None#         self.right &#x3D; Noneclass Solution:    def __init__(self):        self.ans &#x3D; float(&#39;-inf&#39;)    def _maxPathSum(self, root: TreeNode) -&gt; int:        if root is None:            return 0        # 注意这里要取 max，以防添加了负路径        left &#x3D; max(0, self._maxPathSum(root.left))        right &#x3D; max(0, self._maxPathSum(root.right))        self.ans &#x3D; max(self.ans, left + right + root.val)        return max(left, right) + root.val    def maxPathSum(self, root: TreeNode) -&gt; int:        self._maxPathSum(root)        return self.ans




125 给定一个字符串，只考虑字母和数字，忽略大小写，判断是否是回文字符串太简单了，没啥可说的

    C 解答

12345678910111213141516171819bool isPalindrome(char* s) {    int len &#x3D; strlen(s);    if (len &#x3D;&#x3D; 0) return true;    int left &#x3D; 0, right &#x3D; len - 1;    while (left &lt; right) {        char l &#x3D; s[left], r &#x3D; s[right];        if (isalnum(l) &amp;&amp; isalnum(r)) {            if (tolower(l) !&#x3D; tolower(r))                return false;            left++, right--;        } else {            if (!isalnum(l))                left++;            if (!isalnum(r))                right--;        }    }    return true;}



127 单词梯子给定梯子，和开始单词和结束单词，最少需要多少个中间单词，才能变化过去，每次只能变化一个字母

    C++ 解答

1234567891011121314151617181920212223242526272829303132333435363738int ladderLength(string beginWord, string endWord, unordered_set&lt;string&gt;&amp; wordList) {    unordered_set&lt;string&gt; beginSet, endSet, *set1, * set2;    beginSet.insert(beginWord);    endSet.insert(endWord);    int dist &#x3D; 2;    while (!beginSet.empty() &amp;&amp; !endSet.empty()) {        if (beginSet.size() &lt; endSet.size()) {            set1 &#x3D; &amp;beginSet;            set2 &#x3D; &amp;endSet;        } else {            set1 &#x3D; &amp;endSet;            set2 &#x3D; &amp;beginSet;        }        unordered_set&lt;string&gt; temp;        for (auto word : *set1) { &#x2F;&#x2F; notice word in not ref            wordList.erase(word);            for (auto&amp; letter : word) {                for (int i &#x3D; 0; i &lt; 26; i++) {                    char oldLetter &#x3D; letter;                    letter &#x3D; &#39;a&#39; + i;                    if (set2-&gt;find(word) !&#x3D; set2-&gt;end())                        return dist;                    if (wordList.find(word) !&#x3D; wordList.end()) {                        temp.insert(word);                        wordList.erase(word);                    }                    letter &#x3D; oldLetter;                }            }        }        dist++;        swap(*set1, temp);    }    return 0;}



128 最长递增子序列使用动态规划

    C++ 解答

1234567891011121314151617int longestConsecutive(vector&lt;int&gt;&amp; nums) {    int result &#x3D; 0;    unordered_map&lt;int, int&gt; hash; &#x2F;&#x2F; 每个元素和它们所在序列的长度    for (auto n : nums) {        if (hash.find(n) &#x3D;&#x3D; hash.end()) {            &#x2F;&#x2F; 查找两边的元素，如果找到，把新元素合并进去            int left &#x3D; hash.find(n-1) !&#x3D; hash.end() ? hash[n-1] : 0;            int right &#x3D; hash.find(n+1) !&#x3D; hash.end() ? hash[n+1] : 0;            int sum &#x3D; left + right + 1;            hash[n] &#x3D; hash[n-left] &#x3D; hash[n+right] &#x3D; sum; &#x2F;&#x2F; 注意此处的更新，并不需要更新区间内的每个值，只需要更新边界即可            result &#x3D; max(result, sum);        }    }    return result;}



129 二叉树中只有 0-9 找出所有根节点到子节点的和
    C 解答

123456789101112131415int sum(struct TreeNode* root, int x) {    if (!root-&gt;left &amp;&amp; !root-&gt;right)        return x * 10 + root-&gt;val;    int val &#x3D; 0;    if (root-&gt;left)        val +&#x3D; sum(root-&gt;left, x * 10 + root-&gt;val);    if (root-&gt;right)        val +&#x3D; sum(root-&gt;right, x * 10 + root-&gt;val);    return val;}int sumNumbers(struct TreeNode* root) {    if (!root) return 0;    return sum(root, 0);}



130 把所有被包围的 O 置为 X使用并查集

    C++ 解答

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class UnionFind {private:    vector&lt;int&gt; m_father, m_rank;public:    UnionFind(int n): m_father(n), m_rank(n, 0) {        for (int i &#x3D; 0; i &lt; m_father.size(); i++)            m_father[i] &#x3D; i;    }    int find(int x) {        if (x !&#x3D; m_father[x])            m_father[x] &#x3D; find(m_father[x]);        return m_father[x];    }    void unionify(int x, int y) {        x &#x3D; find(x);        y &#x3D; find(y);        if (x &#x3D;&#x3D; y) return;        if (m_rank[x] &gt; m_rank[y]) {            m_father[y] &#x3D; x;        } else {            if (m_rank[x] &#x3D;&#x3D; m_rank[y])                m_rank[y]++;            m_father[x] &#x3D; y;        }    }};class Solution {public:    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {        int n &#x3D; board.size();        if (n &#x3D;&#x3D; 0) return;        int m &#x3D; board[0].size();        UnionFind uf(n*m+1);        for (int i &#x3D; 0; i &lt; n; i++) {            for (int j &#x3D; 0; j &lt; m; j++) {                if ((i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0 || i &#x3D;&#x3D; n-1 || j &#x3D;&#x3D; m-1) &amp;&amp; board[i][j] &#x3D;&#x3D; &#39;O&#39;)                    uf.unionify(i * m + j, n * m);                else if (board[i][j] &#x3D;&#x3D; &#39;O&#39;) {                    if (board[i-1][j] &#x3D;&#x3D; &#39;O&#39;)                        uf.unionify(i * m + j, (i - 1) * m + j);                    if (board[i+1][j] &#x3D;&#x3D; &#39;O&#39;)                        uf.unionify(i*m+j, (i+1)*m+j);                    if (board[i][j-1] &#x3D;&#x3D; &#39;O&#39;)                        uf.unionify(i*m+j, i*m+j-1);                    if (board[i][j+1] &#x3D;&#x3D; &#39;O&#39;)                        uf.unionify(i*m+j, i*m+j+1);                }            }        }        for (int i &#x3D; 0; i &lt; n; i++)            for (int j &#x3D; 0; j &lt; m; j++)                if (uf.find(i*m+j) !&#x3D; uf.find(n*m))                    board[i][j] &#x3D; &#39;X&#39;;    }};



131 对字符串分组，是的每个字串都是回文，返回所有可能的分组
    C++ 解答

1234567891011121314151617181920212223242526272829vector&lt;vector&lt;string&gt;&gt; partition(string s) {    vector&lt;vector&lt;string&gt;&gt; result;    vector&lt;string&gt; group;    dfs(result, s, group, 0);    return result;}void dfs(vector&lt;vector&lt;string&gt;&gt;&amp; result, const string&amp; s, vector&lt;string&gt;&amp; group, int start) {    if (start &#x3D;&#x3D; s.size()) {        result.push_back(group);        return;    }    for (int i &#x3D; start; i &lt; s.size(); i++) {        if (isPalindrome(s, start, i)) {            group.push_back(s.substr(start, i - start + 1));            dfs(result, s, group, i + 1);            group.pop_back();        }    }}bool isPalindrome(const string&amp; s, int left, int right) {    while (left &lt; right) {        if (s[left++] !&#x3D; s[right--])            return false;    }    return true;}



132 如上题，找出最少需要分组几次
    C++ 解答

1234567891011121314int minCut(string s) {    vector&lt;int&gt; cut(s.size() + 1, 0);    for (int i &#x3D; 0; i &lt; s.size() + 1; i++)        cut[i] &#x3D; i - 1;    for (int i &#x3D; 0; i &lt; s.size(); i++) {        for (int j &#x3D; 0; i - j &gt;&#x3D; 0 &amp;&amp; i + j &lt; s.size() &amp;&amp; s[i+j] &#x3D;&#x3D; s[i-j]; j++)            cut[i+j+1] &#x3D; min(cut[i+j+1], cut[i-j] + 1); &#x2F;&#x2F; i-j -&gt; i+j 是 palindrome，所以只需要 cut[i-j] 在加上这一段就好了        for (int j &#x3D; 1; i - j + 1 &gt;&#x3D; 0 &amp;&amp; i + j &lt; s.size() &amp;&amp; s[i+j] &#x3D;&#x3D; s[i-j+1]; j++)            cut[i+j+1] &#x3D; min(cut[i+j+1], cut[i - j + 1] + 1);    }    return cut[s.size()];}



133 复制有向图
    C++ 解答

123456789101112unordered_map&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; hash; &#x2F;&#x2F; old -&gt; new pairUndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {    if (!node)        return NULL;    if (hash.find(node) &#x3D;&#x3D; hash.end()) {        hash[node] &#x3D; new UndirectedGraphNode(node-&gt;label);        for (auto n : node-&gt;neighbors)            hash[node]-&gt;neighbors.push_back(cloneGraph(n));    }    return hash[node];}



134 加油站
    C 解答

123456789101112131415int canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize) {    int total &#x3D; 0;    int j &#x3D; -1;    for (int i &#x3D; 0, sum &#x3D; 0; i &lt; gasSize; ++i) {        sum +&#x3D; gas[i] - cost[i]; &#x2F;&#x2F; 从此处经过能够净增多少汽油        total +&#x3D; gas[i] - cost[i]; &#x2F;&#x2F; 记录总的汽油量是否是正的        if (sum &lt; 0) { &#x2F;&#x2F; 如果当前汽油量已经小于 0，说明之前的节点都是不行的，到下一个节点            j &#x3D; i;            sum &#x3D; 0; &#x2F;&#x2F; 同时重新开始计数        }    }    return total &gt;&#x3D; 0 ? j + 1 : -1;}



135 糖块，成绩高的需要比他身边成绩低的获得更多的糖
    C++ 解答

1234567891011121314151617181920int candy(vector&lt;int&gt;&amp; ratings) {    int n &#x3D; ratings.size();    if (n &lt;&#x3D; 1)        return n;    vector&lt;int&gt; candies(n, 1);    for (int i &#x3D;1; i &lt; n; i++)        if (ratings[i] &gt; ratings[i-1])            candies[i] &#x3D; candies[i-1] + 1;    for (int i &#x3D; n - 1; i &gt; 0; i--)        if (ratings[i-1] &gt; ratings[i])            candies[i-1] &#x3D; max(candies[i] + 1, candies[i-1]);    int result &#x3D; 0;    for (auto i : candies)        result +&#x3D; i;    return result;}



136 找出数组中只出现一次的数字
    C 解答

123456int singleNumber(int* nums, int numsSize) {    int result &#x3D; nums[0];    for (int i &#x3D; 1; i &lt; numsSize; i++)        result ^&#x3D; nums[i];    return result;}



137 一个数组中，所有数字都出现三次，除了一个数字以外，找出这个数字
    C 解答

12345678910111213&#x2F;&#x2F; 使用二进制计算&#x2F;&#x2F; 00-&gt;10-&gt;01-&gt;00(0-&gt;1-&gt;2-&gt;3&#x2F;0)&#x2F;&#x2F; ones &#x3D; ones ^ A[i]; if (twos &#x3D;&#x3D; 1) then ones &#x3D; 0&#x2F;&#x2F; twos &#x3D; twos ^ A[i]; if (ones* &#x3D;&#x3D; 1) then twos &#x3D; 0int singleNumber(int* nums, int numsSize) {    int ones &#x3D; 0, twos &#x3D; 0;    for (int i &#x3D; 0; i &lt; numsSize; i++) {        ones &#x3D; (ones ^ nums[i]) &amp; ~twos;        twos &#x3D; (twos ^ nums[i]) &amp; ~ones;    }    return ones;}



138 复制复杂结构链表
    C 解答

1234567891011121314151617181920212223242526272829303132333435363738&#x2F;** * Definition for singly-linked list with a random pointer. * struct RandomListNode { *     int label; *     struct RandomListNode *next; *     struct RandomListNode *random; * }; *&#x2F;struct RandomListNode *copyRandomList(struct RandomListNode *head) {    struct RandomListNode* p;    p &#x3D; head;    while (p) {        struct RandomListNode* node &#x3D; malloc(sizeof(struct RandomListNode));        node-&gt;next &#x3D; node-&gt;random &#x3D; NULL; &#x2F;&#x2F; spicial notice to struct initialization in c        node-&gt;label &#x3D; p-&gt;label;        node-&gt;next &#x3D; p-&gt;next;        p-&gt;next &#x3D; node;        p &#x3D; node-&gt;next;    }    p &#x3D; head;    while (p) {        if (p-&gt;random)            p-&gt;next-&gt;random &#x3D; p-&gt;random-&gt;next;        p &#x3D; p-&gt;next-&gt;next;    }    struct RandomListNode dummy, *q &#x3D; &amp;dummy;    dummy.next &#x3D; dummy.random &#x3D; NULL;    p &#x3D; head;    while (p) {        q-&gt;next &#x3D; p-&gt;next;        q &#x3D; q-&gt;next;        p-&gt;next &#x3D; p-&gt;next-&gt;next;        p &#x3D; p-&gt;next;    }    return dummy.next;}



139 查找单词是否能组成句子
    C++ 解答

123456789101112131415161718bool wordBreak(string s, unordered_set&lt;string&gt;&amp; wordDict) {    if (wordDict.empty()) return false;    vector&lt;bool&gt; dp(s.size() + 1, false);    dp[0] &#x3D; true;    &#x2F;&#x2F; 动态规划，假设前 i 个字符已经匹配到了，尝试匹配 i 到 i+j，如果找到了，就匹配到了 i+j    for (int i &#x3D; 1; i &lt;&#x3D; s.size(); i++) {        for (int j &#x3D; i-1; j &gt;&#x3D; 0; j--) {            if (dp[j]) {                string word &#x3D; s.substr(j, i-j);                if (wordDict.find(word) !&#x3D; wordDict.end()) {                    dp[i] &#x3D; true;                    break;                }            }        }    }    return dp[s.size()];}



141 列表是否有环slow 每次走一步，而 fast 每次走两步，因此在进入环之后，两者一定会相遇

    C 解答

12345678910bool hasCycle(struct ListNode *head) {    struct ListNode* slow &#x3D; head, * fast &#x3D; head;    while (fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) {        fast &#x3D; fast-&gt;next-&gt;next;        slow &#x3D; slow-&gt;next;        if (slow &#x3D;&#x3D; fast)            return true;    }    return false;}



142 列表是否有环？如果有找到环的开始从两者出发，到两者相遇，slow 指针走了 p 步，而 fast 指针走了 2p 步，显然 fast 多走了一圈（或者多圈）。设 p &#x3D; k + x, 2p &#x3D; k + x + loop -&gt; 2k + 2x &#x3D; k + x + loop -&gt; k + x &#x3D; loop -&gt; k &#x3D; loop - x，剩下的长度正好也是 k。假设入口处距离起点的距离是 k，那么发生碰撞的点距离环的入口处距离也是 k，所以两个指针分别从开始和碰撞点出发匀速一定会在环的入口相遇。

    C 解答

1234567891011121314151617181920struct ListNode *detectCycle(struct ListNode *head) {    struct ListNode* slow &#x3D; head, * fast &#x3D; head, *entry &#x3D; NULL;    bool found &#x3D; false;    while (!found &amp;&amp; fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) {        fast &#x3D; fast-&gt;next-&gt;next;        slow &#x3D; slow-&gt;next;        if (slow &#x3D;&#x3D; fast)            found &#x3D; true;    }    if (!found) return NULL;    slow &#x3D; head;    while (slow !&#x3D; fast) {        slow &#x3D; slow-&gt;next;        fast &#x3D; fast-&gt;next;    }    return slow;}



144 前序遍历
    C++ 解答

123456789101112131415161718192021vector&lt;int&gt; preorderTraversal(TreeNode* root) {    vector&lt;int&gt; result;    if (!root) return result;    stack&lt;TreeNode*&gt; stk;    stk.push(root);    while (!stk.empty()) {        TreeNode* node  &#x3D; stk.top();        stk.pop();        result.push_back(node-&gt;val);        if (node-&gt;right)            stk.push(node-&gt;right);        if (node-&gt;left)            stk.push(node-&gt;left);    }    return result;}



145 二叉树的后序遍历参见树的遍历

    C++ 解答

123456789101112131415161718192021vector&lt;int&gt; postorderTraversal(TreeNode* root) {    vector&lt;int&gt; result;    if (!root) return result;    stack&lt;TreeNode*&gt; stk, output;    stk.push(root);    while (!stk.empty()) {        auto node &#x3D; stk.top();        stk.pop();        output.push(node);        if (node-&gt;left)            stk.push(node-&gt;left);        if (node-&gt;right)            stk.push(node-&gt;right);    }    while (!output.empty()) {        result.push_back(output.top()-&gt;val);        output.pop();    }    return result;}



146 LRU 缓存
    C++ 解答

1234567891011121314151617181920212223242526272829303132333435363738394041class LRUCache{public:typedef unordered_map&lt;int, pair&lt;int, list&lt;int&gt;::iterator&gt;&gt; cache_t; &#x2F;&#x2F; k: v, iter    LRUCache(int capacity) : m_capacity(capacity) {    }int get(int key) {        auto it &#x3D; m_cache.find(key);        if (it &#x3D;&#x3D; m_cache.end())             return -1;        touch(it);        return it-&gt;second.first;    }    void set(int key, int value) {        auto it &#x3D; m_cache.find(key);        if (it !&#x3D; m_cache.end()) {            touch(it);        } else {            if (m_cache.size() &#x3D;&#x3D; m_capacity) {                m_cache.erase(m_used.back());                m_used.pop_back();            }            m_used.push_front(key);        }        m_cache[key] &#x3D; {value, m_used.begin()};    }private:    void touch(cache_t::iterator it) {        int key &#x3D; it-&gt;first;        m_used.erase(it-&gt;second.second);        m_used.push_front(key);        it-&gt;second.second &#x3D; m_used.begin();    }    cache_t m_cache;    list&lt;int&gt; m_used;    int m_capacity;};



147 链表插入排序
    C 解答

12345678910111213141516struct ListNode* insertionSortList(struct ListNode* head) {    if (!head) return NULL;    struct ListNode dummy, *p &#x3D; head;    dummy.val &#x3D; INT_MIN;    dummy.next &#x3D; NULL;    while (p) {        struct ListNode* iter &#x3D; &amp;dummy;        while (iter-&gt;next &amp;&amp; iter-&gt;next-&gt;val &lt; p-&gt;val)            iter &#x3D; iter-&gt;next;        struct ListNode* pnext &#x3D; p-&gt;next;        p-&gt;next &#x3D; iter-&gt;next;        iter-&gt;next &#x3D; p;        p &#x3D; pnext;    }    return dummy.next;}



148 排序链表，要求达到 O(nlogn) 时间复杂度
    C 解答

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void split(struct ListNode* source, struct ListNode** frontptr, struct ListNode** backptr) {    struct ListNode* fast, * slow;    if (!source || !source-&gt;next)        *backptr &#x3D; source;    else {        slow &#x3D; source;        fast &#x3D; source-&gt;next;        while (fast &amp;&amp; fast-&gt;next) {            fast &#x3D; fast-&gt;next-&gt;next;            slow &#x3D; slow-&gt;next;        }        *backptr &#x3D; slow-&gt;next;        slow-&gt;next &#x3D; NULL;    }    *frontptr &#x3D; source;}struct ListNode* merge(struct ListNode* l1, struct ListNode* l2) {    if (l1 &#x3D;&#x3D; NULL) return l2;    if (l2 &#x3D;&#x3D; NULL) return l1;    struct ListNode dummy;    dummy.next &#x3D;&#x3D; NULL;    struct ListNode* p &#x3D; &amp;dummy;    while (l1 &amp;&amp; l2) {        if (l1-&gt;val &lt; l2-&gt;val) {            p-&gt;next &#x3D; l1;            l1 &#x3D; l1-&gt;next;        } else {            p-&gt;next &#x3D; l2;            l2 &#x3D; l2-&gt;next;        }        p &#x3D; p-&gt;next;    }    if (l1)        p-&gt;next &#x3D; l1;    if (l2)        p-&gt;next &#x3D; l2;    return dummy.next;}&#x2F;&#x2F; merge sortstruct ListNode* sortList(struct ListNode* head) {    struct ListNode* front, * back;    if (!head || !head-&gt;next) return head;    split(head, &amp;front, &amp;back);    front &#x3D; sortList(front);    back &#x3D; sortList(back);    head &#x3D; merge(front, back);    return head;}



149 在同一条线上的点最多的线
    C++ 解答

1234567891011121314151617181920212223242526272829303132int maxPoints(vector&lt;Point&gt;&amp; points) {    if (points.size() &lt; 2) return points.size();    int result &#x3D; 0;    &#x2F;&#x2F; 对于每一个点    for (int i &#x3D; 0; i &lt; points.size(); i++) {        &#x2F;&#x2F; 经过该点的直线，使用分数作为斜率，避免使用浮点数        map&lt;pair&lt;int, int&gt;, int&gt; lines;        int localMax &#x3D; 0, overlap &#x3D; 0;        for (int j &#x3D; i + 1; j &lt; points.size(); j++) { &#x2F;&#x2F; 避免重复计算            if (points[j].x &#x3D;&#x3D; points[i].x &amp;&amp; points[j].y &#x3D;&#x3D; points[i].y) {                overlap++; &#x2F;&#x2F; 同一个点                continue;            } else {                int x &#x3D; points[j].x - points[i].x;                int y &#x3D; points[j].y - points[i].y;                int g &#x3D; gcd(x, y);                x &#x2F;&#x3D; g, y &#x2F;&#x3D; g; &#x2F;&#x2F; verticle case: x &#x3D;&#x3D; 0 -&gt; (0, 1)                lines[make_pair(x, y)]++;                localMax &#x3D; max(localMax, lines[make_pair(x, y)]);            }        }        &#x2F;&#x2F; overlap 算在任意条线上        result &#x3D; max(result, localMax + overlap + 1);    }    return result;}int gcd(int x, int y) {    if (y &#x3D;&#x3D; 0) return x;    else return gcd(y, x % y);}



150 后缀表达式求值
    C++ 解答

123456789101112131415161718192021222324252627bool is_operator(char t) {    return t &#x3D;&#x3D; &#39;+&#39; || t &#x3D;&#x3D; &#39;-&#39; || t &#x3D;&#x3D; &#39;*&#39; || t &#x3D;&#x3D; &#39;&#x2F;&#39;;}int calc(int left, char op, int right) {    switch(op) {        case &#39;+&#39;: return left + right;        case &#39;-&#39;: return left - right;        case &#39;*&#39;: return left * right;        case &#39;&#x2F;&#39;: return left &#x2F; right;    }}int evalRPN(vector&lt;string&gt;&amp; tokens) {    stack&lt;int&gt; nums;    for (auto&amp; token : tokens) {        if (is_operator(token[0]) &amp;&amp; token.size() &#x3D;&#x3D; 1) {            char op &#x3D; token[0];            int right_num &#x3D; nums.top();            nums.pop();            int left_num &#x3D; nums.top();            nums.pop();            nums.push(calc(left_num, op, right_num));        } else {            nums.push(stoi(token));        }    }    return nums.top();}



151 反转句子中的单词顺序一般面试的时候会假定没有多余字符的，解法是

    C 解答

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#96;&#96;&#96;&lt;&#x2F;details&gt;LeetCode 需要处理多余空格：&lt;details&gt;    &lt;summary&gt;C 解答&lt;&#x2F;summary&gt;&#96;&#96;&#96;Cvoid swap(char *a, char *b) {    char tmp &#x3D; *a; *a &#x3D; *b; *b &#x3D; tmp;}void reverse(char* start, char* end) {    while(start &lt; end)        swap(start++, end--);}void trim(char* s) {    char* fast, *slow;    for (fast &#x3D; s; *fast !&#x3D;&#39;\0&#39;; fast++) {        if (isspace(*fast)) {            while(isspace(*(fast + 1)) &amp;&amp; *(fast + 1) !&#x3D; 0)                fast++;            if(*(fast+1) &#x3D;&#x3D; 0)                break;            if(slow &#x3D;&#x3D; s)                continue;        }        swap(fast, slow++);    }    *slow &#x3D; 0;}void reverseWords(char *s) {    int len &#x3D; strlen(s);    if (len &#x3D;&#x3D; 0)        return;    trim(s);    len &#x3D; strlen(s);    if (len &#x3D;&#x3D; 0)        return;    reverse(s, s + len - 1);    char* head &#x3D; s, * tail &#x3D;s ;    while (*(tail + 1) !&#x3D; &#39;\0&#39;) {        tail &#x3D; head;        while (!isspace(*(tail + 1)) &amp;&amp; *(tail + 1) !&#x3D; &#39;\0&#39;)            tail++;        reverse(head, tail);    }}



152 最大子序列乘积
    C 解答

1234567891011121314int maxProduct(vector&lt;int&gt;&amp; A) {    int n &#x3D; A.size();    int r &#x3D; A[0];    for (int i &#x3D; 1, imax &#x3D; r, imin &#x3D; r; i &lt; n; i++) {        if (A[i] &lt; 0)            swap(imax, imin);        imax &#x3D; max(A[i], imax * A[i]);        imin &#x3D; min(A[i], imin * A[i]);        r &#x3D; max(r, imax);    }    return r;}



153 在旋转数组中查找最小值
    C 解答

12345678910111213int findMin(int* A, int n) {    int left &#x3D; 0; int right &#x3D; n - 1;    while (left &lt; right - 1) {        int mid &#x3D; left + (right - left) &#x2F; 2;        if (A[left] &gt; A[mid])            right &#x3D; mid;        else if (A[right] &lt; A[mid])            left &#x3D; mid;        else            right &#x3D; mid;    }    return A[left] &lt; A[right] ? A[left] : A[right];}



154 在旋转数组中查找最小值，可能有重复
    C 解答

1234567891011121314int findMin(int* A, int n) {    int left &#x3D; 0, right &#x3D; n - 1;    while (left &lt; right) {        int mid &#x3D; left + (right - left) &#x2F; 2;        if (A[mid] &gt; A[right]) { &#x2F;&#x2F; 当需要找的是 left，也就是较小的数字，使用 right 比较不需要等于号            left &#x3D; mid + 1;        } else if (A[right] &lt; A[mid]) {            right &#x3D; mid;        } else {            right--;        }    }    return A[left];}



155 设计一个栈，在普通栈的基础上支持 getmin 操作解法 1: 使用额外的栈，每个值都记录一个当前最小值，浪费空间
解法 2: 也是使用额外的栈，但是惰性记录，只有当需要更新的时候才去记录

    C++ 解答

12345678910111213141516171819202122232425class MinStack {private:    stack&lt;int&gt; m_stk;    stack&lt;int&gt; m_min;public:    void push(int x) {        if (x &lt;&#x3D; getMin())            m_min.push(x);        m_stk.push(x);    }    void pop() {        if (m_stk.top() &#x3D;&#x3D; getMin())            m_min.pop();        m_stk.pop();    }    int top() {        return m_stk.top();    }    int getMin() {        return m_min.empty() ? INT_MAX : m_min.top();    }};



156-159 Locked
160 求两个链表的交叉点分析题目可知，如果有一个交叉点，那么在这之后的所有点都是交叉的。这里有一个非常巧妙的做法。使用两个指针，如果到达结尾就指向另一个链表，会产生一下三种情况：

如果交叉点前面的节点数目相同，显然会返回正确节点。
如果不同假设 A 的节点为 a + c，B 的节点为 b + c，则在下一次遍历时： a + c + b &#x3D;&#x3D; b + c + a，恰好到达相同部分的第一个顶点 C1
如果两个列表不相交，那么经过 a + b, b + a 距离后，恰好都等于 NULL


    C 解答

12345678910111213struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {    if (!headA || !headB) return NULL;    struct ListNode *p1 &#x3D; headA, *p2&#x3D;headB;    while (p1 !&#x3D; p2) {        &#x2F;&#x2F; 两个列表手尾相接，如果有一个点相同，一定会返回        &#x2F;&#x2F; a + c + b &#x3D;&#x3D; b + c + a   --&gt; C1        &#x2F;&#x2F; a + b &#x3D;&#x3D; b + a    --&gt; NULL        p1 &#x3D; p1 ? p1-&gt;next : headB;        p2 &#x3D; p2 ? p2-&gt;next : headA;    }    return p1;}



161 Locked
162  找到极大值，给定一个数组，可能有多个极大值，找到任意一个即可，给定数组中 A[i] !&#x3D; A[i+1]题目要求在对数时间内做出来，二分搜索，如果中间的数在左半部分，就向右找。

    C 解答

1234567891011int findPeakElement(int* nums, int numsSize) {    int left &#x3D; 0, right &#x3D; numsSize - 1;    while (left &lt; right) {        int mid &#x3D; left + (right - left) &#x2F; 2;        if (nums[mid] &lt; nums[mid + 1]) &#x2F;&#x2F; mid in left part of summit            left &#x3D; mid + 1;        else                           &#x2F;&#x2F; mid in right part of summit            right&#x3D; mid;    }    return left;}



163 Locked
164 未排序数组中相差最大的两个数之间的差根据抽屉原理，最大差不可能小于 (max - min) &#x2F; (n - 1)。证明：如果小于，那么整个数组的大小就会小于 max - min。因此我们把
165 比较版本号大小
    C++ 解答

1234567891011121314151617181920212223242526272829vector&lt;int&gt; ver(const string&amp; version) {    vector&lt;int&gt; result;    int num &#x3D; 0;    for (auto c : version) {        if (c !&#x3D; &#39;.&#39;) {            num &#x3D; num * 10 + c - &#39;0&#39;;        } else {            result.push_back(num);            num &#x3D; 0;        }    }    &#x2F;&#x2F; 对于所有这种分割符中读取数字的都需要注意最后一个    result.push_back(num); &#x2F;&#x2F; notice here    return result;}int compareVersion(string version1, string version2) {    auto v1 &#x3D; ver(version1);    auto v2 &#x3D; ver(version2);    for (int i &#x3D; 0; i &lt; v1.size() || i &lt; v2.size(); i++) {        int a &#x3D; i &lt; v1.size() ? v1[i] : 0;        int b &#x3D; i &lt; v2.size() ? v2[i] : 0;        if (a !&#x3D; b)            return a &gt; b ? 1 : -1;    }    return 0;}



166 分数生成小数
    C++ 解答

1234567891011121314151617181920212223242526272829string fractionToDecimal(long numerator, long denominator) {    if (numerator &#x3D;&#x3D; 0) return &quot;0&quot;;    string result;    &#x2F;&#x2F; 符号    if (numerator &lt; 0 ^ denominator &lt; 0)        result +&#x3D; &quot;-&quot;;    long n &#x3D; abs(numerator), d &#x3D; abs(denominator);    &#x2F;&#x2F; 整数部分    result +&#x3D; to_string(n &#x2F; d);    if (n % d &#x3D;&#x3D; 0) return result;    &#x2F;&#x2F; 小数部分    result+&#x3D; &quot;.&quot;;    unordered_map&lt;int, int&gt; map;    for (long r &#x3D; n % d; r !&#x3D; 0; r %&#x3D; d) { &#x2F;&#x2F; 模拟手工除法        if (map.count(r) &gt; 0) {            result.insert(map[r], 1, &#39;(&#39;);            result +&#x3D; &quot;)&quot;;            break;        }        map[r] &#x3D; result.size(); &#x2F;&#x2F; 记录对应的位置，以便插入括号        r *&#x3D; 10; &#x2F;&#x2F; 从上借位        result +&#x3D; to_string(r &#x2F; d);    }    return result;}



167 Locked
168 生成 Excel 表格标题注意 A 对应的是 1 而不是 0，而且数字也是从 1 开始的

    C++ 解答

123456789string convertToTitle(int n) {    string title;    while (n) {        char c &#x3D; (n-1) % 26 + &#39;A&#39;;        n &#x3D; (n-1) &#x2F; 26;        title &#x3D; c + title;    }    return title;}



169 给定一个数组，有一个数字的出现频率超过了一半，找出这个数字非常经典的一道题，首先我们假设拿到的数字就是目标，并记录他出现的次数，如果下一个数字和他不一样，那么我们减一，当次数为 0 的时候，我们知道这个数字在已经遍历过的数字中出现小于一半了，这时候我们换下一个数字，最后剩下的一定是超过一半的数字。

    C++ 解答

123456789101112int majorityElement(vector&lt;int&gt;&amp; nums) {    int candidate, count &#x3D; 0;    for (auto i : nums) {        if (count &#x3D;&#x3D; 0 || candidate &#x3D;&#x3D; i) {            count++;            candidate &#x3D; i;        } else {            count--;        }    }    return candidate;}



170 Locked
171 Excel 标题转换为数字同样，我们需要注意 A 对应的是 1，而不是 0

    C 解答

123456int titleToNumber(char* s) {    int result &#x3D; 0;    while (*s)        result &#x3D; result * 26 + *s++ - &#39;A&#39; + 1;    return result;}



172 阶乘中能有几个 0显然先算出阶乘数字是会溢出的，而有 0 的话，就是需要 10，也就是就需要 2 和 5，显然 2 是比 5 多的。那么我们只要考虑 5 的个数就行了， 这时候需要注意，5&#x2F;15 等是算一个 5，而 25&#x2F;75 包含了两个 5，所以我们计算的时候，数一遍包含 5 的（这时 25 等也被计算了），然后再数一遍包含 25 的就像当于数了两次了。

    C 解答

12345678int trailingZeroes(int n) {    if (n &lt; 0)        return -1;    int fives &#x3D; 0;    for (int i &#x3D; 5; n &#x2F; i &gt; 0; i *&#x3D; 5)        fives +&#x3D; n &#x2F; i;    return fives;}



173 二叉树中序遍历迭代器
    C 解答

1234567891011121314151617181920212223242526272829303132333435class BSTIterator {public:    BSTIterator(TreeNode *root) {        pushAll(root);    }    &#x2F;** @return whether we have a next smallest number *&#x2F;    bool hasNext() {        return !m_stack.empty();    }    &#x2F;** @return the next smallest number *&#x2F;    int next() {        TreeNode* temp &#x3D; m_stack.top();        m_stack.pop();        pushAll(temp-&gt;right);        return temp-&gt;val;    }private:    stack&lt;TreeNode*&gt; m_stack;    void pushAll(TreeNode* root) {        while (root) {            m_stack.push(root);            root &#x3D; root-&gt;left;        }    }};&#x2F;** * Your BSTIterator will be called like this: * BSTIterator i &#x3D; BSTIterator(root); * while (i.hasNext()) cout &lt;&lt; i.next(); *&#x2F;



174 地下城游戏王子在格子的左上角，需要到右下角去救公主，在过程中王子不能死掉，和机器人走路一样，使用动态规划

    C++ 解答

1234567891011121314int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) {    int row &#x3D; dungeon.size();    int col &#x3D; dungeon[0].size();    vector&lt;vector&lt;int&gt;&gt; bloods(row + 1, vector&lt;int&gt; (col + 1, INT_MAX));    bloods[row][col-1] &#x3D; bloods[row-1][col] &#x3D; 1; &#x2F;&#x2F; 公主的两边    &#x2F;&#x2F; 从公主那里逆向推    for (int i &#x3D; row-1; i &gt;&#x3D; 0; i--) {        for (int j &#x3D; col-1; j &gt;&#x3D; 0; j--) {             int need &#x3D; min(bloods[i+1][j], bloods[i][j+1]) - dungeon[i][j]; &#x2F;&#x2F; 缺乏的血量 &#x3D; 到达下一步最少的血量 - 这一步消耗的血量             bloods[i][j] &#x3D; need &gt; 0 ? need : 1; &#x2F;&#x2F; 王子的血量至少为 1        }    }    return bloods[0][0];}



175-178 Missing179 最大的数字神奇的排序方法

    C++ 解答

123456789101112131415string largestNumber(vector&lt;int&gt;&amp; nums) {    vector&lt;string&gt; num_strings(nums.size());    for (int i &#x3D; 0; i &lt; nums.size(); i++)        num_strings[i] &#x3D; to_string(nums[i]);    auto comparator &#x3D; [] (string&amp; s1, string&amp; s2) {        return s1 + s2 &gt; s2 + s1;    };    sort(num_strings.begin(), num_strings.end(), comparator);    string result;    for (auto&amp; num_string: num_strings)        result +&#x3D; num_string;    int start &#x3D; result.find_first_not_of(&quot;0&quot;);    if (start &#x3D;&#x3D; string::npos) return &quot;0&quot;;    return result.substr(start);}



180-185 Missing186 Locked
187 找到所有 10 个字母唱的重复 DNA 序列
    C++ 解答

123456789101112&#x2F;&#x2F; naive 的做法从前往后，记录字符串&#x2F;&#x2F; 观察 ATCG 四个字符的特征，并把他们编码为一个 int&#x2F;&#x2F; 十个字符正好编码在 32bit 的 int 中vector&lt;string&gt; findRepeatedDnaSequences(string s) {    unordered_map&lt;int, int&gt; hash;    vector&lt;string&gt; result;    for (int t &#x3D; 0, i &#x3D; 0; i &lt; s.size(); i++)        &#x2F;&#x2F; 左移弹出老元素，求交为了只使用 30bit，求或添加新元素。        if (hash[t &#x3D; t &lt;&lt; 3 &amp; 0x3FFFFFFF | s[i] &amp; 0b111]++ &#x3D;&#x3D; 1) &#x2F;&#x2F; 等于 1 为了避免重复            result.push_back(s.substr(i - 9, 10));    return result;}



189 翻转树组
    C 解答

123456789101112131415161718void reverse(int* nums, int left, int right) {    while (left &lt; right) {        int temp &#x3D; nums[left];        nums[left] &#x3D; nums[right];        nums[right] &#x3D; temp;        left++;        right--;    }}void rotate(int* nums, int numsSize, int k) {    if (k &gt;&#x3D; numsSize) k %&#x3D; numsSize;    if (k &lt;&#x3D; 0) return;    reverse(nums, 0, numsSize - k - 1);    reverse(nums, numsSize - k, numsSize - 1);    reverse(nums, 0, numsSize - 1);}



190 翻转二进制表示
    C 解答

123456789101112uint32_t reverseBits(uint32_t n) {    uint32_t r &#x3D; 0;    int len &#x3D; sizeof(n) * 8 - 1;    while (len--) { &#x2F;&#x2F; 31 times shift        r |&#x3D; n &amp; 0x1;        n &gt;&gt;&#x3D; 1;        r &lt;&lt;&#x3D; 1; &#x2F;&#x2F; only shift 31 times    }    r |&#x3D; n &amp; 0x1;    return r;}



191 数字二进制表示中 1 的个数我们知道 n&amp;(n-1) 会把 n 中的最后一个 1 去掉，所以循环直到 n 为 0 即可

    C 解答

12345678int hammingWeight(uint32_t n) {    int count &#x3D; 0;    while (n) {        n &amp;&#x3D; n - 1;        count++;    }    return count;}



还可以采用查表法，对于表我们可以预先构造，或者利用上一个方法生成，对于长度过大的，我们可以分块查表。

    C 解答

1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int counts[16];int _get_count(n) {    int count &#x3D; 0;    while (n) {        n &amp;&#x3D; n-1;        count++;    }    return count;}int init_counts() {    for (int i &#x3D; 0; i &lt; 16; i++)        counts[i] &#x3D; _get_count(i);};int get_count(n) {    int count &#x3D; 0;    while (n) {        int index &#x3D; n &amp; 0xF;        count +&#x3D; counts[index];        n &gt;&gt;&#x3D; 4;    }    return count;}int main() {    init_counts();    for (int i &#x3D; 0; i &lt; 100; i++)        printf(&quot;%d: %d\n&quot;, _get_count(i), get_count(i));    return 0;}



192-197 Missing
198  有一排房子，每个房子中都有一定财产，但是不能偷相邻的两个房子，求能偷到的最大值使用 DP，对于每个房子，可以选择不偷或者前 i-1 个房子加上偷当前房子，即dp[i+1] &#x3D; max(dp[i], dp[i-1] + A[i])

    C 解答

12345678910111213int rob(int* nums, int numsSize) {    if (!nums) return 0;    &#x2F;&#x2F; 因为不能相邻，所以可以从相隔一个的取值    &#x2F;&#x2F; dp[n] &#x3D; max(dp[n-1], dp[n-2] + A[n])    int temp, m &#x3D; 0, n &#x3D; nums[0];    for (int i &#x3D; 1; i &lt; numsSize; i++) {        temp &#x3D; n;        if (m + nums[i] &gt; n)            n &#x3D; m + nums[i];        m &#x3D; temp;    }    return n;}



199 从右边看二叉树的效果
    C++ 解答

1234567891011121314151617181920212223&#x2F;&#x2F; level order 遍历vector&lt;int&gt; rightSideView(TreeNode* root) {    vector&lt;int&gt; result;    if (!root)        return result;    queue&lt;TreeNode*&gt; q;    q.push(root);    while (!q.empty()) {        TreeNode* node;        int len &#x3D; q.size(); &#x2F;&#x2F; 保存为了获得最后一个元素        for (int i &#x3D; 0; i &lt; len; i++) { &#x2F;&#x2F; 当前数组的最后一个元素就是最右边的元素            node &#x3D; q.front();            q.pop();            if (node-&gt;left)                q.push(node-&gt;left);            if (node-&gt;right)                q.push(node-&gt;right);        }        result.push_back(node-&gt;val);    }    return result;}



200 找出小岛的数量采用并查集，找到最后集合的数量

    C++ 解答

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class UnionFind {private:    vector&lt;int&gt; m_father, m_rank;    int m_count; &#x2F;&#x2F; sets countpublic:    UnionFind(int n): m_father(n), m_rank(n, 0), m_count(n) {        for (int i &#x3D; 0; i &lt; m_father.size(); i++)            m_father[i] &#x3D; i;    }    int find(int x) {        if (x !&#x3D; m_father[x])            m_father[x] &#x3D; find(m_father[x]);        return m_father[x];    }    void unionify(int x, int y) {        x &#x3D; find(x);        y &#x3D; find(y);        if (x &#x3D;&#x3D; y) return;        if (m_rank[x] &gt; m_rank[y]) {            m_father[y] &#x3D; x;        } else {            if (m_rank[x] &#x3D;&#x3D; m_rank[y])                m_rank[y]++;            m_father[x] &#x3D; y;        }        m_count--;    }    int getCount() {        return m_count;    }};class Solution {const static char LAND &#x3D; &#39;1&#39;;const static char WATER &#x3D; &#39;0&#39;;public:    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {        if (grid.empty() || grid[0].empty())            return 0;        int r &#x3D; grid.size(), c &#x3D; grid[0].size();        UnionFind uf(r * c + 1); &#x2F;&#x2F; extra element is for water        for (int i &#x3D; 0; i &lt; r; i++) {            for (int j &#x3D; 0; j &lt; c; j++) {                if (grid[i][j] &#x3D;&#x3D; LAND) {                    if (i !&#x3D; r - 1 &amp;&amp; grid[i+1][j] &#x3D;&#x3D; LAND)                         uf.unionify(i*c+j, (i+1)*c+j);                    if (j !&#x3D; c - 1 &amp;&amp; grid[i][j+1] &#x3D;&#x3D; LAND)                         uf .unionify(i*c+j, i*c+j+1);                } else {                    uf.unionify(i*c+j, c*r);                }            }        }        return uf.getCount() - 1; &#x2F;&#x2F; islands + water - 1;    }};





    python 解答

12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class UnionFind:    def __init__(self, count):        self.count &#x3D; count        self.parents &#x3D; list(range(count))  # 初始化时 parent 指针指向自己        self.ranks &#x3D; [1] * count  # 记录每棵树的大小    def union(self, p, q):        &quot;&quot;&quot;把 p, q 两个节点连通起来&quot;&quot;&quot;        p_root &#x3D; self.find(p)        q_root &#x3D; self.find(q)        if p_root &#x3D;&#x3D; q_root:            return        if self.ranks[p_root] &gt; self.ranks[q_root]:            self.parents[q_root] &#x3D; p_root        else:            if self.ranks[p_root] &#x3D;&#x3D; self.ranks[q_root]:                self.ranks[q_root] +&#x3D; 1            self.parents[p_root] &#x3D; q_root        self.count -&#x3D; 1    def find(self, p):        &quot;&quot;&quot;找到 p 节点的根节点&quot;&quot;&quot;        while self.parents[p] !&#x3D; p:            # 神奇的路径压缩            self.parents[p] &#x3D; self.parents[self.parents[p]]            p &#x3D; self.parents[p]        return p    def is_connected(self, p, q):        p_root &#x3D; self.find(p)        q_root &#x3D; self.find(q)        return p_root &#x3D;&#x3D; q_rootclass Solution:    def numIslands(self, grid: List[List[str]]) -&gt; int:        if not grid or not grid[0]:            return 0        m &#x3D; len(grid)        n &#x3D; len(grid[0])        uf &#x3D; UnionFind(m * n + 1)        for i in range(m):            for j in range(n):                if grid[i][j] &#x3D;&#x3D; &quot;1&quot;:                    up &#x3D; max(i - 1, 0)                    if grid[up][j] &#x3D;&#x3D; &quot;1&quot;:                        uf.union(i * n + j, up * n + j)                    left &#x3D; max(j - 1, 0)                    if grid[i][j - 1] &#x3D;&#x3D; &quot;1&quot;:                        uf.union(i * n + j, i * n + left)                else:                    uf.union(i * n + j, m * n)        return uf.count - 1



201 给定区间内，所有数字 AND 的结果显然直接过一遍是会超时的，那么分析可知

    C 解答

12345678910&#x2F;&#x2F; 如果两个数不相等，一定是有不同的位，那么这一位一定为 0int rangeBitwiseAnd(int m, int n) {    int t &#x3D; 0;    while (m !&#x3D; n) {        t++;        m &gt;&gt;&#x3D; 1;        n &gt;&gt;&#x3D; 1;    }    return m &lt;&lt; t;}



202 快乐数字，各位数字平方相加得到下一个数字，如果最后等于 1没啥，一直算就可以了。

    C++ 解答

1234567891011bool isHappy(int n) {    while (n &gt; 6) {        int next &#x3D; 0;        while (n) {            next +&#x3D; (n%10) * (n%10);            n &#x2F;&#x3D; 10;        }        n &#x3D; next;    }    return n &#x3D;&#x3D; 1;}



203 删除链表中给定的值
    C 解答

123456789101112131415struct ListNode* removeElements(struct ListNode* head, int val) {    struct ListNode dummy, *p &#x3D; &amp;dummy;    dummy.next &#x3D; head;    while (p) {        if (p-&gt;next &amp;&amp; p-&gt;next-&gt;val &#x3D;&#x3D; val) { &#x2F;&#x2F; not forward here            struct ListNode* next &#x3D; p-&gt;next;            p-&gt;next &#x3D; next-&gt;next;            free(next);        } else {            p &#x3D; p-&gt;next;        }    }    return dummy.next;}



204 找出素数什么筛子，忘了

    C++ 解答

123456789101112131415int countPrimes(int n) {    vector&lt;bool&gt; primes(n, true);    primes[0] &#x3D; primes[1] &#x3D; false;    for (int i &#x3D; 2; i * i &lt; n; i++) &#x2F;&#x2F; 注意，只到 sqrt(n)        if (primes[i])            for (int j &#x3D; i * i; j &lt; n; j +&#x3D; i) &#x2F;&#x2F; 从 i * i 开始，因为 i* i-- 已经被杀过了                primes[j] &#x3D; false;    int count &#x3D; 0;    for (int i &#x3D; 2; i &lt; n; i++)        if (primes[i])            count++;    return count;}



205 同构字符串，可以看作 word pattern 的简化
    C 解答

1234567891011121314bool isIsomorphic(char* s, char* t) {    int ss[256] &#x3D; { 0 };    int ts[256] &#x3D; { 0 };    if (strlen(s) !&#x3D; strlen(t))        return false;    int i &#x3D; 0;    while (s[i]) {        if (ss[s[i]] !&#x3D; ts[t[i]])            return false;        ss[s[i]] &#x3D; ts[t[i]] &#x3D; i + 1;        i++;    }    return true;}



206 反转链表tags: #pointers
最最基础的指针操作题目了

    Python 解答

12345678910class Solution:    def reverseList(self, head: ListNode) -&gt; ListNode:        prev &#x3D; None        curr &#x3D; head        while curr:            next &#x3D; curr.next            curr.next &#x3D; prev            prev &#x3D; curr            curr &#x3D; next        return prev  # 关键在这里





    C 解答

12345678910111213struct ListNode* reverseList(struct ListNode* head) {    if (!head || !head-&gt;next)        return head;    struct ListNode *p &#x3D; NULL, *cur &#x3D; head, *next;    while (cur) {        next &#x3D; cur-&gt;next; &#x2F;&#x2F; cache        cur-&gt;next &#x3D; p; &#x2F;&#x2F; reverse pointing        p &#x3D; cur; &#x2F;&#x2F; moves forwards        cur &#x3D; next;    }    return p;}





    C 解答

1&#x2F;&#x2F; recursive



207 标准的拓扑排序给定边这种方法表示图也是醉了

    C++ 解答

123456789101112131415161718192021222324bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) { &#x2F;&#x2F; next -&gt; before    vector&lt;unordered_set&lt;int&gt;&gt; graph(numCourses); &#x2F;&#x2F; 每条边和他的下一步，临接表    for (auto&amp; p : prerequisites)        graph[p.second].insert(p.first);    vector&lt;int&gt; d(numCourses, 0); &#x2F;&#x2F; in degree    for (auto&amp; nexts : graph)        for (auto next : nexts)            d[next]++;    for (int i &#x3D; 0; i &lt; numCourses; i++) {        int nondep; &#x2F;&#x2F; in degree &#x3D;&#x3D; 0        for (nondep &#x3D; 0; nondep &lt; numCourses &amp;&amp; d[nondep] !&#x3D; 0; nondep++)            ;        if (nondep &#x3D;&#x3D; numCourses)            return false;        d[nondep] &#x3D; -1; &#x2F;&#x2F; remove        for (auto next : graph[nondep]) &#x2F;&#x2F; 所有下一步都 －1            d[next]--;    }    return true;}




208 实现前缀树
    C++ 解答

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class TrieNode {public:    static const int branchCount &#x3D; 26;    bool isWord;    TrieNode* next[branchCount];    &#x2F;&#x2F; Initialize your data structure here.    TrieNode() : isWord(false) {        for (int i &#x3D; 0; i &lt; branchCount; i++)            next[i] &#x3D; NULL;    }};class Trie {public:    Trie() {        root &#x3D; new TrieNode();    }    &#x2F;&#x2F; Inserts a word into the trie.    void insert(string word) {        TrieNode* location &#x3D; root;        for (auto&amp; c : word) {            if (!location-&gt;next[c - &#39;a&#39;])                location-&gt;next[c - &#39;a&#39;] &#x3D; new TrieNode;            location &#x3D; location-&gt;next[c - &#39;a&#39;];        }        location-&gt;isWord &#x3D; true;    }    &#x2F;&#x2F; Returns if the word is in the trie.    bool search(string word) {        TrieNode* location &#x3D; root;        for (auto&amp; c : word) {            location &#x3D; location-&gt;next[c - &#39;a&#39;];            if (!location)                return false;        }        return location-&gt;isWord;    }    &#x2F;&#x2F; Returns if there is any word in the trie    &#x2F;&#x2F; that starts with the given prefix.    bool startsWith(string prefix) {        TrieNode* location &#x3D; root;        for (auto&amp; c : prefix) {            location &#x3D; location-&gt;next[c - &#39;a&#39;];            if (!location)                return false;        }        return true;    }private:    TrieNode* root;};&#x2F;&#x2F; Your Trie object will be instantiated and called as such:&#x2F;&#x2F; Trie trie;&#x2F;&#x2F; trie.insert(&quot;somestring&quot;);&#x2F;&#x2F; trie.search(&quot;key&quot;);



209 最短子数组使得和大于某个数双指针，超过和之后再尝试从开始处减去元素

    C++ 解答

123456789101112int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) {    int start &#x3D; 0, sum &#x3D; 0, len &#x3D; INT_MAX;    for (int i &#x3D; 0; i &lt; nums.size(); i++) {        sum +&#x3D; nums[i];        while (sum &gt;&#x3D; s) {            len &#x3D; min(len, i - start + 1);            sum -&#x3D; nums[start++];        }    }    return len &#x3D;&#x3D; INT_MAX? 0 : len;}



210 Course Schedule IIBFS

    C++ 解答

123456789101112131415161718192021222324252627282930313233343536class Solution {public:    vector&lt;int&gt; findOrder(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) {        vector&lt;unordered_set&lt;int&gt;&gt; graph &#x3D; make_graph(numCourses, prerequisites);        vector&lt;int&gt; degrees &#x3D; compute_indegree(graph);        queue&lt;int&gt; zeros;        for (int i &#x3D; 0; i &lt; numCourses; i++)            if (!degrees[i]) zeros.push(i);        vector&lt;int&gt; toposort;        for (int i &#x3D; 0; i &lt; numCourses; i++) {            if (zeros.empty()) return {};            int zero &#x3D; zeros.front();            zeros.pop();            toposort.push_back(zero);            for (int neigh : graph[zero]) {                if (!--degrees[neigh])                    zeros.push(neigh);            }        }        return toposort;    }private:    vector&lt;unordered_set&lt;int&gt;&gt; make_graph(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) {        vector&lt;unordered_set&lt;int&gt;&gt; graph(numCourses);        for (auto pre : prerequisites)            graph[pre.second].insert(pre.first);        return graph;    }    vector&lt;int&gt; compute_indegree(vector&lt;unordered_set&lt;int&gt;&gt;&amp; graph) {        vector&lt;int&gt; degrees(graph.size(), 0);        for (auto neighbors : graph)            for (int neigh : neighbors)                degrees[neigh]++;        return degrees;    }};



211 添加和搜索字符串
    C++ 解答

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class TrieNode {public:    static const int branchCount &#x3D; 26;    bool isWord;    TrieNode* next[branchCount];    &#x2F;&#x2F; Initialize your data structure here.    TrieNode() : isWord(false) {        for (int i &#x3D; 0; i &lt; branchCount; i++)            next[i] &#x3D; NULL;    }};class Trie {public:    Trie() {        root &#x3D; new TrieNode();    }    &#x2F;&#x2F; Inserts a word into the trie.    void insert(string word) {        TrieNode* location &#x3D; root;        for (auto&amp; c : word) {            if (!location-&gt;next[c - &#39;a&#39;])                location-&gt;next[c - &#39;a&#39;] &#x3D; new TrieNode;            location &#x3D; location-&gt;next[c - &#39;a&#39;];        }        location-&gt;isWord &#x3D; true;    }    &#x2F;&#x2F; Returns if the word is in the trie.    virtual bool search(string word) {        TrieNode* location &#x3D; root;        for (auto&amp; c : word) {            location &#x3D; location-&gt;next[c - &#39;a&#39;];            if (!location)                return false;        }        return location-&gt;isWord;    }    &#x2F;&#x2F; Returns if there is any word in the trie    &#x2F;&#x2F; that starts with the given prefix.    bool startsWith(string prefix) {        TrieNode* location &#x3D; root;        for (auto&amp; c : prefix) {            location &#x3D; location-&gt;next[c - &#39;a&#39;];            if (!location)                return false;        }        return true;    }    TrieNode* getRoot() {        return root;    }private:    TrieNode* root;};class WordDictionary : public Trie{public:    WordDictionary() : Trie(){}    &#x2F;&#x2F; Adds a word into the data structure.    void addWord(string word) {        insert(word);    }    &#x2F;&#x2F; Returns if the word is in the data structure. A word could    &#x2F;&#x2F; contain the dot character &#39;.&#39; to represent any one letter.    bool search(string word) override {        return search(word.c_str(), getRoot());    }    bool search(const char* word, TrieNode* root) {        TrieNode* run &#x3D; root;        for (int i &#x3D; 0; word[i]; i++) {            if (run &amp;&amp; word[i] !&#x3D; &#39;.&#39;)                run &#x3D; run-&gt;next[word[i] - &#39;a&#39;];            else if (run &amp;&amp; word[i] &#x3D;&#x3D; &#39;.&#39;) {                &#x2F;&#x2F; skip checking this char                TrieNode* tmp &#x3D; run;                for (int j &#x3D; 0; j &lt; 26; j++) {                    run &#x3D; tmp-&gt;next[j];                    if (search(word + i + 1, run))                        return true;                }            }            else break;        }        return run &amp;&amp; run-&gt;isWord;    }};&#x2F;&#x2F; Your WordDictionary object will be instantiated and called as such:&#x2F;&#x2F; WordDictionary wordDictionary;&#x2F;&#x2F; wordDictionary.addWord(&quot;word&quot;);&#x2F;&#x2F; wordDictionary.search(&quot;pattern&quot;);



212 单词搜索Trie 结构见前面，注意要记录 visited，还有边界的问题，另外集合的使用

    C++ 解答

12345678910111213141516171819202122232425262728293031323334353637383940class Solution {private:    Trie m_trie;public:    vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) {        for (auto&amp; word : words)            m_trie.insert(word);        int row &#x3D; board.size();        int col &#x3D; board[0].size();        unordered_set&lt;string&gt; result_set;        vector&lt;vector&lt;bool&gt;&gt; visited(row, vector&lt;bool&gt;(col, false));        for (int i &#x3D; 0; i &lt; row; i++)            for(int j &#x3D; 0; j &lt; col; j++)                find(result_set, board, visited, &quot;&quot;, i, j);        vector&lt;string&gt; result;        for (auto&amp; r : result_set)            result.push_back(r);        return result;    }    void find(unordered_set&lt;string&gt;&amp; r, vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, string word, int i, int j) {        if (i &lt; 0 || i &gt;&#x3D; board.size() || j &lt; 0 || j &gt;&#x3D; board[0].size() || visited[i][j])            return;        word +&#x3D; board[i][j];        if (!m_trie.startsWith(word))            return;        if (m_trie.search(word))            r.insert(word);        visited[i][j] &#x3D; true;        find(r, board, visited, word, i-1, j);        find(r, board, visited, word, i+1, j);        find(r, board, visited, word, i, j-1);        find(r, board, visited, word, i, j+1);        visited[i][j] &#x3D; false;    }};



213 小偷偷环状数组
    C 解答

123456789101112131415161718192021int max(int a, int b) {    return a &gt; b ? a : b;}int robNonCyclic(int* nums, int numsSize) {    if (!nums) return 0;    &#x2F;&#x2F; 因为不能相邻，所以可以从相隔一个的取值    &#x2F;&#x2F; dp[n] &#x3D; max(dp[n-1], dp[n-2] + A[n])    int temp, m &#x3D; 0, n &#x3D; nums[0];    for (int i &#x3D; 1; i &lt; numsSize; i++) {        temp &#x3D; n;        if (m + nums[i] &gt; n)            n &#x3D; m + nums[i];        m &#x3D; temp;    }    return n;}int rob(int* nums, int numsSize) {    return max(robNonCyclic(nums, numsSize - 1), robNonCyclic(nums + 1, numsSize - 1));}




214 最短回文字符串，给指定的字符串添加字母获得回文
    C++ 解答

12345678910111213141516&#x2F;&#x2F; based on kmp next arraystring shortestPalindrome(string s) {    string rev_s &#x3D; s;    reverse(rev_s.begin(), rev_s.end());    string l &#x3D; s + &quot;#&quot; + rev_s;    vector&lt;int&gt; p(l.size(), 0);    for (int i &#x3D; 1; i &lt; l.size(); i++) {        int j &#x3D; p[i - 1];        while (j &gt; 0 &amp;&amp; l[i] !&#x3D; l[j])            j &#x3D; p[j - 1];        p[i] &#x3D; (j +&#x3D; l[i] &#x3D;&#x3D; l[j]);    }    return rev_s.substr(0, s.size() - p[l.size() - 1]) + s;}



215 数组中第 k 大的数字实际上这道题更可能的题目是找到前 k 大的所有数字。首先，设计到数组排序的问题一定向面试官要问清楚数据量的大小，这影响到接下来的实现，同时和面试官探讨数据量大小对实现的影响，有助于更好的把握局面。
我们先假设数据量是比较小的，也就是能够放到内存中。

使用排序就实在是 naive 了，不过面试官非要问的话，当然是使用选择排序更好了。
使用快排中的 partition 算法，时间复杂度 O(n*logk)。
使用 size 为 k 的堆，时间复杂度也是 O(n*logk)，不管数字多大，都只需要遍历一遍。
使用类似插入排序的方法，保持数组大小不变，这样的时间复杂度是 O(n*k)。
数据的范围有限时候，使用计数排序。

当数据过大的时候，我们可以想通过哈希取模之后把文件分组，找出每个文件中最大的 k 个数字
如果数字中有重复呢？使用计数排序，计数强制按一算如果既有重复又是浮点数呢？

    C 解答

12345678910111213141516171819202122232425262728int swap(int* a, int* b) {    int t &#x3D; *a;    *a &#x3D; *b;    *b &#x3D; t;}int partition(int* nums, int start, int end) {    int small &#x3D; start - 1;    int pivot &#x3D; nums[end];    for (int i &#x3D; start; i &lt; end; i++)        if (nums[i] &lt; pivot)            swap(&amp;nums[++small], &amp;nums[i]);    swap(&amp;nums[++small], &amp;nums[end]);    return small;}int findKthLargest(int* nums, int numsSize, int k) {    int left &#x3D; 0, right &#x3D; numsSize - 1;    while (1) {        int index &#x3D; partition(nums, left, right);        if (index &#x3D;&#x3D; numsSize - k)            return nums[index];        if (index &gt; numsSize - k)            right &#x3D; index - 1;        else            left &#x3D; index + 1;    }}



216 找到 k 个数字 [1…9]，使得他们的和是 n
    C++ 解答

1234567891011121314151617181920vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) {    vector&lt;vector&lt;int&gt;&gt; result;    dfs(result, {}, n, k);    return result;}void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; combination, int n, int k) {    if (combination.size() &#x3D;&#x3D; k) {        if (n &#x3D;&#x3D; 0)            result.push_back(combination);        return;    }    int i &#x3D; combination.empty() ? 1 : combination.back() + 1; &#x2F;&#x2F; 保证不重复切实递增序列    while (i &lt;&#x3D; n &amp;&amp; i &lt; 10) {        combination.push_back(i);        dfs(result, combination, n-i, k);        combination.pop_back();        i++;    }}



217 包含重复数字这道题太简单了，也没有什么精妙的解法，可以使用排序，Hash 等多种解法

    C++ 解答

123456789bool containsDuplicate(vector&lt;int&gt;&amp; nums) {    unordered_set&lt;int&gt; s;    for (auto&amp; n : nums)        if (s.find(n) !&#x3D; s.end())            return true;        else            s.insert(n);    return false;}



218 获得矩形重合部分的拐点抄过来的，还没仔细研究

    C++ 解答

1234567891011121314151617181920212223vector&lt;pair&lt;int, int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) {    vector&lt;pair&lt;int, int&gt;&gt; res;    int cur&#x3D;0, cur_X, cur_H &#x3D;-1,  len &#x3D; buildings.size();    priority_queue&lt; pair&lt;int, int&gt;&gt; liveBlg; &#x2F;&#x2F; first: height, second, end time    while(cur&lt;len || !liveBlg.empty()) { &#x2F;&#x2F; if either some new building is not processed or live building queue is not empty        cur_X &#x3D; liveBlg.empty()? buildings[cur][0]:liveBlg.top().second; &#x2F;&#x2F; next timing point to process        if(cur&gt;&#x3D;len || buildings[cur][0] &gt; cur_X) { &#x2F;&#x2F;first check if the current tallest building will end before the next timing point              &#x2F;&#x2F; pop up the processed buildings, i.e. those  have height no larger than cur_H and end before the top one            while(!liveBlg.empty() &amp;&amp; ( liveBlg.top().second &lt;&#x3D; cur_X) ) liveBlg.pop();        } else { &#x2F;&#x2F; if the next new building starts before the top one ends, process the new building in the vector            cur_X &#x3D; buildings[cur][0];            while(cur&lt;len &amp;&amp; buildings[cur][0]&#x3D;&#x3D; cur_X)  &#x2F;&#x2F; go through all the new buildings that starts at the same point            {  &#x2F;&#x2F; just push them in the queue                liveBlg.push(make_pair(buildings[cur][2], buildings[cur][1]));                cur++;            }        }        cur_H &#x3D; liveBlg.empty()?0:liveBlg.top().first; &#x2F;&#x2F; outut the top one        if(res.empty() || (res.back().second !&#x3D; cur_H) ) res.push_back(make_pair(cur_X, cur_H));    }    return res;}



219 包含重复数字，并且两个的坐标不超过 k
    C++ 解答

12345678910111213141516171819&#x2F;&#x2F; 滑动窗口保存前 k 个值，如果有重复的就返回&#x2F;&#x2F; num[i-k] num[i-1]，如果滑过了，就删除该元素bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {    unordered_set&lt;int&gt; s;    if (k &lt;&#x3D; 0)        return false;    if (k &gt;&#x3D; nums.size()) &#x2F;&#x2F; notice here        k &#x3D; nums.size() - 1;    for (int i &#x3D; 0; i &lt; nums.size(); i++) {        if (i &gt; k)            s.erase(nums[i - k - 1]); &#x2F;&#x2F; delete first note        if (s.find(nums[i]) !&#x3D; s.end())            return true;        s.insert(nums[i]); &#x2F;&#x2F; insert    }    return false;}



220 同上一题，同时保证两个数字之间小于 t保证两个数字之差小于 t

    C++ 解答

12345678910111213141516bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) {    set&lt;int&gt; window; &#x2F;&#x2F; 注意不能使用 unordered    if (k &lt;&#x3D; 0)        return false;    if (k &gt;&#x3D; nums.size()) &#x2F;&#x2F; notice here        k &#x3D; nums.size() - 1;    for (int i &#x3D; 0; i &lt; nums.size(); i++) {        if (i &gt; k)            window.erase(nums[i - k - 1]);        auto pos &#x3D; window.lower_bound(nums[i] - t); &#x2F;&#x2F; notice set.lower_bound        if (pos !&#x3D; window.end() &amp;&amp; *pos - nums[i] &lt;&#x3D; t)            return true;        window.insert(nums[i]);    }    return false;}



221 找到最大的正方形使用动态规划 https:&#x2F;&#x2F;leetcode.com&#x2F;discuss&#x2F;38489&#x2F;easy-solution-with-detailed-explanations-8ms-time-and-space

    C++ 解答

123456789101112131415161718int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {    if (matrix.empty()) return 0;    int m &#x3D; matrix.size(), n &#x3D; matrix[0].size();    vector&lt;int&gt; dp(m + 1, 0);    int maxsize &#x3D; 0, pre &#x3D; 0;    for (int j &#x3D; 0; j &lt; n; j++) { &#x2F;&#x2F; 每一列        for (int i &#x3D; 1; i &lt;&#x3D; m; i++) { &#x2F;&#x2F; notice i range            int temp &#x3D; dp[i];            if (matrix[i - 1][j] &#x3D;&#x3D; &#39;1&#39;) {                dp[i] &#x3D; min(dp[i], min(dp[i - 1], pre)) + 1;                maxsize &#x3D; max(maxsize, dp[i]);            }            else dp[i] &#x3D; 0;            pre &#x3D; temp;        }    }    return maxsize * maxsize;}




222 给定一个完全树，计算节点的数量。
    C++ 解答

1234567891011121314151617181920int countNodes(struct TreeNode* root) {    if (!root)             return 0;    int left_height &#x3D; 0, right_height &#x3D; 0;    struct TreeNode* left &#x3D; root, *right &#x3D; root;    while (left) {        left &#x3D; left-&gt;left;        left_height++;    }    while (right) {        right &#x3D; right-&gt;right;        right_height++;    }    if (left_height &#x3D;&#x3D; right_height) &#x2F;&#x2F; 满树 2^h - 1        return (1 &lt;&lt; left_height) - 1;    return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1;}



223 找出两个长方形覆盖的面积
    C 解答

12345678910int computeArea(int left1, int down1, int right1, int up1, int left2, int down2, int right2, int up2) {    int left &#x3D; max(left1, left2); &#x2F;&#x2F; 靠右的    int right &#x3D; max(min(right1, right2), left);&#x2F;&#x2F; 靠左的，但是比左边大    int down &#x3D; max(down1, down2);    int up &#x3D; max(min(up1, up2), down);    &#x2F;&#x2F; 不小心写反了。    return -((left1 - right1) * (up1 - down1) + (left2 - right2) * (up2 - down2) - (left - right) * (up - down));}



224 给定一个字符串，包含加减和括号，计算值难点是对括号的处理，注意每次都要和 signs.top() 相乘

    C++ 解答

1234567891011121314151617181920212223242526272829int calculate(string s) {    stack&lt;int&gt; signs; &#x2F;&#x2F; signs before braces    int sign &#x3D; 1;    int num &#x3D; 0;    int result &#x3D; 0;    signs.push(1);    for (auto c : s) {        if (isdigit(c)) {            num &#x3D; 10 * num + (c - &#39;0&#39;);        } else if (c &#x3D;&#x3D; &#39;+&#39; || c &#x3D;&#x3D; &#39;-&#39;) {            result +&#x3D; signs.top() * sign * num;            num &#x3D; 0;            sign &#x3D; c &#x3D;&#x3D; &#39;+&#39; ? 1 : -1;        } else if (c &#x3D;&#x3D; &#39;(&#39;) {            signs.push(sign * signs.top()); &#x2F;&#x2F; tricky            sign &#x3D; 1;        } else if (c &#x3D;&#x3D; &#39;)&#39;) {            result +&#x3D; signs.top() * sign * num;            num &#x3D; 0;            signs.pop();            sign &#x3D; 1;        }    }    result +&#x3D; signs.top() * sign * num; &#x2F;&#x2F; tricky    return result;}



225 使用队列模拟栈其实有两种做法，一种是在 push 的时候，把队列清空，把 x 放到最底下。另一种是在 pop 的时候，把队列清空到 1，然后弹出。应当询问面试官究竟是 push 居多还是 pop 居多

    C++ 解答

123456789101112131415161718192021222324252627282930313233class Stack {public:    &#x2F;&#x2F; Push element x onto stack.    void push(int x) {        while (!nums.empty()) {            temp.push(nums.front());            nums.pop();        }        nums.push(x);        while (!temp.empty()) {            nums.push(temp.front());            temp.pop();        }    }    &#x2F;&#x2F; Removes the element on top of the stack.    void pop() {        nums.pop();    }    &#x2F;&#x2F; Get the top element.    int top() {        return nums.front();    }    &#x2F;&#x2F; Return whether the stack is empty.    bool empty() {        return nums.empty();    }private:    queue&lt;int&gt; nums;    queue&lt;int&gt; temp;};



226 反转二叉树
    C 解答

1234567struct TreeNode* invertTree(struct TreeNode* root) {    if (!root) return NULL;    struct TreeNode* temp &#x3D; root-&gt;left;    root-&gt;left &#x3D; invertTree(root-&gt;right);    root-&gt;right &#x3D; invertTree(temp);    return root;}



227 给定一个字符串包含 +-*&#x2F; 计算他的值
    C++ 解答

1234567891011121314151617181920212223242526272829303132333435363738int calculate(string s) {    vector&lt;int&gt; stk; &#x2F;&#x2F; 使用 vector 便于统计最后的值    char token &#x3D; &#39;+&#39;;    int num &#x3D; 0;    for (int i &#x3D; 0; i &lt; s.size(); i++) {        if (isdigit(s[i]))            num &#x3D; num * 10 + s[i] - &#39;0&#39;;        &#x2F;&#x2F; 这里不是 else if        if (s[i] &#x3D;&#x3D; &#39;+&#39; || s[i] &#x3D;&#x3D; &#39;-&#39; || s[i] &#x3D;&#x3D; &#39;*&#39; || s[i] &#x3D;&#x3D; &#39;&#x2F;&#39; || i &#x3D;&#x3D; s.size() - 1) { &#x2F;&#x2F; 注意最后一步还需要把最后的值计算            int a;            switch (token) {            case &#39;+&#39;:                stk.push_back(num);                break;            case &#39;-&#39;:                stk.push_back(-num);                break;            case &#39;*&#39;:                a &#x3D; stk.back();                stk.pop_back();                stk.push_back(a * num);                break;            case &#39;&#x2F;&#39;:                a &#x3D; stk.back();                stk.pop_back();                stk.push_back(a &#x2F; num);                break;            };            token &#x3D; s[i];            num &#x3D; 0;        }    }    int result &#x3D; 0;    for (auto i : stk)        result +&#x3D; i;    return result;}



228 聚合区间，给定一排序数组，把相邻的数字用区间表示
    C++ 解答

123456789101112131415161718vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) {    int n &#x3D; nums.size();    vector&lt;string&gt; result;    if (n &#x3D;&#x3D; 0) return result;    for (int i &#x3D; 0; i &lt; n; ) {        int start &#x3D; i, end &#x3D; i;        while (end + 1 &lt; n &amp;&amp; nums[end + 1] &#x3D;&#x3D; nums[end] + 1)            end++;        if (end &gt; start)            result.push_back(to_string(nums[start]) + &quot;-&gt;&quot; + to_string(nums[end]));        else            result.push_back(to_string(nums[start]));        i &#x3D; end + 1;    }    return result;}



229 找出超过三分之一的元素
    C++ 解答

1234567891011121314151617181920212223242526272829303132vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) {    int count1 &#x3D; 0, count2 &#x3D; 0;    int a, b;    for (auto n : nums) {        if (count1 &#x3D;&#x3D; 0 || n &#x3D;&#x3D; a) {            count1++;            a &#x3D; n;        } else if (count2 &#x3D;&#x3D; 0 || n &#x3D;&#x3D; b) {            count2++;            b &#x3D; n;        } else {            count1--;            count2--;        }    }    count1 &#x3D; count2 &#x3D; 0;    for (int n : nums) {        if (n &#x3D;&#x3D; a) count1++;        if (n &#x3D;&#x3D; b) count2++;    }    vector&lt;int&gt; result;    if (count1 &gt; nums.size() &#x2F; 3) &#x2F;&#x2F; verify a        result.push_back(a);    if (count2 &gt; nums.size() &#x2F; 3 &amp;&amp; a !&#x3D; b) &#x2F;&#x2F; verify b        result.push_back(b);    return result;}



230 二叉树中第 k 小的数字
    C 解答

1234567891011121314151617&#x2F;&#x2F; 传递指针void inorder(struct TreeNode* root, int* k, int* number) {    if (!root)        return;    inorder(root-&gt;left, k, number);    (*k)--;    if (*k &#x3D;&#x3D; 0) {        *number &#x3D; root-&gt;val;        return;    }    inorder(root-&gt;right, k, number);}int kthSmallest(struct TreeNode* root, int k) {    int number;    inorder(root, &amp;k, &amp;number);    return number;}



231 2 的次方
    C 解答

1234bool isPowerOfTwo(int n) {    if (n &lt;&#x3D; 0) return false;    return (n &amp; (n - 1)) &#x3D;&#x3D; 0;}





    Rust 解答

12345678impl Solution {    pub fn is_power_of_two(n: i32) -&gt; bool {        if n &lt;&#x3D; 0 {            return false;        }        (n &amp; (n-1)) &#x3D;&#x3D; 0    }}



232 使用栈模拟队列
    C++ 解答

123456789101112131415161718192021222324252627282930313233343536373839class Queue {public:    &#x2F;&#x2F; Push element x to the back of queue.    void push(int x) {        in.push(x);    }    &#x2F;&#x2F; Removes the element from in front of queue.    void pop(void) {        if (empty())            return;        if (out.empty())            transfer();        out.pop();    }    &#x2F;&#x2F; Get the front element.    int peek(void) {        if (empty())            return INT_MIN;        if (out.empty())            transfer();        return out.top();    }    &#x2F;&#x2F; Return whether the queue is empty.    bool empty(void) {        return in.empty() &amp;&amp; out.empty();    }private:    void transfer() {        while (!in.empty()) {            out.push(in.top());            in.pop();        }    };    stack&lt;int&gt; in;    stack&lt;int&gt; out;};



233 小于 n 的数字中 1 的个数对于每一位，有三种情况：

当是数字 0 的时候，可能出先 1 的情况完全由高位出现决定，因为这一位不能贡献 1
当是数字 1 的时候，同上，但是这一位和低位一起可以贡献一个 1
当时数字 2-9 的时候，相当于这一位的 1 可以任意出现，因此高位＋1


    C 解答

12345678910111213int countDigitOne(int n) {    int ones &#x3D; 0;    for (int m &#x3D; 1; m &lt;&#x3D; n; m *&#x3D; 10) { &#x2F;&#x2F; m is the factor        int a &#x3D; n&#x2F;m, b &#x3D; n%m;  &#x2F;&#x2F; a is left half, b is right half        if (a % 10 &gt;&#x3D; 2)            ones +&#x3D; (a &#x2F; 10 + 1) * m;        if (a % 10 &#x3D;&#x3D; 1)            ones +&#x3D; (a &#x2F; 10) * m + b + 1;        if (a % 10 &#x3D;&#x3D; 0)            ones +&#x3D; (a &#x2F; 10) * m;    }    return ones;}



二进制呢

    C 解答

12345678910int countDigitOneBinary(int n) {    int ones &#x3D; 0;    for (int m &#x3D; 1; m &lt;&#x3D; n; m &lt;&lt;&#x3D; 1) {        int a &#x3D; n &#x2F; m, b &#x3D; n % m;        if (a &amp; 0x01)            ones +&#x3D; (a &gt;&gt; 1) * m + b + 1;        else            ones +&#x3D; (a &gt;&gt; 1) * m;    }}



求最大的 countDigitOne(n) &#x3D;&#x3D; n
9    1
99   20
999  300
...
99999999  10000000

234 判断一个链表是否是回文解法 1: 如果链表是可以改变的，不妨反转它的前半部分，然后再与后半部分比较
解法 2: 如果是只读的，复制一份也可以，但是不如使用堆栈
注意对奇数偶数的处理

    C++ 解答

123456789101112131415161718192021222324252627282930313233bool isPalindrome(ListNode* head) {    if (!head || !head-&gt;next)        return true;    int len &#x3D; 0;    ListNode* temp &#x3D; head;    while (temp) {        len++;        temp &#x3D; temp-&gt;next;    }    stack&lt;int&gt; stk;    temp &#x3D; head;    int mid &#x3D; len &#x2F; 2;    while (mid--) {        stk.push(temp-&gt;val);        temp &#x3D; temp-&gt;next;    }    if (len &amp; 0x01)        temp &#x3D; temp-&gt;next;    while (temp !&#x3D; NULL &amp;&amp; !stk.empty()) {        int a &#x3D; stk.top();        stk.pop();        int b &#x3D; temp-&gt;val;        temp &#x3D; temp-&gt;next;        if (a !&#x3D; b) {            return false;        }    }    return true;}



235 二叉搜索树公共祖先
    C 解答

12345678910struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {    while (root) {        if (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)            root &#x3D; root-&gt;left;        else if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)            root &#x3D; root-&gt;right;        else            return root;    }}



236 二叉树公共祖先如果二叉树的根就是其中一个节点，那显然是这个。在两颗子树中分别查找，如果找到了，返回一个非 NULL 值，如果都找到了，则这个节点就是 LCA

    C 解答

123456789101112struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {    if (!root || root &#x3D;&#x3D; p || root &#x3D;&#x3D; q)        return root;    struct TreeNode* left &#x3D; lowestCommonAncestor(root-&gt;left, p, q);    struct TreeNode* right &#x3D; lowestCommonAncestor(root-&gt;right, p, q);    if (!left) &#x2F;&#x2F; not in left subtree        return right;    if (!right)        return left;    return root; &#x2F;&#x2F; both left and right are found!}



237 删除链表中的元素直接将后继节点的值复制到当前节点

    C 解答

12345678void deleteNode(struct ListNode* node) {    if (!node || !node-&gt;next)        return;    struct ListNode* next &#x3D; node-&gt;next;    node-&gt;val &#x3D; next-&gt;val;    node-&gt;next &#x3D; next-&gt;next;    free(next);}



238 数组除了自己以外的乘积，规定不能用除法首先从前往后乘，错开一位元素，这样每个元素都乘到了他之前的所有元素，最后一个元素已经是结果了。然后从后往前乘，同样错开一位，这样每个元素又把他之后的元素都得到了。
239 滑动窗口最大值，给定一个滑动窗口，返回它移动过程中的最大值单调队列的应用，复杂度是 O(n) 的。

    Python 解答

12345678910111213141516171819202122232425262728293031323334353637from collections import dequeclass MonoQueue:    def __init__(self):        self.q &#x3D; deque()  # 实际储存数据        self.m &#x3D; deque()  # 维护单调关系，队首元素总是最大值    def push(self, x):        self.q.append(x)        while len(self.m) &gt; 0 and self.m[-1] &lt; x:            self.m.pop()        self.m.append(x)    def pop(self):        x &#x3D; self.q.popleft()        if self.m[0] &#x3D;&#x3D; x:            self.m.popleft()        return x    def __len__(self):        return len(self.q)    def top(self):        return self.m[0]class Solution:    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:        q &#x3D; MonoQueue()        for i in range(k):            q.push(nums[i])        ans &#x3D; []        for i in range(k, len(nums)):            ans.append(q.top())            q.pop()            q.push(nums[i])        ans.append(q.top())        return ans



另一种现在我已经看不懂的做法

    C++ 解答

1234567891011121314151617&#x2F;&#x2F; 题目给定 k 一定是有效地vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {    vector&lt;int&gt; result;    if (nums.empty() || k &lt;&#x3D; 0)        return result;    deque&lt;int&gt; dq; &#x2F;&#x2F; 存储的是索引，front 存储最大值，保证递减    for (int i &#x3D; 0; i &lt; nums.size(); i++) {        while (!dq.empty() &amp;&amp; dq.front() &lt; i - k + 1) &#x2F;&#x2F; 弹出滑过的窗口            dq.pop_front();        while (!dq.empty() &amp;&amp; nums[dq.back()] &lt; nums[i]) &#x2F;&#x2F; 弹出小的            dq.pop_back();        dq.push_back(i);        if (i &gt;&#x3D; k - 1)            result.push_back(nums[dq.front()]);    }    return result;}



240 给定一个矩阵，每行从左到右都是增大的，每一列从上到下都是增大的，找出给定数字是否存在我们考虑右上角的元素

如果这个元素比 taget 大，那么整列都比 target 大，我们可以 c–
如果这个元素比 target 小，那么正行都比 target 小，我们可以 r++


    C 解答

1234567891011bool searchMatrix(int** matrix, int row, int col, int target) {    int r &#x3D; 0, c &#x3D; col - 1; &#x2F;&#x2F; 右上角    while (r &lt; row &amp;&amp; c &gt; -1) &#x2F;&#x2F; 向左下角        if (matrix[r][c] &#x3D;&#x3D; target)            return true;        else if (matrix[r][c] &gt; target)            c--;        else            r++;    return false;}



241 添加括号得到不同的结果对每一个符号，在他的两边添加括号的好的不同结果再计算。

    C++ 解答

1234567891011121314vector&lt;int&gt; diffWaysToCompute(string input) {    vector&lt;int&gt; output;    for (int i &#x3D; 0; i &lt; input.size(); i++) {        char token &#x3D; input[i];        if (!isdigit(token)) &#x2F;&#x2F; not digit            for (int a : diffWaysToCompute(input.substr(0, i))) &#x2F;&#x2F; 左半部分                for (int b : diffWaysToCompute(input.substr(i+1))) &#x2F;&#x2F; 右半部分                    output.push_back(token &#x3D;&#x3D; &#39;+&#39; ? a + b : token &#x3D;&#x3D; &#39;-&#39;? a - b: a *b); &#x2F;&#x2F; 两半部分之和    }    if (output.empty())        output.push_back(stoi(input));    return output;}



242 一个单词是否能由另一个变幻而来还是，对于 ASCII 字符，直接用数组代替字典

    C 解答

123456789101112bool isAnagram(char* s, char* t) {    char ss[26] &#x3D; {0};    char ts[26] &#x3D; {0};    while (*s) {        ss[*s - &#39;a&#39;]++;        s++;        ts[*t - &#39;a&#39;]++;        t++;    }    if (*t) return false;    return memcmp(ss, ts, sizeof(ss)) &#x3D;&#x3D; 0;}



243-256 Locked
257 二叉树左右路径典型的 DFS，发挥所有从根节点到叶节点的路径

    C++ 解答

12345678910111213141516171819vector&lt;string&gt; binaryTreePaths(TreeNode* root) {    vector&lt;string&gt; result;    if (!root) return result;    paths(result, &quot;&quot;, root);    return result;}void paths(vector&lt;string&gt;&amp; result, string path, TreeNode* root) {    if (path.empty())        path +&#x3D; to_string(root-&gt;val);    else        path +&#x3D; &quot;-&gt;&quot; + to_string(root-&gt;val);    if (root-&gt;left)        paths(result, path, root-&gt;left);    if (root-&gt;right)        paths(result, path, root-&gt;right);    if (!root-&gt;left &amp;&amp; !root-&gt;right)        result.push_back(path);}



258 把数字的每一位加起来，直到变成一个一位的数字这完全是一道数学题，对于每个进制的数字都有规律 (n - 1) % (x - 1) + 1。实际上是把 10 进制的转化为 9 进制数字

    C 解答

123int addDigits(int num) {    return (num - 1) % 9 + 1;}



259 Locked
260 给定一个数组，每个数字都是重复的，只有两个数字不是，找出这两个数字这道题很奇妙，依然可以使用 XOR 来解，首先遍历一遍，这时候由于有两个数字是不同的，那么一定结果不为 0，那么其中一个 bit 位一定是一个数字有，另一个数字没有。在遍历一遍，同时把数字分两组，一组是有这个 bit 位，一组没有。就得出了结果。

    C++ 解答

1234567891011121314vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) {    int r &#x3D; 0;    for (auto&amp; n : nums)        r ^&#x3D; n;    int bit &#x3D; r &amp; -r; &#x2F;&#x2F; last sig bit    vector&lt;int&gt; result &#x3D; {0, 0};    for (auto&amp; n : nums)        if (n &amp; bit)            result[0] ^&#x3D; n;        else            result[1] ^&#x3D; n;    return result;}



261 262 Locked
263 丑陋的数字，质数因子只含有 2,3,5 的数字按定义做就好了

    C 解答

12345678910111213141516bool isUgly(int n) {    if (n &lt;&#x3D; 0)        return false;    if (n &#x3D;&#x3D; 1)        return true;    while (n &gt; 1)        if (n % 2 &#x3D;&#x3D; 0)            n &#x2F;&#x3D; 2;        else if (n % 3 &#x3D;&#x3D; 0)            n &#x2F;&#x3D; 3;        else if (n % 5 &#x3D;&#x3D; 0)            n &#x2F;&#x3D; 5;        else            return false;    return true;}



264 找出第 n 个丑陋数字使用数列记录 n 个丑陋数字，每一个丑陋数字肯定是之前数字乘以 235 得到的，然后用三个指针分别指向上一个做乘法的数字，每次找出最小的一个

    C 解答

12345678910111213141516171819#define MIN(a,b) ((a)&lt;(b)?(a):(b))int nthUglyNumber(int n) {    if (n &lt;&#x3D; 0)        return -1;    if (n &lt; 6) &#x2F;&#x2F; 1..6 恰好都是        return n;    int s2 &#x3D; 0, s3 &#x3D; 0, s5 &#x3D; 0;    int* uglies[n];    uglies[0] &#x3D; 1;    for (int i &#x3D; 1; i &lt; n; i++) {        int c2 &#x3D; uglies[s2] * 2, c3 &#x3D; uglies[s3] * 3, c5 &#x3D; uglies[s5] * 5;        uglies[i] &#x3D; MIN(c2, MIN(c3, c5));        if (uglies[i] &#x3D;&#x3D; c2) s2++;        if (uglies[i] &#x3D;&#x3D; c3) s3++;        if (uglies[i] &#x3D;&#x3D; c5) s5++;    }    return uglies[n-1];}



268 丢失的数字，给定 0…n，丢失了一个，然后放在长度为 n 的数组之中，找出这个数字显然还是使用异或，注意 0 ^ x &#x3D;&#x3D; x，所以直接把 0 忽略就行了。把每个数字都和 i 异或，丢失的数字就出来了

    C 解答

123456int missingNumber(int* nums, int n) {    int result &#x3D; 0;    for (int i &#x3D; 0; i &lt; n; i++)        result &#x3D; result ^ (i + 1) ^ nums[i];    return result;}



269-272 Locked
273 数字转换为英语单词
    C++ 解答

12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution {public:    vector&lt;string&gt; digits &#x3D; {&quot;&quot;, &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;, &quot;Six&quot;, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;, &quot;Ten&quot;, &quot;Eleven&quot;, &quot;Twelve&quot;, &quot;Thirteen&quot;, &quot;Fourteen&quot;, &quot;Fifteen&quot;, &quot;Sixteen&quot;, &quot;Seventeen&quot;, &quot;Eighteen&quot;, &quot;Nineteen&quot;};    vector&lt;string&gt; tens &#x3D; {&quot;&quot;, &quot;&quot;, &quot;Twenty&quot;, &quot;Thirty&quot;, &quot;Forty&quot;, &quot;Fifty&quot;, &quot;Sixty&quot;, &quot;Seventy&quot;, &quot;Eighty&quot;, &quot;Ninety&quot;};    vector&lt;string&gt; seps &#x3D; {&quot;&quot;, &quot; Thousand &quot;, &quot; Million &quot;, &quot; Billion &quot;}; &#x2F;&#x2F; notice the trailing spaces    string numberToWords(int num) {        if (num &#x3D;&#x3D; 0)            return &quot;Zero&quot;;        if (num &lt; 0)            return &quot;Negative &quot; + numberToWords(-num);        int count &#x3D; 0;        string result;        while (num) {            if (num % 1000 !&#x3D; 0)                result &#x3D; s2word(num % 1000) + seps[count] + result;            num &#x2F;&#x3D; 1000;            count++;        }        &#x2F;&#x2F; removw unnecessary tailing space        if (isspace(result.back()))            result.resize(result.size() - 1);        return result;    }    string s2word(int num) {        string result;        if (num &gt;&#x3D; 100) {            result +&#x3D; digits[num&#x2F;100] + &quot; Hundred &quot;;            num %&#x3D; 100;        }        if (num &gt;&#x3D; 20) {            result +&#x3D; tens[num &#x2F; 10] + &quot; &quot;;            num %&#x3D; 10;        }        if (num &gt;&#x3D; 1 &amp;&amp; num &lt;&#x3D; 19)            result +&#x3D; digits[num];        &#x2F;&#x2F; remove tailing spaces        if (isspace(result.back()))            result.resize(result.size() - 1);        return result;    }};



274 H-IndexH-Index 的定义：一个科学家的 N 篇论文 h 个至少有 h 个引用，而且剩下的 N-h 篇论文都没有超过 h 个引用。

    C 解答

123456789101112131415161718192021int hIndex(int* cites, int n) {    int hs[n+1]; &#x2F;&#x2F; Hindex 不可能大于 N    for (int i &#x3D; 0; i &lt;&#x3D; n; i++)        hs[i] &#x3D; 0;    for (int i &#x3D; 0; i &lt; n; i++) {        if (cites[i] &gt; n)            hs[n]++;        else            hs[cites[i]]++;    }    for (int i &#x3D; n, papers &#x3D; 0; i &gt;&#x3D; 0; i--) { &#x2F;&#x2F; 从后往前，如果有符合条件的，那么就是 Hindex        papers +&#x3D; hs[i];        if (papers &gt;&#x3D; i)            return i;    }    return 0;}



275 H-index II，论文已经按照引用数量排序
    C 解答

12345678910111213int hIndex(int* citations, int n) {    int left &#x3D; 0, right &#x3D; n - 1;    while (left &lt;&#x3D; right) { &#x2F;&#x2F; 二分查找是小于等于        int mid &#x3D; left + (right - left) &#x2F; 2;        if (citations[mid] &#x3D;&#x3D; n - mid)            return citations[mid];        else if (citations[mid] &lt; n - mid)            left &#x3D; mid + 1;        else            right &#x3D; mid - 1;    }    return n - right - 1;}



276-277 Locked
278 第一个坏版本
    C 解答

123456789101112&#x2F;&#x2F; 实际上是 lower_bound 函数int firstBadVersion(int n) {    int left &#x3D; 0, right &#x3D; n; &#x2F;&#x2F; 记住 lower_bound 的 right 是 n    while (left &lt; right) {   &#x2F;&#x2F; 使用小于号        int mid &#x3D; left + (right - left) &#x2F; 2;        if (!isBadVersion(mid))            left &#x3D; mid + 1;        else            right &#x3D; mid;    }    return left;}



279 分解为平方数的和最多 4 个即可，尝试在三个以内是否可以。

    C 解答

1234567891011int numSquares(int n) {    int ub &#x3D; sqrt(n);    for (int a&#x3D;0; a&lt;&#x3D;ub; ++a) {        for (int b&#x3D;a; b&lt;&#x3D;ub; ++b) {            int c &#x3D; sqrt(n - a*a - b*b);            if (a*a + b*b + c*c &#x3D;&#x3D; n)                return !!a + !!b + !!c;        }    }    return 4;}



282 添加运算符使得算式成立
    C++ 解答

123456789101112131415161718192021vector&lt;string&gt; addOperators(string num, int target) {    vector&lt;string&gt; result;    if (num.size() &#x3D;&#x3D; 0)        return result;    dfs(num, target, result, num[0] - &#39;0&#39;, num.substr(0, 1), 1, 1);    return result;}void dfs(string num, int target, vector&lt;string&gt; &amp; v, long long last, string s, int idx, int left) {    if (idx &#x3D;&#x3D; num.length()){        if (target &#x3D;&#x3D; last*left)            v.push_back(s);        return;    } else {        if(last!&#x3D;0)            dfs(num, target,         v, last * 10 + num[idx] - &#39;0&#39;, s + num.substr(idx, 1), idx + 1, left); &#x2F;&#x2F; 尝试拼成 10        dfs(num, target,             v, num[idx] - &#39;0&#39;, s + &#39;*&#39; + num.substr(idx, 1), idx + 1, last*left);        dfs(num, target - left*last, v, num[idx] - &#39;0&#39;, s + &#39;+&#39; + num.substr(idx, 1), idx + 1, 1);        dfs(num, target - left*last, v, num[idx] - &#39;0&#39;, s + &#39;-&#39; + num.substr(idx, 1), idx + 1, -1);    }}



283 移动 0注意 swap 的使用

    C++ 解答

1234567void moveZeroes(vector&lt;int&gt;&amp; nums) {    int n &#x3D; 0;    for (int i &#x3D; 0; i &lt; nums.size(); i++) {        if (nums[i] !&#x3D; 0)            swap(nums[n++], nums[i]);    }}



284 Peek Iterator
    C++ 解答

12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;&#x2F; Below is the interface for Iterator, which is already defined for you.&#x2F;&#x2F; **DO NOT** modify the interface for Iterator.class Iterator {    struct Data;    Data* data;public:    Iterator(const vector&lt;int&gt;&amp; nums);    Iterator(const Iterator&amp; iter);    virtual ~Iterator();    &#x2F;&#x2F; Returns the next element in the iteration.    int next();    &#x2F;&#x2F; Returns true if the iteration has more elements.    bool hasNext() const;};class PeekingIterator : public Iterator {public:    PeekingIterator(const vector&lt;int&gt;&amp; nums) : Iterator(nums) {        &#x2F;&#x2F; Initialize any member here.        &#x2F;&#x2F; **DO NOT** save a copy of nums and manipulate it directly.        &#x2F;&#x2F; You should only use the Iterator interface methods.    }    &#x2F;&#x2F; Returns the next element in the iteration without advancing the iterator.    int peek() {        return Iterator(*this).next();    }    &#x2F;&#x2F; hasNext() and next() should behave the same as in the Iterator interface.    &#x2F;&#x2F; Override them if needed.    int next() {        return Iterator::next();    }    bool hasNext() const {        return Iterator::hasNext();    }};



285 ~ 286 Locked287 一个 n 的数组包含了 1…n-1 中的这些数字，证明一定存在重复，并找出这个重复使用抽屉原理可以证明一定存在重复。据说高纳德解这个问题花了四个小时。
我们把这个数组看做一个变幻方程 f(i) &#x3D; A[i]，把一些数字变幻到另一些，那么存在一个 i !&#x3D; j s.t. f(i) &#x3D;&#x3D; f(j).那么这个问题变成了链表求环的问题。对于链表，我们有 n &#x3D; n-&gt;next 遍历列表，对于这个序列，则是 n &#x3D; f(n)

    C 解答

12345678910111213141516int findDuplicate(int* nums, int n) {    &#x2F;&#x2F; 从 n-1 开始    int fast &#x3D; n - 1, slow &#x3D; n - 1;    do {        slow &#x3D; nums[slow] - 1; &#x2F;&#x2F; 减一是为了转化为坐标        fast &#x3D; nums[nums[fast] - 1] - 1;    } while (slow !&#x3D; fast);    fast &#x3D; n - 1;    do {        slow &#x3D; nums[slow] - 1;        fast &#x3D; nums[fast] - 1;    } while (slow !&#x3D; fast);    return slow + 1; &#x2F;&#x2F; 从坐标到数字}



288 Locked289 Conway’s Game of Life哈哈，机智，使用没有使用的第二个位存储下一代

    C 解答

1234567891011121314151617int max(int a, int b) {return a &gt; b ? a :b;}int min(int a, int b) {return a &lt; b ? a :b;}void gameOfLife(int** board, int row, int col) {    for (int i &#x3D; 0; i &lt; row; i++) {        for (int j &#x3D; 0; j &lt; col; j++) {            int count &#x3D; 0;            for (int m&#x3D;max(i-1, 0); m&lt;min(i+2, row); m++) &#x2F;&#x2F; 这里的 min，max 使用的太屌了                for (int n&#x3D;max(j-1, 0); n&lt;min(j+2, col); n++)                    count +&#x3D; (board[m][n] &amp; 1);            if (count &#x3D;&#x3D; 3 || count - board[i][j] &#x3D;&#x3D; 3) &#x2F;&#x2F; 当前为 0，周围为 3；or 当前为 1，周围为 2&#x2F;3 here                board[i][j] |&#x3D; 2;        }    }    for (int i &#x3D; 0; i &lt; row; i++)        for (int j &#x3D; 0; j &lt; col; j++)            board[i][j] &gt;&gt;&#x3D; 1;}



290 单词模式，给定一个模式 abba 等，判断单词是否是这个模式的。
    C++ 解答

12345678910111213bool wordPattern(string pattern, string str) {    map&lt;char, int&gt; chars;  &#x2F;&#x2F; 使用两个 map 纪录    map&lt;string, int&gt; words;    istringstream in(str);    int i &#x3D; 0, n &#x3D; pattern.size(); &#x2F;&#x2F; &#96;i&#96; is word count    for (string word; in &gt;&gt; word; i++) {        if (i &#x3D;&#x3D; n || chars[pattern[i]] !&#x3D; words[word]) &#x2F;&#x2F; 检查是否相等            return false;        chars[pattern[i]] &#x3D; words[word] &#x3D; i + 1; &#x2F;&#x2F; distinct non zero    }    return i &#x3D;&#x3D; n; &#x2F;&#x2F; 检查长度是否相等}



291 Locked292 Nim 游戏，每个人可以选择丢掉 1，2，3，最后一个操作者获胜显然，当我们遇到 4 的时候会输，其他情况都可以赢。

    C 解答

123bool canWinNim(int n) {    return n % 4 !&#x3D; 0;}



300 最长递增子序列最经典的动态规划题目

    Python 解答

123456789101112class Solution:    def lengthOfLIS(self, nums: List[int]) -&gt; int:        if not nums:            return 0        if len(nums) &#x3D;&#x3D; 1:            return 1        dp &#x3D; [1 for _ in range(len(nums))]        for i in range(len(nums)):            for j in range(i):                if nums[i] &gt; nums[j]:                    dp[i] &#x3D; max(dp[i], dp[j] + 1)        return max(*dp)



344 翻转字符串
    C 解答

123456789101112131415char* reverseString(char* s) {    char* start &#x3D; s;    char* e &#x3D; s;    while (*e) ++e;    e--;    char t;    while (s &lt; e) {        t &#x3D; *s;        *s &#x3D; *e;        *e &#x3D; t;        s++;        e--;    }    return start;}



347 出现最多的几个数字C 实在缺乏相关的基础数据结构，这道题用 JS 做了

    JavaScript 解答

1234567891011121314151617181920212223242526272829303132333435363738&#x2F;** * @param {number[]} nums * @param {number} k * @return {number[]} *&#x2F;let topKFrequent &#x3D; function(nums, k) {    let counter &#x3D; {};    for (let num of nums) {        if (num in counter) {            counter[num]++;        } else {            counter[num] &#x3D; 0;        }    }    let bucket &#x3D; [];    for (let num in counter) {        let rev_freq &#x3D; nums.length - counter[num] + 1;        if (rev_freq in bucket) {            bucket[rev_freq].push(num);        } else {            bucket[rev_freq] &#x3D; [num];        }    }    let rv &#x3D; [];    for (let bc of bucket) {        if (! Array.isArray(bc)) continue;        for (let num of bc) {            if (rv.length &#x3D;&#x3D; k)                return rv;            else                rv.push(parseInt(num))        }    }    return rv;};



349 两个数组中都出现的元素先排序，降低复杂度

    C 解答

1234567891011121314151617181920212223242526static int compare(const void* a, const void* b) {    return *(int*)a - *(int*)b;}int* intersection(int* A, int m, int* B, int n, int* k) {    qsort(A, m, sizeof(int), compare);    qsort(B, n, sizeof(int), compare);    int* C &#x3D; malloc((m + n) * sizeof(int));    *k &#x3D; 0;    int i &#x3D; 0;    int j &#x3D; 0;    while (i &lt; m &amp;&amp; j &lt; n) {        if (A[i] &#x3D;&#x3D; B[j]) {            if (*k &#x3D;&#x3D; 0)                C[(*k)++] &#x3D; A[i];            else if (C[*k - 1] !&#x3D; A[i])                C[(*k)++] &#x3D; A[i];            i++;            j++;        } else if (A[i] &lt; B[j]) {            i++;        } else {            j++;        }    }    return C;}




345 翻转一个字符串里面的元音字母使用两个指针，不过需要注意元音字母包括了大小写

    Python 解答

1234567891011121314151617181920212223class Solution:    def reverseVowels(self, s):        &quot;&quot;&quot;        :type s: str        :rtype: str        &quot;&quot;&quot;        if not s:            return s        vowels &#x3D; set(&quot;AEIOUaeiou&quot;)        s &#x3D; list(s)        i &#x3D; 0        j &#x3D; len(s) - 1        while True:            while s[i] not in vowels and i &lt; j:                i +&#x3D; 1            while s[j] not in vowels and i &lt; j:                j -&#x3D; 1            if i &gt;&#x3D; j:                break            s[i], s[j] &#x3D; s[j], s[i]            i +&#x3D; 1            j -&#x3D; 1        return &#39;&#39;.join(s)



371 两个数之和这道题要求不用 + 和 - 来计算出两个数之和，显然应该使用位运算，使用异或计算每一位的值，在使用或计算是否需要进位

    C 解答

1234567891011121314151617int getSum(int a, int b) {    int rv &#x3D; 0;    int carry &#x3D; 0;    for (int i &#x3D; 0; i &lt; 32; i++) {        int last_bit_of_a &#x3D; a &amp; 1;        int last_bit_of_b &#x3D; b &amp; 1;        rv |&#x3D; (last_bit_of_a ^ last_bit_of_b ^ carry) &lt;&lt; i;        carry &#x3D; (carry &amp; last_bit_of_a) | (carry &amp; last_bit_of_b) | (last_bit_of_a &amp; last_bit_of_b);        a &gt;&gt;&#x3D; 1;        b &gt;&gt;&#x3D; 1;    }    return rv;}



388使用栈的一道简单题目, 其实计算长度部分还可以优化

    Python 解答

1234567891011121314151617181920class Solution:    def lengthLongestPath(self, input: str) -&gt; int:        path &#x3D; []        ans &#x3D; 0        for name in input.split(&quot;\n&quot;):            l &#x3D; 0            for c in name:                if c &#x3D;&#x3D; &quot;\t&quot;:                    l +&#x3D; 1                else:                    break            if len(path) &gt; l:                for i in range(len(path) - l):                    path.pop()            path.append(name.strip(&quot;\t&quot;))            if &quot;.&quot; in name:                length &#x3D; sum([len(p) for p in path]) + len(path) - 1                ans &#x3D; max(ans, length)                print(path)        return ans



435 无重叠区间不要被题目迷惑，从反面开始思考，求去除多少个区间其实就是求最多有多少个有效区间

    Python 解答

12345678910class Solution:    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:        intervals.sort(key&#x3D;lambda x: x[1])        max_intervals &#x3D; 0        end &#x3D; float(&quot;-inf&quot;)        for interval in intervals:            if interval[0] &gt;&#x3D; end:                max_intervals +&#x3D; 1                end &#x3D; interval[1]        return len(intervals) - max_intervals



482 注册码格式化要求每 K 个字符添加一个 “-“, 如果不够的话，第一个分组可以不全。

    Python 解答

1234567891011121314class Solution:    def licenseKeyFormatting(self, S: str, K: int) -&gt; str:        key &#x3D; []        i &#x3D; 0        for c in reversed(S):            if c &#x3D;&#x3D; &quot;-&quot;:                continue            key.append(c.upper())            i +&#x3D; 1            if i % K &#x3D;&#x3D; 0:                key.append(&quot;-&quot;)        if key and key[-1] &#x3D;&#x3D; &quot;-&quot;:            key &#x3D; key[:-1]        return &quot;&quot;.join(reversed(key))



547 朋友圈UnionFind 的定义见第 200 题

    Python 解答

123456789class Solution:    def findCircleNum(self, M: List[List[int]]) -&gt; int:        n &#x3D; len(M)        uf &#x3D; UnionFind(n)        for i in range(n):            for j in range(i):                if M[i][j] &#x3D;&#x3D; 1:                    uf.union(i, j)        return uf.count



739单调栈的简单应用

    Python 解答

123456789101112class Solution:    def dailyTemperatures(self, T: List[int]) -&gt; List[int]:        stack &#x3D; []        ans &#x3D; [0] * len(T)        for i in range(len(T)-1, -1, -1):            # 如果当前温度大于当前最低温度            while stack and T[i] &gt;&#x3D; T[stack[-1]]:                stack.pop()            if stack:                ans[i] &#x3D; stack[-1] - i            stack.append(i)        return ans



864 矩形重叠
    Python 解答

123456class Solution:    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -&gt; bool:        # 注意要包含等于号        x_overlap &#x3D; not(rec1[0] &gt;&#x3D; rec2[2] or rec1[2] &lt;&#x3D; rec2[0])        y_overlap &#x3D; not(rec1[1] &gt;&#x3D; rec2[3] or rec1[3] &lt;&#x3D; rec2[1])        return x_overlap and y_overlap




904 找出包含了两个不同数字的最长子序列这道题的题目很坑爹，但是翻译过来其实要求很明确。解题思路也很简单，存储一下当前的最长序列就好了。

    C++ 解答

123456789101112131415161718192021222324252627282930313233&#96;&#96;&#96;&lt;&#x2F;details&gt;&lt;details&gt;    &lt;summary&gt;Rust 解答&lt;&#x2F;summary&gt;&#96;&#96;&#96;Rustuse std::collections::HashMap;use std::cmp::max;impl Solution {    pub fn total_fruit(tree: Vec&lt;i32&gt;) -&gt; i32 {        let mut i &#x3D; 0;        let mut res &#x3D; 0;        let mut counter &#x3D; HashMap::new();        for (j, el) in tree.iter().enumerate() {            *counter.entry(el).or_insert(0) +&#x3D; 1;            while counter.len() &gt; 2 {                *counter.get_mut(&amp;tree[i]).unwrap() -&#x3D; 1;                if let Some(x) &#x3D; counter.get(&amp;tree[i]) {                    if *x &#x3D;&#x3D; 0 {                        counter.remove(&amp;tree[i]);                    }                }                i +&#x3D; 1;            }            res &#x3D; max(res, j - i + 1);        }        res as i32    }}



986 区间列表的交集tags: #interval

    Python 解答

1234567891011121314class Solution:    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -&gt; List[List[int]]:        i, j &#x3D; 0, 0        ans &#x3D; []        while i &lt; len(A) and j &lt; len(B):            lo &#x3D; max(A[i][0], B[j][0])            hi &#x3D; min(A[i][1], B[j][1])            if lo &lt;&#x3D; hi:                ans.append((lo, hi))            if A[i][1] &lt; B[j][1]:                i +&#x3D; 1            else:                j +&#x3D; 1        return ans



929 唯一邮件地址类似 Gmail 的规则，. 去掉，+ 后面的也去掉。但是要注意域名中的 . 不能去掉

    Python 解答

123456789101112131415class Solution:    def normalize(self, username: str) -&gt; str:        username &#x3D; username.replace(&#39;.&#39;, &quot;&quot;)        # 使用 split 更好，懒得改了        username &#x3D; re.sub(r&quot;\+.*$&quot;, &quot;&quot;, username)        return username    def numUniqueEmails(self, emails: List[str]) -&gt; int:        unique_emails &#x3D; set()        for email in emails:            username, domain &#x3D; email.split(&quot;@&quot;)            username &#x3D; self.normalize(username)            # print(username, domain)            unique_emails.add(f&quot;{username}@{domain}&quot;)        return len(unique_emails)



970 强力数字暴力解法

    python 解答

1234567891011121314import mathclass Solution:    def powerfulIntegers(self, x: int, y: int, bound: int) -&gt; List[int]:        if bound &lt;&#x3D; 0:            return []        ans &#x3D; set()        limit &#x3D; int(math.log2(bound)) + 1        for i in range(limit):            for j in range(limit):                v &#x3D; x ** i + y ** j                if v &lt;&#x3D; bound:                    ans.add(v)        return list(ans)



1272 删除区间
    python 解答

12345678910111213class Solution:    def removeInterval(self, intervals: List[List[int]], toBeRemoved: List[int]) -&gt; List[List[int]]:        lo, hi &#x3D; toBeRemoved        ans &#x3D; []        for x, y in intervals:            if y &lt; lo or x &gt; hi:                ans.append([x, y])            else:                if lo &gt; x:                    ans.append([x, lo])                if hi &lt; y:                    ans.append([hi, y])        return ans



1317 将整数转换为两个无零整数的和
    python 解答

1234567class Solution:    def getNoZeroIntegers(self, n: int) -&gt; List[int]:        for a in range(1, n):            b &#x3D; n - a            if &quot;0&quot; not in str(a) and &quot;0&quot; not in str(b):                return [a, b]        return []



1389 按既定顺序创建目标数组
    Python 解答

123456class Solution:    def createTargetArray(self, nums: List[int], index: List[int]) -&gt; List[int]:        target &#x3D; []        for n, i in zip(nums, index):            target &#x3D; target[:i] + [n] + target[i:]        return target



1390 四因数解释见注释，这道题还是很坑的。不过其实也很简单，四个因数就是能够分解成两个质数乘积或者是立方数。
比如：

21 &#x3D; 3 * 7
8 &#x3D; 2 * 4


    py 解答

123456789101112131415161718192021222324252627282930313233343536class Solution:    def sumFourDivisors(self, nums) -&gt; int:        if not nums:            return 0        if len(nums) &#x3D;&#x3D; 1:            upper &#x3D; nums[0]        else:            upper &#x3D; max(*nums)        # 首先在这里筛选素数        isPrim &#x3D; [True for _ in range(upper)]        i &#x3D; 2        while i * i &lt; upper:            if isPrim[i]:                j &#x3D; i * i                while j &lt; upper:                    isPrim[j] &#x3D; False                    j +&#x3D; i            i +&#x3D; 1        # 把素数都提取出来        prims &#x3D; [i for i in range(2, upper) if isPrim[i]]        ans &#x3D; 0        for num in nums:            for prim in prims:                # 已经不可能了，后续不算了                if prim * prim &gt; num:                    break                # 立方数是符合的，这个比较坑，开始没想到，比如 8                if prim * prim * prim &#x3D;&#x3D; num:                    ans +&#x3D; (1 + num + prim + prim * prim)                    break                # 可以分解成两个质数乘积                if num % prim &#x3D;&#x3D; 0 and isPrim[num &#x2F;&#x2F; prim] and prim * prim !&#x3D; num:                    ans +&#x3D; (1 + num + prim + num &#x2F;&#x2F; prim)                    break        return ans





















</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">



一、编程之美1.2 中国象棋将帅问题123456789struct {    unsigned char a:4;    unsigned char b:4;};for (i.a &#x3D; 1; i.a &lt;&#x3D; 9; i.a++)    for (i.b &#x3D; 1; i.b &lt;&#x3D; 9; i.b++)        if (i.a % 3 !&#x3D; i.b % 3)            printf(&quot;%u:%u&quot;, i.a, i.b);

1.14 连连看1234567891011121314Grid* preClick &#x3D; NULL, * curClick &#x3D; NULL;while(true) {    &#x2F;&#x2F; listen user event    if (点击格子 xy 非空) {        preClick &#x3D; curClick;        curClick.pos &#x3D; x, y;    }    if (preClick &amp;&amp; curClick &amp;&amp; findPath(preClick, curClick)) {        显示路径        消去        preClick &#x3D; curClick &#x3D; NULL;    }}

2.1 - 2.6 LeetCode2.7 最大公约数辗转相除法，如果一个数能够整除x,y，那么他也能够整除x,x%y。
12345int gcd(int x, int y) {    if (y &#x3D;&#x3D; 0)        return x;    return gcd(y, x % y);}

1234567891011121314151617181920&#x2F;&#x2F; iterativeint gcd(int x, int y) {    while (y) {        int t &#x3D; x;        x &#x3D; y        y &#x3D; t % y;    }    return x;}取模运算开销较大，但如下方法在y比较小时，求解次数过多，容易溢出&#96;&#96;&#96;Cint gcd(int x, int y) {    if (x &lt; y)        return gcd(y, x);    if (y &#x3D;&#x3D; 0)        return x;    return gcd(x - y, y);}

12345678910111213141516int gcd(int x, int y) {    if (x &lt; y)        return gcd(y, x);    if (y &#x3D;&#x3D; 0)        return x;    if (x &amp; 0x1 &#x3D;&#x3D; 0)        if (y &amp; 0x1 &#x3D;&#x3D; 0)            return gcd(x&gt;&gt;1, y&gt;&gt;1) &lt;&lt; 1;        else            return gcd(x &gt;&gt;1, y);    else        if (y &amp; 0x1 &#x3D;&#x3D; 0)            return gcd(x, y&gt;&gt;1);        else            return gcd(y, x-y);}




2.8 看下讲解2.9 斐波那契数列使用动态规划(Memoization)的算法不在赘述O(n)。
O(logn)的解法
通项公式
f(n), f(n-1) &#x3D; (f(n-1), f(n-2)) * A

A &#x3D; |1  1|
    |1  0| 

f(n), f(n-1) &#x3D; (f(n-1), f(n-2)) * A &#x3D; ... &#x3D; (f1, f0) * A^(n-1)

下面我们计算A^n-1，太简单了，使用A^(2n) &#x3D; A^n * A^n
12345678910111213141516&#x2F;&#x2F; pesudo codeint fib(int n) {    Matrix factor &#x3D; matrixPow(A, n-1);    return f1*factor + f0*factor;}Matrix matrixPow(Matrix m, int n) {    Matrix result &#x3D; Matrix::Identity;    while (n) {        if (n &amp; 1)            result *&#x3D; m;        m *&#x3D; m;        n &gt;&gt;&#x3D; 1;    }    return result;}

拓展问题，如果是前三项相加的数列呢，依然可以求出转移矩阵
2.11 最近点对问题2.12-2.14 LeetCode 2.15 Cracking 2.16 2.17 LeetCode2.18 数组分割2.19 LeetCode3.1 有时间可以尝试写一下3.2 电话号码对应英文单词递归写法
3.3 Edit Distance3.4 删除链表节点3.5 最短摘要的生成问题转化为，在一个单词词组中，找出包含所有给定单词的最短区间。
1234567891011121314151617181920212223pair&lt;int, int&gt; abstract(vector&lt;string&gt; article, unordered_set&lt;string&gt; keywords) {    int start &#x3D; 0, end &#x3D; 0, range &#x3D; INT_MAX;    unordered_map&lt;string, int&gt; indecies;    unordered_set&lt;string&gt; having;    pair&lt;int, int&gt; result;    while (end &lt; article.size()) {        while (end &lt; article.size() &amp;&amp; !isContain(keywords, having)) {            indecies[articel[end]] &#x3D; end;            end++;        }        while (isContain(keywords, having)) {            if (end - start + 1 &lt; range) {                range &#x3D; end - start + 1;                result.first &#x3D; start;                result.second &#x3D; end;            }            if (indecies[aritcle[start]] &#x3D;&#x3D; start)                having.erase[article[start]];            start++;        }    }    return result;}

3.6 判断两个链表是否相交如果链表中有环呢？
3.7 队列中取最大值使用连个minstack模拟队列
3.8 二叉树中两个节点之间的最远距离显然，对一个根节点，最远距离有两种情况：

左子树或者右子树中的最远距离
左子树最长路径＋有子树最长路径+1

123456789101112131415161718192021typedef struct {    int max_distance;    int max_depth;} result_t;&#x2F;&#x2F; get max distance of two nodes in a treeresult_t get_max(tree_node_t* root) {    result_t result;    if (!root) {        result.max_distance &#x3D; 0;        result.max_depth &#x3D; -1;        return result;    }    result_t left &#x3D; get_max(root-&gt;left);    result_t right &#x3D; get_max(root-&gt;right);    result.max_depth &#x3D; max(left.max_depth, right.max_depth) + 1;    result.max_distance &#x3D; max(max(left.max_distance, right.max_distance), left.max_depth + right.max_depth + 2);    return result;}

对于递归问题，书上的心得：

在递归的实现中，往往假设后续的调用已经完成，在此基础上，才能实现递归的逻辑。
分析清楚递归体的逻辑。
考虑清楚递归退出的边界条件，也就是return的地方。

3.9 重建二叉树拓展问题，如何判断前序遍历和中序遍历是合理的？
测试用例：非完全二叉树，退化的二叉树，满二叉树，普通二叉树，空树。。。
3.10 层序遍历注意把LeetCode上的ZigZag层序都看一遍。
递归的遍历需要先计算level
3.11 注意问题对于询问知识点，要答得正确，有条理。最后写出来的程序已定要是没有严重错误，完整，并尝试用一些测试用例。
4.1 金刚询问李博士
4.2 瓷砖覆盖地板斐波那契额数列
1x2覆盖8x8？从小到大，先找出2x2有多少种，再找出4x4有多少种，再找出8x8有多少种。还有考虑好多种，注意不要有重复pxq覆盖mxn？
4.3  Catalan数4.4 点是否在三角形内部给定 ABC，逆时针顺序，判断 D 是否在 ABC 内部
1234567891011121314&#x2F;&#x2F; 利用面积，如果 D 和 ABC 分别构成的三角形的面积小于 ABC 的面积，那么 D 在三角形内部double area(Point A, Point B, Point, C) {    double a, b, c;    b &#x3D; distance(A, C);    a &#x3D; distance(B, C);    c &#x3D; distance(A, B);    double p &#x3D; (a + b + c) &#x2F; 2;    return sqrt((p-a) * (p-b) * (p-c) * p);}bool isInTriangle(A, B, C, D) {    return area(A, B, D) + area(A, C, D) + area(B, C, D) &lt;&#x3D; area(A, B, C);} 

12345678&#x2F;&#x2F; 根据角度考虑，如果两个向量叉积为正，那么 P3 在P1P2的左边，如果一个点同时在 AB，BC，CA 的左边double cross(Point A, Point B, Point X) {    return (B.x - A.x) * (X.y - A.y) - (X.x - A.x) * (B.y - A.y);}bool isInTriangle(A, B, C, D) {    return cross(A, B, D) &gt;&#x3D; 0 &amp;&amp; cross(B, C, D) &gt;&#x3D; 0 &amp;&amp; cross(C, A, D) &gt;&#x3D; 0;}

4.5 磁带文件存储优化只考虑长度，按照文件长度由短到长存放。只考虑访问频率，按照访问频率由高到低存放。综合考虑，按照频率&#x2F;长度由高到低
4.6 桶中取黑白球相当于使用 XOR，可以解任意问题
4.7 蚂蚁爬杆相当于穿越
4.8 三角形测试用例int isTriangle(int a, int b, int c);

用一个字节编码各种情况。

用不同的位表示不同的结果，注意要正交

测试用例

合法输入，各种三角形的形状，以及不是三角形的，还需要考虑交换不同边的顺序；

非法输入，负数，0，类型错误等等；

边界值，一般程序可能在&lt; &lt;&#x3D; &gt; &gt;&#x3D;上犯错误；

很大的数，很小的数，等等。




一般需要给出15-20个用例
4.10 数字哑谜列出方程，使用深度优先搜索，注意剪枝
4.11 扫雷游戏的概率



二、C&#x2F;C++基本算法考点1.1 确定一个字符串中所有数字是否完全不同首先应该询问面试官字符集的大小，是ASCII还是Unicode还是GBK，对于ASCII和GBK，因为字符集大小有限，而且都不太大，可以使用一个数组统计，而对于Unicode，显然只能使用Hash统计
1234567891011bool isUniqueChars(const string&amp; s) {    if (s.size() &gt; 256) return false;    vector&lt;bool&gt; charSet(256);    for (auto c : s)        if (charSet[s])            return false;        else            charSet[c] &#x3D; true;    return true;}

注意：还可以使用位向量提高效率，但是C++的vector本身就是特质化的。
1.2 实现reverse(char* s)123456789101112void reverse(char* s) {    if (!s) return;    char* end &#x3D; s;    while (*end++) ;    end--; &#x2F;&#x2F; back one    while (s &lt; end) {        char t &#x3D; *s;        *s++ &#x3D; *end;        *end-- &#x3D; t;    }}

1.3 判断两个词是否是变位词(Anagram)1.4 编写一个方法，将字符串中的空格全部替换为%20，假设字符串结尾有足够空间对于数组操作的好多题目，尝试从尾部做起一下子就简单多了。
1234567891011121314151617181920void replaceSpaces(char* s, int len) {    int spaceCount &#x3D; 0, newLength &#x3D; 0;    for (int i &#x3D; 0; i &lt; len; i++)        if (isspace(s[i]))            newLength++;    newLength &#x3D; len + spaceCount * 2;    s[newLength] &#x3D; &#39;\0&#39;;    for (int i &#x3D; len - 1; i &gt;&#x3D; 0; i--) {        if (isspace(s[i])) {            s[--newLength] &#x3D; &#39;0&#39;;            s[--newLength] &#x3D; &#39;2&#39;;            s[--newLength] &#x3D; &#39;%&#39;;        } else {            s[--newLength] &#x3D; s[i];        }    }}

1.5 压缩字符串 aabcccccaaa -&gt; a2b1c5a3如果压缩后变短，返回压缩后的字符串首先要计算出新的长度，然后比较是否变短，如果变短，则执行压缩，否则返回
1.6 给定一幅由N＊N矩阵表示的图像，顺时针旋转90度1.7 若m＊n矩阵中某个元素为0，就把这一行和这一列都清零LeetCode 73 注意同样可以使用位向量提高效率
1.8 给定方法isSubstring()，判断s1是不是可以由s2旋转组成假设s1 &#x3D; xy, s2 &#x3D; yx，yx一定是xyxy的字串，而且是中间部分。注意先判断长度，提高效率
1234567bool isRotation(string&amp; s1, string&amp; s2) {    if (s1.size() !&#x3D; s2.size())        return false;    string s1s1 &#x3D; s1 + s1;    return isSubstring(s1s1, s2);}

2.1 移除未排序列表中的重复节点因为是无序的，所以我们还是需要记录重复节点
123456789101112131415&#x2F;&#x2F; 显然第一个节点是不可能被移除的，所以不用返回新的头部void removeDuplicates(ListNode* head) {    unordered_set&lt;int&gt; vals;    ListNode dummy, *p &#x3D; dummy;    dummy.next &#x3D; head;    while (p-&gt;next) {        if (vals.find(p-&gt;next-&gt;val) !&#x3D; vals.end())            ListNode* next &#x3D; p-&gt;next;            p-&gt;next &#x3D; next-&gt;next;            free(next);        } else {            vals.insert(p-&gt;next-&gt;val);        }    }}

如果不允许使用额外空间，那么这个功能至少需要O(N^2)实现
2.2 实现一个算法，找出链表中倒数第K个元素2.3 删除单向链表中的某个节点，假设你只有访问该节点的权限2.4 以给定的值x分割列表，使得小于x的元素都排在x的前面LeetCode 83
2.5 给定一个链表，每个链表节点存放一位数字，并且是反向存放的，求两个链表的和LeetCode 2
如果是正向存放的呢？
先求出两个列表的长度，然后用零填充一个较短的链表，然后在从前往后相加。
2.6 给定一个有环链表，找到环的开头LeetCode 141 142
2.7 判断链表是否是回文(Palindrome)LeetCode 234
3.1 如何用一个数组实现3个栈如果是实现两个堆栈，可以把两头作为栈底，向中间生长。
解法1: 固定分割，显然这样是不能让面试官满意的。。
解法2: 弹性分割，并把数组看成是环状的！
3.2 设计一个栈，支持min方法，返回栈中的最小值LeetCode 155
3.3 实现SetOfStacks，由多个栈组成这实际上是一道OOD(面向对象设计)的题目
3.4 汉诺塔经典问题了，考虑 n＝2的时候，把上面1块放到中间，然后把下面一块移动完成。那么对于n，我们把n-1块移到中间即可
12345678void moveDisks(int n, tower_t origin, tower_t dest, tower_t buffer) {    if (n &lt;&#x3D; 0) return;    moveDisks(n-1, origin, buffer, dest); &#x2F;&#x2F; 先把上面的n-1块放到中间    moveBottom(origin, dest) &#x2F;&#x2F; 把最底下的盘子直接放过去    moveDisks(n-1, buffer, dest, origin) &#x2F;&#x2F; 把中间的再放到最后}

3.5 使用两个栈模拟一个队列3.6 对栈进行排序，额外的数据只能使用栈使用简单插入排序，在一个新的栈中保存排序好的数据，从unsorted中弹出以后，不断弹出sorted为新元素找到正确位置
12345678910111213stack&lt;int&gt; sortStack(const stack&lt;int&gt;&amp; unsorted) {    stack&lt;int&gt; sorted;    while (!unsorted.empty()) {        int temp &#x3D; unsorted.top(); &#x2F;&#x2F; 待插入的新元素        unsorted.pop();        while (!sorted.empty() &amp;&amp; sorted.top() &gt; temp) { &#x2F;&#x2F; 不断弹出，找到合适位置            int big &#x3D; sorted.top(); sorted.pop();            unsorted.push(big);        }        sorted.push(temp); &#x2F;&#x2F; 插入新元素    }    return sorted;}



4.1 检查二叉树是否平衡: 任意两个节点之间的高度差不超过14.2 给定一个有向图，找出两个节点之间是否存在一条路径
碰到这类问题，有必要和面试官探讨一下DFS和BFS之间的利弊，例如，DFS实现起来比较简单，只需要简单的递归即可。BFS适合用来查找最短路径。而DFS在访问临近借点之前可能会深度便利其中一个临近节点

🌲的遍历一定要注意visited数组或者集合，因为树中可能有几个节点指向同一个节点
123456789101112131415161718bool search(Graph* graph, Node* start, Node* end) {    queue&lt;Node*&gt; q;    unordered_set&lt;Node*&gt; visited;    q.push(start);    while(!q.empty()) {        auto node &#x3D; q.pop();        for (auto adj : q.adjs())            if (visited.find(adj) &#x3D;&#x3D; visited.end())                if (adj &#x3D;&#x3D; end)                   return true;                else                    q.push(adj);    }    return false;}
4.3 给定一个有序数组，元素各不相同且按升序排列，创建一颗高度最小的二叉查找树LeetCode 108
4.4 给定一棵二叉树，创建层序访问的链表LeetCode 102
4.5 检查一棵二叉树是否为二叉查找树LeetCode 98
4.6 找到二叉查找树指定节点的下一个节点(中序后继)，假设每个节点都有指向父节点的指针按照中序遍历，左子树，当前节点，右子树，显然下一个节点应该在右边。也就是右子树中最左边的节点。考虑没有右子树的情况，如果当前节点是左子节点，下一个节点应该是父节点。如果是右节点，我们继续向上，如果到达了root，显然没有更多节点了。
对于树这种可以分情况的最好先把各种情况想好了，在写代码。
12345678910111213141516TreeNode* inorderSucc(TreeNode* n) {    if (!n) return NULL;    if (n-&gt;right) {        TreeNode* right &#x3D; n-&gt;right;        while (right-&gt;left)            right &#x3D; right-&gt;left;        return right;    } else {        TreeNode* q &#x3D; n, * parent &#x3D; q.parent;        while (parent &amp;&amp; parent-&gt;left !&#x3D; q) { &#x2F;&#x2F; 找到当前节点可以作为左子节点的父节点            q &#x3D; parent;            parent &#x3D; parent-&gt;parent;        }        return parent;    }}

4.7 查找二叉树的公共祖先LeetCode 236
4.8 又两棵非常大的二叉树：T1 有几百万个节点，T2，有几百个节点。判断T2是否是T1的子树这道题并没有标准解法。值得和面试官探讨，详见树上的讲解（161页）。
4.9 打印节点数值总和为给定值的路径，路径可以从任意节点开始，任意节点结束对于一个没有见过的问题，可以先简化，然后在推广。假设路径必须从root开始，那很简单。如果路径可以从任意节点开始，那么我们需要向上检查是否得到了相符的总和，而不能假定root是起点
12345678910111213141516171819202122232425void findSum(TreeNode* root, int sum) {    int depth &#x3D; depth(root);    vector&lt;int&gt; path(depth);    findSum(root, sum, path, 0);}void depth(TreeNode* root) {    if (!root) return 0;    return max(depth(root-&gt;left), depth(root-&gt;right)) + 1;}void findSum(TreeNode* root, int sum, vector&lt;int&gt; path, int level) {    if (!root)        return;    path[level] &#x3D; root-&gt;val;    for (int i &#x3D; level, t&#x3D; 0; i &gt;&#x3D; 0; i--) {        t +&#x3D; path[i];        if (t &#x3D;&#x3D; sum)            print(path, i ,level); &#x2F;&#x2F; printing out path from i to level    }    findSum(root-&gt;left, sum, path, level + 1);    findSum(root-&gt;right, sum, path, level + 1);}

5.1 给定一个数n，和另一个数字m，然后给定区间(i, j)，区间保证可以大于m的二进制长度，把m的二进制表示插入到n的区间内示例：n&#x3D;100&#x2F;000&#x2F;00, m &#x3D; 101, i &#x3D; 2, j &#x3D; 4 -&gt; 100&#x2F;101&#x2F;00

把n中对应位置清零
把m移动到对应的位置
合并

12345678910int merge(int n, int m, int i, int j) {    int left_mask &#x3D; ~0 &lt;&lt; (j+1);    int right_mask &#x3D; (1 &lt;&lt; i) - 1    int mask &#x3D; left_mask | right_mask;    n &amp;&#x3D; mask;    m &lt;&lt;&#x3D; i;    return n | m;}

5.2 给定一个0和1之间的实数，打印他的二进制表示，如果32位以内无法表示，打印error我们知道 (0.101)2 &#x3D; 1 * 2^-1 + 0 * 2^-2 + 1 * 2^-3，我们只要让这个数字不断的乘2，然后看它是否大于1，然后就可以得到第一位是不是1了
1234567891011121314151617181920string printBinary(double num) {    if (num &gt;&#x3D; 1 || num &lt;&#x3D; 0)        return &quot;error&quot;;    string result;    result +&#x3D; &quot;.&quot;;    while (num &gt; 0) {        if (result.size() &gt;&#x3D; 32)            return &quot;error&quot;;        num *&#x3D; 2;        if (num &gt;&#x3D; 1) {            result +&#x3D; &quot;1&quot;;            num -&#x3D; 1;        } else {            result +&#x3D; &quot;0&quot;;        }    }    return result;}

5.3 给定一个正整数，找出和其二进制表示中一的数字相同的数字，并且最接近，一共两个我们需要把某个0反转为1，把某个1反转为0。0 -&gt; 1在1-&gt;0 左边，数字变大，在右边数字变小。如果想变大，反转的0需要在1的左边。
把p位置1；把0到p之间请0；在添加ending1 - 1个1。
1234567891011121314int getNext(int n) {    int c &#x3D; n, ending0 &#x3D; 0, ending1 &#x3D; 0;    while ((c &amp; 1 &#x3D;&#x3D; 0) &amp;&amp; c !&#x3D; 0) {        ending0++;        c &gt;&gt;&#x3D; 1;    }    while (c &amp; 1) {        ending1++;        c &gt;&gt;&#x3D; 1;    }    return n + (1 &lt;&lt; ending0) + (1 &lt;&lt; (ending1 - 1)) - 1;}

把位p值0；把位p右边的位值1，再把0到ending0-1置0
12345678910111213int getPrev(int n) {    int c &#x3D; n, ending0 &#x3D; 0, ending1 &#x3D; 0;    while (c &amp; 1) {        ending1++;        c &gt;&gt;&#x3D; 1;    }    if (c &#x3D;&#x3D; 0) return -1;    while ((c &amp; 1) &#x3D;&#x3D; 0 &amp;&amp; c !&#x3D; 0) {        ending0++;        c &gt;&gt;&#x3D; 1;    }    return n - (1 &lt;&lt; ending1) - (1 &lt;&lt; (ending0 - 1)) + 1;}

5.4 解释n &amp; (n-10) &#x3D;&#x3D; 0LeetCode 231
5.5 A和B之间有多少位不相同&#x2F;需要改变多少位，才能把A变成B使用XOR找出不同的位，然后统计1的个位数。需要注意的是不同的题目
12345678int bitSwapRequired(int a, int b) {    int diff &#x3D; a ^ b, count &#x3D; 0;    while (diff) {        diff &amp;&#x3D; diff - 1;        count++;    }    return count;}

5.6 交换一个整数的奇数位和偶数位这道题很有趣，选取特殊的掩码即可
123456&#x2F;&#x2F; 考虑32bit intint32_t swapBits(int32_t x) {    int32_t odd_bits &#x3D; x &amp; 0xAAAAAAAA; &#x2F;&#x2F; 0xAA as 10101010    int32_t even_bits &#x3D; x &amp; 0x55555555; &#x2F;&#x2F; 0x55 as 01010101    return (odd_bits &gt;&gt; 1) | (even_bits &lt;&lt; 1);}

5.8 单色屏幕存贮在一维字节数组中，每个字节存储八个像素，屏幕宽度为w px，绘制从x1到达x2的水平线显然可以逐bit设定，然而这样是拿不到offer的。更好的做法是逐字节设定。
123456789101112131415161718192021222324252627282930313233void drawHorizentalLine(uint8_t * screen, int width, int x1, int x2, int y) {    int start_offset &#x3D; x1 % 8;    int start_full_byte &#x3D; x1 &#x2F; 8; &#x2F;&#x2F; x1 所在字节    if (start_offset !&#x3D; 0)        start_full_byte++;    int end_offset &#x3D; x2 % 8;    int end_full_byte &#x3D; x2 &#x2F; 8; &#x2F;&#x2F; x2 所在字节    if (end_offset !&#x3D; 7)        end_full_byte--;    &#x2F;&#x2F; 逐字节设定    for (int i &#x3D; start_full_byte; i &lt;&#x3D; end_full_byte; i++)        screen[width &#x2F; 8 * y + i] &#x3D; (uint8_t)0xff;    uint8_t start_mask &#x3D; (uint8_t) (0xff &gt;&gt; start_offset);    uint8_t end_mast &#x3D; (uint8_t) ~(0xff &gt;&gt; end_offset + 1);    if ((x1 &#x2F; 8) &#x3D;&#x3D; (x2 &#x2F; 8)) {        uint8_t mask &#x3D; (uint8_t)(start_mask &amp; end_mask);        screen[(width &#x2F; 8) * y + x1 &#x2F; 8] |&#x3D; mask;    } else {        if (start_offset !&#x3D; 0) {            int byte_number &#x3D; (width &#x2F; 8) * y + start_full_byte - 1;            screen[byte_number] |&#x3D; start_mask;        }        if (end_offset !&#x3D; 7) {            int byte_number &#x3D; (width &#x2F; 8) * y + end_full_byte + 1;            screen[byte_number] |&#x3D; end_mask;        }    }



6.1 给定直角坐标系的两条线，确定他们会不会相交我们知道在二维平面上两条线的关系不外乎：平行，相交，重合。问题是两条线重合算不算相交呢，需要问清楚。对于两条线如何表示，这又是面向对象设计的问题，需要讨论。
123456789101112131415161718class Line {private:    static double EPSILON;    double m_slope; &#x2F;&#x2F; 斜率    double m_y_intercept; &#x2F;&#x2F; y轴交点public:    Line(double s, double y): m_slope(s), m_y_intercept(y) {};    &#x2F;&#x2F; 重合视作相交    bool intersect(const Line&amp; other) {        return abs(slope() - other.slope()) &gt; EPSILON || &#x2F;&#x2F; 斜率不同            abs(y_intercept() - other.y_intercept()) &lt; EPSILON; &#x2F;&#x2F; y轴交点相同    }    double slope() {return m_slope;}    double y_intercept() {return m_y_intercept;}};double Line::EPSILON &#x3D; 0.00001;

遇到这类问题，务必：

多问，面试官可能故意模糊问题
仔细设计数据结构，权衡利弊，和面试官讨论
千万不要用＝＝判定浮点数

6.2 只使用加号实现减法和乘除法12345678910111213141516171819202122232425262728293031int neg(int a) {    int result &#x3D; 0;    int d &#x3D; a &lt; 0 ? 1 : -1;    while (a) {        result +&#x3D; d;        a +&#x3D; d;    }    return result;}int abs(int a) {    return a &gt; 0 ? a : neg(a);}int minus(int a, int b) {    return a + neg(b);}int multiply(int a, int b) {    int sign &#x3D; (a &gt; 0) &#x3D;&#x3D; (b &gt; 0) ? 1 : -1;    a &#x3D; abs(a);    b &#x3D; abs(b);    int result &#x3D; 0;    while (b--)        result +&#x3D; a;    return sign &#x3D;&#x3D; 1 ? result : neg(result);}int devide(int a, int b) {    &#x2F;&#x2F; see leetcode}

6.3 找出第k个丑数LeetCode 264
7.1 小孩上楼梯，楼梯有n阶，小孩可以一次上1，2，3步，请问一共有多少种方法 注意如果只能1或2就是斐波那契数列。
123456789&#x2F;&#x2F; 递归int countSteps(int n) {    static vector&lt;int&gt; steps(1000, 1);    if (n &lt; 0)        return 0;    if (n &gt; 1 &amp;&amp; steps[n] &#x3D;&#x3D; 1)        steps[n] &#x3D; countSteps(n -1) + countSteps(n - 2) + countSteps(n - 3);    return steps[n];}

12345678910111213141516171819&#x2F;&#x2F; 迭代int countSteps(int n) {    int n3 &#x3D; 1; &#x2F;&#x2F; starts from n &#x3D; 0    int n2 &#x3D; 1; &#x2F;&#x2F; starts from n &#x3D; 1    int n1 &#x3D; 2; &#x2F;&#x2F; starts from n &#x3D; 2    if (n &lt; 0)        return 0;    if (n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1)        return 1;    int steps &#x3D; 0;    for (int i &#x3D; 3; i &lt;&#x3D; n; i++) {        steps &#x3D; n3 + n2 + n1;        n3 &#x3D; n2;        n2 &#x3D; n1;        n1 &#x3D; steps;    }    return steps;}

8.1 设计一种算法，机器人只能向右向下移动，从(0, 0)移动到(x, y)有几种走法LeetCode 62 63
9.1 在有序数组A[0…n-1]中存在A[i] &#x3D;&#x3D; i，找出该数字。如果存在重复值，又该如何做12345678910111213int magic(int* A, n) {    int left &#x3D; 0; right &#x3D; n - 1;    while (left &lt;&#x3D; right) {        int mid &#x3D; left + (right - left) &#x2F; 2;        if (A[mid] &#x3D;&#x3D; mid)            return mid;        else if (A[mid] &lt; mid)            left &#x3D; mid + 1;        else            right &#x3D; mid - 1;    }    return -1;}

9.2 返回一个集合的所有子集LeetCode 78
9.3 全排列LeetCode
9.4 生成n对括号的全部有效集合LeetCode
9.5 实现填充颜色功能1234567891011121314151617void paintFill(vector&lt;vector&lt;int&gt;&gt; screen, int x, int y, int color) {    if (screen[y][x] &#x3D;&#x3D; color)        return;    paintFill(screen, int x, int y, screen[y][x], int color);}void paintFill(vector&lt;vector&lt;int&gt;&gt; screen, int x, int y, int start, int color) {    if (x &lt; 0 || x &gt;&#x3D; screen[0].size() || y &lt; 0 || y &gt;&#x3D; screen.size())        return;    if (screen[y][x] &#x3D;&#x3D; start) {        screen[y][x] &#x3D;&#x3D; color;        paintFill(screen, int x-1, int y, start, color);        paintFill(screen, x+1, y, start, color);        paintFill(screen, x, y+1, start, color);        paintFill(screen, x, y-1, start, color);    }}

9.6 给定数量不限的硬币，编写代码计算有几种表示方法12345678910111213141516171819vector&lt;int&gt; makeChange(vector&lt;int&gt; coins, int target) {    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; solution(coins.size(), 0)    make(result, coins, solution, 0, target);    return result; }void make(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; coins, vector&lt;int&gt; solution, int start, int target) {    if (target &lt;&#x3D; 0 || start &gt;&#x3D; coins.size()) {        if (target &#x3D;&#x3D; 0)            result.push_back(solution);        return;    }    for (int i &#x3D; 0; i *coins[start] &lt; target ; i++) {        solution[start] &#x3D; i;        make(result, coins, solution, start + 1, target - i * coins[start]);}}

9.7 N-Queen问题LeetCode
9.8 给你一堆箱子，上面的箱子的长宽高要求小于下面的箱子，实现一个方法，搭出最高的箱子10.1 合并两个有序数组LeetCode 88
11.1 对一个字符串数组排序，把变位词(Anagram)放在一起LeetCode 49
11.2 在已经被旋转过的排序数组中，查找元素LeetCode 81
11.3 有一个20GB的文件，每行一个字符串，如何排序20GB暗示无法放入内存中，把文件分块后，分别载入内存中，采用归并排序
12.1 使用 C++ 写个方法，打印输入文件的最后 K 行使用循环数组，容量设为 K，同时记录当前的最早元素
123456789101112131415void printLastKLines(char* filename) {    const int K &#x3D; 10;    ifstream file(filename);    string lines[K];    int size &#x3D; 0;    while (file.good())        getline(file, lines[size++ % K];    int start &#x3D; size &gt; K ? (size % K) : 0;    int count &#x3D; min(K, size);    for (int i &#x3D; 0; i &lt; count; i++)         cout &lt;&lt; lines[(start + i) % K] &lt;&lt; endl;}


12.2 编写malloc_aligned12.3 malloc2d函数，分配二维数组，返回int**可以通过a[i][j]访问，并且尽量少调用malloc前面rows大小的区域用作存储指针，后面存储数据。
hhh|ddddd|ddddd|ddddd

123456789101112131415void** malloc2d(int rows, int cols) {    int header &#x3D; rows * sizeof(void*);    void** ptr &#x3D; (void**)malloc(header + rows * cols);    if (!ptr)        return NULL;    void* buf &#x3D; (void*)(rawptr + rows);    for (int i &#x3D; 0; i &lt; rows; i++)         ptr[i] &#x3D; buf + i * cols;    return ptr;}void free2d(void** ptr) {    void* p &#x3D; void* p;    free(p);}


12.4 不用中间变量，直接交换两个数字想像把 a 和 b 都放在数轴上，假设 a0，b0分别是初值，那么有 diff &#x3D; a - b。我们把diff 保存在 a 中，然后 b &#x3D; b0 + diff 也就是 a0 ，而再另 a &#x3D; b - diff，也就是 b0。
12345void swap(int&amp; a, int&amp; b) {    a &#x3D; a - b;    b &#x3D; b + a;    a &#x3D; b - a;}

更巧妙的是，我们还可以使用异或 XOR 在解。假设 a &#x3D; a0 ^ b0，那么 b &#x3D; a ^ b0 &#x3D; a0 ^ b0 ^ b0 &#x3D; a0，然后 a &#x3D; a ^ b &#x3D; a0 ^ b0 ^ a0 &#x3D; b0。完美解决！值得注意的是，因为使用异或不考虑变量的实际类型，只是粗暴地按 bit 位交换，因此适用于各种类型。不过值得注意的是千万不要用这种方法去交换变量的值，当x&#x3D;&#x3D;y的时候会有灾难性后果。
123456template&lt;typename T&gt;void swap(T&amp; a, T&amp; b) {    a ^&#x3D; b;    b ^&#x3D; a;    a ^&#x3D; b;}




13.1 n! 结尾有多少个零LeetCode 172
13.2 找出两个数字中较大的一个，但不得使用判断语句判断a&gt;b就是判断a-b的正负号，显然我们可以使用bit运算
1234567int flip(int a) { &#x2F;&#x2F; flip last bit    return 1 ^ a;}int sign(int a) {    return flip((a &gt;&gt; 31) &amp; 0x1);}


13.3 把数字转换为英文单词13.4 把数字转换为汉语句子13.5 数组最大序列和LeetCode 53
13.6 给定产生数字概率相同的rand5()，实现一个方法rand7()，要求产生每个数字的概率相同扩大rand5产生随机数的范围，然后对舍去一定范围的数字，对剩下的数字取模，虽然这样会导致调用次数不固定，但实现了效果对于randx，扩大范围的方法是 x * randx() + randx()
1234567int rand7() {    while (1) {        int num &#x3D; 5 * rand5() + rand5();        if (num &lt; 21)            return num % 7;    }}

该问题可以拓展到对于 x &lt; y，由randx() 构造 randy()
13.7 在数组中找到两个数字，是的他们的和为指定的数字LeetCode 1
13.8 把二叉树转化为双向链表先把二叉树变成一个环形链表，然后再从头部解开即可
123456789101112131415161718192021222324252627282930313233343536373839404142434445void concat(struct tree_node* x, struct tree_node* y) {    x-&gt;right &#x3D; y;    y-&gt;left &#x3D; x;}struct tree_node* convert_circular(struct tree_node* root) {    if (!root)        return NULL;    struct tree_node* left &#x3D; convert_circular(root-&gt;left);    struct tree_node* right &#x3D; convert_circular(root-&gt;right);    if (!left &amp;&amp; !right) {        root-&gt;left &#x3D; root;        root-&gt;right &#x3D; root;        return root;    }    struct tree_node* tail_right &#x3D; right ? right-&gt;left : NULL;    &#x2F;&#x2F; 把左边添加到根部    if (!left)        concat(right-&gt;left, root);    else        concat(left-&gt;left, root);    &#x2F;&#x2F; 把右边添加到根部    if (!right)        concat(root, left);    else        concat(root, right);    &#x2F;&#x2F; 把右边和左边链接    if (left &amp;&amp; right)        concat(tail_right, left);    return left ? left : root;}struct tree_node* convert(struct tree_node* root) {    struct tree_node* head &#x3D; convert_circular(root);    head-&gt;left-&gt;right &#x3D; NULL;    head-&gt;left &#x3D; NULL;    return head;}

14.2 实现加法显然是使用位运算。
12345678int add(int a, int b) {    while (b) {        int sum &#x3D; a ^ b;        int carry &#x3D; (a &amp; b) &lt;&lt; 1;        a &#x3D; sum, b &#x3D; carry;    }    return a;}

15.2 完美洗牌，使得一副牌中任意一种排列出现的概率都相等显然全排列是n!个，那么我们保证每一个全排列都可能出现就好了。
123456void shuffle(int* A, int n) {    for (int i &#x3D; 0; i &lt; n; i++) {        int k &#x3D; rand(i);        swap(A[k], A[i]);    }}

16.1 从n个数组中选出m个，要求被选中概率一样1234vector&lt;int&gt; pink_k(vector&lt;int&gt; nums, int k) {    vector&lt;int&gt; result(k);}

16.2 小于 n 的数字中出现2的个数16.3 矩阵链乘法问题16.4 判断是否是合法地出栈序列参考
16.5 二叉树的非递归遍历参考







三、树的遍历树的递归遍历都非常简单，但是非递归遍历有时候不是很简单。一般做题的时候直接写递归版就行了，但是对于三个基础的遍历方法，有时候会要求写迭代版本，基本就是花式用栈就行了。
前序遍历递归版12345class Solution:    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:        if root is None:            return []        return [root.val, *self.preorderTraversal(root.left), *self.preorderTraversal(root.right)]

非递归版使用栈做了一个顺序的反转。
123456789101112131415class Solution:    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:        if not root:            return []        ans &#x3D; []        stack &#x3D; []        stack.append(root)        while stack:            node &#x3D; stack.pop()            ans.append(node.val)            if node.right:                stack.append(node.right)            if node.left:                stack.append(node.left)        return ans

中序遍历递归版12345class Solution:    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:        if root is None:            return []        return [*self.inorderTraversal(root.left), root.val, *self.inorderTraversal(root.right)]

非递归版12345678910111213141516class Solution:    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:        if root is None:            return []        ans &#x3D; []        stack &#x3D; []        node &#x3D; root        while stack or node:            while node:                stack.append(node)                node &#x3D; node.left            left &#x3D; stack.pop()            ans.append(left.val)            if left.right:                node &#x3D; left.right        return ans

后续遍历LeetCode 145
递归版12345class Solution:    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:        if root is None:            return []        return [*self.postorderTraversal(root.left), *self.postorderTraversal(root.right), root.val]

非递归版这个方法还是有点 trick 的，类似于前序遍历，但是把左右子树反过来了，最后再翻转一遍，就变成了后序遍历。
123  1 &#x2F; \2   3

比如：前序遍历是 123, 现在这种遍历方式是 132, 在翻转一次正好是 231, 也就是后续遍历了。
1234567891011121314class Solution:    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:        if root is None:            return []        ans &#x3D; []        stack &#x3D; [root]        while stack:            node &#x3D; stack.pop()            ans.append(node.val)            if node.left:                stack.append(node.left)            if node.right:                stack.append(node.right)        return list(reversed(ans))

参考资料
https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;binary-tree-preorder-traversal&#x2F;solution&#x2F;leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2&#x2F;












四、LeetCode 突击手册一共定义了几个标签，可以通过 Ctrl+F&#x2F;Cmd+F 搜索这些标签还快速浏览相同的题目。
标签：#hash #backtracking #slidewindow #stack #queue #pointers
1 从数组中找出两个数字使得他们的和是给定的数字tags: #hash
使用一个散列，存储数字和他对应的索引。然后遍历数组，如果另一半在散列当中，那么返回这两个数的索引，程序结束；如果不在，把当前数字加入到散列中。

    C++ 解答

1234567891011121314vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {    unordered_map&lt;int, int&gt; hash;    vector&lt;int&gt; result(2);    for (int i &#x3D; 0; i !&#x3D; nums.size(); ++i) {        int reminder &#x3D; target - nums[i];        if (hash.find(reminder) !&#x3D; hash.end()) {            result[0] &#x3D; hash[reminder] + 1;            result[1] &#x3D; i + 1;            return result;        }        hash[nums[i]] &#x3D; i;    }    return result;}





    Python 解答

123456789class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        seen &#x3D; {}        for i, num in enumerate(nums):            if target - num in seen:                return [seen[target-num], i]            else:                seen[num] &#x3D; i        return [-1, -1]





    rust 解答

1234567891011121314use std::collections::HashMap;impl Solution {    pub fn two_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;i32&gt; {        let mut map &#x3D; HashMap::with_capacity(nums.len());        for (idx, num) in nums.iter().enumerate() {            match map.get(&amp;(target - num)) {                None &#x3D;&gt; {map.insert(num, idx);},                Some(sub_idx) &#x3D;&gt; {return vec![*sub_idx as i32, idx as i32]; }            }        }        vec! []    }}





    go 解答

123456789101112func twoSum(nums []int, target int) []int {    m :&#x3D; make(map[int]int)    for index, num :&#x3D; range nums {        last_index, ok :&#x3D; m[num]        if ok {            return []int{last_index, index}        } else {            m[target - num] &#x3D; index        }    }    return []int{-1, -1}}



Follow up: 如果数组是已经排序的呢？

    C++ 解答

12345678910111213sort(nums.begin(), nums.end()) &#x2F;&#x2F; 假设已经排序，只有一个结果pair&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {    int left &#x3D; 0, right &#x3D; nums.size() - 1;    while (left &lt; right) {        int s &#x3D; nums[left] + nums[right];        if (s &#x3D;&#x3D; target)            return make_pair(left, right);        else if (s &lt; sum)            left++;        else            right--;    }}



2 给两个列表，数字在其中按低位到高位存储，求他们的和直接迭代遍历数组，考察细节操作。注意 dummy head 的使用。

    C 解答

12345678910111213141516171819struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {    struct ListNode dummy, *p &#x3D; &amp;dummy;    int carry &#x3D; 0;    &#x2F;&#x2F; 注意最后如果有 carry 的话，需要再生成一个节点    while (l1 || l2 || carry) {        int v1 &#x3D; l1 ? l1-&gt;val: 0;        int v2 &#x3D; l2 ? l2-&gt;val: 0;        int v &#x3D; v1 + v2 + carry;        p-&gt;next &#x3D; malloc(sizeof(struct ListNode));        p &#x3D; p-&gt;next;        p-&gt;val &#x3D; v % 10;        p-&gt;next &#x3D; NULL;        carry &#x3D; v &#x2F; 10;        l1 &#x3D; l1 ? l1-&gt;next: NULL;        l2 &#x3D; l2 ? l2-&gt;next: NULL;    }    return dummy.next;}





    C++ 解答

1234567891011121314151617181920212223242526272829303132333435class Solution {    public:        ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {            if (l1 &#x3D;&#x3D; NULL) return l2;            if (l2 &#x3D;&#x3D; NULL) return l1;            int shift &#x3D; 0;            ListNode* result &#x3D; new ListNode(0);            ListNode* p &#x3D; result;            while (l1 !&#x3D; NULL || l2 !&#x3D; NULL) {                ListNode* newNode &#x3D; new ListNode(0);                int v1 &#x3D; l1 !&#x3D; NULL ? l1-&gt;val : 0;                int v2 &#x3D; l2 !&#x3D; NULL ? l2-&gt;val : 0;                newNode-&gt;val &#x3D; v1 + v2 + shift;                if (newNode-&gt;val &gt; 9) {                    newNode-&gt;val -&#x3D; 10;                    shift &#x3D; 1;                } else {                    shift &#x3D; 0;                }                if (l1) {                    l1 &#x3D; l1-&gt;next;                }                if (l2) {                    l2 &#x3D; l2-&gt;next;                }                p-&gt;next &#x3D; newNode;                p &#x3D; p-&gt;next;            }            &#x2F;&#x2F; 注意最后多余的一个进位处理            if (shift &#x3D;&#x3D; 1) {                p-&gt;next &#x3D; new ListNode(1);            }            return result-&gt;next;        }};





    rust 解答

1234567891011121314151617181920212223242526272829303132impl Solution {    pub fn add_two_numbers(l1: Option&lt;Box&lt;ListNode&gt;&gt;, l2: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {        let (mut l1, mut l2) &#x3D; (l1, l2);        let mut dummy &#x3D; Box&lt;ListNode::new(0)&gt;;        let mut carry &#x3D; 0;        let mut p &#x3D; dummy;        while l1.is_some() || l2.is_some() || carry !&#x3D; 0 {            match l1, l2{                Some(a), Some(b) &#x3D;&gt; {                    let mut v &#x3D; a + b + carry;                    l1 &#x3D; l1.next();                    l2 &#x3D; l2.next();                },                Some(a), None &#x3D;&gt; {                    let mut v &#x3D; a + carry;                    l1 &#x3D; l1.next();                },                None, Some(b) &#x3D;&gt; {                    let mut v &#x3D; b + carry;                    l2 &#x3D; l2.next();                },                None, None &#x3D;&gt; {                }            }            p.next &#x3D; Some(Box&lt;ListNode::new(v)&gt;);            p &#x3D; p.next;            p.val &#x3D; v % 10;            carry &#x3D; v &#x2F; 10;        }        dummy.next    }}





    Python 解答

12345678910111213141516171819202122232425262728293031# Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val &#x3D; x#         self.next &#x3D; Noneclass Solution:    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        dummy &#x3D; ListNode(-1)        p &#x3D; dummy        carry &#x3D; 0        while l1 or l2 or carry:            if l1:                v1 &#x3D; l1.val                l1 &#x3D; l1.next            else:                v1 &#x3D; 0            if l2:                v2 &#x3D; l2.val                l2 &#x3D; l2.next            else:                v2 &#x3D; 0            v &#x3D; v1 + v2 + carry  # 别忘了这里            if v &gt;&#x3D; 10:                carry &#x3D; 1                v -&#x3D; 10            else:                carry &#x3D; 0            p.next &#x3D; ListNode(v)            p &#x3D; p.next        return dummy.next



3 最长不重复子串tags: #slidewindow
滑动窗口解决
注意，当字符有限的时候，比如限定为 ASCII 字符，可以使用一个数组代替 Hash。

    C 解答

1234567891011121314int lengthOfLongestSubstring(char* s) {    int indices[256];    for (int i &#x3D; 0; i &lt; 256; i++)  &#x2F;&#x2F; init the array, memset can only be used for char        indices[i] &#x3D; -1;    int left &#x3D; 0;    int longest &#x3D; 0;    for (int i &#x3D; 0; s[i] !&#x3D; &#39;\0&#39;; i++) {        left &#x3D; max(left, indices[s[i]] + 1);   &#x2F;&#x2F; 考虑新加入字符后对左边界的影响        indices[s[i]] &#x3D; i;                     &#x2F;&#x2F; 更新元素上次出现位置        longest &#x3D; max(longest, i - left + 1);  &#x2F;&#x2F; 应用动态规划    }    return longest;}





    Python 解答

12345678910class Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        last_seen &#x3D; {}        ans &#x3D; 0        lo &#x3D; 0        for i, c in enumerate(s):            lo &#x3D; max(lo, last_seen.get(c, -1) + 1)  # 更新下边界            last_seen[c] &#x3D; i            ans &#x3D; max(ans, i - lo + 1)        return ans




4 找到两个排序数组的中位数解法参见这里
使用两个数字 i 和 j, 分别作为 AB 的分隔元素，把 AB 分成两份，比如A[0..i], B[0..j] 和 A[i, m], B[j, n]，这样我们只需要下面两个条件就可以了：

i+j &#x3D; m-i + n-j, 也就是 i+j &#x3D; (m+n)&#x2F;2
B[j-1] &lt;&#x3D; A[i] &amp;&amp; A[i-1] &lt;&#x3D; B[j],  B 的前一半元素小于 A 的分隔符，A 的前一半元素小于 B 的分隔符

这时候我们就得到了 A[i] 就是我们的中位数，或者之一。 i 的初始值在 0 到 m 之间，然后我们二分搜索 i &#x3D; (imin + imax) &#x2F; 2, j &#x3D; mid - i。

    C 解答

1234567891011121314151617181920212223242526272829303132#define max(a,b) ((a)&gt;(b)?(a):(b))#define min(a,b) ((a)&lt;(b)?(a):(b))double findMedianSortedArrays(int* A, int m, int* B, int n) {    if (m &gt; n) return findMedianSortedArrays(B, n, A, m);    int imin &#x3D; 0, imax &#x3D; m, i, j, num1, mid &#x3D; (m + n + 1) &gt;&gt; 1, num2;    while (imin &lt;&#x3D; imax) {        i &#x3D; (imin + imax) &#x2F;&#x2F; 2;        j &#x3D; mid - i;        if (i &lt; m &amp;&amp; j &gt; 0 &amp;&amp; B[j-1] &gt; A[i]) {  &#x2F;&#x2F; B 中的数字偏大            imin &#x3D; i + 1;        } else if (i &gt; 0 &amp;&amp; j &lt; n &amp;&amp; B[j] &lt; A[i-1]) { &#x2F;&#x2F; A 中的数字偏大            imax &#x3D; i - 1;        } else {            if (i &#x3D;&#x3D; 0)                num1 &#x3D; B[j-1];            else if (j &#x3D;&#x3D; 0)                num1 &#x3D; A[i - 1];            else                num1 &#x3D; max(A[i-1],B[j-1]);  &#x2F;&#x2F; 普通情况            break;        }    }    if ((m + n) &amp; 0x1) &#x2F;&#x2F; odd        return num1;    if (i &#x3D;&#x3D; m)        num2 &#x3D; B[j];    else if (j &#x3D;&#x3D; n)        num2 &#x3D; A[i];    else        num2 &#x3D; min(A[i], B[j]); &#x2F;&#x2F; 普通情况    return (num1 + num2) &#x2F; 2.0; &#x2F;&#x2F; 注意整数除法}



5 最长回文子串
以某个元素为中心，向两边展开，注意处理奇数和偶数两种情况
Manacher 算法，参见这里


    Python 解答

1234567891011121314151617181920class Solution:    def longestPalindrome(self, s: str) -&gt; str:        ans &#x3D; &quot;&quot;        length &#x3D; 0        for i in range(len(s)):            j &#x3D; 0            # 奇数长度回文子串            while i - j &gt;&#x3D; 0 and i + j &lt; len(s) and s[i-j] &#x3D;&#x3D; s[i+j]:                if j * 2 + 1 &gt; length:                    length &#x3D; j * 2 + 1                    ans &#x3D; s[i-j:i+j+1]                j +&#x3D; 1            j &#x3D; 0            # 偶数长度回文子串            while i - j &gt;&#x3D; 0 and i + j + 1 &lt; len(s) and s[i-j] &#x3D;&#x3D; s[i+j+1]:                if j * 2 + 2 &gt; length:                    length &#x3D; j * 2 + 2                    ans &#x3D; s[i-j:i+j+2]                j +&#x3D; 1        return ans





    C 解答

123456789101112131415161718192021222324252627282930313233343536char* longestPalindrome(char* s) {    if (!s) return NULL;    int length &#x3D; 0; &#x2F;&#x2F; length of the longest palindromic string    int start &#x3D; -1; &#x2F;&#x2F; start of the lonest palidromic string    int len &#x3D; strlen(s);    for (int i &#x3D; 0; i &lt; len; i++) {        &#x2F;&#x2F; 奇数长度的回文子串        for (int j &#x3D; 0; (i - j &gt;&#x3D; 0) &amp;&amp; (i + j &lt; len); j++) {            if (s[i - j] !&#x3D; s[i + j])                break;            if (j * 2 + 1 &gt; length) {                length &#x3D; j * 2 + 1;                start &#x3D; i - j;            }        }        &#x2F;&#x2F; 偶数长度的回文子串        for (int j &#x3D; 0; (i - j &gt;&#x3D; 0) &amp;&amp; (i + j + 1 &lt; len); j++) {            if (s[i - j] !&#x3D; s[i + j + 1])                break;            if (j * 2 + 2 &gt; length) {                length &#x3D; j * 2 + 2;                start &#x3D; i - j;            }        }    }    char* result &#x3D; malloc(sizeof(char) * length + 1);    strncpy(result, s + start, length);    result[length] &#x3D; 0;    return result;}



6 ZigZag 字符串，把字符串掰弯，然后再按行输出考察数学，找出规律，所以实际上并不是 Z 子形，而是由 V 组成的，然后组合按行号重构后的字符串即可。

    C 解答

123456789101112131415161718192021&#x2F;&#x2F; 这个方法不容易理解，建议看 Python 的char* convert(char* s, int numRows) {    int len &#x3D; strlen(s);    if (!s || numRows &lt;&#x3D; 1 || len &lt; numRows) return s; &#x2F;&#x2F; no need to convert    char* zigzag &#x3D; malloc(sizeof(char) * (len + 1));    int cur &#x3D; 0;    for (int i &#x3D; 0; i &lt; numRows; i++) {        for (int j &#x3D; i; j &lt; len; j +&#x3D; 2 * (numRows - 1)) { &#x2F;&#x2F; 每个 v 字型长度            zigzag[cur++] &#x3D; s[j];            if (i !&#x3D; 0 &amp;&amp; i !&#x3D; numRows - 1) { &#x2F;&#x2F; 中间行有斜线                int t &#x3D; j + 2 * (numRows - 1) - 2 * i; &#x2F;&#x2F; V 的第二笔                if (t &lt; len)                    zigzag[cur++] &#x3D; s[t];            }        }    }    zigzag[cur] &#x3D; &#39;\0&#39;;    return zigzag;}





    Python 解答

1234567891011121314151617181920212223242526class Solution:    def convert(self, s: str, numRows: int) -&gt; str:        if numRows &lt;&#x3D; 1 or len(s) &lt;&#x3D; numRows:  # 没有这个条件会超时            return s        interval &#x3D; 2 * numRows - 2        ans &#x3D; []        # 第一行        j &#x3D; 0        while j &lt; len(s):            ans.append(s[j])            j +&#x3D; interval        # 中间行        for i in range(1, numRows-1):            j &#x3D; 0            while j &lt; len(s):                if i + j &lt; len(s):                    ans.append(s[i+j])                if interval - i + j &lt; len(s):  # 一定要注意这里的索引                    ans.append(s[interval - i + j])                j +&#x3D; interval        # 最后一行        j &#x3D; numRows - 1        while j &lt; len(s):            ans.append(s[j])            j +&#x3D; interval        return &quot;&quot;.join(ans)



7 翻转数字，溢出返回 0注意溢出

    C 解答

123456789101112int reverse(int x) {    if (x &#x3D;&#x3D; INT_MIN) return 0;    if (x &lt; 0) return -reverse(-x);    long result &#x3D; 0;    while (x) {        result &#x3D; result * 10 + x % 10;        x &#x2F;&#x3D; 10;    }    return result &gt; INT_MAX ? 0 : result;}





    Python 解答

1234567891011class Solution:    def reverse(self, x: int) -&gt; int:        sign &#x3D; 1 if x &gt;&#x3D; 0 else -1        x *&#x3D; sign        y &#x3D; 0        while x &gt; 0:            y &#x3D; y * 10 + x % 10            x &#x2F;&#x2F;&#x3D; 10        if y &gt; 2**31:            return 0        return y * sign



8 实现 atoi这道题考察各种细节，注意各种特殊情况：

首先过滤空格
判定符号，符号只能出现一次
是否溢出，溢出返回 INT_MAX 或者 INT_MIN


    Python 解答

123456789101112131415161718class Solution:    def myAtoi(self, s: str) -&gt; int:        s &#x3D; s.lstrip()        if not s:            return 0        sign &#x3D; 1        ans &#x3D; 0        i &#x3D; 0        if s[i] &#x3D;&#x3D; &quot;-&quot;:            sign &#x3D; -1            i +&#x3D; 1        elif s[i] &#x3D;&#x3D; &quot;+&quot;:            i +&#x3D; 1        while i &lt; len(s) and s[i].isdigit():            ans &#x3D; ans * 10 + ord(s[i]) - ord(&quot;0&quot;)            i +&#x3D; 1        ans *&#x3D; sign        return max(min(ans, 2**31-1), - 2 ** 31)





    C 解答

123456789101112131415161718192021222324252627int myAtoi(char* str) {    if (!str) return 0;    int sign &#x3D; 1;    int result &#x3D; 0;    &#x2F;&#x2F; discarding spaces    while (isspace(*str))        str++;    &#x2F;&#x2F; determining sign    if (*str &#x3D;&#x3D; &#39;-&#39; || *str &#x3D;&#x3D; &#39;+&#39;) {        if (*str &#x3D;&#x3D; &#39;-&#39;) sign &#x3D; -1;        if (*str &#x3D;&#x3D; &#39;+&#39;) sign &#x3D; 1;        str++;    }    &#x2F;&#x2F; constructing integer    while (isdigit(*str)) {        &#x2F;&#x2F; handling overflow        if (result &gt; INT_MAX &#x2F; 10 || result &#x3D;&#x3D; INT_MAX &#x2F; 10 &amp;&amp; *str - &#39;0&#39; &gt; INT_MAX % 10)            return sign &gt; 0 ? INT_MAX : INT_MIN;        result &#x3D; *str - &#39;0&#39; + result * 10;        str++;    }    return result * sign;}



9 是否是回文数字限定不能用额外空间，所以直接把 x 取余得到的数字作为一个反向作为一个新的数字

    Python 解答

123456789101112class Solution:    def isPalindrome(self, x: int) -&gt; bool:        if x &lt; 0:            return False        if x !&#x3D; 0 and x % 10 &#x3D;&#x3D; 0:            return False        y &#x3D; 0        # 回文走到一半就行了，没必要完全翻转过来        while x &gt; y:            y &#x3D; y * 10 + x % 10            x &#x2F;&#x2F;&#x3D; 10        return x &#x3D;&#x3D; y or x &#x3D;&#x3D; y &#x2F;&#x2F; 10






    C 解答

123456789101112bool isPalindrome(int x) {    &#x2F;&#x2F; tricky here, for x &#x3D;&#x3D; k * 10^j    if (x &lt; 0 || x &amp;&amp; (x % 10 &#x3D;&#x3D; 0)) return false;    int y &#x3D; 0;    while (x &gt; y) {        y &#x3D; y * 10 + x % 10;        x &#x2F;&#x3D; 10;    }    return x &#x3D;&#x3D; y || x &#x3D;&#x3D; y &#x2F; 10; &#x2F;&#x2F; 注意 x 可能是奇数长度也可能是偶数}



10 正则表达式实现正则表达式，只需要实现.代表任意字符，*代表任意重复。只需要特殊处理*，如果遇到了*，贪婪地向后匹配。和通配符的不同之处在于，正则表达式需要两个字母组成模式，*是对前一个字母的修饰。

    C 解答

123456789101112131415bool isMatch(char* s, char* p) {    for (char c &#x3D; *p; c !&#x3D; 0; s++, c &#x3D; *p) {        &#x2F;&#x2F; if next char in pattern is not *        if (*(p+1) !&#x3D; &#39;*&#39;)            p++;        &#x2F;&#x2F; if we got an *, check if we can skip &#96;.*&#96; or &#96;x*&#96;        else if (isMatch(s, p + 2))            return true;        &#x2F;&#x2F; s ends or p and s differs        if (*s &#x3D;&#x3D; 0 || c !&#x3D; &#39;.&#39; &amp;&amp; c !&#x3D; *s)            return false;    }    return *s &#x3D;&#x3D; 0;}



11 盛最多水的容器从左右向中间逼近，如果有更大的就更新。简单的一道双指针题目，别想太多。

    C++ 解答

12345678910111213int maxArea(vector&lt;int&gt;&amp; height) {    int left &#x3D; 0, right &#x3D; height.size() - 1;    int result &#x3D; 0;    while (left &lt; right) {        water &#x3D; min(height[left], height[right]) * (right - left)        result &#x3D; max(result, water);        if (height[left] &lt; height[right])            left++;        else            right--;    }    return result;}





    Python 解答

12345678910111213class Solution:    def maxArea(self, height: List[int]) -&gt; int:        lo &#x3D; 0        hi &#x3D; len(height) - 1        ans &#x3D; 0        while lo &lt; hi:            water &#x3D; min(height[lo], height[hi]) * (hi - lo)            ans &#x3D; max(ans, water)            if height[lo] &lt; height[hi]:                lo +&#x3D; 1            else:                hi -&#x3D; 1        return ans




12 十进制转换为罗马数字直接按每位把罗马数字转换出来在拼接就好了，使用 C 的话，拼接字符串很麻烦。

    Python 解答

1234567class Solution:    def intToRoman(self, x: int) -&gt; str:        thousands &#x3D; [&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;]        hundreds &#x3D; [&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;]        tens &#x3D; [&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;]        ones &#x3D; [&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;]        return thousands[x&#x2F;&#x2F;1000] + hundreds[x%1000&#x2F;&#x2F;100] + tens[x%100&#x2F;&#x2F;10] + ones[x%10]






    C++ 解答

12345678string intToRoman(int num) {    &#x2F;&#x2F; note, the leading empty string is the trick here    string thousands[] &#x3D; {&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;};    string handreds[] &#x3D; {&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;};    string tens[] &#x3D; {&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;};    string ones[] &#x3D; {&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;};    return thousands[num &#x2F; 1000] + handreds[num % 1000 &#x2F; 100] + tens[num % 100 &#x2F; 10] + ones[num % 10];}





    C 解答

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475char *intToRoman(int num) {    int digits[4] &#x3D; {0};    char* romans &#x3D; (char*)malloc(sizeof(char));    char* cursor &#x3D; romans;    &#x2F;&#x2F; if num &#x3D; 1234, then    &#x2F;&#x2F; digits &#x3D; {1, 2, 3, 4};    int base &#x3D; 1000;    for (int i &#x3D; 0; i &lt; 4; i++) {        digits[i] &#x3D; num &#x2F; base;        num &#x3D; num % base;        base &#x2F;&#x3D; 10;    }    doRoman(digits[0], &#39;_&#39;, &#39;_&#39;, &#39;M&#39;, &amp;cursor); &#x2F;&#x2F; &#39;_&#39; can be anything    doRoman(digits[1], &#39;M&#39;, &#39;D&#39;, &#39;C&#39;, &amp;cursor);    doRoman(digits[2], &#39;C&#39;, &#39;L&#39;, &#39;X&#39;, &amp;cursor);    doRoman(digits[3], &#39;X&#39;, &#39;V&#39;, &#39;I&#39;, &amp;cursor);    *cursor &#x3D; &#39;\0&#39;;    return romans;}void doRoman(int number, char ten, char five, char one, char** str) {    switch (number) {        case 9:            (*str)[0] &#x3D; one;            (*str)[1] &#x3D; ten;            (*str) +&#x3D; 2;            break;        case 8:            (*str)[0] &#x3D; five;            (*str)[1] &#x3D; one;            (*str)[2] &#x3D; one;            (*str)[3] &#x3D; one;            (*str) +&#x3D; 4;            break;        case 7:            (*str)[0] &#x3D; five;            (*str)[1] &#x3D; one;            (*str)[2] &#x3D; one;            (*str) +&#x3D; 3;            break;        case 6:            (*str)[0] &#x3D; five;            (*str)[1] &#x3D; one;            (*str) +&#x3D; 2;            break;        case 5:            (*str)[0] &#x3D; five;            (*str) +&#x3D; 1;            break;        case 4:            (*str)[0] &#x3D; one;            (*str)[1] &#x3D; five;            (*str) +&#x3D; 2;            break;        case 3:            (*str)[0] &#x3D; one;            (*str)[1] &#x3D; one;            (*str)[2] &#x3D; one;            (*str) +&#x3D; 3;            break;        case 2:            (*str)[0] &#x3D; one;            (*str)[1] &#x3D; one;            (*str) +&#x3D; 2;            break;        case 1:            (*str)[0] &#x3D; one;            (*str) +&#x3D; 1;            break;        case 0:        default:            break;    }}



13 罗马数字转为十进制主要是当前一个数字小于后一个数字的时候，需要添加的是后一个数和前一个数字的差。

    Python 解答

123456789101112131415161718192021class Solution:    def romanToInt(self, s: str) -&gt; int:        vals &#x3D; {            &quot;I&quot;: 1,            &quot;V&quot;: 5,            &quot;X&quot;: 10,            &quot;L&quot;: 50,            &quot;C&quot;: 100,            &quot;D&quot;: 500,            &quot;M&quot;: 1000        }        ans &#x3D; 0        i &#x3D; 0        while i &lt; len(s):            if i+1&lt;len(s) and vals[s[i]] &lt; vals[s[i+1]]:                ans +&#x3D; vals[s[i+1]] - vals[s[i]]                i +&#x3D; 2            else:                ans +&#x3D; vals[s[i]]                i +&#x3D; 1        return ans






    C 解答

1234567891011121314151617181920212223&#x2F;&#x2F; acts like a dict or mapint getVal(char c) {    switch (c) {        case &#39;I&#39;: return 1;        case &#39;V&#39;: return 5;        case &#39;X&#39;: return 10;        case &#39;L&#39;: return 50;        case &#39;C&#39;: return 100;        case &#39;D&#39;: return 500;        case &#39;M&#39;: return 1000;    }}int romanToInt(char* s) {    int result &#x3D; 0;    for (int i &#x3D; 0; s[i] !&#x3D; 0; ) {        if (getVal(s[i]) &lt; getVal(s[i+1]))            result +&#x3D; getVal(s[i+1]) - getVal(s[i]), i +&#x3D; 2;        else            result +&#x3D; getVal(s[i]), i++;    }    return result;}



14 最长公共前缀纵向扫描，从头到尾，如果不一致，返回当前子串即可。

    Python 解答

123456789101112class Solution:    def longestCommonPrefix(self, strs: List[str]) -&gt; str:        if not strs:            return &quot;&quot;        if len(strs) &#x3D;&#x3D; 1:            return strs[0]        minlen &#x3D; min([len(str) for str in strs])        for i in range(minlen):            for j in range(1, len(strs)):                if strs[j][i] !&#x3D; strs[0][i]:                    return strs[0][:i]        return strs[0][:minlen]






    C 解答

12345678910111213141516&#x2F;&#x2F; 纵向扫描char* longestCommonPrefix(char** strs, int strsSize) {    if (!strs || !strs[0]) return &quot;&quot;;    if (strsSize &#x3D;&#x3D; 1) return strs[0];    int len &#x3D; strlen(strs[0]);    for (int i &#x3D; 0; i &lt; len; i++) {        for (int j &#x3D; 1; j &lt; strsSize; j++) {            if (strs[j][i] !&#x3D; strs[0][i]) {                strs[0][i] &#x3D; &#39;\0&#39;;                return strs[0];            }        }    }    return strs[0];}



15 从数组中找出三个数使得他们的和是 0首先把数组排序，然后使用类似 two sum 的方法做就好了。做这种数组题的套路就是实在不行排个序。

    Python 解答

1234567891011121314151617181920212223242526class Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        if len(nums) &lt; 3:            return []        nums.sort()        ans &#x3D; []        for i in range(len(nums)):            if i &gt; 0 and nums[i] &#x3D;&#x3D; nums[i-1]:                continue            k &#x3D; len(nums) - 1            j &#x3D; i + 1            while j &lt; k:                sum &#x3D; nums[i] + nums[j] + nums[k]                if sum &gt; 0:                    k -&#x3D; 1                elif sum &lt; 0:                    j +&#x3D; 1                else:                    ans.append([nums[i], nums[j], nums[k]])                    while j &lt; k and nums[j] &#x3D;&#x3D; nums[j+1]:                        j +&#x3D; 1                    while j &lt; k and nums[k] &#x3D;&#x3D; nums[k-1]:                        k -&#x3D; 1                    j +&#x3D; 1                    k -&#x3D; 1        return ans






    C++ 解答

123456789101112131415161718192021222324252627vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {    sort(nums.begin(), nums.end());    vector&lt;vector&lt;int&gt;&gt; result;    for (int i &#x3D; 0; i &lt; nums.size(); i++) {        if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i-1])            continue;        int k &#x3D; nums.size() - 1;        int j &#x3D; i + 1;        while (j &lt; k) {            if (nums[i] + nums[j] + nums[k] &gt; 0)                k--;            else if (nums[i] + nums[j] + nums[k] &lt; 0)                j++;            else {                result.push_back({nums[i], nums[j], nums[k]});                &#x2F;&#x2F; skipping duplicates                while (j &lt; k &amp;&amp; nums[k] &#x3D;&#x3D; nums[k - 1])                    k--;                while (j &lt; k &amp;&amp; nums[j] &#x3D;&#x3D; nums[j + 1])                    j++;                k--; &#x2F;&#x2F; 别忘了这里，还要继续寻找下一组                j++;            }        }    }    return result;}



16 在数组中找到三个数字使得他们得和尽可能的接近给定数字，假设结果唯一和上一题解法类似，在 http:&#x2F;&#x2F;stackoverflow.com&#x2F;q&#x2F;2070359 有详尽解释

    Python 解答

123456789101112131415161718192021class Solution:    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:        if len(nums) &lt; 3:            return []        nums.sort()        ans &#x3D; nums[0] + nums[1] + nums[2]        for i in range(len(nums)):            j &#x3D; i + 1            k &#x3D; len(nums) - 1            while j &lt; k:                sum &#x3D; nums[i] + nums[j] + nums[k]                if sum &#x3D;&#x3D; target:                    return target                elif abs(target-sum) &lt; abs(target-ans):                    ans &#x3D; sum                else:                    if sum &gt; target:                        k -&#x3D; 1                    else:                        j +&#x3D; 1        return ans







    C 解答

123456789101112131415161718192021222324252627int cmp(int* a, int* b) {    return *a - *b;}int threeSumClosest(int* nums, int numsSize, int target) {    if (numsSize &lt;&#x3D; 3)        return nums[0] + nums[1] + nums[2];    qsort(nums, numsSize, sizeof(int), cmp);    int result &#x3D; nums[0] + nums[1] +nums[2];    for (int i &#x3D; 0; i &lt; numsSize; i++) {        int j &#x3D; i + 1;        int k &#x3D; numsSize - 1;        while (j &lt; k) {            int sum &#x3D; nums[i] + nums[j] + nums[k];            if (sum &#x3D;&#x3D; target)                return target;            if (abs(target - sum) &lt; abs(target - result))                result &#x3D; sum;            if (sum &gt; target)                k--;            else                j++;        }    }    return result;}



17 生成电话键盘按键数字对应的所有可能的字符串，不限制返回结果的顺序tags: #backtracking

递归：
这道题是一道典型的，最简单的深度优先遍历，生成所有可能解的问题。
迭代：
遍历数字，设当前结果为{a, b, c}, 下一个数字是3, 找出对应的字母{d, e, f}, 则新的结果是
1{ a + {def}, b + {def}, c + {def}}

然后把新获得的数组作为下一轮的初始数组。最开始时，使用空数组开始。

    Python 解答

1234567891011121314151617181920212223class Solution:    def letterCombinations(self, digits: str) -&gt; List[str]:        c2n &#x3D; {            &quot;2&quot;: &quot;abc&quot;,            &quot;3&quot;: &quot;def&quot;,            &quot;4&quot;: &quot;ghi&quot;,            &quot;5&quot;: &quot;jkl&quot;,            &quot;6&quot;: &quot;mno&quot;,            &quot;7&quot;: &quot;pqrs&quot;,            &quot;8&quot;: &quot;tuv&quot;,            &quot;9&quot;: &quot;wxyz&quot;        }        def dfs(combination, next_digits):            if not next_digits:                ans.append(combination)                return            for char in c2n[next_digits[0]]:                dfs(combination + char, next_digits[1:])        if not digits:            return []        ans &#x3D; []        dfs(&quot;&quot;, digits)        return ans






    C++ 解答

123456789101112131415161718&#x2F;&#x2F; iterativevector&lt;string&gt; letterCombinations(string digits) {    if (digits.size() &#x3D;&#x3D; 0) return vector&lt;string&gt; {};    string mapping[] &#x3D; {&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};    vector&lt;string&gt; combinations(1, &quot;&quot;); &#x2F;&#x2F; 注意使用空字符串作为种子    for (int i &#x3D; 0; i &lt; digits.size(); i++) {        int digit &#x3D; digits[i] - &#39;0&#39;;        if (mapping[digit].empty())            continue;        vector&lt;string&gt; temp;        for (auto&amp; c : mapping[digit])            for (auto&amp; combination : combinations)                temp.push_back(combination + c);        swap(combinations, temp);    }    return combinations;}



还可以使用深度优先的搜索方法
追问：如何通过用户按的数字来查找是否有对应的单词呢

通过把所有的单词计算出来，然后查询哪个是合法的，查询可以使用 Trie
通过把已经有的单词字典转换为数字字典，然后通过数字序列查询可能的单词组合。

18 4Sumtags: #backtracking
其实可以用 深度优先搜索的方式直接解答 nSum

    Python 解答

123456789101112131415161718192021222324252627282930313233343536373839404142class Solution:    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:        return self.nSum(nums, target, 4)    def nSum(self, nums, target, n):        def dfs(pos: int, cur: List[int], n: int, target: int):            if n &#x3D;&#x3D; 2:                j &#x3D; pos                k &#x3D; len(nums) - 1                while j &lt; k:                    sum &#x3D; nums[j] + nums[k]                    if sum &lt; target:                        j +&#x3D; 1                    elif sum &gt; target:                        k -&#x3D; 1                    else:                        solution &#x3D; cur[:] + [nums[j], nums[k]]                        ans.append(solution)                        while j &lt; k and nums[j] &#x3D;&#x3D; nums[j+1]:                            j +&#x3D; 1                        while j &lt; k and nums[k] &#x3D;&#x3D; nums[k-1]:                            k -&#x3D; 1                        j +&#x3D; 1                        k -&#x3D; 1                return            i &#x3D; pos            while i &lt; len(nums) - n + 1:                # 剪枝的一种情况                if nums[i] * n &gt; target or nums[-1] * n &lt; target:                    break                # 排除重复数字                if i &gt; pos and nums[i] &#x3D;&#x3D; nums[i-1]:                    i +&#x3D; 1                    continue                cur.append(nums[i])                dfs(i+1, cur, n-1, target-nums[i])                cur.pop()                i +&#x3D; 1        ans &#x3D; []        nums.sort()        dfs(0, [], n, target)        return ans




下面的 C++ 解法是一个传统解法

    C++ 解答

12345678910111213141516171819202122232425262728293031323334353637vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {    vector&lt;vector&lt;int&gt;&gt; result;    int n &#x3D; nums.size();    if (n &lt; 4) return result;    sort(nums.begin(), nums.end());    unordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; hash;    for(int i &#x3D; 0; i &lt; n; i++){        for(int j &#x3D; i + 1; j &lt; n; j++){            hash[nums[i]+nums[j]].push_back(make_pair(i,j));        }    }    for (int i &#x3D; 0; i &lt; n; i++) {        if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i-1])            continue;        for (int j &#x3D; i+1; j &lt; n; j++) {            if (j &gt; i + 1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j-1])                continue;            int re &#x3D; target - nums[i] - nums[j];            if (hash.find(re) !&#x3D; hash.end()) {                for (auto match : hash[re]) {                    int k &#x3D; match.first, l &#x3D; match.second;                    if (k &gt; j) {                        if (!result.empty()                            &amp;&amp; result.back()[0] &#x3D;&#x3D; nums[i] &amp;&amp; result.back()[1] &#x3D;&#x3D; nums[j]                            &amp;&amp; result.back()[2] &#x3D;&#x3D; nums[k] &amp;&amp; result.back()[3] &#x3D;&#x3D; nums[l])                        continue;                        result.push_back({nums[i], nums[j], nums[k], nums[l]});                    }                }            }        }    }    return result;}



19 删除链表中倒数第 k 的节点tags: #pointers
双指针经典题目，一个快指针先走 k 步，另一个慢指针再出发，注意链表长度小于 k 时。
注意：LeetCode 给定的 n 都是有效地，但要求返回头指针，如果头指针被删除需要额外注意，因此采用 dummy head

    Python 解答

1234567891011121314class Solution:    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:        dummy &#x3D; ListNode(-1)        dummy.next &#x3D; head        p &#x3D; dummy        while n &gt;&#x3D; 0:            p &#x3D; p.next            n -&#x3D; 1        q &#x3D; dummy        while p:            q &#x3D; q.next            p &#x3D; p.next        q.next &#x3D; q.next.next        return dummy.next





    C 解答

12345678910111213141516struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {    struct ListNode dummy, *fast, *slow;    dummy.next &#x3D; fast &#x3D; head;    slow &#x3D; &amp;dummy;    while (n--)        fast &#x3D; fast-&gt;next;    while (fast) {        fast &#x3D; fast-&gt;next;        slow &#x3D; slow-&gt;next;    }    struct ListNode* next &#x3D; slow-&gt;next;    slow-&gt;next &#x3D; next-&gt;next;    free(next); &#x2F;&#x2F; remeber to free memory    return dummy.next;}




20 判定给定的字符串是否是合法的括号序列，可能包括大中小三类tags: #stack
使用栈的基础题，注意逻辑简化

    Python 解答

123456789101112131415class Solution:    def isValid(self, s: str) -&gt; bool:        valid &#x3D; True        stack &#x3D; []        match &#x3D; {&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;}&quot;: &quot;{&quot;}        for c in s:            if c in (&quot;(&quot;, &quot;[&quot;, &quot;{&quot;):                stack.append(c)            else:                if not stack:                    return False                if stack[-1] !&#x3D; match[c]:                    return False                stack.pop()        return not stack





    C 解答

123456789101112131415161718192021char opposite(char c) {    switch (c) {        case &#39;)&#39; : return &#39;(&#39;;        case &#39;]&#39; : return &#39;[&#39;;        case &#39;}&#39; : return &#39;{&#39;;    }}bool isValid(string s) {    stack&lt;char&gt; stk;    for (auto&amp; c : s) {        if (c &#x3D;&#x3D; &#39;(&#39; || c &#x3D;&#x3D; &#39;[&#39; || c &#x3D;&#x3D; &#39;{&#39;)            stk.push(c);        else if (!stk.empty() &amp;&amp; stk.top() &#x3D;&#x3D; opposite(c))            stk.pop();        else            return false;    }    return stk.empty(); &#x2F;&#x2F; 注意为空的条件}





    Rust 解答

12345678910111213141516impl Solution {    pub fn is_valid(s: String) -&gt; bool {        let mut stack &#x3D; vec![];        &#x2F;&#x2F; let map &#x3D;        for ch in s.chars() {            match ch {                &#39;(&#39; | &#39;{&#39; | &#39;[&#39; &#x3D;&gt; stack.push(ch),                &#39;)&#39; &#x3D;&gt; if let Some(&#39;(&#39;) &#x3D; stack.pop() {} else { return false },                &#39;}&#39; &#x3D;&gt; if let Some(&#39;{&#39;) &#x3D; stack.pop() {} else { return false },                &#39;]&#39; &#x3D;&gt; if let Some(&#39;[&#39;) &#x3D; stack.pop() {} else { return false },                _ &#x3D;&gt; return false            }        }        stack.len() &#x3D;&#x3D; 0    }}



21 合并两个已经排序的链表tags: #pointers
考察链表的基本操作，很简单

    Python 解答

1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val &#x3D; x#         self.next &#x3D; Noneclass Solution:    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        dummy &#x3D; ListNode(-1)        p &#x3D; dummy        while l1 and l2:            if l1.val &lt; l2.val:                p.next &#x3D; l1                l1 &#x3D; l1.next            else:                p.next &#x3D; l2                l2 &#x3D; l2.next            p &#x3D; p.next        if l1:            p.next &#x3D; l1        if l2:            p.next &#x3D; l2        return dummy.next





    C 解答

1234567891011121314151617181920212223242526struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {    if (l1 &#x3D;&#x3D; NULL) return l2;    if (l2 &#x3D;&#x3D; NULL) return l1;    struct ListNode dummy;    dummy.next &#x3D;&#x3D; NULL;    struct ListNode* p &#x3D; &amp;dummy;    while (l1 &amp;&amp; l2) {        if (l1-&gt;val &lt; l2-&gt;val) {            p-&gt;next &#x3D; l1;            l1 &#x3D; l1-&gt;next;        } else {            p-&gt;next &#x3D; l2;            l2 &#x3D; l2-&gt;next;        }        p &#x3D; p-&gt;next;    }    if (l1)        p-&gt;next &#x3D; l1;    if (l2)        p-&gt;next &#x3D; l2;    return dummy.next;}



22 给定数字 n, 生成所有合法的 n 个括号组成的序列tags: #backtracking
一道典型的深度优先搜索题目

    Python 解答

12345678910111213class Solution:    def generateParenthesis(self, n: int) -&gt; List[str]:        def dfs(s, lefts, rights):            if lefts &#x3D;&#x3D; 0 and rights &#x3D;&#x3D; 0:                ans.append(s)                return            if lefts &gt; 0:                dfs(s+&quot;(&quot;, lefts-1, rights)            if (lefts &lt; rights):                dfs(s+&quot;)&quot;, lefts, rights-1)        ans &#x3D; []        dfs(&quot;&quot;, n, n)        return ans





    C++ 解答

1234567891011121314151617vector&lt;string&gt; generateParenthesis(int n) {    vector&lt;string&gt; result;    gen(result, &quot;&quot;, n, n);    return result;}&#x2F;&#x2F; left 剩下的左括号，right 剩下的右括号void gen(vector&lt;string&gt;&amp; result, string s, int left, int right) {    if (left &#x3D;&#x3D; 0 &amp;&amp; right &#x3D;&#x3D; 0) {        result.push_back(s);        return;    }    if (left !&#x3D; 0)        gen(result, s + &#39;(&#39;, left - 1, right);    if (left &lt; right)        gen(result, s + &#39;)&#39;, left, right - 1);}



23 合并 K 个排序的列表使用优先级队列，复杂度最小。

    Python 解答

12345678910111213141516171819202122232425262728293031&#96;&#96;&#96;&lt;&#x2F;details&gt;把列表看做一个队列，每次拿出两个列表，合并他们后放回到列表中，每次遍历列表的一半，这样每次遍历完一遍，列表的长度都会减半，直到列表的长度为 1,  合并函数使用 21 题中的合并两个列表的函数&lt;details&gt;    &lt;summary&gt;C 解答&lt;&#x2F;summary&gt;&#96;&#96;&#96;Cstruct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {    &#x2F;&#x2F; see above}struct ListNode* mergeKLists(struct ListNode** lists, int listsSize) {    if (!lists || listsSize &lt; 1)        return NULL;    while (listsSize &gt; 1) {        &#x2F;&#x2F; listsize is halfed        for (int i &#x3D; 0; i &lt; listsSize &#x2F; 2; i++)            &#x2F;&#x2F; merge i and last i list            lists[i] &#x3D; mergeTwoLists(lists[i], lists[listsSize-1-i]);        listsSize &#x3D; (listsSize + 1) &#x2F; 2; &#x2F;&#x2F; 注意这里！    }    return lists[0];}



24 给定一个链表，交换两个相邻节点的值最简单的做法显然是直接把前后两个节点的值交换，但是 LeetCode 规定不能改变节点的值。主要考察链表的指针操作，注意各种细节，一定要在纸上先把链表画出来。

    Python 解答

123456789101112class Solution:    def swapPairs(self, head: ListNode) -&gt; ListNode:        dummy &#x3D; ListNode(-1)        dummy.next &#x3D; head        p &#x3D; dummy        while p.next and p.next.next:            t &#x3D; p.next            p.next &#x3D; t.next            t.next &#x3D; p.next.next            p.next.next &#x3D; t            p &#x3D; p.next.next        return dummy.next





    C 解答

123456789101112struct ListNode* swapPairs(struct ListNode* head) {    struct ListNode dummy, *temp, *pnext, *p &#x3D; &amp;dummy;    dummy.next &#x3D; head;    while (p-&gt;next &amp;&amp; p-&gt;next-&gt;next) {        temp &#x3D; p-&gt;next;        p-&gt;next &#x3D; temp-&gt;next;        temp-&gt;next &#x3D; p-&gt;next-&gt;next;        p-&gt;next-&gt;next &#x3D; temp;        p &#x3D; temp;    }    return dummy.next;}



25 给定一个链表，把相邻的 k 个节点反转和上题一样，同样禁止改变节点的值。比较简单地解法是浪费一点空间，使用 Stack, 实现逆转 k 个节点，注意如果 k 较大的话，这种方法是不合适的。另一种方法是直接翻转，空间是O(1) 的，但是时间复杂度是 2N。

    Python 解答

1234567891011121314151617181920212223242526272829303132333435class Solution:    def reverseList(self, head):        prev &#x3D; None        curr &#x3D; head        while curr:            next &#x3D; curr.next            curr.next &#x3D; prev            prev &#x3D; curr            curr &#x3D; next        return prev    def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode:        dummy &#x3D; ListNode(-1)        dummy.next &#x3D; head        p &#x3D; dummy        while p.next:            n &#x3D; k            q &#x3D; p            # 找到下一组接点的头            while n &gt; 0 and q.next:                q &#x3D; q.next                n -&#x3D; 1            # 如果节点不够了直接退出            if n &gt; 0:                break            # 把这段链表先截下来            next &#x3D; q.next            q.next &#x3D; None            tail &#x3D; p.next            p.next &#x3D; self.reverseList(p.next)            p &#x3D; tail            p.next &#x3D; next        return dummy.next



使用 Stack 的 C++ 解法

    C++ 解答

12345678910111213141516171819202122232425262728ListNode* reverseKGroup(ListNode* head, int k) {    stack&lt;ListNode*&gt; stk;    ListNode dummy(-1), *p &#x3D; &amp;dummy, *pp;    dummy.next &#x3D; head;    while (1) {        pp &#x3D; p;        for (int i &#x3D; 0; i &lt; k; i++) {            if (pp-&gt;next) {                stk.push(pp-&gt;next);                pp &#x3D; pp-&gt;next;            } else {                break;            }        }        if (stk.size() &lt; k) &#x2F;&#x2F; 剩下的节点不够 k 个了            return dummy.next;        pp &#x3D; stk.top()-&gt;next; &#x2F;&#x2F; 下一组中的第一个        while (!stk.empty()) {            p-&gt;next &#x3D; stk.top();            stk.pop();            p &#x3D; p-&gt;next;        }        p-&gt;next &#x3D; pp;    }}



26 删除排序数组中的重复项tags: #naive
in-place 的删除重复元素，使用两个指针，一个遍历，一个指向当前的结尾。
PS：这个基础题竟然做了半个小时才做对，⊙﹏⊙b 汗，要加强基础啊！
这类数组中去除中间元素的题写的时候还是很容易出错，重点是使用一个 length 变量，然后还是要遍历整个数组。不要想什么双指针了。

    Python 解答

1234567891011class Solution:    def removeDuplicates(self, nums: List[int]) -&gt; int:        if len(nums) &lt; 2:            return len(nums)        length &#x3D; 0        for i in range(len(nums)):            # 处理 i &#x3D;&#x3D; 0 的情况也是需要注意的            if i &#x3D;&#x3D; 0 or nums[i] !&#x3D; nums[length-1]:                nums[length] &#x3D; nums[i]                length +&#x3D; 1        return length





    C 解答

12345678int removeDuplicates(int* nums, int numsSize) {    if (numsSize &lt;&#x3D; 1) return numsSize;    int len &#x3D; 0;    for (int i &#x3D; 0; i &lt; numsSize; i++)        if (i &#x3D;&#x3D; 0 || nums[i] !&#x3D; nums[len - 1])            nums[len++] &#x3D; nums[i];    return len;}



27 删除元素和上一题类似，注意细节

    Python 解答

12345678910class Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        if not nums:            return 0        length &#x3D; 0        for i in range(len(nums)):            if nums[i] !&#x3D; val:                nums[length] &#x3D; nums[i]                length +&#x3D; 1        return length





    C 解答

123456789int removeElement(int* nums, int numsSize, int val) {    if (!nums || numsSize &#x3D;&#x3D; 0) return 0;    int len &#x3D; 0;    for (int i &#x3D; 0; i &lt; numsSize; i++) {        if (nums[i] !&#x3D; val)            nums[len++] &#x3D; nums[i];    }    return len;}



28 实现 strstr 函数，即查找子串使用暴力算法，时间复杂度 O(n)。也可以用 kmp 算法。

    Python 解答

1234567891011121314151617181920212223# kmp 算法class Solution:    def strStr(self, haystack: str, needle: str) -&gt; int:        if not needle:            return 0        next &#x3D; [0]        j &#x3D; 0        # 特别注意这里的 1        for i in range(1, len(needle)):            while j &gt; 0 and needle[i] !&#x3D; needle[j]:                j &#x3D; next[j-1]            if needle[i] &#x3D;&#x3D; needle[j]:                j +&#x3D; 1            next.append(j)        j &#x3D; 0        for i in range(len(haystack)):            while j &gt; 0 and haystack[i] !&#x3D; needle[j]:                j &#x3D; next[j-1]            if haystack[i] &#x3D;&#x3D; needle[j]:                j +&#x3D; 1            if j &#x3D;&#x3D; len(needle):                return i - j + 1        return -1





    C 解答

123456789101112131415161718&#x2F;* * Brute Force *&#x2F;int strStr(char* haystack, char* needle) {    int h &#x3D; strlen(haystack);    int n &#x3D; strlen(needle);    if (n &#x3D;&#x3D; 0) return 0;    &#x2F;&#x2F; note h - n + 1    for (int i &#x3D; 0; i &lt; h - n + 1; i++) {        for (int j &#x3D; 0; j &lt; n; j++) {            if (needle[j] !&#x3D; haystack[i+j])                break;            if (j &#x3D;&#x3D; n - 1)                return i;        }    }    return -1;}




29 给定连个整数，不使用乘法和除法计算除法。这里 有一个非常好的算法
计算可以从被除数中减去除数的次数

    C 解答

12345678910111213141516171819202122int divide(int dividend, int divisor) {    &#x2F;&#x2F; abs(INT_MIN) &#x3D;&#x3D; INT_MAX + 1    if (divisor &#x3D;&#x3D; 0 || (dividend &#x3D;&#x3D; INT_MIN &amp;&amp; divisor &#x3D;&#x3D; -1))        return INT_MAX;    int sign &#x3D; (dividend &gt; 0) &#x3D;&#x3D; (divisor &gt; 0) ? 1 : -1;    long long n &#x3D; labs(dividend);    long long d &#x3D; labs(divisor);    int result &#x3D; 0;    while (n &gt;&#x3D; d) {        long long temp &#x3D; d;        long long multi &#x3D; 1;        while (n &gt;&#x3D; (temp &lt;&lt; 1)) {            temp &lt;&lt;&#x3D; 1;            multi &lt;&lt;&#x3D; 1;        }        n -&#x3D; temp;        result +&#x3D; multi;    }    return sign * result;}



30 包串联所有单词的子串tags: #slidewindow
一道诡异的滑动窗口的题目，对这类问题还是不很熟啊。

    Python 解答

123456789101112131415161718192021222324252627282930313233&#96;&#96;&#96;&lt;&#x2F;details&gt;&lt;details&gt;    &lt;summary&gt;C++ 解答&lt;&#x2F;summary&gt;&#96;&#96;&#96;C++vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {    unordered_map&lt;string, int&gt; counts;    for (string word : words)        counts[word]++;    int n &#x3D; s.length(), num &#x3D; words.size(), len &#x3D; words[0].size();    vector&lt;int&gt; indexes;    for (int i &#x3D; 0; i &lt; n - num * len + 1; i++) {        unordered_map&lt;string, int&gt; seen;        int j &#x3D; 0;        for (; j &lt; num; j++) {            string word &#x3D; s.substr(i + j * len, len);            if (counts.find(word) !&#x3D; counts.end()) {                seen[word]++;                if (seen[word] &gt; counts[word])                    break;            } else {               break;            }        }        if (j &#x3D;&#x3D; num)            indexes.push_back(i);    }    return indexes;}



31 全排列，下一个首先，对于所有的组合，最小的一个一定是按照升序排序的，最大的一定是倒过来，因此

如果我们发现是完全倒序的，直接翻转就好了；
如果是一般情况，从后向前遍历，找到逆序的数字的边界，假设是 k。那么后边这段已经是完全逆序的，无法变小了，为了保证生成的数字变大，我们再从后向前找到第一个比 k 大的数字，交换这两个数字，再把后续的逆序数组翻转。


    Python 解答

1234567891011121314151617181920212223242526272829class Solution:    def nextPermutation(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        # 前后都是闭区间        def reverse(nums, lo, hi):            while lo &lt; hi:                nums[lo], nums[hi] &#x3D; nums[hi], nums[lo]                lo +&#x3D; 1                hi -&#x3D; 1        k &#x3D; -1        for i in range(len(nums)-2, -1, -1):            if nums[i] &lt; nums[i + 1]:                k &#x3D; i                break        if k &#x3D;&#x3D; -1:            reverse(nums, 0, len(nums)-1)            return        l &#x3D; -1        for i in range(len(nums)-1, k, -1):            if nums[i] &gt; nums[k]:                l &#x3D; i                break        nums[l], nums[k] &#x3D; nums[k], nums[l]        reverse(nums, k+1, len(nums)-1)





    C++ 解答

1234567891011121314151617181920212223void nextPermutation(vector&lt;int&gt;&amp; nums) {    int k &#x3D; -1; &#x2F;&#x2F; 升序排列的最后一个数字    for (int i &#x3D; nums.size() - 2; i &gt;&#x3D; 0; i--) {        if (nums[i] &lt; nums[i + 1]) {            k &#x3D; i;            break;        }    }    &#x2F;&#x2F; 完全是逆序的，直接返回第一个，也就是升序排列    if (k &#x3D;&#x3D; -1) {        reverse(nums.begin(), nums.end());        return;    }    int l &#x3D; -1; &#x2F;&#x2F; 逆序数字中比 k 大的最小的数字    for (int i &#x3D; nums.size() - 1; i &gt; k; i--) {        if (nums[i] &gt; nums[k]) {            l &#x3D; i;            break;        }    }    swap(nums[k], nums[l]); &#x2F;&#x2F; 保证变大    reverse(nums.begin() + k + 1, nums.end()); &#x2F;&#x2F; 保证是下一个}



32 从一个括号构成的字符串中找出最长的合法括号序列动态规划的基础题目。

    Python 解答

123456789101112131415161718class Solution:    def longestValidParentheses(self, s: str) -&gt; int:        dp &#x3D; [0] * len(s)        ans &#x3D; 0        for i in range(1, len(s)):            if s[i] &#x3D;&#x3D; &quot;)&quot;:                if s[i-1] &#x3D;&#x3D; &quot;(&quot;:                    if i &gt;&#x3D; 2:                        dp[i] &#x3D; dp[i-2] + 2                    else:                        dp[i] &#x3D; 2                elif i - dp[i-1] &gt; 0 and s[i-dp[i-1]-1] &#x3D;&#x3D; &quot;(&quot;:                    if i - dp[i-1] &gt;&#x3D; 2:                        dp[i] &#x3D; dp[i-1] + dp[i-dp[i-1]-2] + 2                    else:                        dp[i] &#x3D; dp[i-1] + 2                ans &#x3D; max(ans, dp[i])        return ans



也可以使用栈来解。但是这种方法非常 tricky, 因为要考虑到 ()() 的情况。
33 在排序后又被反转的数组中搜索既然是部分有序的，自然还是使用二分搜索了，注意终止条件。不同于普通二分搜索的两种情况，我们有了四种情况：

前半部分有序，并且在前半部分当中，
前半部分有序，但是不在前半部分
后半部分有序，并且在后半部分
后半部分有序，但是不在后半部分


    Python 解答

12345678910111213141516171819202122class Solution:    def search(self, nums: List[int], target: int) -&gt; int:        if not nums:            return -1        lo &#x3D; 0        hi &#x3D; len(nums) - 1        while lo &lt;&#x3D; hi:            mi &#x3D; lo + (hi - lo) &#x2F;&#x2F; 2            if nums[mi] &#x3D;&#x3D; target:                return mi            # 这里为什么要包含等于号呢            if nums[lo] &lt;&#x3D; nums[mi]:                if nums[lo] &lt;&#x3D; target &lt; nums[mi]:                    hi &#x3D; mi - 1                else:                    lo &#x3D; mi + 1            else:                if nums[mi] &lt; target &lt;&#x3D; nums[hi]:                    lo &#x3D; mi + 1                else:                    hi &#x3D; mi - 1        return -1





    C 解答

12345678910111213141516171819202122232425int search(int* nums, int numsSize, int target) {    int left &#x3D; 0, right &#x3D; numsSize - 1;    while (left &lt;&#x3D; right) {        int mid &#x3D; left + (right - left) &#x2F; 2;        if (nums[mid] &#x3D;&#x3D; target)            return mid;        &#x2F;&#x2F; left half is sorted        if (nums[left] &lt;&#x3D; nums[mid]) {            if (nums[left] &lt;&#x3D; target &amp;&amp; target &lt; nums[mid])                right &#x3D; mid - 1;            else                left &#x3D; mid + 1;        &#x2F;&#x2F; right half is sorted        } else {            if (nums[mid] &lt; target &amp;&amp; target &lt;&#x3D; nums[right])                left &#x3D; mid + 1;            else                right &#x3D; mid - 1;        }    }    return -1;}



34 在排序数组中查找元素的第一个和最后一个位置在 C++ 的标准库中包含了这两个函数，分别是std::lower_bound和std::upper_bound.

    C++ 解答

123456789101112131415161718192021222324252627282930class Solution:    def searchRange(self, nums: List[int], target: int) -&gt; List[int]:        if not nums:            return [-1, -1]        lo &#x3D; 0        hi &#x3D; len(nums)        lower &#x3D; -1        while lo &lt; hi:            mi &#x3D; lo + (hi - lo) &#x2F;&#x2F; 2            if nums[mi] &lt; target:                lo &#x3D; mi + 1            else:                hi &#x3D; mi        if lo &lt; len(nums) and nums[lo] &#x3D;&#x3D; target:            lower &#x3D; lo        lo &#x3D; 0        hi &#x3D; len(nums)        upper &#x3D; -1        while lo &lt; hi:            mi &#x3D; lo + (hi - lo) &#x2F;&#x2F; 2            if nums[mi] &lt;&#x3D; target:                lo &#x3D; mi + 1            else:                hi &#x3D; mi        if nums[lo-1] &#x3D;&#x3D; target:            upper &#x3D; lo - 1        return [lower, upper]



35 二分查找数字，如果没有找到，返回应该插入的位置就是最基础的二分查找

    Python 解答

12345678910111213class Solution:    def searchInsert(self, nums: List[int], target: int) -&gt; int:        lo &#x3D; 0        hi &#x3D; len(nums)        while lo &lt; hi:            mi &#x3D; lo + (hi - lo) &#x2F;&#x2F; 2            if nums[mi] &#x3D;&#x3D; target:                return mi            elif nums[mi] &lt; target:                lo &#x3D; mi + 1            else:                hi &#x3D; mi        return lo





    C 解答

12345678910111213int searchInsert(int* nums, int numsSize, int target) {    int left &#x3D; 0, right &#x3D; numsSize - 1;    while (left &lt;&#x3D; right) {        int mid &#x3D; left + (right - left) &#x2F; 2;        if (nums[mid] &#x3D;&#x3D; target)            return mid;        else if (nums[mid] &lt; target)            left &#x3D; mid + 1;        else            right &#x3D; mid - 1;    }    return left;}



36 合法数独，给定一个数独表，判定当前是否合法
    Python 解答

123456789101112131415161718192021class Solution:    def isValidSudoku(self, board: List[List[str]]) -&gt; bool:        &quot;&quot;&quot;        这道题的关键就在于小格子也是可以用 i 和 j 来计算的：        box_index &#x3D; (row &#x2F; 3) * 3 + columns &#x2F; 3        &quot;&quot;&quot;        # 特别注意浅拷贝的问题        used_i &#x3D; [[0] * 9 for _ in range(9)]        used_j &#x3D; [[0] * 9 for _ in range(9)]        used_k &#x3D; [[0] * 9 for _ in range(9)]        for i in range(9):            for j in range(9):                piece &#x3D; board[i][j]                if piece &#x3D;&#x3D; &quot;.&quot;:                    continue                n &#x3D; int(piece) - 1                k &#x3D; i &#x2F;&#x2F; 3 * 3 + j &#x2F;&#x2F; 3                if used_i[i][n] or used_j[j][n] or used_k[k][n]:                    return False                used_i[i][n] &#x3D; used_j[j][n] &#x3D; used_k[k][n] &#x3D; 1        return True





    C 解答

1234567891011121314&#x2F;&#x2F; 有点浪费空间bool isValidSudoku(char** board, int row, int col) {    bool used_row[9][9] &#x3D; {false}, used_col[9][9] &#x3D; {false}, used_box[9][9] &#x3D; {false};    for (int i &#x3D; 0; i &lt; row; i++)        for (int j &#x3D; 0; j &lt; col; j++)            if (board[i][j] !&#x3D; &#39;.&#39;) {                int num &#x3D; board[i][j] - &#39;0&#39; - 1;                int k &#x3D; i &#x2F; 3 * 3 + j &#x2F; 3;                if (used_row[i][num] || used_col[j][num] || used_box[k][num])                    return false;                used_row[i][num] &#x3D; used_col[j][num] &#x3D; used_box[k][num] &#x3D; true;            }    return true;}



37 求解数独
    C++ 解答

12345678910111213141516171819202122232425262728void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {    solve(board, 0);}bool solve(vector&lt;vector&lt;char&gt;&gt;&amp; board, int ind){    if(ind&#x3D;&#x3D;81) return true;    int i&#x3D;ind&#x2F;9, j&#x3D;ind%9;    if(board[i][j]!&#x3D;&#39;.&#39;)        return solve(board, ind+1);    else{        for(char f &#x3D; &#39;1&#39;; f &lt;&#x3D; &#39;9&#39;; f++) {            if(isValidFill(board, i, j, f)) {                board[i][j]&#x3D; f;                if(solve(board, ind+1)) return true;                board[i][j]&#x3D;&#39;.&#39;;            }        }        return false;    }}bool isValidFill(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j, char fill) {    for(int k&#x3D;0; k&lt;9; k++) {        if(board[i][k]&#x3D;&#x3D;fill) return false; &#x2F;&#x2F;check the row        if(board[k][j]&#x3D;&#x3D;fill) return false; &#x2F;&#x2F;check the column        int r&#x3D; i&#x2F;3*3+j&#x2F;3;   &#x2F;&#x2F;select the block        if(board[r&#x2F;3*3+k&#x2F;3][r%3*3+k%3]&#x3D;&#x3D;fill) return false; &#x2F;&#x2F;check the block    }    return true;}



38 数数并说出来不太理解这道题有什么意义，直接暴力做出来了

    C++ 解答

12345678910111213141516string countAndSay(int n) {    string result &#x3D; &quot;1&quot;;    for (int i &#x3D; 0; i &lt; n -1; i++) {        string temp;        for (int j &#x3D; 0; j &lt; result.size(); j++) {            int count &#x3D; 1;            while (j + 1 &lt; result.size() &amp;&amp; result[j+1] &#x3D;&#x3D; result[j]) {                j++; count++;            }            temp +&#x3D; count + &#39;0&#39;;            temp +&#x3D; result[j];        }        result &#x3D; temp;    }    return result;}



39 给定一个集合，在集合中找出和为 target 的数字，数字可以使用多次，集合中没有重复数字典型的深度优先搜索

    C++ 解答

1234567891011121314151617181920vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {    vector&lt;vector&lt;int&gt;&gt; result;    dfs(result, candidates, {}, target);    return result;}void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; candidates, vector&lt;int&gt; comb, int target) {    if (target &#x3D;&#x3D; 0) {        result.push_back(comb);        return;    }    for (auto c : candidates) {        if (c &gt; target) continue; &#x2F;&#x2F; 数字太大了        if (!comb.empty() &amp;&amp; c &lt; comb.back()) continue; &#x2F;&#x2F; 保证不重复且升序        comb.push_back(c);        dfs(result, candidates, comb, target - c);        comb.pop_back(); &#x2F;&#x2F; 注意此处还需要弹出，因为需要循环    }}



40 同上题一样，但是集合中的数字只能使用一次，并且集合中有重复数字
    C++ 解答

1234567891011121314151617181920212223vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {    vector&lt;vector&lt;int&gt;&gt; result;    sort(candidates.begin(), candidates.end());    dfs(result, candidates, {}, target, 0);    return result;}void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; candidates, vector&lt;int&gt; comb, int target, int start) {    if (target &#x3D;&#x3D; 0) {        result.push_back(comb);        return;    }    for (int i &#x3D; start; i &lt; candidates.size(); i++) {        if (candidates[i] &gt; target)            break;        if (i !&#x3D; start &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i-1])            continue;        comb.push_back(candidates[i]);        dfs(result, candidates, comb, target - candidates[i], i + 1);        comb.pop_back();    }}



41 给定一个数组，找到第一个缺失的正数显然，结果的范围是 [1..n+1]. 而数组的长度为 n 我们把每个位置都放上 i+1,这样如果有位置不是 i+1, 则找到了结果，如果都相等则是 n+1.

    c 解答

12345678910111213141516void swap(int* a, int* b) {    int t &#x3D; *a; *a &#x3D; *b; *b &#x3D; t;}int firstMissingPositive(int* nums, int numsSize) {    for (int i &#x3D; 0; i &lt; numsSize; i++)        &#x2F;&#x2F; 注意此处的 while        while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt;&#x3D; numsSize &amp;&amp; nums[i] !&#x3D; nums[nums[i] - 1])            swap(&amp;nums[i], &amp;nums[nums[i] - 1]);    for (int i &#x3D; 0; i &lt; numsSize; i++)        if (nums[i] !&#x3D; i + 1)            return i + 1;    return numsSize + 1;}



42 给定一个数组表示柱子的高度，求能存贮的雨水的总量从两边向中间收拢

    C 解答

1234567891011121314151617181920212223int trap(int* height, int heightSize) {    int left &#x3D; 0, right &#x3D; heightSize - 1;    int water &#x3D; 0;    int max_left &#x3D; 0, max_right &#x3D; 0;    &#x2F;&#x2F; 从两侧向中间缩小，可以算作是两个指针吧    while (left &lt;&#x3D; right) {        if (height[left] &lt;&#x3D; height[right]) {            if (height[left] &gt;&#x3D; max_left)                max_left &#x3D; height[left];            else                water +&#x3D; max_left - height[left];            left++;        } else {            if (height[right] &gt;&#x3D; max_right)                max_right &#x3D; height[right];            else                water +&#x3D; max_right - height[right];            right--;        }    }    return water;}





    Rust 解答

123456789101112131415161718192021222324252627282930313233impl Solution {    pub fn trap(height: Vec&lt;i32&gt;) -&gt; i32 {        if height.is_empty() {            return 0;        }        let mut left &#x3D; 0;        let mut right &#x3D; height.len() - 1;        let mut water &#x3D; 0;        let mut max_left &#x3D; 0;        let mut max_right &#x3D; 0;        while left &lt;&#x3D; right {            if height[left] &lt;&#x3D; height[right] {                if height[left] &gt;&#x3D; max_left {                    max_left &#x3D; height[left];                } else {                    water +&#x3D; max_left - height[left];                }                left +&#x3D; 1;            } else {                if height[right] &gt;&#x3D; max_right {                    max_right &#x3D; height[right];                } else {                    water +&#x3D; max_right - height[right];                }                right -&#x3D; 1;            }        }        water    }}

t

43 给定两个任意长的字符串，返回一个字符串，代表他们相乘的结果按整数除法运算即可，重点是下标的表示

    C 解答

1234567891011121314151617181920212223242526272829#define tonum(c) (c - &#39;0&#39;)#define tochar(i) (i + &#39;0&#39;)char* multiply(char* num1, char* num2) {    &#x2F;&#x2F; 结果的长度不会超过 m+n,    &#x2F;&#x2F; 假设某个数是 n 位的 9, 则结果比另一个数结尾加上 n 个 0 还小    int n &#x3D; strlen(num1), m &#x3D; strlen(num2);    int len &#x3D; m+n;    char* result &#x3D; malloc(sizeof(char) * (len + 1));    for (int i &#x3D; 0; i &lt; len; i++)        result[i] &#x3D; &#39;0&#39;;    result[len] &#x3D; &#39;\0&#39;;    for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) {        int carry &#x3D; 0;        for (int j &#x3D; m - 1; j &gt;&#x3D; 0; j--) {            int v &#x3D; tonum(result[i+j+1]) +  tonum(num1[i]) * tonum(num2[j]) + carry;            result[i+j+1] &#x3D; tochar(v % 10);            carry &#x3D; v &#x2F; 10;        }        result[i] +&#x3D; carry;    }    for (int i &#x3D; 0; i &lt; len; i++)        if (result[i] !&#x3D; &#39;0&#39;)            return result+i;    return &quot;0&quot;;}



44 通配符匹配，? 代表任意一个字符，*代表任意一个或多个字符注意和正则表达式的区别，要求完全匹配。这道题的关键在于对星号的处理，如果出现星号的时候，我们记录当时的 p 和 s 的值，如果发生了不匹配的话，我们尝试回到该位置的下一个位置开始匹配

    C 解答

1234567891011121314151617181920212223bool isMatch(char* s, char* p) {    char* star &#x3D; NULL;    char* revert &#x3D; s;    while (*s) {        if (*s &#x3D;&#x3D; *p || *p &#x3D;&#x3D; &#39;?&#39;)            s++, p++;        else if (*p &#x3D;&#x3D; &#39;*&#39;)            star &#x3D; p++, revert &#x3D; s;        else if (star)            p &#x3D; star + 1, s &#x3D; ++revert;        else            return false;    }    &#x2F;&#x2F; 如果剩下了 p, 那应该全都是*才对    while (*p) {        if (*p++ !&#x3D; &#39;*&#39;)            return false;    }    return true;}



45 跳跃游戏，给定一个数组，每个数字是在该位置可以向前移动的距离，返回最少需要多少次才能到达终点比较简单，看注释吧

    C 解答

123456789101112131415int jump(int* nums, int numsSize) {    int steps &#x3D; 0;    int last &#x3D; 0; &#x2F;&#x2F; last range    int cur &#x3D; 0; &#x2F;&#x2F; current range    for (int i &#x3D; 0; i &lt; numsSize; i++) {        &#x2F;&#x2F; beyond range, make another jump        if (i &gt; last)            last &#x3D; cur, steps++;        &#x2F;&#x2F; if we could reach longer?        if (nums[i] + i &gt; cur)            cur &#x3D; nums[i] + i;    }    return steps;}



46 生成全排列Cracking 上给出了一种解法，通过不断的添加下一个元素到上一组元素的不同位置来生成全排列，这样固然可以，但是大规模的拼接数组或者字符串是很耗费资源的。
在已经有了字符串（或者数组）的初始排列以后，可以通过不断交换的方法生成每一组全排列。比如对于 xyz，我们有全排列为
x + per(yx)
y + per(xz)
z + per(xy)

那么我们通过把每个元素交换到第一个位置，就把问题规模缩小了，知道把问题规模缩小为 1.

    C++ 解答

123456789101112131415161718vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {    vector&lt;vector&lt;int&gt;&gt; result;    per(result, nums, 0);    return result;}void per(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; nums, int begin) {    if (begin &gt;&#x3D; nums.size()) {        result.push_back(nums);        return;    }    for (int i &#x3D; begin; i &lt; nums.size(); i++) { &#x2F;&#x2F; 注意是从 begin 开始，这样未改变的才能加入进来        swap(nums[begin], nums[i]);        per(result, nums, begin + 1);        swap(nums[begin], nums[i]); &#x2F;&#x2F; 注意因为参数中是传引用，这里需要复原    }}





    Rust 解答

12345678910111213141516171819impl Solution {    pub fn permute(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {        let mut result: Vec&lt;Vec&lt;i32&gt;&gt; &#x3D; vec![];        Self::per(&amp;mut result, nums, 0);        result    }    pub fn per(result: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;, nums: Vec&lt;i32&gt;, begin: usize) {        if begin &gt;&#x3D; nums.len() {            result.push(nums);            return        }        for i in begin..nums.len() {            let mut nums &#x3D; nums.clone();            nums.swap(begin, i);            Self::per(result, nums, begin + 1);        }    }}



47 全排列，数组中有重复元素和上一题基本是一样的，注意跳过重复元素就好了

    C++ 解答

1234567891011121314151617181920vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {    sort(nums.begin(), nums.end());    vector&lt;vector&lt;int&gt;&gt; result;    per(result, nums, 0);    return result;}void per(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; nums, int start) {    if (start &gt;&#x3D; nums.size()) {        result.push_back(nums);        return;    }    for (int i &#x3D; start; i &lt; nums.size(); i++) {        if (start !&#x3D; i &amp;&amp; nums[start] &#x3D;&#x3D; nums[i])            continue;        swap(nums[start], nums[i]);        per(result, nums, start + 1); &#x2F;&#x2F; 事实证明，传引用反倒会超时    }}



48 给定一个n*n的图像旋转图像，顺时针旋转 90 度做法显然是从里到外，一层一层的旋转，这道题主要考察下标的操作

    C 解答

123456789101112131415161718void rotate(int** matrix, int m, int n) {    for (int layer &#x3D; 0; layer &lt; n &#x2F; 2; layer++) {        int first  &#x3D; layer;        int last &#x3D; n - 1 - layer;        for (int i &#x3D; first; i &lt; last; i++) {            int offset &#x3D; i - first;            int top &#x3D; matrix[first][i];            &#x2F;&#x2F; up &lt;- left            matrix[first][i] &#x3D; matrix[last-offset][first];            &#x2F;&#x2F; left &lt;- down            matrix[last-offset][first] &#x3D; matrix[last][last-offset];            &#x2F;&#x2F; down &lt;- right            matrix[last][last-offset] &#x3D; matrix[i][last];            &#x2F;&#x2F; right &lt;- up            matrix[i][last] &#x3D; top;        }    }}



49 给定字符数组，把他们按照 Anagram 分组
    C++ 解答

1234567891011121314151617&#x2F;&#x2F; Anagram 分组&#x2F;&#x2F; 这道题没什么可做的，只需要统计vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {    vector&lt;vector&lt;string&gt;&gt; result;    string temp;    unordered_map&lt;string, vector&lt;string&gt;&gt; records;    for (int i &#x3D; 0; i &lt; strs.size(); ++i) {        temp &#x3D; strs[i];        sort(temp.begin(), temp.end());        records[temp].push_back(strs[i]);    }    for (auto&amp; record : records) {        sort(record.second.begin(), record.second.end());        result.push_back(record.second);    }    return result;}



50 实现 pow(x, n)显然不能直接阶乘过去，分治法
递归做法

    C 解答

123456789101112&#x2F;&#x2F; recursivedouble myPow(double x, int n) {    if (n &#x3D;&#x3D; INT_MIN) return myPow(x, n - 1) * x;    if (n &lt; 0) return 1 &#x2F; myPow(x, -n);    if (n &#x3D;&#x3D; 0) return 1;    if (n &#x3D;&#x3D; 1) return x;    double y &#x3D; myPow(x, n &#x2F; 2);    if (n &amp; 0x1)        return y * y * x;    else        return y * y;}



迭代做法

    C 解答

12345678910111213&#x2F;&#x2F; iterativelydouble myPow(double x, long p) {    double result &#x3D; 1;    if (p &lt; 0)         return 1 &#x2F; myPow(x, -p);    while (p) {        if (p &amp; 1)            result *&#x3D; x;        x *&#x3D; x;        p &#x2F;&#x3D; 2;    }    return result;}



51 N 皇后问题需要大幅度修改

    C++ 解答

1234567891011121314151617181920212223242526272829303132333435363738394041&#x2F;&#x2F; N 皇后问题，皇后不能再一条直线，一条竖线，一条斜线上&#x2F;&#x2F; 使用深度优先求解，对于 dfs 问题，我们首先把算法的框架写下来，然后确定这个问题的限制条件&#x2F;&#x2F; 对于这个问题，限制条件当前行的元素不能在以前的列中出现过，也不能在对角线中出现过vector&lt;vector&lt;string&gt;&gt; result;vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {    if (n &lt; 1) return result;    vector&lt;int&gt; x(n);    dfs(0, x, n);    return result;}void dfs(int t, vector&lt;int&gt;&amp; x, int n) {    &#x2F;&#x2F; 当新添加一个 Q 到当前解的时候    if (t &gt;&#x3D; n) {        &#x2F;&#x2F; result.push_back(make_solution(x));        &#x2F;&#x2F; return;        vector&lt;string&gt; solution;        for (int i &#x3D; 0; i &lt; n; i++) {            string line(n, &#39;.&#39;);            line[x[i]] &#x3D; &#39;Q&#39;;            solution.push_back(line);        }        result.push_back(solution);    } else {        for (int i &#x3D; 0; i &lt; n; i++) {            bool skip &#x3D; false;            for (int j &#x3D; 0; j &lt; t; j++) {                if (x[j] &#x3D;&#x3D; i || abs(i - x[j]) &#x3D;&#x3D; abs(t - j)) {                    skip &#x3D; true;                    break;                }            }            if (skip) continue;            x[t] &#x3D; i;            dfs(t+1, x, n);        }    }}



52 N 皇后一共有多少个解不要直接把皇后放好，而是把占用的都记录下来，然后继续深度优先搜索

    C++ 解答

1234567891011121314151617181920212223242526272829class Solution {public:    unordered_set&lt;int&gt; cols, digs1, digs2;    int totalNQueens(int n) {        return total(0, 0, n);    }    int total(int row, int count, int n) {        for (int col &#x3D; 0; col &lt; n; col++) {            if (cols.find(col) !&#x3D; cols.end()                || digs1.find(row - col) !&#x3D; digs1.end()                || digs2.find(row + col) !&#x3D; digs2.end())            continue;            if (row &#x3D;&#x3D; n-1)                count++;            else {                cols.insert(col);                digs1.insert(row-col);                digs2.insert(row+col);                count &#x3D; total(row+1, count, n);                cols.erase(col);                digs1.erase(row-col);                digs2.erase(row+col);            }        }        return count;    }};



53 最大子序列和动态规划经典题目，遍历数组，如果已经当前子序列已经小于 0 了，抛弃并置 sum &#x3D; 0如果比当前和更大，更新。对于一个子序列，要么使得序列和增大，要么减小。
dp[n+1] &#x3D; max(dp[n], dp[n] + A[n+1])

    C 解答

12345678910111213int maxSubArray(int* nums, int numsSize) {    int sum &#x3D; 0;    int m &#x3D; INT_MIN;    for (int i &#x3D;0; i&lt; numsSize; i++) {        sum +&#x3D; nums[i];        if (sum &gt; m)            m &#x3D; sum;        if (sum &lt; 0)            sum &#x3D; 0;    }    return m;}





    Python 解答

123456789class Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        current_sum &#x3D; 0        max_value &#x3D; float(&#39;-inf&#39;)        for i in nums:            current_sum +&#x3D; i            max_value &#x3D; max(max_value, current_sum)            current_sum &#x3D; max(0, current_sum)        return max_value



54 顺时针螺旋打印矩阵一圈一圈地打印就好了

    C 解答

12345678910111213141516171819202122232425int* spiralOrder(int** matrix, int row, int col) {    if (row &#x3D;&#x3D; 0 || col &#x3D;&#x3D; 0) return NULL;    int top &#x3D; 0, right &#x3D; col - 1, down &#x3D; row - 1, left &#x3D; 0;    int index &#x3D; 0;    int* result &#x3D; malloc(sizeof(int) * row * col);    while (top &lt;&#x3D; down &amp;&amp; left &lt;&#x3D; right) {        for (int i &#x3D; left; i &lt;&#x3D; right; i++)            result[index++] &#x3D; matrix[top][i];        top++; &#x2F;&#x2F;        for (int i &#x3D; top; i &lt;&#x3D; down; i++)            result[index++] &#x3D; matrix[i][right];        right--; &#x2F;&#x2F;        &#x2F;&#x2F; 注意这个 if 语句        if (top &lt;&#x3D; down)            for (int i &#x3D; right; i &gt;&#x3D; left; i--)                result[index++] &#x3D; matrix[down][i];        down--; &#x2F;&#x2F;        &#x2F;&#x2F; 注意这个 if 语句        if (left &lt;&#x3D; right)            for (int i &#x3D; down; i &gt;&#x3D; top; i--)                result[index++] &#x3D; matrix[i][left];        left++; &#x2F;&#x2F;    }    return result;}



55 给定一个数组，每个数字表示在当前步可以移动的距离，返回是不是能够到达终点使用动态规划求解，如果当前距离大于最远距离，更新最远距离，如果已经超过了最远距离，跳出

    C 解答

1234567bool canJump(int* nums, int numsSize) {    int i;    int reach &#x3D; 0;    for (i &#x3D; 0; i &lt; numsSize &amp;&amp; i &lt;&#x3D; reach; i++)            reach &#x3D; max(reach, nums[i] + i);    return i &#x3D;&#x3D; numsSize;}



56 合并序列，给定一组序列，把其中重叠的序列合并这道题用 Python 做竟然比用 C++ 还要快

    Python 解答

12345678910111213141516&quot;&quot;&quot;class Interval(object):    def __init__(self, start&#x3D;0, end&#x3D;0):        self.start &#x3D; start        self.end&#x3D; end&quot;&quot;&quot;def merge(intervals):    intervals.sort(key&#x3D;lambda x: x.start)    combined &#x3D; []    for interval in intervals:        if combined and interval.start &lt;&#x3D; combined[-1].end:            combined[-1].end &#x3D; max(combined[-1].end, interval.end)        else:            combined.append(interval)    return combined



57 添加序列，给定一组已经排序的序列，向其中插入一个序列，需要合并的合并把剩余的部分都拷贝过来也不失为一种机智的做法。

    Python 解答

12345678910111213141516171819class Solution:    def insert(self, intervals, newInterval):        ans &#x3D; []        start, end &#x3D; newInterval        remainder &#x3D; 0        for x, y in intervals:            # 未重叠            if start &gt; y:                ans.append([x, y])            # 进入重叠状态            else:                if end &lt; x:  # 当前区间已经不重叠了                    break  # 找到了结尾了                start &#x3D; min(start, x)                end &#x3D; max(end, y)            remainder +&#x3D; 1        ans.append([start, end])        ans +&#x3D; intervals[remainder:]        return ans




58 给定一个字符串，求其中最后一个单词的长度显然这道题可以用 strlen 求出长度然后从后往前数，但是，这样相当于多遍历了一次直接从后往前可以保证只遍历一次

    C 解答

123456789101112131415161718int lengthOfLastWord(char* s) {    int len &#x3D; 0;    bool inWord &#x3D; false;    while (*s) {        if (isspace(*s)) {            inWord &#x3D; false;        } else {            if (!inWord) {                len &#x3D; 1;                inWord &#x3D; true;            } else {                len++;            }        }        s++;    }    return len;}



59 给定 n，把 1, 2, 3 … 螺旋打印到矩阵中和上一个完全一样的思路，只是这次是打印罢了

    C 解答

123456789101112131415161718192021222324252627282930&#x2F;** * Return an array of arrays. * Note: The returned array must be malloced, assume caller calls free(). *&#x2F;int** generateMatrix(int n) {    int** matrix &#x3D; malloc(sizeof(int*) * n);    for (int i &#x3D; 0; i &lt; n; i++)        matrix[i] &#x3D; malloc(sizeof(int) * n);    int top &#x3D; 0, left &#x3D; 0, down &#x3D; n - 1, right &#x3D; n - 1;    int a &#x3D; 1;    while (top &lt;&#x3D; down &amp;&amp; left &lt;&#x3D; right) {        for (int i &#x3D; left; i &lt;&#x3D;right; i++)            matrix[top][i] &#x3D; a++;        top++;        for (int i &#x3D; top; i &lt;&#x3D; down; i++) {            matrix[i][right] &#x3D; a++;        }        right--;        if (top &lt;&#x3D; down)            for (int i &#x3D; right; i &gt;&#x3D; left; i--)                matrix[down][i] &#x3D; a++;        down--;        if (left &lt;&#x3D; right)            for (int i &#x3D; down; i &gt;&#x3D; top; i--)                matrix[i][left] &#x3D; a++;        left++;    }    return matrix;}



60 给定 n 个数字，找出第 k 个 Permutation
    C++ 解答

12345678910111213141516171819202122232425262728293031class Solution {public:    &#x2F;*The logic is as follows:    for n numbers the permutations can be divided to (n-1)! groups,    thus k&#x2F;(n-1)! indicates the index of current number,    and k%(n-1)! denotes remaining sequence (to the right).    We keep doing this until n reaches 0, then we get n numbers permutations that is kth.    *&#x2F;    string getPermutation(int n, int k) {        int f &#x3D; 1;        string s(n, &#39;0&#39;);        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {            f *&#x3D; i;            s[i-1] &#x3D; i + &#39;0&#39;;        }        &#x2F;&#x2F; 给定 n, 一共有 n! 个序列，f &#x3D;&#x3D; n!        k--;        for (int i &#x3D; 0; i &lt; n; i++) {            f &#x2F;&#x3D; n - i; &#x2F;&#x2F; f &#x2F;&#x3D; n, f &#x2F;&#x3D; n - 1 ...            int j &#x3D; i + k &#x2F; f;            char c&#x3D; s[j];            for (;j &gt; i; j--) &#x2F;&#x2F; shift space to put &#96;c&#96;, actually we could use swap                s[j] &#x3D; s[j-1];            s[i] &#x3D; c;            k %&#x3D; f;        }        return s;    }};



61 把列表旋转到倒数第 k 位需要注意的是 k 大于列表长度的情况，这时候需要取余

    C 解答

1234567891011121314151617181920212223242526struct ListNode* rotateRight(struct ListNode* head, int k) {    if (!head || k &lt;&#x3D; 0) return head;    int l &#x3D; 1;    struct ListNode* n &#x3D; head;    while (n-&gt;next) {        n &#x3D; n-&gt;next;        l++;    }    &#x2F;&#x2F; n is now the tail!    if (k &gt;&#x3D; l) k %&#x3D; l;    if (k &#x3D;&#x3D; 0) return head;    struct ListNode dummy, *p &#x3D; &amp;dummy;    dummy.next &#x3D; head;    int i &#x3D; l - k;    while (i--)        p &#x3D; p-&gt;next;    dummy.next &#x3D; p-&gt;next;    p-&gt;next &#x3D; NULL;    n-&gt;next &#x3D; head;    return dummy.next;}



62 给定一个m*n的矩阵，有多少种方法从左上角移动到右下角显然可以使用组合数学直接求出来解，但是容易溢出。而且这是一道经典的动态规划题目，对于每个格子，可以从他的上部或者左面移动过来。

    C++ 解答

1234567int uniquePaths(int m, int n) {    vector&lt;vector&lt;int&gt;&gt; grid(m, vector&lt;int&gt; (n, 1));    for (int i &#x3D; 1; i &lt; m; i++)        for (int j &#x3D; 1; j &lt; n; j++)            grid[i][j] &#x3D; grid[i - 1][j] + grid[i][j - 1];    return grid[m - 1][n - 1];}



63 同上题，区别是在一些位置是有障碍物的经过分析可知，递推关系是一样的，只需要把有障碍格子的到达方法设定为 0。这个主要是实现上的一些技巧，见注释。

    C++ 解答

1234567891011121314int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {    int m &#x3D; obstacleGrid.size(), n &#x3D; obstacleGrid[0].size();    &#x2F;&#x2F; 注意设定长宽均 +1，但是初始化为 0，边界就成了障碍    vector&lt;vector&lt;int&gt;&gt; pathes(m + 1, vector&lt;int&gt; (n + 1, 0));    pathes[0][1] &#x3D; 1; &#x2F;&#x2F; 给定一个入口    for (int i &#x3D; 1; i &lt; m + 1; i++)        for (int j &#x3D; 1; j &lt; n + 1; j++)            &#x2F;&#x2F; 注意此处的偏移            if (obstacleGrid[i-1][j-1] &#x3D;&#x3D; 1)                pathes[i][j] &#x3D; 0;            else                pathes[i][j] &#x3D; pathes[i-1][j] + pathes[i][j-1];    return pathes[m][n];}



64 给定一个m*n矩阵，每个数字代表经过该处的耗费，找出一条耗费最小的路径依然是动态规划

    C++ 解答

123456789101112131415int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {    &#x2F;&#x2F; if modifying the grid is disallowed, copy it    int m &#x3D; grid.size(), n &#x3D; grid[0].size();    for (int i &#x3D; 0; i &lt; m; i++)        for (int j &#x3D; 0; j &lt; n; j++)            if (i &#x3D;&#x3D; 0 &amp;&amp; j &#x3D;&#x3D; 0)                continue;            else if (i &#x3D;&#x3D; 0 &amp;&amp; j !&#x3D; 0)                grid[i][j] +&#x3D; grid[i][j-1];            else if (i !&#x3D; 0 &amp;&amp; j &#x3D;&#x3D; 0)                grid[i][j] +&#x3D; grid[i-1][j];            else                grid[i][j] +&#x3D; min(grid[i-1][j], grid[i][j-1]);    return grid[m-1][n-1];}



65 判定一个字符串是否是合法的数字，包括了正负号，小数点，e等一些例子：
&quot;0&quot; &#x3D;&gt; true
&quot; 0.1 &quot; &#x3D;&gt; true
&quot;abc&quot; &#x3D;&gt; false
&quot;1 a&quot; &#x3D;&gt; false
&quot;2e10&quot; &#x3D;&gt; true

这道题就是细节题，用 C 处理字符串太蛋疼了，直接上 Python 了

    Python 解答

123456789101112131415161718192021222324252627282930313233343536373839404142434445def isNumber(self, s):    BEFORE &#x3D; 0 # before dot    AFTER &#x3D; 1 # after dot    EXP &#x3D; 2 # after e    phase &#x3D; BEFORE    allow_sign &#x3D; True    s &#x3D; s.strip()    if not any([c.isdigit() for c in s]):        return False    if s &#x3D;&#x3D; &#39;&#39; or s[0] &#x3D;&#x3D; &#39;e&#39; or s[-1] &#x3D;&#x3D; &#39;e&#39; or s &#x3D;&#x3D; &#39;.&#39;:        return False    if s[0] &#x3D;&#x3D; &#39;.&#39; and s[1] &#x3D;&#x3D; &#39;e&#39;:        return False    if s[0] &#x3D;&#x3D; &#39;-&#39; and s[1] &#x3D;&#x3D; &#39;e&#39;:        return False    for c in s:        if &#39;0&#39; &lt;&#x3D; c &lt;&#x3D; &#39;9&#39;:            allow_sign &#x3D; False        elif c &#x3D;&#x3D; &#39;.&#39;:            allow_sign &#x3D; False            if phase &#x3D;&#x3D; EXP or phase &#x3D;&#x3D; AFTER:                return False            else:                phase &#x3D; AFTER        elif c &#x3D;&#x3D; &#39;e&#39;:            if phase &#x3D;&#x3D; EXP:                return False            allow_sign &#x3D; True            phase &#x3D; EXP        elif c &#x3D;&#x3D; &#39;-&#39; or c &#x3D;&#x3D; &#39;+&#39;:            if not allow_sign:                return False            allow_sign &#x3D; False        else:            return False    if phase &#x3D;&#x3D; EXP:        return s[-1].isdigit()    return True



66 给定一个字符串代表的数字，返回加 1 后的数字乍一看如果需要进位的话，可能需要拷贝整个数组。实际上并不需要，我们知道只有当数字是 999…999 的时候，才会使得数字的长度 +1 变为 1000…000。

    C++ 解答

1234567891011121314vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) {    int n &#x3D; digits.size();    for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) {        if (digits[i] &#x3D;&#x3D; 9) {            digits[i] &#x3D; 0;        } else {            digits[i]++;            return digits;    }    &#x2F;&#x2F; trick here, we know that the number is 999...999    digits[0] &#x3D; 1;    digits.push_back(0);    return digits;}





    Rust 解答

12345678910111213impl Solution {    pub fn plus_one(mut digits: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {        for i in (0..digits.len()).rev() {            match digits[i] {                9 &#x3D;&gt; digits[i] &#x3D; 0,                _ &#x3D;&gt; {digits[i] +&#x3D; 1; return digits}            }        }        digits[0] &#x3D; 1;        digits.push(0);        digits    }}



67 给定两个字符串代表的二进制数字，返回他们相加的和和上一题一样，按照加法定义做就好了

    C 解答

12345678910111213141516#define tonum(c) (c - &#39;0&#39;)#define tochar(i) (i + &#39;0&#39;)char* addBinary(char* a, char* b) {    int m &#x3D; strlen(a), n &#x3D; strlen(b);    int len &#x3D; (m &gt; n ? m : n) + 1; &#x2F;&#x2F; strlen(c)    char* c &#x3D; malloc(sizeof(char) * len + 1); &#x2F;&#x2F; with ending null    memset(c, &#39;0&#39;, len+1);    c[len] &#x3D; 0;    int carry &#x3D; 0;    for (int i &#x3D; 1; i &lt;&#x3D; len; i++) {         c[len-i] &#x3D; tochar((i &lt;&#x3D; m ? tonum(a[m-i]) : 0) ^ (i &lt;&#x3D; n ? tonum(b[n-i]) : 0) ^ carry);         carry &#x3D; ((i &lt;&#x3D; m ? tonum(a[m-i]) : 0) + (i &lt;&#x3D; n ? tonum(b[n-i]) : 0) + carry) &gt;&gt; 1;    }    return c[0] &#x3D;&#x3D; &#39;0&#39; ? c+1 : c;}



68 文字对齐待研究

    C++ 解答

1234567891011121314151617vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int L) {    vector&lt;string&gt; res;    for(int i &#x3D; 0, k, l; i &lt; words.size(); i +&#x3D; k) {        for(k &#x3D; l &#x3D; 0; i + k &lt; words.size() and l + words[i+k].size() &lt;&#x3D; L - k; k++) {            l +&#x3D; words[i+k].size();        }        string tmp &#x3D; words[i];        for(int j &#x3D; 0; j &lt; k - 1; j++) {            if(i + k &gt;&#x3D; words.size()) tmp +&#x3D; &quot; &quot;;            else tmp +&#x3D; string((L - l) &#x2F; (k - 1) + (j &lt; (L - l) % (k - 1)), &#39; &#39;);            tmp +&#x3D; words[i+j+1];        }        tmp +&#x3D; string(L - tmp.size(), &#39; &#39;);        res.push_back(tmp);    }    return res;}



69 给定整数 x，求 sqrt(x)比较坑的是 LeetCode 要求的是 y*y &lt; x 的最大整数

    C 解答

123456789101112int mySqrt(int x) {    if (x &lt;&#x3D; 1) return x;    const double EPS &#x3D; x * 0.0001;    double y &#x3D; x &#x2F; 2; &#x2F;&#x2F; initial guess    while (fabs(y * y - x) &gt; EPS) {        y &#x3D; (y + x &#x2F; y) &#x2F; 2;    }    long z &#x3D; (long) y;    while (z * z &gt; x) z--;    return z;}



70 爬梯子，一次可以爬一步或者两步，有几种方法爬完梯子斐波那契数列，也可以理解为动态规划

    C 解答

123456int climbStairs(int n) {    int a &#x3D; 1, b &#x3D; 1, t;    for (int i &#x3D; 1; i &lt; n; i++)        t &#x3D; b, b +&#x3D; a, a &#x3D; t;    return b;}



71 简化 Unix 路径，需要处理., .. 和多个斜杠等情况没有什么需要注意的，主要是使用 stringstream 用作 string.split

    C++ 解答

12345678910111213141516171819string simplifyPath(string&amp; path) {    vector&lt;string&gt; dirs;    stringstream ss(path);    string dir;    while (getline(ss, dir, &#39;&#x2F;&#39;)) {        if (dir &#x3D;&#x3D; &quot;.&quot; || dir &#x3D;&#x3D; &quot;&quot;)            continue;        else if (dir &#x3D;&#x3D; &quot;..&quot;) {            if (!dirs.empty())            dirs.pop_back();        } else            dirs.push_back(dir);    }    string result;    for (auto&amp; dir : dirs)        if (!dir.empty())            result +&#x3D; &quot;&#x2F;&quot; + dir;    return result.size() ? result : &quot;&#x2F;&quot;;}



72 编辑距离，允许替换，删除，插入三种操作对于两个字符串比较，往往要使用二维的动态规划。使用 f[i][j] 表示 word1[1..i] 和 word2[1..j] 之间的距离。see here
那么：

相等 f[i][j] &#x3D; f[i-1][j-1];

不相等

替换：f[i][j] &#x3D; f[i-1][j-1] + 1;  都向前一步
添加：f[i][j] &#x3D; f[i][j-1] + 1; word2 向前一步
删除：f[i][j] &#x3D; f[i-1][j] + 1; word1 向前一步



另外使用一维数组表示二维数组还需要了解

    C++ 解答

123456789101112131415161718&#x2F;&#x2F; unoptimized codeint minDistance(string word1, string word2) {    int m &#x3D; word1.length(), n &#x3D; word2.length();    vector&lt;vector&lt;int&gt; &gt; dp(m + 1, vector&lt;int&gt; (n + 1, 0));    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)        dp[i][0] &#x3D; i;    for (int j &#x3D; 1; j &lt;&#x3D; n; j++)        dp[0][j] &#x3D; j;    for (int i &#x3D; 1; i &lt;&#x3D; m; i++) {        for (int j &#x3D; 1; j &lt;&#x3D; n; j++) {            if (word1[i - 1] &#x3D;&#x3D; word2[j - 1])                dp[i][j] &#x3D; dp[i - 1][j - 1];            else dp[i][j] &#x3D; min(dp[i - 1][j - 1] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j] + 1));        }    }    return dp[m][n];}





    C++ 解答

1234567891011121314151617181920&#x2F;&#x2F; optimizedint minDistance(string word1, string word2) {    int m &#x3D; word1.length(), n &#x3D; word2.length();    vector&lt;int&gt; cur(m + 1, 0);    &#x2F;&#x2F; 把剩余的字符删掉的距离    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)        cur[i] &#x3D; i;    for (int j &#x3D; 1; j &lt;&#x3D; n; j++) {        int pre &#x3D; cur[0];        cur[0] &#x3D; j;        for (int i &#x3D; 1; i &lt;&#x3D; m; i++) {            int temp &#x3D; cur[i];            if (word1[i - 1] &#x3D;&#x3D; word2[j - 1])                cur[i] &#x3D; pre;            else cur[i] &#x3D; min(pre + 1, min(cur[i] + 1, cur[i - 1] + 1));            pre &#x3D; temp;        }    }    return cur[m];}





    C++ 解答

12345678910111213141516171819202122&#x2F;&#x2F; recursive code from beauty of programming&#x2F;&#x2F; TLE on LeetCodeint minDistance(string word1, string word2) {    return minDistance(&amp;word1.front(), &amp;word1.back(), &amp;word2.front(), &amp;word2.back())}int minDistance(char* start1, char* end1, char* start2, char* end2) {    if (start1 &gt; end1)        return start2 &gt; end2 ? 0 : end2 - start2 + 1;    if (start2 &gt; end2)        return start1 &gt; end1 ? 0 : end1 - start1 + 1;    if (*start1 &#x3D;&#x3D; *start2)        return minDistance(start1 + 1, end1, start2 + 1, end2);    else {        int t1 &#x3D; minDistance(start1 + 1, end1, start2 + 1, end2);        int t2 &#x3D; minDistance(start1 + 1, end1, start2, end2);        int t3 &#x3D; minDistance(start1, end1, start2 + 1, end2);        return min(t1, min(t2, t3)) + 1;    }}



73 给定一个矩阵，如果某个元素为零，把所在的行和所在的列都设为零一种可以接受的方法是使用 O(m+n) 的空间，记录哪行哪列需要设为零

    C++ 解答

123456789101112131415161718void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {    int m &#x3D; matrix.size();    if (m &#x3D;&#x3D; 0) return;    int n &#x3D; matrix[0].size();    if (n &#x3D;&#x3D; 0) return;    vector&lt;bool&gt; row(m), column(n);    for (int i &#x3D; 0; i &lt; m; ++i)        for (int j &#x3D; 0; j &lt; n; ++j)            if (matrix[i][j] &#x3D;&#x3D; 0)                row[i] &#x3D; true, column[j] &#x3D; true;    for (int i &#x3D; 0; i &lt; m; ++i)        for (int j &#x3D; 0; j &lt; n; ++j)            if (row[i] || column[j])                matrix[i][j] &#x3D; 0;}



74 搜索矩阵，矩阵每行从左到右依次增大，每行都比上一行大当做数组直接二分搜索就可以了

    C++ 解答

12345678910111213bool searchMatrix(int** matrix, int row, int col, int target) {    int left &#x3D; 0, right &#x3D; row * col - 1;    while (left &lt;&#x3D; right) {        int mid &#x3D; left + (right - left) &#x2F; 2;        if (matrix[mid&#x2F;col][mid%col] &lt; target)            left &#x3D; mid + 1;        else if (matrix[mid&#x2F;col][mid%col] &#x3D;&#x3D; target)            return true;        else            right &#x3D; mid - 1;    }    return false;}



75 颜色排序，每个物体有颜色属性，把他们按照 RGB 的顺序排序 (🇳🇱国旗问题）一种方法是简单地 2 pass 解法，遍历一遍计数再输出。另一种方法是把红色往前交换，蓝色往后交换

    C 解答

123456789101112void swap(int* a, int* b) {    int t &#x3D; *a; *a &#x3D; *b; *b &#x3D; t;}void sortColors(int* nums, int numsSize) {    const int RED &#x3D; 0, GREEN &#x3D; 1, BLUE &#x3D; 2;    int reds &#x3D; 0,  blues &#x3D; numsSize - 1;    for (int i &#x3D; 0; i &lt;&#x3D; blues; i++) {        while (nums[i] &#x3D;&#x3D; BLUE &amp;&amp; i &lt; blues) swap(&amp;nums[i], &amp;nums[blues--]);        while (nums[i] &#x3D;&#x3D; RED &amp;&amp; i &gt; reds) swap(&amp;nums[i], &amp;nums[reds++]);    }}



76 跳过
77 给定数字 n 和 k，生成从 n 中取出 k 个数字的所有情况数学上的组合，使用回溯来做，对状态空间进行深度搜索。
回溯方法通常适合对状态空间树的深度优先搜索相结合的，当一个解已经不满足条件时，剪枝；如果满足条件，直到找到完全解未知。

    C++ 解答

123456789101112131415161718192021222324&#x2F;&#x2F; 组合是不要求顺序的vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {    vector&lt;vector&lt;int&gt;&gt; result;    if (n &lt; k)        return result;    vector&lt;int&gt; temp(0, k);    combine(result, temp, 0, 0, n, k);    return result;}void combine(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; temp, int start, int count, int n, int k) {    &#x2F;&#x2F; 1. 回溯条件，找到了一个解    if (count &#x3D;&#x3D; k) {        result.push_back(temp);        return;    }    &#x2F;&#x2F; 2. 深度优先搜索    for (int i &#x3D; start; i &lt; n; i++) {        temp.push_back(i + 1);        &#x2F;&#x2F; 只搜索比 i 大的即可        combine(result, temp, i+ 1, count+1, n, k);        temp.pop_back();    }}



78 给定一个集合，找到它的所有子集这道题至少有 3 种解法：

DFS，我们知道对于 n 个元素的集合，有 2^n 个子集，通过每个元素在不在子集中构造一个状态空间树
类似于电话键盘生成字母，迭代
巧妙的利用 1..2^n 对应


    C++ 解答

1234567891011121314151617181920212223&#x2F;&#x2F; use backtracking and do a dfs searchvector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {    vector&lt;vector&lt;int&gt;&gt; result;    if (nums.empty()) return result;    sort(nums.begin(), nums.end());    vector&lt;int&gt; temp;    subsets(nums, result, temp, 0);    return result;}&#x2F;&#x2F; for each solution, the can be divided into two sub solutions: in or outvoid subsets(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; temp, int i) {    if (i &#x3D;&#x3D; nums.size()) {        result.push_back(temp);        return;    }    vector&lt;int&gt; t &#x3D; temp;    subsets(nums, result, temp, i + 1);    temp.push_back(nums[i]);    subsets(nums, result, temp, i + 1);}





    C++ 解答

123456789101112131415161718&#x2F;&#x2F; iterativevector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {    vector&lt;vector&lt;int&gt;&gt; result;    result.push_back({});    if (nums.empty())        return result;    result.push_back(vector&lt;int&gt;(1, nums[0]));    for (int i &#x3D; 1; i &lt; nums.size(); i++) {        int size &#x3D; result.size(); &#x2F;&#x2F; notice the cached size        for (int j &#x3D; 0; j &lt; size; j++) {            auto new_subset &#x3D; result[j];            new_subset.push_back(nums[i]);            sort(new_subset.begin(), new_subset.end());            result.push_back(new_subset);        }    }    return result;}





    C++ 解答

1234567891011121314151617&#x2F;&#x2F; trickyvector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {    vector&lt;vector&lt;int&gt;&gt; result;    int size &#x3D; (1 &lt;&lt; nums.size());    for (int i &#x3D; 0; i &lt; size; i++) {        vector&lt;int&gt; subset;        int k &#x3D; i;        for (int j &#x3D; 0; j &lt; nums.size(); j++) {            if (k &amp; 0x1)                subset.push_back(nums[j]);            k &gt;&gt;&#x3D; 1;        }        sort(subset.begin(), subset.end());        result.push_back(subset);    }    return result;}



79 给定一个二维字符数组，查找一个单词是否能够有连续的字母构成，不能交叉也是深度优先的做法，首先找到开始的字母，然后依次向上下左右查找，注意还需要统计有没有访问过

    C++ 解答

123456789101112131415161718192021222324252627282930313233bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {    int row &#x3D; board.size();    int col &#x3D; board[0].size();    vector&lt;vector&lt;bool&gt;&gt; visited(row, vector&lt;bool&gt; (col, false));    bool found &#x3D; false;    for (int i &#x3D; 0; i &lt; row; i++) {        for (int j &#x3D; 0; j &lt; col; j++) {            if (board[i][j] &#x3D;&#x3D; word[0]) {                if (findNext(board, word, visited, i, j, 0))                    found &#x3D; true;            }        }    }    return found;}bool findNext(vector&lt;vector&lt;char&gt;&gt;&amp; board, string&amp; word, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int m, int n, int i) {    if (i &#x3D;&#x3D; word.size())        return true;    if (m &gt;&#x3D; board.size() || n &gt;&#x3D; board[0].size() || m &lt; 0 || n &lt; 0|| visited[m][n] || board[m][n] !&#x3D; word[i])        return false;    char temp &#x3D; board[m][n];    board[m][n] &#x3D; -1;    bool exist &#x3D; findNext(board, word, visited, m + 1, n, i+1) ||        findNext(board, word, visited, m - 1, n, i+1) ||        findNext(board, word, visited, m, n+1, i+1) ||        findNext(board, word, visited, m, n-1, i+1);    board[m][n] &#x3D; temp;    return exist;}



80 从排序数组中删除重复元素，但是允许一个元素重复出现两次巧妙地解法，和i-2的元素对比

    C 解答

123456789int removeDuplicates(int* nums, int numsSize) {    if (!nums || numsSize &lt; 1) return 0;    int len &#x3D; 0, counter &#x3D; 0;    for (int i &#x3D; 0; i &lt; numsSize; i++) {        if (len &lt; 2 || nums[i] !&#x3D; nums[len-2])            nums[len++] &#x3D; nums[i];    }    return len;}



81 在被翻转的数组中查找元素，可能包含重复元素经典题目，还是一个二分查找问题，只是要分很多种情况

    C 解答

12345678910111213141516171819202122bool search(int A[], int n, int key) {    int left &#x3D; 0, right &#x3D; n - 1;    while (left &lt;&#x3D; right) {        int mid &#x3D; left + (right - left)&#x2F;2;        if (A[mid] &#x3D;&#x3D; key)            return true; &#x2F;&#x2F;return m in Search in Rotated Array I        if (A[left] &lt; A[mid]) { &#x2F;&#x2F;left half is sorted            if (A[left] &lt;&#x3D; key &amp;&amp; key &lt; A[mid])                right &#x3D; mid - 1;            else                left &#x3D; mid + 1;        } else if (A[left] &gt; A[mid]) { &#x2F;&#x2F;right half is sorted            if (A[mid] &lt; key &amp;&amp; key &lt;&#x3D; A[right])                left &#x3D; mid + 1;            else                right &#x3D; mid - 1;        } else { &#x2F;&#x2F; A[left] &#x3D;&#x3D; A[mid]            left++;        }    }    return false;}



82 从已经排序的链表中删除所有重复过的元素，只留下只出现一次的元素考察链表操作

    C 解答

1234567891011121314151617struct ListNode* deleteDuplicates(struct ListNode* head) {    struct ListNode dummy, *p &#x3D; &amp;dummy;    dummy.next &#x3D; head;    while (p &amp;&amp; p-&gt;next &amp;&amp; p-&gt;next-&gt;next) {        if (p-&gt;next-&gt;val &#x3D;&#x3D; p-&gt;next-&gt;next-&gt;val) {            struct ListNode* distinct &#x3D; p-&gt;next;            int dup &#x3D; p-&gt;next-&gt;val;            while (distinct &amp;&amp; distinct-&gt;val &#x3D;&#x3D; dup) {                distinct &#x3D; distinct-&gt;next; &#x2F;&#x2F; TODO: fix mem leak            }            p-&gt;next &#x3D; distinct;        } else {            p&#x3D;p-&gt;next;        }    }    return dummy.next;}



83 从已经排序的链表中删除所有重复过的元素，但是重复过的也留下一个，即，使新链表不重复同样是考察链表基本操作

    C 解答

123456789101112struct ListNode* deleteDuplicates(struct ListNode* head) {    struct ListNode dummy, *p &#x3D; &amp;dummy; dummy.next &#x3D; head; dummy.val &#x3D; head-&gt;val + 1;    while (p &amp;&amp; p-&gt;next) {        if (p-&gt;val &#x3D;&#x3D; p-&gt;next-&gt;val) {            int dup &#x3D; p-&gt;val;            while (p-&gt;next &amp;&amp; p-&gt;next-&gt;val &#x3D;&#x3D; dup)                p-&gt;next &#x3D; p-&gt;next-&gt;next; &#x2F;&#x2F; TODO: fix mem leak        } else            p &#x3D; p-&gt;next;    }    return dummy.next;}



84 在柱状图中查找最大的矩形见注释

    C++ 解答

123456789101112131415161718int largestRectangleArea(vector&lt;int&gt;&amp; height) {    stack&lt;int&gt; stk;    height.push_back(0); &#x2F;&#x2F; dummy end    int result  &#x3D;0;    &#x2F;&#x2F; 总结，对于需要查找上一次最大元素的问题，可以考虑使用栈存储    for (int i &#x3D; 0; i &lt; height.size(); ) {        &#x2F;&#x2F; 当遇到更高的柱子时候，先存入堆栈        if (stk.empty() || height[i] &gt; height[stk.top()]) &#x2F;&#x2F; meet higher            stk.push(i++);        &#x2F;&#x2F; 当遇到低一些的柱子时候，计算这些柱子到上一个更矮的柱子之间的最大举行，如果已经清空，说明之前所有柱子都更低        else { &#x2F;&#x2F; lower            int h &#x3D; stk.top();            stk.pop();            result &#x3D; max(result, height[h] * (stk.empty() ? i : i - stk.top() -1));        }    }    return result;}



85 最大的长方形
    C 解答

12345678910111213141516171819202122232425262728293031323334353637int max(int a, int b) {    return a &gt; b ? a : b;}int min(int a, int b) {    return a &lt; b ? a : b;}int maximalRectangle(char** matrix, int row, int col) {    if (!matrix) return 0;    int left[col], right[col], height[col];    for (int i &#x3D; 0; i &lt; col; i++)        left[i] &#x3D; 0, right[i] &#x3D; col, height[i] &#x3D; 0;    int area &#x3D; 0;    for (int i &#x3D; 0; i &lt; row; i++) {        int cur_left &#x3D; 0, cur_right &#x3D; col;        for (int j &#x3D; 0; j &lt; col; j++)            if (matrix[i][j] &#x3D;&#x3D; &#39;1&#39;)  &#x2F;&#x2F; 在第 j 列的高度                height[j]++;            else                height[j] &#x3D; 0;        for (int j &#x3D; 0; j &lt; col; j++)            if (matrix[i][j] &#x3D;&#x3D; &#39;1&#39;)                left[j] &#x3D; max(left[j], cur_left);            else                left[j] &#x3D; 0, cur_left &#x3D; j + 1;        for (int j &#x3D; col - 1; j &gt;&#x3D; 0; j--)            if (matrix[i][j] &#x3D;&#x3D; &#39;1&#39;)                right[j] &#x3D; min(right[j], cur_right);            else                right[j] &#x3D; col, cur_right &#x3D; j;        for (int j &#x3D; 0; j &lt; col; j++)            area &#x3D; max(area, (right[j] - left[j]) * height[j]);    }    return area;}



86 链表分区，要求把小于某个值得元素全都放到前面对于链表这道题很简单，分两个列表在合并就好了，问题是当我们处理类似的数组问题时，也有一种巧妙地 O(n) 的解法

    C 解答

12345678910111213141516171819struct ListNode* partition(struct ListNode* head, int x) {    struct ListNode small, *psmall &#x3D; &amp;small; &#x2F;&#x2F; double dummy head    struct ListNode big, *pbig &#x3D; &amp;big;    psmall-&gt;next &#x3D; pbig-&gt;next &#x3D; NULL;    while (head !&#x3D; NULL) {        if (head-&gt;val &lt; x) {            psmall-&gt;next &#x3D; head;            psmall &#x3D; psmall-&gt;next;        } else {            pbig-&gt;next &#x3D; head;            pbig &#x3D; pbig-&gt;next;        }        head &#x3D; head-&gt;next;    }    psmall-&gt;next &#x3D; big.next;    pbig-&gt;next &#x3D; NULL;    return small.next;}



87 把字符串分区后，交换得到的字符串
    C++ 解答

123456789101112131415161718192021222324bool isScramble(string s1, string s2) {    if(s1&#x3D;&#x3D;s2)        return true;    &#x2F;&#x2F; 先判断字符是否一致    int len &#x3D; s1.size();    int count[26] &#x3D; {0};    for(int i&#x3D;0; i&lt;len; i++) {        count[s1[i]-&#39;a&#39;]++;        count[s2[i]-&#39;a&#39;]--;    }    for(int i &#x3D; 0; i &lt; 26; i++)        if(count[i]!&#x3D;0)            return false;    for(int i &#x3D; 1; i &lt; len; i++) {        if( isScramble(s1.substr(0,i), s2.substr(0,i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(i)))            return true;        if( isScramble(s1.substr(0,i), s2.substr(len-i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(0,len-i)))            return true;    }    return false;}



88 合并已排序数组，要求合并到其中一个空间较大的数组中对于这种要求 in-place 的算法，从后往前往往可以解决

    C 解答

12345678910111213141516void merge(int* nums1, int m, int* nums2, int n) {    int len &#x3D; m + n - 1;    m--, n--;    while (m &gt;&#x3D; 0 &amp;&amp; n &gt;&#x3D; 0) {        if (nums1[m] &gt; nums2[n]) {            nums1[len--] &#x3D; nums1[m--];        } else {            nums1[len--] &#x3D; nums2[n--];        }    }    while (n &gt;&#x3D; 0) {        nums1[n] &#x3D; nums2[n];        n--;    }}



89 生成格雷码 (Gray Code)记住格雷码的生成规则

    C++ 解答

1234567vector&lt;int&gt; grayCode(int n) {    vector&lt;int&gt; v;    for (int i &#x3D; 0; i &lt; (1 &lt;&lt; n); i++) {        v.push_back((i &gt;&gt; 1) ^ i);    }    return v;}



90 由给定元素生成子集，可能包含重复元素使用了和手机键盘生成字符串号码类似的迭代算法，注意其中对重复元素的处理，当然也可以用 DFS 来做

    C++ 解答

12345678910111213141516171819202122vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {    vector&lt;vector&lt;int&gt;&gt; sets;    sets.push_back({});    sort(nums.begin(), nums.end()); &#x2F;&#x2F; 处理包含重复元素的一半需要预排序    for (int i &#x3D; 0; i &lt; nums.size(); ) {        int count &#x3D; 0; &#x2F;&#x2F; dup count        while (count + i &lt; nums.size() &amp;&amp; nums[count+i] &#x3D;&#x3D; nums[i])            count++;        int prev_n &#x3D; sets.size();        for (int j &#x3D; 0; j &lt; prev_n; j++) {            vector&lt;int&gt; instance &#x3D; sets[j];            &#x2F;&#x2F; put dup element &#96;count&#96; times            for (int k &#x3D; 0; k &lt; count; k++) {                instance.push_back(nums[i]);                sets.push_back(instance);            }        }        i +&#x3D; count;    }    return sets;}



91 给定一个数组只包含 1-9，可以用 1-26 代表字母，求出从其中能都得到多少字符串使用动态规划，但是注意其中 0 的处理，很玄妙

    C 解答

1234567891011121314151617181920int numDecodings(char* s) {    if (!s || strlen(s) &#x3D;&#x3D; 0 || s[0] &#x3D;&#x3D; &#39;0&#39;) return 0;    int r1 &#x3D; 1, r2 &#x3D; 1; &#x2F;&#x2F; r1: 前一个字符， r2：前两个字符    char* p &#x3D; s++; &#x2F;&#x2F; 上一个字符    while (*s) {        if (*s &#x3D;&#x3D; &#39;0&#39;)             r1 &#x3D; 0; &#x2F;&#x2F; 0 不能单独构成字母        if (*p &#x3D;&#x3D; &#39;1&#39; || *p &#x3D;&#x3D; &#39;2&#39; &amp;&amp; *s &lt; &#39;7&#39;) { &#x2F;&#x2F; 形成两种可能            int t &#x3D; r1;            r1 &#x3D; r2 + r1;            r2 &#x3D; t;        } else {            r2 &#x3D; r1; &#x2F;&#x2F; 新加入的数字只能单独构成字母        }        p &#x3D; s++;    }    return r1;}



92 在给定区间上翻转数组同样是数组操作细节题

    C 解答

123456789101112131415161718struct ListNode* reverseBetween(struct ListNode* head, int m, int n) {    if (m &#x3D;&#x3D; n) return head;    struct ListNode dummy, *p &#x3D; &amp;dummy, * small_node, * big_node; &#x2F;&#x2F; actually the prev ones    dummy.next &#x3D; head;    n -&#x3D; m;    while (--m) &#x2F;&#x2F; m starts from 1, so not m--        p &#x3D; p-&gt;next;    struct ListNode* start &#x3D; p-&gt;next;    while (n--) {        struct ListNode* next &#x3D; start-&gt;next;        start-&gt;next &#x3D; next-&gt;next;        next-&gt;next &#x3D; p-&gt;next;        p-&gt;next &#x3D; next;    }    return dummy.next;}



93 恢复 IP 地址，给定一个字符串，适当插入点，一共有多少种方式构成 IP 地址又是一道 DFS 的题，注意对于字符串问题如何处理

    C++ 解答

123456789101112131415161718192021vector&lt;string&gt; restoreIpAddresses(string s) {    vector&lt;string&gt; result;    restore(result, s, &quot;&quot;, 0, 0);    return result;}void restore(vector&lt;string&gt;&amp; result, string&amp; s, string restored, int start, int dots) {    if (dots &gt; 4) return;    if (dots &#x3D;&#x3D; 4 &amp;&amp; start &#x3D;&#x3D; s.size())        result.push_back(restored);    for (int i &#x3D; 1; i &lt; 4; i++) {        if (start + i &gt; s.size())            break;        string part &#x3D; s.substr(start, i);        if (part[0] &#x3D;&#x3D; &#39;0&#39; &amp;&amp; part.size() &gt; 1 || i &#x3D;&#x3D; 3 &amp;&amp; stoi(part) &gt; 255)            continue;        restore(result, s, restored + part + (dots&#x3D;&#x3D;3 ? &quot;&quot; : &quot;.&quot;), start + i, dots + 1);    }}



94 中序遍历二叉树当然是使用栈了

    C++ 解答

123456789101112131415161718vector&lt;int&gt; inorderTraversal(TreeNode* root) {    vector&lt;int&gt; result;    stack&lt;TreeNode*&gt; stk;    TreeNode* current &#x3D; root;    while (!stk.empty() || current) {        if (current) {            stk.push(current);            current &#x3D; current-&gt;left;        } else {            current &#x3D; stk.top();            stk.pop();            result.push_back(current-&gt;val);            current &#x3D; current-&gt;right;        }    }    return result;}



递归解法

    go 解答

12345678func inorderTraversal(root *TreeNode) []int {    if root &#x3D;&#x3D; nil {        return nil    }    left :&#x3D; inorderTraversal(root.Left)    right :&#x3D; inorderTraversal(root.Right)    return append(append(left, root.Val), right...)}



95 生成二叉树，同下题一样
    C++ 解答

12345678910111213141516171819202122232425vector&lt;TreeNode*&gt; generateTrees(int n) {    return gen(1, n);}vector&lt;TreeNode*&gt; gen(int start, int end) {    vector&lt;TreeNode*&gt; result;    if (start &gt; end) {        result.push_back(NULL);        return result;    }    for (int i &#x3D; start; i &lt;&#x3D; end; i++) {        auto leftTrees &#x3D; gen(start, i - 1);        auto rightTrees &#x3D; gen(i + 1, end);        for (auto&amp; l : leftTrees) {            for (auto&amp; r : rightTrees) {                auto root &#x3D; new TreeNode(i);                root-&gt;left &#x3D; l;                root-&gt;right &#x3D; r;                result.push_back(root);            }        }    }    return result;}



96 给定数字 n，从 1 到 n 作为节点有多少种方式生成二叉树这道题看似是树，实际上是一个动态规划问题。

    C 解答

1234567891011121314int numTrees(int n) {    if (n &#x3D;&#x3D; 0) return 0;    int* dp &#x3D; malloc(sizeof(int) * (n+1));    dp[0] &#x3D; 1;    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {        int num &#x3D; 0;        for (int j &#x3D; 0; j &lt;&#x3D; i; j++) &#x2F;&#x2F; 依次选取第 k 个点作为根            num +&#x3D; dp[j - 1] * dp[i - j];        dp[i] &#x3D; num;    }    return dp[n];}



97 给定两个字符串交叉是否能够构成第三个字符串这道题是一道二维的 DP 问题，因为需要对于每个字符串的每个位置用另一个字符串尝试匹配

    C 解答

1234567891011121314151617181920bool isInterleave(char* s1, char* s2, char* s3) {    int l1 &#x3D; strlen(s1), l2 &#x3D; strlen(s2), l3 &#x3D; strlen(s3);    if (l1 + l2 !&#x3D; l3) return false;    &#x2F;&#x2F; 在 i+j 位置 s1[i] s2[j] 是否能够构成 s[i+j]    bool** dp &#x3D; malloc(sizeof(bool*) * (l1 + 1));    for (int i &#x3D; 0; i &lt;&#x3D; l1; i++)        dp[i] &#x3D; malloc(sizeof(bool) * (l2 + 1));    for (int i &#x3D; 0; i &lt;&#x3D; l1; i++)        for (int j &#x3D; 0; j &lt;&#x3D; l2; j++)            if (i &#x3D;&#x3D; 0 &amp;&amp; j &#x3D;&#x3D; 0)                dp[i][j] &#x3D; true;            else if (i &#x3D;&#x3D; 0)                dp[i][j] &#x3D; (dp[i][j-1] &amp;&amp; s2[j-1] &#x3D;&#x3D; s3[i+j-1]); &#x2F;&#x2F; 注意：赋值的优先级更高            else if (j &#x3D;&#x3D; 0)                dp[i][j] &#x3D; (dp[i-1][j] &amp;&amp; s1[i-1] &#x3D;&#x3D; s3[i+j-1]);            else                dp[i][j] &#x3D; (dp[i-1][j] &amp;&amp; s1[i-1] &#x3D;&#x3D; s3[i+j-1] || dp[i][j-1] &amp;&amp; s2[j-1] &#x3D;&#x3D; s3[i+j-1]);    return dp[l1][l2];}



98 验证二叉搜索树是否合法先序遍历即可

    C 解答

123456789bool valid(struct TreeNode* root, long left, long right) {    return root &#x3D;&#x3D; NULL || root-&gt;val &gt; left &amp;&amp; root-&gt;val &lt; right &amp;&amp;        valid(root-&gt;left, left, root-&gt;val) &amp;&amp;        valid(root-&gt;right, root-&gt;val, right);}bool isValidBST(struct TreeNode* root) {    return valid(root, INT_MIN - 1l, INT_MAX + 1l);}



99 在二叉搜索树中有两个节点被调换了，找出这两个节点，并恢复该二叉树
    C 解答

1234567891011121314151617181920212223struct TreeNode* prev &#x3D; NULL;struct TreeNode* first &#x3D; NULL;struct TreeNode* second &#x3D; NULL;void traverse(struct TreeNode* root) {    if (!root) return;    traverse(root-&gt;left);    if (prev &amp;&amp; prev-&gt;val &gt; root-&gt;val) {         if (!first) first &#x3D; prev;         second &#x3D; root;    }    prev &#x3D; root;    traverse(root-&gt;right);}void recoverTree(struct TreeNode* root) {    prev &#x3D; first &#x3D; second &#x3D; NULL;    traverse(root);    if (!first) return;    int temp &#x3D; first-&gt;val;    first-&gt;val &#x3D; second-&gt;val;    second-&gt;val &#x3D; temp;}



100 判断是否是相同的树
    C 解答

123456789bool isSameTree(struct TreeNode *p, struct TreeNode *q) {    if (p &#x3D;&#x3D; NULL || q &#x3D;&#x3D; NULL) {        return p &#x3D;&#x3D; q;    } else {        return p-&gt;val &#x3D;&#x3D; q-&gt;val            &amp;&amp; isSameTree(p-&gt;left, q-&gt;left)            &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);    }}



101 判断是不是左右对称的树
    C 解答

12345678910111213bool sym(struct TreeNode* left, struct TreeNode* right) {    if (left &amp;&amp; !right || !left &amp;&amp; right)        return false;    return !left &amp;&amp; !right ||        left-&gt;val &#x3D;&#x3D; right-&gt;val &amp;&amp;        sym(left-&gt;left, right-&gt;right) &amp;&amp;        sym(right-&gt;left, left-&gt;right);}bool isSymmetric(struct TreeNode* root) {    if (!root) return true;    return sym(root-&gt;left, root-&gt;right);}



102 二叉树层序遍历
    C++ 解答

1234567891011121314151617181920vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {    vector&lt;vector&lt;int&gt;&gt; result;    if (!root) return result;    vector&lt;TreeNode*&gt; current, next;    current.push_back(root);    while (!current.empty()) {        next.resize(0);        vector&lt;int&gt; vals;        for (int i &#x3D; 0; i &lt; current.size(); i++) {            if (current[i]-&gt;left)                next.push_back(current[i]-&gt;left);            if (current[i]-&gt;right)                next.push_back(current[i]-&gt;right);            vals.push_back(current[i]-&gt;val);        }        result.push_back(vals);        current &#x3D; next;    }    return result;}



103 二叉树 ZigZag 层序遍历这道题更好的做法是使用一个栈，从而使得每行的顺序都是上一行的翻转

    C++ 解答

1234567891011121314151617181920212223vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) {    vector&lt;vector&lt;int&gt;&gt; result;    if (!root) return result;    vector&lt;TreeNode*&gt; current, next;    current.push_back(root);    bool odd &#x3D; true;    while (!current.empty()) {        next.resize(0);        vector&lt;int&gt; vals;        for (int i &#x3D; 0; i &lt; current.size(); i++) {            if (current[i]-&gt;left)                next.push_back(current[i]-&gt;left);            if (current[i]-&gt;right)                next.push_back(current[i]-&gt;right);            vals.push_back(current[i]-&gt;val);        }        if (!odd) reverse(vals.begin(), vals.end());        odd &#x3D; !odd;        result.push_back(vals);        current &#x3D; next;    }    return result;}



104 树的最大深度
    C 解答

12345int maxDepth(struct TreeNode* root) {    if (!root) return 0;    int left &#x3D; maxDepth(root-&gt;left), right &#x3D; maxDepth(root-&gt;right);    return (left &gt; right ?left : right) + 1;}



105 从前序遍历和中序遍历生成生二叉树
    C 解答

123456789101112131415161718192021222324struct TreeNode* build(int* prestart, int* preend, int* instart, int* inend) {    struct TreeNode* root &#x3D; malloc(sizeof(struct TreeNode));    root-&gt;val &#x3D; *prestart;    root-&gt;left &#x3D; root-&gt;right &#x3D; NULL;    if (prestart &#x3D;&#x3D; preend)        return root;    int* root_inorder &#x3D; instart;    while (root_inorder &lt;&#x3D; inend &amp;&amp; *root_inorder !&#x3D; *prestart)        root_inorder++;    int left_len &#x3D; root_inorder - instart;    int right_len &#x3D; inend - root_inorder;    if (left_len &gt; 0)        root-&gt;left &#x3D; build(prestart + 1, prestart + left_len, instart, root_inorder - 1);    if (right_len &gt; 0)        root-&gt;right &#x3D; build(prestart + left_len + 1, preend, root_inorder + 1, inend);    return root;}&#x2F;&#x2F; m always equals n, otherwise it&#39;s bad inputstruct TreeNode* buildTree(int* preorder, int m, int* inorder, int n) {    if (n&#x3D;&#x3D;0) return NULL;    return build(preorder, preorder + n - 1, inorder, inorder + n - 1);}



106 从中序遍历和后序遍历生成二叉树
    C 解答

1234567891011121314151617181920212223struct TreeNode* build(int* instart, int* inend, int* poststart, int* postend) {    struct TreeNode* root &#x3D; malloc(sizeof(struct TreeNode));    root-&gt;val &#x3D; *postend;    root-&gt;left &#x3D; root-&gt;right &#x3D; NULL;    if (poststart &#x3D;&#x3D; postend)        return root;    int* root_inorder &#x3D; instart;    while (root_inorder &lt;&#x3D; inend &amp;&amp; *root_inorder !&#x3D; *postend)        root_inorder++;    int left_len &#x3D; root_inorder - instart;    int right_len &#x3D; inend - root_inorder;    if (left_len &gt; 0)        root-&gt;left &#x3D; build(instart, root_inorder - 1, poststart, poststart + left_len - 1);    if (right_len &gt; 0)        root-&gt;right &#x3D; build(root_inorder + 1, inend, poststart + left_len, postend - 1);    return root;}struct TreeNode* buildTree(int* inorder, int m, int* postorder, int n) {    if (n &#x3D;&#x3D; 0) return NULL;    return build(inorder, inorder + n - 1, postorder, postorder +n - 1);}



107 二叉树层序遍历，但要生成翻转的遍历序列
    C++ 解答

123456789101112131415161718192021vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) {    vector&lt;vector&lt;int&gt;&gt; result;    if (!root) return result;    vector&lt;TreeNode*&gt; current, next;    current.push_back(root);    while (!current.empty()) {        next.resize(0);        vector&lt;int&gt; vals;        for (int i &#x3D; 0; i &lt; current.size(); i++) {            if (current[i]-&gt;left)                next.push_back(current[i]-&gt;left);            if (current[i]-&gt;right)                next.push_back(current[i]-&gt;right);            vals.push_back(current[i]-&gt;val);        }        result.push_back(vals);        current &#x3D; next;    }    reverse(result.begin(), result.end());    return result;}



108 把排序数组转化为二叉树
    C 解答

123456789101112131415 struct TreeNode* bst(int* left, int* right) {    int* mid &#x3D; left + (right - left) &#x2F; 2;    struct TreeNode* root &#x3D; malloc(sizeof(struct TreeNode));    root-&gt;val &#x3D; *mid;    root-&gt;left &#x3D; root-&gt;right &#x3D; NULL;    if (left &lt; mid)        root-&gt;left &#x3D; bst(left, mid-1);    if (mid &lt; right)        root-&gt;right &#x3D; bst(mid+1, right);    return root;}struct TreeNode* sortedArrayToBST(int* nums, int n) {    if (n &#x3D;&#x3D; 0) return NULL;    return bst(nums, nums + n -1);}



109 把排序列表转化为二叉树
    C 解答

12345678910111213141516171819202122struct ListNode* list;int len(struct ListNode* head) {    int l &#x3D; 0;    while (head)        head &#x3D; head-&gt;next, l++;    return l;}struct TreeNode* bst(int n) {    if (n &#x3D;&#x3D; 0) return NULL;    struct TreeNode* root &#x3D; malloc(sizeof(struct TreeNode));    root-&gt;left &#x3D; bst(n&#x2F;2);    root-&gt;val &#x3D; list-&gt;val;    list &#x3D; list-&gt;next;    root-&gt;right &#x3D; bst(n - n &#x2F; 2 - 1);    return root;}struct TreeNode* sortedListToBST(struct ListNode* head) {    if (!head) return 0;    list &#x3D; head;    return bst(len(head));}



110 平衡二叉树
    C 解答

1234567891011int height(struct TreeNode* root) {    if (!root) return 0;    int left &#x3D; height(root-&gt;left);    int right &#x3D; height(root-&gt;right);    if (left &gt; right + 1 || right &gt; left + 1 || left &#x3D;&#x3D; -1 || right &#x3D;&#x3D; -1)        return -1;    return (left &gt; right ? left : right) + 1;}bool isBalanced(struct TreeNode* root) {    return height(root) !&#x3D; -1;}



111 二叉树最小高度
    C 解答

123456789int minDepth(struct TreeNode* root) {    if (!root) return 0;    int left &#x3D; minDepth(root-&gt;left);    int right &#x3D; minDepth(root-&gt;right);    if (!right) return left + 1;    if (!left) return right + 1; &#x2F;&#x2F; tricky here, 当有空节点时，不能返回 0，而是返回另一个值    return (left &lt; right ? left : right) + 1;}



112 二叉树中是否存在和为某个数的路径
    C 解答

123456bool hasPathSum(struct TreeNode* root, int sum) {    if (!root) return false;    if (!root-&gt;left &amp;&amp; !root-&gt;right) return sum &#x3D;&#x3D; root-&gt;val;    return hasPathSum(root-&gt;left, sum - root-&gt;val) ||        hasPathSum(root-&gt;right, sum - root-&gt;val);}



113 接上题，把这个路径找出来
    C++ 解答

12345678910111213141516171819vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) {    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    getPaths(result, path, root, sum);    return result;}void getPaths(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; path, TreeNode* root, int sum) {    if (!root)        return;    path.push_back(root-&gt;val);    if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum &#x3D;&#x3D; root-&gt;val) {        result.push_back(path);        return;    }    getPaths(result, path, root-&gt;left, sum - root-&gt;val);    getPaths(result, path, root-&gt;right, sum - root-&gt;val);}



114 把二叉树扁平成列表
    C++ 解答

123456789TreeNode* prev;void flatten(TreeNode* root) {    if (!root) return;    flatten(root-&gt;right);    flatten(root-&gt;left);    root-&gt;right &#x3D; prev;    root-&gt;left &#x3D; NULL;    prev &#x3D; root; &#x2F;&#x2F; last flattened element}



115 通过删掉一些字母得到子序列，问有多少种方法能够得到子序列呢使用 DP，

    C++ 解答

1234567891011121314151617181920212223242526272829303132&#x2F;** * Solution (DP): * 我们扫描字符串 s * Path[i][j] 代表 T.substr(1...i) 在 S(1...j) 不同的子序列的数量 * * Path[i][j] &#x3D; Path[i][j-1]            (discard S[j]) *              +     Path[i-1][j-1]    (S[j] &#x3D;&#x3D; T[i] and we are going to use S[j]) *                 or 0                 (S[j] !&#x3D; T[i] so we could not use S[j]) * while Path[0][j] &#x3D; 1 and Path[i][0] &#x3D; 0. *&#x2F;class Solution {public:    int numDistinct(string s, string t) {        int m &#x3D; t.size();        int n &#x3D; s.size();        if (m &gt; n)            return 0;        vector&lt;vector&lt;int&gt;&gt; path(m+1, vector&lt;int&gt;(n+1, 0));        for (int i &#x3D; 0; i &lt;&#x3D; n; i++)            path[0][i] &#x3D; 1;        for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#x2F;&#x2F; S            for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#x2F;&#x2F; T                path[i][j] &#x3D; path[i][j-1] + (t[i-1] &#x3D;&#x3D; s[j-1] ? path[i-1][j-1] : 0);        return path[m][n];    }};



116 完全二叉树中把每个节点指向他这一层的右面的节点显然左节点的下一个节点是父节点的右节点，右节点的下一个节点是父节点下一个节点的左节点。

    C 解答

12345678910void connect(struct TreeLinkNode *root) {    if (!root)        return;    if (root-&gt;left)        root-&gt;left-&gt;next &#x3D; root-&gt;right;    if (root-&gt;right)        root-&gt;right-&gt;next &#x3D; root-&gt;next ? root-&gt;next-&gt;left : NULL;    connect(root-&gt;left);    connect(root-&gt;right);}



117 同上题，但是是任意的🌲通过上一层已经被连接的 next 指针，顺序层序访问，从而连接下一层。

    C 解答

1234567891011121314151617181920212223242526void connect(struct TreeLinkNode *root) {    struct TreeLinkNode* head &#x3D; root, * prev &#x3D; NULL, *p &#x3D; NULL;    while (head) { &#x2F;&#x2F; head 是每层的开始        p &#x3D; head;        prev &#x3D; head &#x3D; NULL;        while (p) {            if (p-&gt;left) {                if (prev)                    prev-&gt;next &#x3D; p-&gt;left;                else                    head &#x3D; p-&gt;left;                prev &#x3D; p-&gt;left;            }            if (p-&gt;right) {                if (prev)                    prev-&gt;next &#x3D; p-&gt;right;                else                    head &#x3D; p-&gt;right;                prev &#x3D; p-&gt;right;            }            p &#x3D; p-&gt;next;        }    }}



118 杨辉三角注意坐标关系，不要被骗了

    C++ 解答

123456789101112vector&lt;vector&lt;int&gt;&gt; generate(int n) {    vector&lt;vector&lt;int&gt;&gt; result(n);    for (int i &#x3D; 0; i &lt; n; i++) {        result[i].resize(i+1);        result[i][0] &#x3D; result[i][i] &#x3D; 1;        for (int j &#x3D; 1; j &lt; i; j++)            result[i][j] &#x3D; result[i-1][j-1] + result[i-1][j];    }    return result;}



119 返回杨辉三角的第 k 行要求只能使用 O(k) 的额外空间，比较蛋疼的是这里的 k 是从 0 计数的。

    C++ 解答

123456789101112vector&lt;int&gt; getRow(int rowIndex) {    rowIndex++;    vector&lt;int&gt; row;    for (int i &#x3D; 0; i &lt; rowIndex; i++) {        vector&lt;int&gt; newRow(i+1);        newRow[0] &#x3D; newRow[i] &#x3D; 1;        for (int j &#x3D; 1; j &lt; i; j++)            newRow[j] &#x3D; row[j-1] + row[j];        swap(row, newRow);    }    return row;}



120 给定一个类似杨辉三角形状的数组，求从顶部到底部的最短路径显然是使用 DP，但是有一个问题，如果是 top down 的话，最后还需要遍历一下，而如果是 bottom up 就只需要返回 dp[0] 就好了。

    C++ 解答

1234567int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {    vector&lt;int&gt; dp(triangle.back()); &#x2F;&#x2F; 复制最后一行    for (int layer &#x3D; triangle.size() - 2; layer &gt;&#x3D; 0; layer--)        for (int i &#x3D; 0; i &lt;&#x3D; layer; i++)            dp[i] &#x3D; triangle[layer][i] + min(dp[i], dp[i+1]);    return dp[0];}



121 买卖股票最佳时机，只能交易一次
    C 解答

1234567891011121314int maxProfit(int* prices, int pricesSize) {    if (pricesSize &lt; 2) return 0;    int profit &#x3D; 0;    int min &#x3D; prices[0];    &#x2F;&#x2F; 从前到后依次遍历，如果有更好的收益更新，或者更新 min，限制条件是先出现最小值    for (int i &#x3D; 0; i &lt; pricesSize; i++) {        if (prices[i] &gt; min) {                profit &#x3D; max(profit, prices[i] - min);        } else {            min &#x3D; prices[i];        }    }    return profit;}



122 买卖股票的最佳时机，可以做任意多比交易有两种解法，一种是不断做交易，完全不考虑交易次数，这种做法不符合实际情况。另一种做法是模拟交易，这样会生成最少的交易次数，结果也是对的。

    C 解答

123456789&#x2F;&#x2F; 1int maxProfit(int* prices, int pricesSize)    int total &#x3D; 0;    for (int i&#x3D;0; i&lt; pricesSize-1; i++)        if (prices[i+1]&gt;prices[i])            total +&#x3D; prices[i+1]-prices[i];    return total;}





    C 解答

12345678910111213141516171819202122232425&#x2F;&#x2F; 2int maxProfit(int* prices, int pricesSize) {    if (!prices) return 0;    int profit &#x3D; 0;bool buy &#x3D; true;    int min &#x3D; prices[0], max &#x3D; prices[0];    for (int i &#x3D; 0; i &lt; pricesSize; i++) {        if (prices[i] &lt; min &amp;&amp; buy) {            min &#x3D; prices[i];            max &#x3D; prices[i];        }        if (prices[i] &gt; min &amp;&amp; buy)            buy &#x3D; false;        if (prices[i] &gt; max &amp;&amp; !buy)            max &#x3D; prices[i];        if ((prices[i] &lt; max || i &#x3D;&#x3D; pricesSize - 1) &amp;&amp; !buy){            profit +&#x3D; max - min;            min &#x3D; prices[i];            max &#x3D; prices[i];            buy &#x3D; true;        }    }    return profit;}



123 股票交易，限制只能交易两股每次求解的是：卖出两股以后的最大值，刚刚买入第二股的最大值，卖出第一股时候的最大值，买入第一股时候的最大值。

    C++ 解答

12345678910111213int maxProfit(vector&lt;int&gt;&amp; prices) {    int hold1 &#x3D; INT_MIN, hold2 &#x3D; INT_MIN;    int release1 &#x3D; 0, release2 &#x3D; 0;    for (auto i : prices) {        release2 &#x3D; max(release2, hold2 + i);        hold2 &#x3D; max(hold2, release1 - i);        release1 &#x3D; max(release1, hold1 + i);        hold1 &#x3D; max(hold1, -i);    }    return release2;}



124 二叉树路径最大和，路径可以从任意一个节点开始到任意一个节点结束
    C 解答

12345678910111213141516171819int max(int a, int b) {    return a &gt; b ? a : b;}int doSum(struct TreeNode* root, int* sum) {    if (!root)        return 0;    int left &#x3D; max(0, doSum(root-&gt;left, sum));    int right &#x3D; max(0, doSum(root-&gt;right, sum));    *sum &#x3D; max(*sum, left+right+root-&gt;val);    return max(left, right) + root-&gt;val;}int maxPathSum(struct TreeNode* root) {    int sum &#x3D; INT_MIN;    doSum(root, &amp;sum);    return sum;}



这道题是把最终答案放在了全局变量中，并采用了辅助函数的方法。全局变量中存储两条路径的和，而返回值中存储当前子树中最长的单边。

    Python 解答

1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val &#x3D; x#         self.left &#x3D; None#         self.right &#x3D; Noneclass Solution:    def __init__(self):        self.ans &#x3D; float(&#39;-inf&#39;)    def _maxPathSum(self, root: TreeNode) -&gt; int:        if root is None:            return 0        # 注意这里要取 max，以防添加了负路径        left &#x3D; max(0, self._maxPathSum(root.left))        right &#x3D; max(0, self._maxPathSum(root.right))        self.ans &#x3D; max(self.ans, left + right + root.val)        return max(left, right) + root.val    def maxPathSum(self, root: TreeNode) -&gt; int:        self._maxPathSum(root)        return self.ans




125 给定一个字符串，只考虑字母和数字，忽略大小写，判断是否是回文字符串太简单了，没啥可说的

    C 解答

12345678910111213141516171819bool isPalindrome(char* s) {    int len &#x3D; strlen(s);    if (len &#x3D;&#x3D; 0) return true;    int left &#x3D; 0, right &#x3D; len - 1;    while (left &lt; right) {        char l &#x3D; s[left], r &#x3D; s[right];        if (isalnum(l) &amp;&amp; isalnum(r)) {            if (tolower(l) !&#x3D; tolower(r))                return false;            left++, right--;        } else {            if (!isalnum(l))                left++;            if (!isalnum(r))                right--;        }    }    return true;}



127 单词梯子给定梯子，和开始单词和结束单词，最少需要多少个中间单词，才能变化过去，每次只能变化一个字母

    C++ 解答

1234567891011121314151617181920212223242526272829303132333435363738int ladderLength(string beginWord, string endWord, unordered_set&lt;string&gt;&amp; wordList) {    unordered_set&lt;string&gt; beginSet, endSet, *set1, * set2;    beginSet.insert(beginWord);    endSet.insert(endWord);    int dist &#x3D; 2;    while (!beginSet.empty() &amp;&amp; !endSet.empty()) {        if (beginSet.size() &lt; endSet.size()) {            set1 &#x3D; &amp;beginSet;            set2 &#x3D; &amp;endSet;        } else {            set1 &#x3D; &amp;endSet;            set2 &#x3D; &amp;beginSet;        }        unordered_set&lt;string&gt; temp;        for (auto word : *set1) { &#x2F;&#x2F; notice word in not ref            wordList.erase(word);            for (auto&amp; letter : word) {                for (int i &#x3D; 0; i &lt; 26; i++) {                    char oldLetter &#x3D; letter;                    letter &#x3D; &#39;a&#39; + i;                    if (set2-&gt;find(word) !&#x3D; set2-&gt;end())                        return dist;                    if (wordList.find(word) !&#x3D; wordList.end()) {                        temp.insert(word);                        wordList.erase(word);                    }                    letter &#x3D; oldLetter;                }            }        }        dist++;        swap(*set1, temp);    }    return 0;}



128 最长递增子序列使用动态规划

    C++ 解答

1234567891011121314151617int longestConsecutive(vector&lt;int&gt;&amp; nums) {    int result &#x3D; 0;    unordered_map&lt;int, int&gt; hash; &#x2F;&#x2F; 每个元素和它们所在序列的长度    for (auto n : nums) {        if (hash.find(n) &#x3D;&#x3D; hash.end()) {            &#x2F;&#x2F; 查找两边的元素，如果找到，把新元素合并进去            int left &#x3D; hash.find(n-1) !&#x3D; hash.end() ? hash[n-1] : 0;            int right &#x3D; hash.find(n+1) !&#x3D; hash.end() ? hash[n+1] : 0;            int sum &#x3D; left + right + 1;            hash[n] &#x3D; hash[n-left] &#x3D; hash[n+right] &#x3D; sum; &#x2F;&#x2F; 注意此处的更新，并不需要更新区间内的每个值，只需要更新边界即可            result &#x3D; max(result, sum);        }    }    return result;}



129 二叉树中只有 0-9 找出所有根节点到子节点的和
    C 解答

123456789101112131415int sum(struct TreeNode* root, int x) {    if (!root-&gt;left &amp;&amp; !root-&gt;right)        return x * 10 + root-&gt;val;    int val &#x3D; 0;    if (root-&gt;left)        val +&#x3D; sum(root-&gt;left, x * 10 + root-&gt;val);    if (root-&gt;right)        val +&#x3D; sum(root-&gt;right, x * 10 + root-&gt;val);    return val;}int sumNumbers(struct TreeNode* root) {    if (!root) return 0;    return sum(root, 0);}



130 把所有被包围的 O 置为 X使用并查集

    C++ 解答

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class UnionFind {private:    vector&lt;int&gt; m_father, m_rank;public:    UnionFind(int n): m_father(n), m_rank(n, 0) {        for (int i &#x3D; 0; i &lt; m_father.size(); i++)            m_father[i] &#x3D; i;    }    int find(int x) {        if (x !&#x3D; m_father[x])            m_father[x] &#x3D; find(m_father[x]);        return m_father[x];    }    void unionify(int x, int y) {        x &#x3D; find(x);        y &#x3D; find(y);        if (x &#x3D;&#x3D; y) return;        if (m_rank[x] &gt; m_rank[y]) {            m_father[y] &#x3D; x;        } else {            if (m_rank[x] &#x3D;&#x3D; m_rank[y])                m_rank[y]++;            m_father[x] &#x3D; y;        }    }};class Solution {public:    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {        int n &#x3D; board.size();        if (n &#x3D;&#x3D; 0) return;        int m &#x3D; board[0].size();        UnionFind uf(n*m+1);        for (int i &#x3D; 0; i &lt; n; i++) {            for (int j &#x3D; 0; j &lt; m; j++) {                if ((i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0 || i &#x3D;&#x3D; n-1 || j &#x3D;&#x3D; m-1) &amp;&amp; board[i][j] &#x3D;&#x3D; &#39;O&#39;)                    uf.unionify(i * m + j, n * m);                else if (board[i][j] &#x3D;&#x3D; &#39;O&#39;) {                    if (board[i-1][j] &#x3D;&#x3D; &#39;O&#39;)                        uf.unionify(i * m + j, (i - 1) * m + j);                    if (board[i+1][j] &#x3D;&#x3D; &#39;O&#39;)                        uf.unionify(i*m+j, (i+1)*m+j);                    if (board[i][j-1] &#x3D;&#x3D; &#39;O&#39;)                        uf.unionify(i*m+j, i*m+j-1);                    if (board[i][j+1] &#x3D;&#x3D; &#39;O&#39;)                        uf.unionify(i*m+j, i*m+j+1);                }            }        }        for (int i &#x3D; 0; i &lt; n; i++)            for (int j &#x3D; 0; j &lt; m; j++)                if (uf.find(i*m+j) !&#x3D; uf.find(n*m))                    board[i][j] &#x3D; &#39;X&#39;;    }};



131 对字符串分组，是的每个字串都是回文，返回所有可能的分组
    C++ 解答

1234567891011121314151617181920212223242526272829vector&lt;vector&lt;string&gt;&gt; partition(string s) {    vector&lt;vector&lt;string&gt;&gt; result;    vector&lt;string&gt; group;    dfs(result, s, group, 0);    return result;}void dfs(vector&lt;vector&lt;string&gt;&gt;&amp; result, const string&amp; s, vector&lt;string&gt;&amp; group, int start) {    if (start &#x3D;&#x3D; s.size()) {        result.push_back(group);        return;    }    for (int i &#x3D; start; i &lt; s.size(); i++) {        if (isPalindrome(s, start, i)) {            group.push_back(s.substr(start, i - start + 1));            dfs(result, s, group, i + 1);            group.pop_back();        }    }}bool isPalindrome(const string&amp; s, int left, int right) {    while (left &lt; right) {        if (s[left++] !&#x3D; s[right--])            return false;    }    return true;}



132 如上题，找出最少需要分组几次
    C++ 解答

1234567891011121314int minCut(string s) {    vector&lt;int&gt; cut(s.size() + 1, 0);    for (int i &#x3D; 0; i &lt; s.size() + 1; i++)        cut[i] &#x3D; i - 1;    for (int i &#x3D; 0; i &lt; s.size(); i++) {        for (int j &#x3D; 0; i - j &gt;&#x3D; 0 &amp;&amp; i + j &lt; s.size() &amp;&amp; s[i+j] &#x3D;&#x3D; s[i-j]; j++)            cut[i+j+1] &#x3D; min(cut[i+j+1], cut[i-j] + 1); &#x2F;&#x2F; i-j -&gt; i+j 是 palindrome，所以只需要 cut[i-j] 在加上这一段就好了        for (int j &#x3D; 1; i - j + 1 &gt;&#x3D; 0 &amp;&amp; i + j &lt; s.size() &amp;&amp; s[i+j] &#x3D;&#x3D; s[i-j+1]; j++)            cut[i+j+1] &#x3D; min(cut[i+j+1], cut[i - j + 1] + 1);    }    return cut[s.size()];}



133 复制有向图
    C++ 解答

123456789101112unordered_map&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; hash; &#x2F;&#x2F; old -&gt; new pairUndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {    if (!node)        return NULL;    if (hash.find(node) &#x3D;&#x3D; hash.end()) {        hash[node] &#x3D; new UndirectedGraphNode(node-&gt;label);        for (auto n : node-&gt;neighbors)            hash[node]-&gt;neighbors.push_back(cloneGraph(n));    }    return hash[node];}



134 加油站
    C 解答

123456789101112131415int canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize) {    int total &#x3D; 0;    int j &#x3D; -1;    for (int i &#x3D; 0, sum &#x3D; 0; i &lt; gasSize; ++i) {        sum +&#x3D; gas[i] - cost[i]; &#x2F;&#x2F; 从此处经过能够净增多少汽油        total +&#x3D; gas[i] - cost[i]; &#x2F;&#x2F; 记录总的汽油量是否是正的        if (sum &lt; 0) { &#x2F;&#x2F; 如果当前汽油量已经小于 0，说明之前的节点都是不行的，到下一个节点            j &#x3D; i;            sum &#x3D; 0; &#x2F;&#x2F; 同时重新开始计数        }    }    return total &gt;&#x3D; 0 ? j + 1 : -1;}



135 糖块，成绩高的需要比他身边成绩低的获得更多的糖
    C++ 解答

1234567891011121314151617181920int candy(vector&lt;int&gt;&amp; ratings) {    int n &#x3D; ratings.size();    if (n &lt;&#x3D; 1)        return n;    vector&lt;int&gt; candies(n, 1);    for (int i &#x3D;1; i &lt; n; i++)        if (ratings[i] &gt; ratings[i-1])            candies[i] &#x3D; candies[i-1] + 1;    for (int i &#x3D; n - 1; i &gt; 0; i--)        if (ratings[i-1] &gt; ratings[i])            candies[i-1] &#x3D; max(candies[i] + 1, candies[i-1]);    int result &#x3D; 0;    for (auto i : candies)        result +&#x3D; i;    return result;}



136 找出数组中只出现一次的数字
    C 解答

123456int singleNumber(int* nums, int numsSize) {    int result &#x3D; nums[0];    for (int i &#x3D; 1; i &lt; numsSize; i++)        result ^&#x3D; nums[i];    return result;}



137 一个数组中，所有数字都出现三次，除了一个数字以外，找出这个数字
    C 解答

12345678910111213&#x2F;&#x2F; 使用二进制计算&#x2F;&#x2F; 00-&gt;10-&gt;01-&gt;00(0-&gt;1-&gt;2-&gt;3&#x2F;0)&#x2F;&#x2F; ones &#x3D; ones ^ A[i]; if (twos &#x3D;&#x3D; 1) then ones &#x3D; 0&#x2F;&#x2F; twos &#x3D; twos ^ A[i]; if (ones* &#x3D;&#x3D; 1) then twos &#x3D; 0int singleNumber(int* nums, int numsSize) {    int ones &#x3D; 0, twos &#x3D; 0;    for (int i &#x3D; 0; i &lt; numsSize; i++) {        ones &#x3D; (ones ^ nums[i]) &amp; ~twos;        twos &#x3D; (twos ^ nums[i]) &amp; ~ones;    }    return ones;}



138 复制复杂结构链表
    C 解答

1234567891011121314151617181920212223242526272829303132333435363738&#x2F;** * Definition for singly-linked list with a random pointer. * struct RandomListNode { *     int label; *     struct RandomListNode *next; *     struct RandomListNode *random; * }; *&#x2F;struct RandomListNode *copyRandomList(struct RandomListNode *head) {    struct RandomListNode* p;    p &#x3D; head;    while (p) {        struct RandomListNode* node &#x3D; malloc(sizeof(struct RandomListNode));        node-&gt;next &#x3D; node-&gt;random &#x3D; NULL; &#x2F;&#x2F; spicial notice to struct initialization in c        node-&gt;label &#x3D; p-&gt;label;        node-&gt;next &#x3D; p-&gt;next;        p-&gt;next &#x3D; node;        p &#x3D; node-&gt;next;    }    p &#x3D; head;    while (p) {        if (p-&gt;random)            p-&gt;next-&gt;random &#x3D; p-&gt;random-&gt;next;        p &#x3D; p-&gt;next-&gt;next;    }    struct RandomListNode dummy, *q &#x3D; &amp;dummy;    dummy.next &#x3D; dummy.random &#x3D; NULL;    p &#x3D; head;    while (p) {        q-&gt;next &#x3D; p-&gt;next;        q &#x3D; q-&gt;next;        p-&gt;next &#x3D; p-&gt;next-&gt;next;        p &#x3D; p-&gt;next;    }    return dummy.next;}



139 查找单词是否能组成句子
    C++ 解答

123456789101112131415161718bool wordBreak(string s, unordered_set&lt;string&gt;&amp; wordDict) {    if (wordDict.empty()) return false;    vector&lt;bool&gt; dp(s.size() + 1, false);    dp[0] &#x3D; true;    &#x2F;&#x2F; 动态规划，假设前 i 个字符已经匹配到了，尝试匹配 i 到 i+j，如果找到了，就匹配到了 i+j    for (int i &#x3D; 1; i &lt;&#x3D; s.size(); i++) {        for (int j &#x3D; i-1; j &gt;&#x3D; 0; j--) {            if (dp[j]) {                string word &#x3D; s.substr(j, i-j);                if (wordDict.find(word) !&#x3D; wordDict.end()) {                    dp[i] &#x3D; true;                    break;                }            }        }    }    return dp[s.size()];}



141 列表是否有环slow 每次走一步，而 fast 每次走两步，因此在进入环之后，两者一定会相遇

    C 解答

12345678910bool hasCycle(struct ListNode *head) {    struct ListNode* slow &#x3D; head, * fast &#x3D; head;    while (fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) {        fast &#x3D; fast-&gt;next-&gt;next;        slow &#x3D; slow-&gt;next;        if (slow &#x3D;&#x3D; fast)            return true;    }    return false;}



142 列表是否有环？如果有找到环的开始从两者出发，到两者相遇，slow 指针走了 p 步，而 fast 指针走了 2p 步，显然 fast 多走了一圈（或者多圈）。设 p &#x3D; k + x, 2p &#x3D; k + x + loop -&gt; 2k + 2x &#x3D; k + x + loop -&gt; k + x &#x3D; loop -&gt; k &#x3D; loop - x，剩下的长度正好也是 k。假设入口处距离起点的距离是 k，那么发生碰撞的点距离环的入口处距离也是 k，所以两个指针分别从开始和碰撞点出发匀速一定会在环的入口相遇。

    C 解答

1234567891011121314151617181920struct ListNode *detectCycle(struct ListNode *head) {    struct ListNode* slow &#x3D; head, * fast &#x3D; head, *entry &#x3D; NULL;    bool found &#x3D; false;    while (!found &amp;&amp; fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) {        fast &#x3D; fast-&gt;next-&gt;next;        slow &#x3D; slow-&gt;next;        if (slow &#x3D;&#x3D; fast)            found &#x3D; true;    }    if (!found) return NULL;    slow &#x3D; head;    while (slow !&#x3D; fast) {        slow &#x3D; slow-&gt;next;        fast &#x3D; fast-&gt;next;    }    return slow;}



144 前序遍历
    C++ 解答

123456789101112131415161718192021vector&lt;int&gt; preorderTraversal(TreeNode* root) {    vector&lt;int&gt; result;    if (!root) return result;    stack&lt;TreeNode*&gt; stk;    stk.push(root);    while (!stk.empty()) {        TreeNode* node  &#x3D; stk.top();        stk.pop();        result.push_back(node-&gt;val);        if (node-&gt;right)            stk.push(node-&gt;right);        if (node-&gt;left)            stk.push(node-&gt;left);    }    return result;}



145 二叉树的后序遍历参见树的遍历

    C++ 解答

123456789101112131415161718192021vector&lt;int&gt; postorderTraversal(TreeNode* root) {    vector&lt;int&gt; result;    if (!root) return result;    stack&lt;TreeNode*&gt; stk, output;    stk.push(root);    while (!stk.empty()) {        auto node &#x3D; stk.top();        stk.pop();        output.push(node);        if (node-&gt;left)            stk.push(node-&gt;left);        if (node-&gt;right)            stk.push(node-&gt;right);    }    while (!output.empty()) {        result.push_back(output.top()-&gt;val);        output.pop();    }    return result;}



146 LRU 缓存
    C++ 解答

1234567891011121314151617181920212223242526272829303132333435363738394041class LRUCache{public:typedef unordered_map&lt;int, pair&lt;int, list&lt;int&gt;::iterator&gt;&gt; cache_t; &#x2F;&#x2F; k: v, iter    LRUCache(int capacity) : m_capacity(capacity) {    }int get(int key) {        auto it &#x3D; m_cache.find(key);        if (it &#x3D;&#x3D; m_cache.end())             return -1;        touch(it);        return it-&gt;second.first;    }    void set(int key, int value) {        auto it &#x3D; m_cache.find(key);        if (it !&#x3D; m_cache.end()) {            touch(it);        } else {            if (m_cache.size() &#x3D;&#x3D; m_capacity) {                m_cache.erase(m_used.back());                m_used.pop_back();            }            m_used.push_front(key);        }        m_cache[key] &#x3D; {value, m_used.begin()};    }private:    void touch(cache_t::iterator it) {        int key &#x3D; it-&gt;first;        m_used.erase(it-&gt;second.second);        m_used.push_front(key);        it-&gt;second.second &#x3D; m_used.begin();    }    cache_t m_cache;    list&lt;int&gt; m_used;    int m_capacity;};



147 链表插入排序
    C 解答

12345678910111213141516struct ListNode* insertionSortList(struct ListNode* head) {    if (!head) return NULL;    struct ListNode dummy, *p &#x3D; head;    dummy.val &#x3D; INT_MIN;    dummy.next &#x3D; NULL;    while (p) {        struct ListNode* iter &#x3D; &amp;dummy;        while (iter-&gt;next &amp;&amp; iter-&gt;next-&gt;val &lt; p-&gt;val)            iter &#x3D; iter-&gt;next;        struct ListNode* pnext &#x3D; p-&gt;next;        p-&gt;next &#x3D; iter-&gt;next;        iter-&gt;next &#x3D; p;        p &#x3D; pnext;    }    return dummy.next;}



148 排序链表，要求达到 O(nlogn) 时间复杂度
    C 解答

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void split(struct ListNode* source, struct ListNode** frontptr, struct ListNode** backptr) {    struct ListNode* fast, * slow;    if (!source || !source-&gt;next)        *backptr &#x3D; source;    else {        slow &#x3D; source;        fast &#x3D; source-&gt;next;        while (fast &amp;&amp; fast-&gt;next) {            fast &#x3D; fast-&gt;next-&gt;next;            slow &#x3D; slow-&gt;next;        }        *backptr &#x3D; slow-&gt;next;        slow-&gt;next &#x3D; NULL;    }    *frontptr &#x3D; source;}struct ListNode* merge(struct ListNode* l1, struct ListNode* l2) {    if (l1 &#x3D;&#x3D; NULL) return l2;    if (l2 &#x3D;&#x3D; NULL) return l1;    struct ListNode dummy;    dummy.next &#x3D;&#x3D; NULL;    struct ListNode* p &#x3D; &amp;dummy;    while (l1 &amp;&amp; l2) {        if (l1-&gt;val &lt; l2-&gt;val) {            p-&gt;next &#x3D; l1;            l1 &#x3D; l1-&gt;next;        } else {            p-&gt;next &#x3D; l2;            l2 &#x3D; l2-&gt;next;        }        p &#x3D; p-&gt;next;    }    if (l1)        p-&gt;next &#x3D; l1;    if (l2)        p-&gt;next &#x3D; l2;    return dummy.next;}&#x2F;&#x2F; merge sortstruct ListNode* sortList(struct ListNode* head) {    struct ListNode* front, * back;    if (!head || !head-&gt;next) return head;    split(head, &amp;front, &amp;back);    front &#x3D; sortList(front);    back &#x3D; sortList(back);    head &#x3D; merge(front, back);    return head;}



149 在同一条线上的点最多的线
    C++ 解答

1234567891011121314151617181920212223242526272829303132int maxPoints(vector&lt;Point&gt;&amp; points) {    if (points.size() &lt; 2) return points.size();    int result &#x3D; 0;    &#x2F;&#x2F; 对于每一个点    for (int i &#x3D; 0; i &lt; points.size(); i++) {        &#x2F;&#x2F; 经过该点的直线，使用分数作为斜率，避免使用浮点数        map&lt;pair&lt;int, int&gt;, int&gt; lines;        int localMax &#x3D; 0, overlap &#x3D; 0;        for (int j &#x3D; i + 1; j &lt; points.size(); j++) { &#x2F;&#x2F; 避免重复计算            if (points[j].x &#x3D;&#x3D; points[i].x &amp;&amp; points[j].y &#x3D;&#x3D; points[i].y) {                overlap++; &#x2F;&#x2F; 同一个点                continue;            } else {                int x &#x3D; points[j].x - points[i].x;                int y &#x3D; points[j].y - points[i].y;                int g &#x3D; gcd(x, y);                x &#x2F;&#x3D; g, y &#x2F;&#x3D; g; &#x2F;&#x2F; verticle case: x &#x3D;&#x3D; 0 -&gt; (0, 1)                lines[make_pair(x, y)]++;                localMax &#x3D; max(localMax, lines[make_pair(x, y)]);            }        }        &#x2F;&#x2F; overlap 算在任意条线上        result &#x3D; max(result, localMax + overlap + 1);    }    return result;}int gcd(int x, int y) {    if (y &#x3D;&#x3D; 0) return x;    else return gcd(y, x % y);}



150 后缀表达式求值
    C++ 解答

123456789101112131415161718192021222324252627bool is_operator(char t) {    return t &#x3D;&#x3D; &#39;+&#39; || t &#x3D;&#x3D; &#39;-&#39; || t &#x3D;&#x3D; &#39;*&#39; || t &#x3D;&#x3D; &#39;&#x2F;&#39;;}int calc(int left, char op, int right) {    switch(op) {        case &#39;+&#39;: return left + right;        case &#39;-&#39;: return left - right;        case &#39;*&#39;: return left * right;        case &#39;&#x2F;&#39;: return left &#x2F; right;    }}int evalRPN(vector&lt;string&gt;&amp; tokens) {    stack&lt;int&gt; nums;    for (auto&amp; token : tokens) {        if (is_operator(token[0]) &amp;&amp; token.size() &#x3D;&#x3D; 1) {            char op &#x3D; token[0];            int right_num &#x3D; nums.top();            nums.pop();            int left_num &#x3D; nums.top();            nums.pop();            nums.push(calc(left_num, op, right_num));        } else {            nums.push(stoi(token));        }    }    return nums.top();}



151 反转句子中的单词顺序一般面试的时候会假定没有多余字符的，解法是

    C 解答

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#96;&#96;&#96;&lt;&#x2F;details&gt;LeetCode 需要处理多余空格：&lt;details&gt;    &lt;summary&gt;C 解答&lt;&#x2F;summary&gt;&#96;&#96;&#96;Cvoid swap(char *a, char *b) {    char tmp &#x3D; *a; *a &#x3D; *b; *b &#x3D; tmp;}void reverse(char* start, char* end) {    while(start &lt; end)        swap(start++, end--);}void trim(char* s) {    char* fast, *slow;    for (fast &#x3D; s; *fast !&#x3D;&#39;\0&#39;; fast++) {        if (isspace(*fast)) {            while(isspace(*(fast + 1)) &amp;&amp; *(fast + 1) !&#x3D; 0)                fast++;            if(*(fast+1) &#x3D;&#x3D; 0)                break;            if(slow &#x3D;&#x3D; s)                continue;        }        swap(fast, slow++);    }    *slow &#x3D; 0;}void reverseWords(char *s) {    int len &#x3D; strlen(s);    if (len &#x3D;&#x3D; 0)        return;    trim(s);    len &#x3D; strlen(s);    if (len &#x3D;&#x3D; 0)        return;    reverse(s, s + len - 1);    char* head &#x3D; s, * tail &#x3D;s ;    while (*(tail + 1) !&#x3D; &#39;\0&#39;) {        tail &#x3D; head;        while (!isspace(*(tail + 1)) &amp;&amp; *(tail + 1) !&#x3D; &#39;\0&#39;)            tail++;        reverse(head, tail);    }}



152 最大子序列乘积
    C 解答

1234567891011121314int maxProduct(vector&lt;int&gt;&amp; A) {    int n &#x3D; A.size();    int r &#x3D; A[0];    for (int i &#x3D; 1, imax &#x3D; r, imin &#x3D; r; i &lt; n; i++) {        if (A[i] &lt; 0)            swap(imax, imin);        imax &#x3D; max(A[i], imax * A[i]);        imin &#x3D; min(A[i], imin * A[i]);        r &#x3D; max(r, imax);    }    return r;}



153 在旋转数组中查找最小值
    C 解答

12345678910111213int findMin(int* A, int n) {    int left &#x3D; 0; int right &#x3D; n - 1;    while (left &lt; right - 1) {        int mid &#x3D; left + (right - left) &#x2F; 2;        if (A[left] &gt; A[mid])            right &#x3D; mid;        else if (A[right] &lt; A[mid])            left &#x3D; mid;        else            right &#x3D; mid;    }    return A[left] &lt; A[right] ? A[left] : A[right];}



154 在旋转数组中查找最小值，可能有重复
    C 解答

1234567891011121314int findMin(int* A, int n) {    int left &#x3D; 0, right &#x3D; n - 1;    while (left &lt; right) {        int mid &#x3D; left + (right - left) &#x2F; 2;        if (A[mid] &gt; A[right]) { &#x2F;&#x2F; 当需要找的是 left，也就是较小的数字，使用 right 比较不需要等于号            left &#x3D; mid + 1;        } else if (A[right] &lt; A[mid]) {            right &#x3D; mid;        } else {            right--;        }    }    return A[left];}



155 设计一个栈，在普通栈的基础上支持 getmin 操作解法 1: 使用额外的栈，每个值都记录一个当前最小值，浪费空间
解法 2: 也是使用额外的栈，但是惰性记录，只有当需要更新的时候才去记录

    C++ 解答

12345678910111213141516171819202122232425class MinStack {private:    stack&lt;int&gt; m_stk;    stack&lt;int&gt; m_min;public:    void push(int x) {        if (x &lt;&#x3D; getMin())            m_min.push(x);        m_stk.push(x);    }    void pop() {        if (m_stk.top() &#x3D;&#x3D; getMin())            m_min.pop();        m_stk.pop();    }    int top() {        return m_stk.top();    }    int getMin() {        return m_min.empty() ? INT_MAX : m_min.top();    }};



156-159 Locked
160 求两个链表的交叉点分析题目可知，如果有一个交叉点，那么在这之后的所有点都是交叉的。这里有一个非常巧妙的做法。使用两个指针，如果到达结尾就指向另一个链表，会产生一下三种情况：

如果交叉点前面的节点数目相同，显然会返回正确节点。
如果不同假设 A 的节点为 a + c，B 的节点为 b + c，则在下一次遍历时： a + c + b &#x3D;&#x3D; b + c + a，恰好到达相同部分的第一个顶点 C1
如果两个列表不相交，那么经过 a + b, b + a 距离后，恰好都等于 NULL


    C 解答

12345678910111213struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {    if (!headA || !headB) return NULL;    struct ListNode *p1 &#x3D; headA, *p2&#x3D;headB;    while (p1 !&#x3D; p2) {        &#x2F;&#x2F; 两个列表手尾相接，如果有一个点相同，一定会返回        &#x2F;&#x2F; a + c + b &#x3D;&#x3D; b + c + a   --&gt; C1        &#x2F;&#x2F; a + b &#x3D;&#x3D; b + a    --&gt; NULL        p1 &#x3D; p1 ? p1-&gt;next : headB;        p2 &#x3D; p2 ? p2-&gt;next : headA;    }    return p1;}



161 Locked
162  找到极大值，给定一个数组，可能有多个极大值，找到任意一个即可，给定数组中 A[i] !&#x3D; A[i+1]题目要求在对数时间内做出来，二分搜索，如果中间的数在左半部分，就向右找。

    C 解答

1234567891011int findPeakElement(int* nums, int numsSize) {    int left &#x3D; 0, right &#x3D; numsSize - 1;    while (left &lt; right) {        int mid &#x3D; left + (right - left) &#x2F; 2;        if (nums[mid] &lt; nums[mid + 1]) &#x2F;&#x2F; mid in left part of summit            left &#x3D; mid + 1;        else                           &#x2F;&#x2F; mid in right part of summit            right&#x3D; mid;    }    return left;}



163 Locked
164 未排序数组中相差最大的两个数之间的差根据抽屉原理，最大差不可能小于 (max - min) &#x2F; (n - 1)。证明：如果小于，那么整个数组的大小就会小于 max - min。因此我们把
165 比较版本号大小
    C++ 解答

1234567891011121314151617181920212223242526272829vector&lt;int&gt; ver(const string&amp; version) {    vector&lt;int&gt; result;    int num &#x3D; 0;    for (auto c : version) {        if (c !&#x3D; &#39;.&#39;) {            num &#x3D; num * 10 + c - &#39;0&#39;;        } else {            result.push_back(num);            num &#x3D; 0;        }    }    &#x2F;&#x2F; 对于所有这种分割符中读取数字的都需要注意最后一个    result.push_back(num); &#x2F;&#x2F; notice here    return result;}int compareVersion(string version1, string version2) {    auto v1 &#x3D; ver(version1);    auto v2 &#x3D; ver(version2);    for (int i &#x3D; 0; i &lt; v1.size() || i &lt; v2.size(); i++) {        int a &#x3D; i &lt; v1.size() ? v1[i] : 0;        int b &#x3D; i &lt; v2.size() ? v2[i] : 0;        if (a !&#x3D; b)            return a &gt; b ? 1 : -1;    }    return 0;}



166 分数生成小数
    C++ 解答

1234567891011121314151617181920212223242526272829string fractionToDecimal(long numerator, long denominator) {    if (numerator &#x3D;&#x3D; 0) return &quot;0&quot;;    string result;    &#x2F;&#x2F; 符号    if (numerator &lt; 0 ^ denominator &lt; 0)        result +&#x3D; &quot;-&quot;;    long n &#x3D; abs(numerator), d &#x3D; abs(denominator);    &#x2F;&#x2F; 整数部分    result +&#x3D; to_string(n &#x2F; d);    if (n % d &#x3D;&#x3D; 0) return result;    &#x2F;&#x2F; 小数部分    result+&#x3D; &quot;.&quot;;    unordered_map&lt;int, int&gt; map;    for (long r &#x3D; n % d; r !&#x3D; 0; r %&#x3D; d) { &#x2F;&#x2F; 模拟手工除法        if (map.count(r) &gt; 0) {            result.insert(map[r], 1, &#39;(&#39;);            result +&#x3D; &quot;)&quot;;            break;        }        map[r] &#x3D; result.size(); &#x2F;&#x2F; 记录对应的位置，以便插入括号        r *&#x3D; 10; &#x2F;&#x2F; 从上借位        result +&#x3D; to_string(r &#x2F; d);    }    return result;}



167 Locked
168 生成 Excel 表格标题注意 A 对应的是 1 而不是 0，而且数字也是从 1 开始的

    C++ 解答

123456789string convertToTitle(int n) {    string title;    while (n) {        char c &#x3D; (n-1) % 26 + &#39;A&#39;;        n &#x3D; (n-1) &#x2F; 26;        title &#x3D; c + title;    }    return title;}



169 给定一个数组，有一个数字的出现频率超过了一半，找出这个数字非常经典的一道题，首先我们假设拿到的数字就是目标，并记录他出现的次数，如果下一个数字和他不一样，那么我们减一，当次数为 0 的时候，我们知道这个数字在已经遍历过的数字中出现小于一半了，这时候我们换下一个数字，最后剩下的一定是超过一半的数字。

    C++ 解答

123456789101112int majorityElement(vector&lt;int&gt;&amp; nums) {    int candidate, count &#x3D; 0;    for (auto i : nums) {        if (count &#x3D;&#x3D; 0 || candidate &#x3D;&#x3D; i) {            count++;            candidate &#x3D; i;        } else {            count--;        }    }    return candidate;}



170 Locked
171 Excel 标题转换为数字同样，我们需要注意 A 对应的是 1，而不是 0

    C 解答

123456int titleToNumber(char* s) {    int result &#x3D; 0;    while (*s)        result &#x3D; result * 26 + *s++ - &#39;A&#39; + 1;    return result;}



172 阶乘中能有几个 0显然先算出阶乘数字是会溢出的，而有 0 的话，就是需要 10，也就是就需要 2 和 5，显然 2 是比 5 多的。那么我们只要考虑 5 的个数就行了， 这时候需要注意，5&#x2F;15 等是算一个 5，而 25&#x2F;75 包含了两个 5，所以我们计算的时候，数一遍包含 5 的（这时 25 等也被计算了），然后再数一遍包含 25 的就像当于数了两次了。

    C 解答

12345678int trailingZeroes(int n) {    if (n &lt; 0)        return -1;    int fives &#x3D; 0;    for (int i &#x3D; 5; n &#x2F; i &gt; 0; i *&#x3D; 5)        fives +&#x3D; n &#x2F; i;    return fives;}



173 二叉树中序遍历迭代器
    C 解答

1234567891011121314151617181920212223242526272829303132333435class BSTIterator {public:    BSTIterator(TreeNode *root) {        pushAll(root);    }    &#x2F;** @return whether we have a next smallest number *&#x2F;    bool hasNext() {        return !m_stack.empty();    }    &#x2F;** @return the next smallest number *&#x2F;    int next() {        TreeNode* temp &#x3D; m_stack.top();        m_stack.pop();        pushAll(temp-&gt;right);        return temp-&gt;val;    }private:    stack&lt;TreeNode*&gt; m_stack;    void pushAll(TreeNode* root) {        while (root) {            m_stack.push(root);            root &#x3D; root-&gt;left;        }    }};&#x2F;** * Your BSTIterator will be called like this: * BSTIterator i &#x3D; BSTIterator(root); * while (i.hasNext()) cout &lt;&lt; i.next(); *&#x2F;



174 地下城游戏王子在格子的左上角，需要到右下角去救公主，在过程中王子不能死掉，和机器人走路一样，使用动态规划

    C++ 解答

1234567891011121314int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) {    int row &#x3D; dungeon.size();    int col &#x3D; dungeon[0].size();    vector&lt;vector&lt;int&gt;&gt; bloods(row + 1, vector&lt;int&gt; (col + 1, INT_MAX));    bloods[row][col-1] &#x3D; bloods[row-1][col] &#x3D; 1; &#x2F;&#x2F; 公主的两边    &#x2F;&#x2F; 从公主那里逆向推    for (int i &#x3D; row-1; i &gt;&#x3D; 0; i--) {        for (int j &#x3D; col-1; j &gt;&#x3D; 0; j--) {             int need &#x3D; min(bloods[i+1][j], bloods[i][j+1]) - dungeon[i][j]; &#x2F;&#x2F; 缺乏的血量 &#x3D; 到达下一步最少的血量 - 这一步消耗的血量             bloods[i][j] &#x3D; need &gt; 0 ? need : 1; &#x2F;&#x2F; 王子的血量至少为 1        }    }    return bloods[0][0];}



175-178 Missing179 最大的数字神奇的排序方法

    C++ 解答

123456789101112131415string largestNumber(vector&lt;int&gt;&amp; nums) {    vector&lt;string&gt; num_strings(nums.size());    for (int i &#x3D; 0; i &lt; nums.size(); i++)        num_strings[i] &#x3D; to_string(nums[i]);    auto comparator &#x3D; [] (string&amp; s1, string&amp; s2) {        return s1 + s2 &gt; s2 + s1;    };    sort(num_strings.begin(), num_strings.end(), comparator);    string result;    for (auto&amp; num_string: num_strings)        result +&#x3D; num_string;    int start &#x3D; result.find_first_not_of(&quot;0&quot;);    if (start &#x3D;&#x3D; string::npos) return &quot;0&quot;;    return result.substr(start);}



180-185 Missing186 Locked
187 找到所有 10 个字母唱的重复 DNA 序列
    C++ 解答

123456789101112&#x2F;&#x2F; naive 的做法从前往后，记录字符串&#x2F;&#x2F; 观察 ATCG 四个字符的特征，并把他们编码为一个 int&#x2F;&#x2F; 十个字符正好编码在 32bit 的 int 中vector&lt;string&gt; findRepeatedDnaSequences(string s) {    unordered_map&lt;int, int&gt; hash;    vector&lt;string&gt; result;    for (int t &#x3D; 0, i &#x3D; 0; i &lt; s.size(); i++)        &#x2F;&#x2F; 左移弹出老元素，求交为了只使用 30bit，求或添加新元素。        if (hash[t &#x3D; t &lt;&lt; 3 &amp; 0x3FFFFFFF | s[i] &amp; 0b111]++ &#x3D;&#x3D; 1) &#x2F;&#x2F; 等于 1 为了避免重复            result.push_back(s.substr(i - 9, 10));    return result;}



189 翻转树组
    C 解答

123456789101112131415161718void reverse(int* nums, int left, int right) {    while (left &lt; right) {        int temp &#x3D; nums[left];        nums[left] &#x3D; nums[right];        nums[right] &#x3D; temp;        left++;        right--;    }}void rotate(int* nums, int numsSize, int k) {    if (k &gt;&#x3D; numsSize) k %&#x3D; numsSize;    if (k &lt;&#x3D; 0) return;    reverse(nums, 0, numsSize - k - 1);    reverse(nums, numsSize - k, numsSize - 1);    reverse(nums, 0, numsSize - 1);}



190 翻转二进制表示
    C 解答

123456789101112uint32_t reverseBits(uint32_t n) {    uint32_t r &#x3D; 0;    int len &#x3D; sizeof(n) * 8 - 1;    while (len--) { &#x2F;&#x2F; 31 times shift        r |&#x3D; n &amp; 0x1;        n &gt;&gt;&#x3D; 1;        r &lt;&lt;&#x3D; 1; &#x2F;&#x2F; only shift 31 times    }    r |&#x3D; n &amp; 0x1;    return r;}



191 数字二进制表示中 1 的个数我们知道 n&amp;(n-1) 会把 n 中的最后一个 1 去掉，所以循环直到 n 为 0 即可

    C 解答

12345678int hammingWeight(uint32_t n) {    int count &#x3D; 0;    while (n) {        n &amp;&#x3D; n - 1;        count++;    }    return count;}



还可以采用查表法，对于表我们可以预先构造，或者利用上一个方法生成，对于长度过大的，我们可以分块查表。

    C 解答

1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int counts[16];int _get_count(n) {    int count &#x3D; 0;    while (n) {        n &amp;&#x3D; n-1;        count++;    }    return count;}int init_counts() {    for (int i &#x3D; 0; i &lt; 16; i++)        counts[i] &#x3D; _get_count(i);};int get_count(n) {    int count &#x3D; 0;    while (n) {        int index &#x3D; n &amp; 0xF;        count +&#x3D; counts[index];        n &gt;&gt;&#x3D; 4;    }    return count;}int main() {    init_counts();    for (int i &#x3D; 0; i &lt; 100; i++)        printf(&quot;%d: %d\n&quot;, _get_count(i), get_count(i));    return 0;}



192-197 Missing
198  有一排房子，每个房子中都有一定财产，但是不能偷相邻的两个房子，求能偷到的最大值使用 DP，对于每个房子，可以选择不偷或者前 i-1 个房子加上偷当前房子，即dp[i+1] &#x3D; max(dp[i], dp[i-1] + A[i])

    C 解答

12345678910111213int rob(int* nums, int numsSize) {    if (!nums) return 0;    &#x2F;&#x2F; 因为不能相邻，所以可以从相隔一个的取值    &#x2F;&#x2F; dp[n] &#x3D; max(dp[n-1], dp[n-2] + A[n])    int temp, m &#x3D; 0, n &#x3D; nums[0];    for (int i &#x3D; 1; i &lt; numsSize; i++) {        temp &#x3D; n;        if (m + nums[i] &gt; n)            n &#x3D; m + nums[i];        m &#x3D; temp;    }    return n;}



199 从右边看二叉树的效果
    C++ 解答

1234567891011121314151617181920212223&#x2F;&#x2F; level order 遍历vector&lt;int&gt; rightSideView(TreeNode* root) {    vector&lt;int&gt; result;    if (!root)        return result;    queue&lt;TreeNode*&gt; q;    q.push(root);    while (!q.empty()) {        TreeNode* node;        int len &#x3D; q.size(); &#x2F;&#x2F; 保存为了获得最后一个元素        for (int i &#x3D; 0; i &lt; len; i++) { &#x2F;&#x2F; 当前数组的最后一个元素就是最右边的元素            node &#x3D; q.front();            q.pop();            if (node-&gt;left)                q.push(node-&gt;left);            if (node-&gt;right)                q.push(node-&gt;right);        }        result.push_back(node-&gt;val);    }    return result;}



200 找出小岛的数量采用并查集，找到最后集合的数量

    C++ 解答

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class UnionFind {private:    vector&lt;int&gt; m_father, m_rank;    int m_count; &#x2F;&#x2F; sets countpublic:    UnionFind(int n): m_father(n), m_rank(n, 0), m_count(n) {        for (int i &#x3D; 0; i &lt; m_father.size(); i++)            m_father[i] &#x3D; i;    }    int find(int x) {        if (x !&#x3D; m_father[x])            m_father[x] &#x3D; find(m_father[x]);        return m_father[x];    }    void unionify(int x, int y) {        x &#x3D; find(x);        y &#x3D; find(y);        if (x &#x3D;&#x3D; y) return;        if (m_rank[x] &gt; m_rank[y]) {            m_father[y] &#x3D; x;        } else {            if (m_rank[x] &#x3D;&#x3D; m_rank[y])                m_rank[y]++;            m_father[x] &#x3D; y;        }        m_count--;    }    int getCount() {        return m_count;    }};class Solution {const static char LAND &#x3D; &#39;1&#39;;const static char WATER &#x3D; &#39;0&#39;;public:    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {        if (grid.empty() || grid[0].empty())            return 0;        int r &#x3D; grid.size(), c &#x3D; grid[0].size();        UnionFind uf(r * c + 1); &#x2F;&#x2F; extra element is for water        for (int i &#x3D; 0; i &lt; r; i++) {            for (int j &#x3D; 0; j &lt; c; j++) {                if (grid[i][j] &#x3D;&#x3D; LAND) {                    if (i !&#x3D; r - 1 &amp;&amp; grid[i+1][j] &#x3D;&#x3D; LAND)                         uf.unionify(i*c+j, (i+1)*c+j);                    if (j !&#x3D; c - 1 &amp;&amp; grid[i][j+1] &#x3D;&#x3D; LAND)                         uf .unionify(i*c+j, i*c+j+1);                } else {                    uf.unionify(i*c+j, c*r);                }            }        }        return uf.getCount() - 1; &#x2F;&#x2F; islands + water - 1;    }};





    python 解答

12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class UnionFind:    def __init__(self, count):        self.count &#x3D; count        self.parents &#x3D; list(range(count))  # 初始化时 parent 指针指向自己        self.ranks &#x3D; [1] * count  # 记录每棵树的大小    def union(self, p, q):        &quot;&quot;&quot;把 p, q 两个节点连通起来&quot;&quot;&quot;        p_root &#x3D; self.find(p)        q_root &#x3D; self.find(q)        if p_root &#x3D;&#x3D; q_root:            return        if self.ranks[p_root] &gt; self.ranks[q_root]:            self.parents[q_root] &#x3D; p_root        else:            if self.ranks[p_root] &#x3D;&#x3D; self.ranks[q_root]:                self.ranks[q_root] +&#x3D; 1            self.parents[p_root] &#x3D; q_root        self.count -&#x3D; 1    def find(self, p):        &quot;&quot;&quot;找到 p 节点的根节点&quot;&quot;&quot;        while self.parents[p] !&#x3D; p:            # 神奇的路径压缩            self.parents[p] &#x3D; self.parents[self.parents[p]]            p &#x3D; self.parents[p]        return p    def is_connected(self, p, q):        p_root &#x3D; self.find(p)        q_root &#x3D; self.find(q)        return p_root &#x3D;&#x3D; q_rootclass Solution:    def numIslands(self, grid: List[List[str]]) -&gt; int:        if not grid or not grid[0]:            return 0        m &#x3D; len(grid)        n &#x3D; len(grid[0])        uf &#x3D; UnionFind(m * n + 1)        for i in range(m):            for j in range(n):                if grid[i][j] &#x3D;&#x3D; &quot;1&quot;:                    up &#x3D; max(i - 1, 0)                    if grid[up][j] &#x3D;&#x3D; &quot;1&quot;:                        uf.union(i * n + j, up * n + j)                    left &#x3D; max(j - 1, 0)                    if grid[i][j - 1] &#x3D;&#x3D; &quot;1&quot;:                        uf.union(i * n + j, i * n + left)                else:                    uf.union(i * n + j, m * n)        return uf.count - 1



201 给定区间内，所有数字 AND 的结果显然直接过一遍是会超时的，那么分析可知

    C 解答

12345678910&#x2F;&#x2F; 如果两个数不相等，一定是有不同的位，那么这一位一定为 0int rangeBitwiseAnd(int m, int n) {    int t &#x3D; 0;    while (m !&#x3D; n) {        t++;        m &gt;&gt;&#x3D; 1;        n &gt;&gt;&#x3D; 1;    }    return m &lt;&lt; t;}



202 快乐数字，各位数字平方相加得到下一个数字，如果最后等于 1没啥，一直算就可以了。

    C++ 解答

1234567891011bool isHappy(int n) {    while (n &gt; 6) {        int next &#x3D; 0;        while (n) {            next +&#x3D; (n%10) * (n%10);            n &#x2F;&#x3D; 10;        }        n &#x3D; next;    }    return n &#x3D;&#x3D; 1;}



203 删除链表中给定的值
    C 解答

123456789101112131415struct ListNode* removeElements(struct ListNode* head, int val) {    struct ListNode dummy, *p &#x3D; &amp;dummy;    dummy.next &#x3D; head;    while (p) {        if (p-&gt;next &amp;&amp; p-&gt;next-&gt;val &#x3D;&#x3D; val) { &#x2F;&#x2F; not forward here            struct ListNode* next &#x3D; p-&gt;next;            p-&gt;next &#x3D; next-&gt;next;            free(next);        } else {            p &#x3D; p-&gt;next;        }    }    return dummy.next;}



204 找出素数什么筛子，忘了

    C++ 解答

123456789101112131415int countPrimes(int n) {    vector&lt;bool&gt; primes(n, true);    primes[0] &#x3D; primes[1] &#x3D; false;    for (int i &#x3D; 2; i * i &lt; n; i++) &#x2F;&#x2F; 注意，只到 sqrt(n)        if (primes[i])            for (int j &#x3D; i * i; j &lt; n; j +&#x3D; i) &#x2F;&#x2F; 从 i * i 开始，因为 i* i-- 已经被杀过了                primes[j] &#x3D; false;    int count &#x3D; 0;    for (int i &#x3D; 2; i &lt; n; i++)        if (primes[i])            count++;    return count;}



205 同构字符串，可以看作 word pattern 的简化
    C 解答

1234567891011121314bool isIsomorphic(char* s, char* t) {    int ss[256] &#x3D; { 0 };    int ts[256] &#x3D; { 0 };    if (strlen(s) !&#x3D; strlen(t))        return false;    int i &#x3D; 0;    while (s[i]) {        if (ss[s[i]] !&#x3D; ts[t[i]])            return false;        ss[s[i]] &#x3D; ts[t[i]] &#x3D; i + 1;        i++;    }    return true;}



206 反转链表tags: #pointers
最最基础的指针操作题目了

    Python 解答

12345678910class Solution:    def reverseList(self, head: ListNode) -&gt; ListNode:        prev &#x3D; None        curr &#x3D; head        while curr:            next &#x3D; curr.next            curr.next &#x3D; prev            prev &#x3D; curr            curr &#x3D; next        return prev  # 关键在这里





    C 解答

12345678910111213struct ListNode* reverseList(struct ListNode* head) {    if (!head || !head-&gt;next)        return head;    struct ListNode *p &#x3D; NULL, *cur &#x3D; head, *next;    while (cur) {        next &#x3D; cur-&gt;next; &#x2F;&#x2F; cache        cur-&gt;next &#x3D; p; &#x2F;&#x2F; reverse pointing        p &#x3D; cur; &#x2F;&#x2F; moves forwards        cur &#x3D; next;    }    return p;}





    C 解答

1&#x2F;&#x2F; recursive



207 标准的拓扑排序给定边这种方法表示图也是醉了

    C++ 解答

123456789101112131415161718192021222324bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) { &#x2F;&#x2F; next -&gt; before    vector&lt;unordered_set&lt;int&gt;&gt; graph(numCourses); &#x2F;&#x2F; 每条边和他的下一步，临接表    for (auto&amp; p : prerequisites)        graph[p.second].insert(p.first);    vector&lt;int&gt; d(numCourses, 0); &#x2F;&#x2F; in degree    for (auto&amp; nexts : graph)        for (auto next : nexts)            d[next]++;    for (int i &#x3D; 0; i &lt; numCourses; i++) {        int nondep; &#x2F;&#x2F; in degree &#x3D;&#x3D; 0        for (nondep &#x3D; 0; nondep &lt; numCourses &amp;&amp; d[nondep] !&#x3D; 0; nondep++)            ;        if (nondep &#x3D;&#x3D; numCourses)            return false;        d[nondep] &#x3D; -1; &#x2F;&#x2F; remove        for (auto next : graph[nondep]) &#x2F;&#x2F; 所有下一步都 －1            d[next]--;    }    return true;}




208 实现前缀树
    C++ 解答

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class TrieNode {public:    static const int branchCount &#x3D; 26;    bool isWord;    TrieNode* next[branchCount];    &#x2F;&#x2F; Initialize your data structure here.    TrieNode() : isWord(false) {        for (int i &#x3D; 0; i &lt; branchCount; i++)            next[i] &#x3D; NULL;    }};class Trie {public:    Trie() {        root &#x3D; new TrieNode();    }    &#x2F;&#x2F; Inserts a word into the trie.    void insert(string word) {        TrieNode* location &#x3D; root;        for (auto&amp; c : word) {            if (!location-&gt;next[c - &#39;a&#39;])                location-&gt;next[c - &#39;a&#39;] &#x3D; new TrieNode;            location &#x3D; location-&gt;next[c - &#39;a&#39;];        }        location-&gt;isWord &#x3D; true;    }    &#x2F;&#x2F; Returns if the word is in the trie.    bool search(string word) {        TrieNode* location &#x3D; root;        for (auto&amp; c : word) {            location &#x3D; location-&gt;next[c - &#39;a&#39;];            if (!location)                return false;        }        return location-&gt;isWord;    }    &#x2F;&#x2F; Returns if there is any word in the trie    &#x2F;&#x2F; that starts with the given prefix.    bool startsWith(string prefix) {        TrieNode* location &#x3D; root;        for (auto&amp; c : prefix) {            location &#x3D; location-&gt;next[c - &#39;a&#39;];            if (!location)                return false;        }        return true;    }private:    TrieNode* root;};&#x2F;&#x2F; Your Trie object will be instantiated and called as such:&#x2F;&#x2F; Trie trie;&#x2F;&#x2F; trie.insert(&quot;somestring&quot;);&#x2F;&#x2F; trie.search(&quot;key&quot;);



209 最短子数组使得和大于某个数双指针，超过和之后再尝试从开始处减去元素

    C++ 解答

123456789101112int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) {    int start &#x3D; 0, sum &#x3D; 0, len &#x3D; INT_MAX;    for (int i &#x3D; 0; i &lt; nums.size(); i++) {        sum +&#x3D; nums[i];        while (sum &gt;&#x3D; s) {            len &#x3D; min(len, i - start + 1);            sum -&#x3D; nums[start++];        }    }    return len &#x3D;&#x3D; INT_MAX? 0 : len;}



210 Course Schedule IIBFS

    C++ 解答

123456789101112131415161718192021222324252627282930313233343536class Solution {public:    vector&lt;int&gt; findOrder(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) {        vector&lt;unordered_set&lt;int&gt;&gt; graph &#x3D; make_graph(numCourses, prerequisites);        vector&lt;int&gt; degrees &#x3D; compute_indegree(graph);        queue&lt;int&gt; zeros;        for (int i &#x3D; 0; i &lt; numCourses; i++)            if (!degrees[i]) zeros.push(i);        vector&lt;int&gt; toposort;        for (int i &#x3D; 0; i &lt; numCourses; i++) {            if (zeros.empty()) return {};            int zero &#x3D; zeros.front();            zeros.pop();            toposort.push_back(zero);            for (int neigh : graph[zero]) {                if (!--degrees[neigh])                    zeros.push(neigh);            }        }        return toposort;    }private:    vector&lt;unordered_set&lt;int&gt;&gt; make_graph(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) {        vector&lt;unordered_set&lt;int&gt;&gt; graph(numCourses);        for (auto pre : prerequisites)            graph[pre.second].insert(pre.first);        return graph;    }    vector&lt;int&gt; compute_indegree(vector&lt;unordered_set&lt;int&gt;&gt;&amp; graph) {        vector&lt;int&gt; degrees(graph.size(), 0);        for (auto neighbors : graph)            for (int neigh : neighbors)                degrees[neigh]++;        return degrees;    }};



211 添加和搜索字符串
    C++ 解答

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class TrieNode {public:    static const int branchCount &#x3D; 26;    bool isWord;    TrieNode* next[branchCount];    &#x2F;&#x2F; Initialize your data structure here.    TrieNode() : isWord(false) {        for (int i &#x3D; 0; i &lt; branchCount; i++)            next[i] &#x3D; NULL;    }};class Trie {public:    Trie() {        root &#x3D; new TrieNode();    }    &#x2F;&#x2F; Inserts a word into the trie.    void insert(string word) {        TrieNode* location &#x3D; root;        for (auto&amp; c : word) {            if (!location-&gt;next[c - &#39;a&#39;])                location-&gt;next[c - &#39;a&#39;] &#x3D; new TrieNode;            location &#x3D; location-&gt;next[c - &#39;a&#39;];        }        location-&gt;isWord &#x3D; true;    }    &#x2F;&#x2F; Returns if the word is in the trie.    virtual bool search(string word) {        TrieNode* location &#x3D; root;        for (auto&amp; c : word) {            location &#x3D; location-&gt;next[c - &#39;a&#39;];            if (!location)                return false;        }        return location-&gt;isWord;    }    &#x2F;&#x2F; Returns if there is any word in the trie    &#x2F;&#x2F; that starts with the given prefix.    bool startsWith(string prefix) {        TrieNode* location &#x3D; root;        for (auto&amp; c : prefix) {            location &#x3D; location-&gt;next[c - &#39;a&#39;];            if (!location)                return false;        }        return true;    }    TrieNode* getRoot() {        return root;    }private:    TrieNode* root;};class WordDictionary : public Trie{public:    WordDictionary() : Trie(){}    &#x2F;&#x2F; Adds a word into the data structure.    void addWord(string word) {        insert(word);    }    &#x2F;&#x2F; Returns if the word is in the data structure. A word could    &#x2F;&#x2F; contain the dot character &#39;.&#39; to represent any one letter.    bool search(string word) override {        return search(word.c_str(), getRoot());    }    bool search(const char* word, TrieNode* root) {        TrieNode* run &#x3D; root;        for (int i &#x3D; 0; word[i]; i++) {            if (run &amp;&amp; word[i] !&#x3D; &#39;.&#39;)                run &#x3D; run-&gt;next[word[i] - &#39;a&#39;];            else if (run &amp;&amp; word[i] &#x3D;&#x3D; &#39;.&#39;) {                &#x2F;&#x2F; skip checking this char                TrieNode* tmp &#x3D; run;                for (int j &#x3D; 0; j &lt; 26; j++) {                    run &#x3D; tmp-&gt;next[j];                    if (search(word + i + 1, run))                        return true;                }            }            else break;        }        return run &amp;&amp; run-&gt;isWord;    }};&#x2F;&#x2F; Your WordDictionary object will be instantiated and called as such:&#x2F;&#x2F; WordDictionary wordDictionary;&#x2F;&#x2F; wordDictionary.addWord(&quot;word&quot;);&#x2F;&#x2F; wordDictionary.search(&quot;pattern&quot;);



212 单词搜索Trie 结构见前面，注意要记录 visited，还有边界的问题，另外集合的使用

    C++ 解答

12345678910111213141516171819202122232425262728293031323334353637383940class Solution {private:    Trie m_trie;public:    vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) {        for (auto&amp; word : words)            m_trie.insert(word);        int row &#x3D; board.size();        int col &#x3D; board[0].size();        unordered_set&lt;string&gt; result_set;        vector&lt;vector&lt;bool&gt;&gt; visited(row, vector&lt;bool&gt;(col, false));        for (int i &#x3D; 0; i &lt; row; i++)            for(int j &#x3D; 0; j &lt; col; j++)                find(result_set, board, visited, &quot;&quot;, i, j);        vector&lt;string&gt; result;        for (auto&amp; r : result_set)            result.push_back(r);        return result;    }    void find(unordered_set&lt;string&gt;&amp; r, vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, string word, int i, int j) {        if (i &lt; 0 || i &gt;&#x3D; board.size() || j &lt; 0 || j &gt;&#x3D; board[0].size() || visited[i][j])            return;        word +&#x3D; board[i][j];        if (!m_trie.startsWith(word))            return;        if (m_trie.search(word))            r.insert(word);        visited[i][j] &#x3D; true;        find(r, board, visited, word, i-1, j);        find(r, board, visited, word, i+1, j);        find(r, board, visited, word, i, j-1);        find(r, board, visited, word, i, j+1);        visited[i][j] &#x3D; false;    }};



213 小偷偷环状数组
    C 解答

123456789101112131415161718192021int max(int a, int b) {    return a &gt; b ? a : b;}int robNonCyclic(int* nums, int numsSize) {    if (!nums) return 0;    &#x2F;&#x2F; 因为不能相邻，所以可以从相隔一个的取值    &#x2F;&#x2F; dp[n] &#x3D; max(dp[n-1], dp[n-2] + A[n])    int temp, m &#x3D; 0, n &#x3D; nums[0];    for (int i &#x3D; 1; i &lt; numsSize; i++) {        temp &#x3D; n;        if (m + nums[i] &gt; n)            n &#x3D; m + nums[i];        m &#x3D; temp;    }    return n;}int rob(int* nums, int numsSize) {    return max(robNonCyclic(nums, numsSize - 1), robNonCyclic(nums + 1, numsSize - 1));}




214 最短回文字符串，给指定的字符串添加字母获得回文
    C++ 解答

12345678910111213141516&#x2F;&#x2F; based on kmp next arraystring shortestPalindrome(string s) {    string rev_s &#x3D; s;    reverse(rev_s.begin(), rev_s.end());    string l &#x3D; s + &quot;#&quot; + rev_s;    vector&lt;int&gt; p(l.size(), 0);    for (int i &#x3D; 1; i &lt; l.size(); i++) {        int j &#x3D; p[i - 1];        while (j &gt; 0 &amp;&amp; l[i] !&#x3D; l[j])            j &#x3D; p[j - 1];        p[i] &#x3D; (j +&#x3D; l[i] &#x3D;&#x3D; l[j]);    }    return rev_s.substr(0, s.size() - p[l.size() - 1]) + s;}



215 数组中第 k 大的数字实际上这道题更可能的题目是找到前 k 大的所有数字。首先，设计到数组排序的问题一定向面试官要问清楚数据量的大小，这影响到接下来的实现，同时和面试官探讨数据量大小对实现的影响，有助于更好的把握局面。
我们先假设数据量是比较小的，也就是能够放到内存中。

使用排序就实在是 naive 了，不过面试官非要问的话，当然是使用选择排序更好了。
使用快排中的 partition 算法，时间复杂度 O(n*logk)。
使用 size 为 k 的堆，时间复杂度也是 O(n*logk)，不管数字多大，都只需要遍历一遍。
使用类似插入排序的方法，保持数组大小不变，这样的时间复杂度是 O(n*k)。
数据的范围有限时候，使用计数排序。

当数据过大的时候，我们可以想通过哈希取模之后把文件分组，找出每个文件中最大的 k 个数字
如果数字中有重复呢？使用计数排序，计数强制按一算如果既有重复又是浮点数呢？

    C 解答

12345678910111213141516171819202122232425262728int swap(int* a, int* b) {    int t &#x3D; *a;    *a &#x3D; *b;    *b &#x3D; t;}int partition(int* nums, int start, int end) {    int small &#x3D; start - 1;    int pivot &#x3D; nums[end];    for (int i &#x3D; start; i &lt; end; i++)        if (nums[i] &lt; pivot)            swap(&amp;nums[++small], &amp;nums[i]);    swap(&amp;nums[++small], &amp;nums[end]);    return small;}int findKthLargest(int* nums, int numsSize, int k) {    int left &#x3D; 0, right &#x3D; numsSize - 1;    while (1) {        int index &#x3D; partition(nums, left, right);        if (index &#x3D;&#x3D; numsSize - k)            return nums[index];        if (index &gt; numsSize - k)            right &#x3D; index - 1;        else            left &#x3D; index + 1;    }}



216 找到 k 个数字 [1…9]，使得他们的和是 n
    C++ 解答

1234567891011121314151617181920vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) {    vector&lt;vector&lt;int&gt;&gt; result;    dfs(result, {}, n, k);    return result;}void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; combination, int n, int k) {    if (combination.size() &#x3D;&#x3D; k) {        if (n &#x3D;&#x3D; 0)            result.push_back(combination);        return;    }    int i &#x3D; combination.empty() ? 1 : combination.back() + 1; &#x2F;&#x2F; 保证不重复切实递增序列    while (i &lt;&#x3D; n &amp;&amp; i &lt; 10) {        combination.push_back(i);        dfs(result, combination, n-i, k);        combination.pop_back();        i++;    }}



217 包含重复数字这道题太简单了，也没有什么精妙的解法，可以使用排序，Hash 等多种解法

    C++ 解答

123456789bool containsDuplicate(vector&lt;int&gt;&amp; nums) {    unordered_set&lt;int&gt; s;    for (auto&amp; n : nums)        if (s.find(n) !&#x3D; s.end())            return true;        else            s.insert(n);    return false;}



218 获得矩形重合部分的拐点抄过来的，还没仔细研究

    C++ 解答

1234567891011121314151617181920212223vector&lt;pair&lt;int, int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) {    vector&lt;pair&lt;int, int&gt;&gt; res;    int cur&#x3D;0, cur_X, cur_H &#x3D;-1,  len &#x3D; buildings.size();    priority_queue&lt; pair&lt;int, int&gt;&gt; liveBlg; &#x2F;&#x2F; first: height, second, end time    while(cur&lt;len || !liveBlg.empty()) { &#x2F;&#x2F; if either some new building is not processed or live building queue is not empty        cur_X &#x3D; liveBlg.empty()? buildings[cur][0]:liveBlg.top().second; &#x2F;&#x2F; next timing point to process        if(cur&gt;&#x3D;len || buildings[cur][0] &gt; cur_X) { &#x2F;&#x2F;first check if the current tallest building will end before the next timing point              &#x2F;&#x2F; pop up the processed buildings, i.e. those  have height no larger than cur_H and end before the top one            while(!liveBlg.empty() &amp;&amp; ( liveBlg.top().second &lt;&#x3D; cur_X) ) liveBlg.pop();        } else { &#x2F;&#x2F; if the next new building starts before the top one ends, process the new building in the vector            cur_X &#x3D; buildings[cur][0];            while(cur&lt;len &amp;&amp; buildings[cur][0]&#x3D;&#x3D; cur_X)  &#x2F;&#x2F; go through all the new buildings that starts at the same point            {  &#x2F;&#x2F; just push them in the queue                liveBlg.push(make_pair(buildings[cur][2], buildings[cur][1]));                cur++;            }        }        cur_H &#x3D; liveBlg.empty()?0:liveBlg.top().first; &#x2F;&#x2F; outut the top one        if(res.empty() || (res.back().second !&#x3D; cur_H) ) res.push_back(make_pair(cur_X, cur_H));    }    return res;}



219 包含重复数字，并且两个的坐标不超过 k
    C++ 解答

12345678910111213141516171819&#x2F;&#x2F; 滑动窗口保存前 k 个值，如果有重复的就返回&#x2F;&#x2F; num[i-k] num[i-1]，如果滑过了，就删除该元素bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {    unordered_set&lt;int&gt; s;    if (k &lt;&#x3D; 0)        return false;    if (k &gt;&#x3D; nums.size()) &#x2F;&#x2F; notice here        k &#x3D; nums.size() - 1;    for (int i &#x3D; 0; i &lt; nums.size(); i++) {        if (i &gt; k)            s.erase(nums[i - k - 1]); &#x2F;&#x2F; delete first note        if (s.find(nums[i]) !&#x3D; s.end())            return true;        s.insert(nums[i]); &#x2F;&#x2F; insert    }    return false;}



220 同上一题，同时保证两个数字之间小于 t保证两个数字之差小于 t

    C++ 解答

12345678910111213141516bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) {    set&lt;int&gt; window; &#x2F;&#x2F; 注意不能使用 unordered    if (k &lt;&#x3D; 0)        return false;    if (k &gt;&#x3D; nums.size()) &#x2F;&#x2F; notice here        k &#x3D; nums.size() - 1;    for (int i &#x3D; 0; i &lt; nums.size(); i++) {        if (i &gt; k)            window.erase(nums[i - k - 1]);        auto pos &#x3D; window.lower_bound(nums[i] - t); &#x2F;&#x2F; notice set.lower_bound        if (pos !&#x3D; window.end() &amp;&amp; *pos - nums[i] &lt;&#x3D; t)            return true;        window.insert(nums[i]);    }    return false;}



221 找到最大的正方形使用动态规划 https:&#x2F;&#x2F;leetcode.com&#x2F;discuss&#x2F;38489&#x2F;easy-solution-with-detailed-explanations-8ms-time-and-space

    C++ 解答

123456789101112131415161718int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {    if (matrix.empty()) return 0;    int m &#x3D; matrix.size(), n &#x3D; matrix[0].size();    vector&lt;int&gt; dp(m + 1, 0);    int maxsize &#x3D; 0, pre &#x3D; 0;    for (int j &#x3D; 0; j &lt; n; j++) { &#x2F;&#x2F; 每一列        for (int i &#x3D; 1; i &lt;&#x3D; m; i++) { &#x2F;&#x2F; notice i range            int temp &#x3D; dp[i];            if (matrix[i - 1][j] &#x3D;&#x3D; &#39;1&#39;) {                dp[i] &#x3D; min(dp[i], min(dp[i - 1], pre)) + 1;                maxsize &#x3D; max(maxsize, dp[i]);            }            else dp[i] &#x3D; 0;            pre &#x3D; temp;        }    }    return maxsize * maxsize;}




222 给定一个完全树，计算节点的数量。
    C++ 解答

1234567891011121314151617181920int countNodes(struct TreeNode* root) {    if (!root)             return 0;    int left_height &#x3D; 0, right_height &#x3D; 0;    struct TreeNode* left &#x3D; root, *right &#x3D; root;    while (left) {        left &#x3D; left-&gt;left;        left_height++;    }    while (right) {        right &#x3D; right-&gt;right;        right_height++;    }    if (left_height &#x3D;&#x3D; right_height) &#x2F;&#x2F; 满树 2^h - 1        return (1 &lt;&lt; left_height) - 1;    return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1;}



223 找出两个长方形覆盖的面积
    C 解答

12345678910int computeArea(int left1, int down1, int right1, int up1, int left2, int down2, int right2, int up2) {    int left &#x3D; max(left1, left2); &#x2F;&#x2F; 靠右的    int right &#x3D; max(min(right1, right2), left);&#x2F;&#x2F; 靠左的，但是比左边大    int down &#x3D; max(down1, down2);    int up &#x3D; max(min(up1, up2), down);    &#x2F;&#x2F; 不小心写反了。    return -((left1 - right1) * (up1 - down1) + (left2 - right2) * (up2 - down2) - (left - right) * (up - down));}



224 给定一个字符串，包含加减和括号，计算值难点是对括号的处理，注意每次都要和 signs.top() 相乘

    C++ 解答

1234567891011121314151617181920212223242526272829int calculate(string s) {    stack&lt;int&gt; signs; &#x2F;&#x2F; signs before braces    int sign &#x3D; 1;    int num &#x3D; 0;    int result &#x3D; 0;    signs.push(1);    for (auto c : s) {        if (isdigit(c)) {            num &#x3D; 10 * num + (c - &#39;0&#39;);        } else if (c &#x3D;&#x3D; &#39;+&#39; || c &#x3D;&#x3D; &#39;-&#39;) {            result +&#x3D; signs.top() * sign * num;            num &#x3D; 0;            sign &#x3D; c &#x3D;&#x3D; &#39;+&#39; ? 1 : -1;        } else if (c &#x3D;&#x3D; &#39;(&#39;) {            signs.push(sign * signs.top()); &#x2F;&#x2F; tricky            sign &#x3D; 1;        } else if (c &#x3D;&#x3D; &#39;)&#39;) {            result +&#x3D; signs.top() * sign * num;            num &#x3D; 0;            signs.pop();            sign &#x3D; 1;        }    }    result +&#x3D; signs.top() * sign * num; &#x2F;&#x2F; tricky    return result;}



225 使用队列模拟栈其实有两种做法，一种是在 push 的时候，把队列清空，把 x 放到最底下。另一种是在 pop 的时候，把队列清空到 1，然后弹出。应当询问面试官究竟是 push 居多还是 pop 居多

    C++ 解答

123456789101112131415161718192021222324252627282930313233class Stack {public:    &#x2F;&#x2F; Push element x onto stack.    void push(int x) {        while (!nums.empty()) {            temp.push(nums.front());            nums.pop();        }        nums.push(x);        while (!temp.empty()) {            nums.push(temp.front());            temp.pop();        }    }    &#x2F;&#x2F; Removes the element on top of the stack.    void pop() {        nums.pop();    }    &#x2F;&#x2F; Get the top element.    int top() {        return nums.front();    }    &#x2F;&#x2F; Return whether the stack is empty.    bool empty() {        return nums.empty();    }private:    queue&lt;int&gt; nums;    queue&lt;int&gt; temp;};



226 反转二叉树
    C 解答

1234567struct TreeNode* invertTree(struct TreeNode* root) {    if (!root) return NULL;    struct TreeNode* temp &#x3D; root-&gt;left;    root-&gt;left &#x3D; invertTree(root-&gt;right);    root-&gt;right &#x3D; invertTree(temp);    return root;}



227 给定一个字符串包含 +-*&#x2F; 计算他的值
    C++ 解答

1234567891011121314151617181920212223242526272829303132333435363738int calculate(string s) {    vector&lt;int&gt; stk; &#x2F;&#x2F; 使用 vector 便于统计最后的值    char token &#x3D; &#39;+&#39;;    int num &#x3D; 0;    for (int i &#x3D; 0; i &lt; s.size(); i++) {        if (isdigit(s[i]))            num &#x3D; num * 10 + s[i] - &#39;0&#39;;        &#x2F;&#x2F; 这里不是 else if        if (s[i] &#x3D;&#x3D; &#39;+&#39; || s[i] &#x3D;&#x3D; &#39;-&#39; || s[i] &#x3D;&#x3D; &#39;*&#39; || s[i] &#x3D;&#x3D; &#39;&#x2F;&#39; || i &#x3D;&#x3D; s.size() - 1) { &#x2F;&#x2F; 注意最后一步还需要把最后的值计算            int a;            switch (token) {            case &#39;+&#39;:                stk.push_back(num);                break;            case &#39;-&#39;:                stk.push_back(-num);                break;            case &#39;*&#39;:                a &#x3D; stk.back();                stk.pop_back();                stk.push_back(a * num);                break;            case &#39;&#x2F;&#39;:                a &#x3D; stk.back();                stk.pop_back();                stk.push_back(a &#x2F; num);                break;            };            token &#x3D; s[i];            num &#x3D; 0;        }    }    int result &#x3D; 0;    for (auto i : stk)        result +&#x3D; i;    return result;}



228 聚合区间，给定一排序数组，把相邻的数字用区间表示
    C++ 解答

123456789101112131415161718vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) {    int n &#x3D; nums.size();    vector&lt;string&gt; result;    if (n &#x3D;&#x3D; 0) return result;    for (int i &#x3D; 0; i &lt; n; ) {        int start &#x3D; i, end &#x3D; i;        while (end + 1 &lt; n &amp;&amp; nums[end + 1] &#x3D;&#x3D; nums[end] + 1)            end++;        if (end &gt; start)            result.push_back(to_string(nums[start]) + &quot;-&gt;&quot; + to_string(nums[end]));        else            result.push_back(to_string(nums[start]));        i &#x3D; end + 1;    }    return result;}



229 找出超过三分之一的元素
    C++ 解答

1234567891011121314151617181920212223242526272829303132vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) {    int count1 &#x3D; 0, count2 &#x3D; 0;    int a, b;    for (auto n : nums) {        if (count1 &#x3D;&#x3D; 0 || n &#x3D;&#x3D; a) {            count1++;            a &#x3D; n;        } else if (count2 &#x3D;&#x3D; 0 || n &#x3D;&#x3D; b) {            count2++;            b &#x3D; n;        } else {            count1--;            count2--;        }    }    count1 &#x3D; count2 &#x3D; 0;    for (int n : nums) {        if (n &#x3D;&#x3D; a) count1++;        if (n &#x3D;&#x3D; b) count2++;    }    vector&lt;int&gt; result;    if (count1 &gt; nums.size() &#x2F; 3) &#x2F;&#x2F; verify a        result.push_back(a);    if (count2 &gt; nums.size() &#x2F; 3 &amp;&amp; a !&#x3D; b) &#x2F;&#x2F; verify b        result.push_back(b);    return result;}



230 二叉树中第 k 小的数字
    C 解答

1234567891011121314151617&#x2F;&#x2F; 传递指针void inorder(struct TreeNode* root, int* k, int* number) {    if (!root)        return;    inorder(root-&gt;left, k, number);    (*k)--;    if (*k &#x3D;&#x3D; 0) {        *number &#x3D; root-&gt;val;        return;    }    inorder(root-&gt;right, k, number);}int kthSmallest(struct TreeNode* root, int k) {    int number;    inorder(root, &amp;k, &amp;number);    return number;}



231 2 的次方
    C 解答

1234bool isPowerOfTwo(int n) {    if (n &lt;&#x3D; 0) return false;    return (n &amp; (n - 1)) &#x3D;&#x3D; 0;}





    Rust 解答

12345678impl Solution {    pub fn is_power_of_two(n: i32) -&gt; bool {        if n &lt;&#x3D; 0 {            return false;        }        (n &amp; (n-1)) &#x3D;&#x3D; 0    }}



232 使用栈模拟队列
    C++ 解答

123456789101112131415161718192021222324252627282930313233343536373839class Queue {public:    &#x2F;&#x2F; Push element x to the back of queue.    void push(int x) {        in.push(x);    }    &#x2F;&#x2F; Removes the element from in front of queue.    void pop(void) {        if (empty())            return;        if (out.empty())            transfer();        out.pop();    }    &#x2F;&#x2F; Get the front element.    int peek(void) {        if (empty())            return INT_MIN;        if (out.empty())            transfer();        return out.top();    }    &#x2F;&#x2F; Return whether the queue is empty.    bool empty(void) {        return in.empty() &amp;&amp; out.empty();    }private:    void transfer() {        while (!in.empty()) {            out.push(in.top());            in.pop();        }    };    stack&lt;int&gt; in;    stack&lt;int&gt; out;};



233 小于 n 的数字中 1 的个数对于每一位，有三种情况：

当是数字 0 的时候，可能出先 1 的情况完全由高位出现决定，因为这一位不能贡献 1
当是数字 1 的时候，同上，但是这一位和低位一起可以贡献一个 1
当时数字 2-9 的时候，相当于这一位的 1 可以任意出现，因此高位＋1


    C 解答

12345678910111213int countDigitOne(int n) {    int ones &#x3D; 0;    for (int m &#x3D; 1; m &lt;&#x3D; n; m *&#x3D; 10) { &#x2F;&#x2F; m is the factor        int a &#x3D; n&#x2F;m, b &#x3D; n%m;  &#x2F;&#x2F; a is left half, b is right half        if (a % 10 &gt;&#x3D; 2)            ones +&#x3D; (a &#x2F; 10 + 1) * m;        if (a % 10 &#x3D;&#x3D; 1)            ones +&#x3D; (a &#x2F; 10) * m + b + 1;        if (a % 10 &#x3D;&#x3D; 0)            ones +&#x3D; (a &#x2F; 10) * m;    }    return ones;}



二进制呢

    C 解答

12345678910int countDigitOneBinary(int n) {    int ones &#x3D; 0;    for (int m &#x3D; 1; m &lt;&#x3D; n; m &lt;&lt;&#x3D; 1) {        int a &#x3D; n &#x2F; m, b &#x3D; n % m;        if (a &amp; 0x01)            ones +&#x3D; (a &gt;&gt; 1) * m + b + 1;        else            ones +&#x3D; (a &gt;&gt; 1) * m;    }}



求最大的 countDigitOne(n) &#x3D;&#x3D; n
9    1
99   20
999  300
...
99999999  10000000

234 判断一个链表是否是回文解法 1: 如果链表是可以改变的，不妨反转它的前半部分，然后再与后半部分比较
解法 2: 如果是只读的，复制一份也可以，但是不如使用堆栈
注意对奇数偶数的处理

    C++ 解答

123456789101112131415161718192021222324252627282930313233bool isPalindrome(ListNode* head) {    if (!head || !head-&gt;next)        return true;    int len &#x3D; 0;    ListNode* temp &#x3D; head;    while (temp) {        len++;        temp &#x3D; temp-&gt;next;    }    stack&lt;int&gt; stk;    temp &#x3D; head;    int mid &#x3D; len &#x2F; 2;    while (mid--) {        stk.push(temp-&gt;val);        temp &#x3D; temp-&gt;next;    }    if (len &amp; 0x01)        temp &#x3D; temp-&gt;next;    while (temp !&#x3D; NULL &amp;&amp; !stk.empty()) {        int a &#x3D; stk.top();        stk.pop();        int b &#x3D; temp-&gt;val;        temp &#x3D; temp-&gt;next;        if (a !&#x3D; b) {            return false;        }    }    return true;}



235 二叉搜索树公共祖先
    C 解答

12345678910struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {    while (root) {        if (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)            root &#x3D; root-&gt;left;        else if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)            root &#x3D; root-&gt;right;        else            return root;    }}



236 二叉树公共祖先如果二叉树的根就是其中一个节点，那显然是这个。在两颗子树中分别查找，如果找到了，返回一个非 NULL 值，如果都找到了，则这个节点就是 LCA

    C 解答

123456789101112struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {    if (!root || root &#x3D;&#x3D; p || root &#x3D;&#x3D; q)        return root;    struct TreeNode* left &#x3D; lowestCommonAncestor(root-&gt;left, p, q);    struct TreeNode* right &#x3D; lowestCommonAncestor(root-&gt;right, p, q);    if (!left) &#x2F;&#x2F; not in left subtree        return right;    if (!right)        return left;    return root; &#x2F;&#x2F; both left and right are found!}



237 删除链表中的元素直接将后继节点的值复制到当前节点

    C 解答

12345678void deleteNode(struct ListNode* node) {    if (!node || !node-&gt;next)        return;    struct ListNode* next &#x3D; node-&gt;next;    node-&gt;val &#x3D; next-&gt;val;    node-&gt;next &#x3D; next-&gt;next;    free(next);}



238 数组除了自己以外的乘积，规定不能用除法首先从前往后乘，错开一位元素，这样每个元素都乘到了他之前的所有元素，最后一个元素已经是结果了。然后从后往前乘，同样错开一位，这样每个元素又把他之后的元素都得到了。
239 滑动窗口最大值，给定一个滑动窗口，返回它移动过程中的最大值单调队列的应用，复杂度是 O(n) 的。

    Python 解答

12345678910111213141516171819202122232425262728293031323334353637from collections import dequeclass MonoQueue:    def __init__(self):        self.q &#x3D; deque()  # 实际储存数据        self.m &#x3D; deque()  # 维护单调关系，队首元素总是最大值    def push(self, x):        self.q.append(x)        while len(self.m) &gt; 0 and self.m[-1] &lt; x:            self.m.pop()        self.m.append(x)    def pop(self):        x &#x3D; self.q.popleft()        if self.m[0] &#x3D;&#x3D; x:            self.m.popleft()        return x    def __len__(self):        return len(self.q)    def top(self):        return self.m[0]class Solution:    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:        q &#x3D; MonoQueue()        for i in range(k):            q.push(nums[i])        ans &#x3D; []        for i in range(k, len(nums)):            ans.append(q.top())            q.pop()            q.push(nums[i])        ans.append(q.top())        return ans



另一种现在我已经看不懂的做法

    C++ 解答

1234567891011121314151617&#x2F;&#x2F; 题目给定 k 一定是有效地vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {    vector&lt;int&gt; result;    if (nums.empty() || k &lt;&#x3D; 0)        return result;    deque&lt;int&gt; dq; &#x2F;&#x2F; 存储的是索引，front 存储最大值，保证递减    for (int i &#x3D; 0; i &lt; nums.size(); i++) {        while (!dq.empty() &amp;&amp; dq.front() &lt; i - k + 1) &#x2F;&#x2F; 弹出滑过的窗口            dq.pop_front();        while (!dq.empty() &amp;&amp; nums[dq.back()] &lt; nums[i]) &#x2F;&#x2F; 弹出小的            dq.pop_back();        dq.push_back(i);        if (i &gt;&#x3D; k - 1)            result.push_back(nums[dq.front()]);    }    return result;}



240 给定一个矩阵，每行从左到右都是增大的，每一列从上到下都是增大的，找出给定数字是否存在我们考虑右上角的元素

如果这个元素比 taget 大，那么整列都比 target 大，我们可以 c–
如果这个元素比 target 小，那么正行都比 target 小，我们可以 r++


    C 解答

1234567891011bool searchMatrix(int** matrix, int row, int col, int target) {    int r &#x3D; 0, c &#x3D; col - 1; &#x2F;&#x2F; 右上角    while (r &lt; row &amp;&amp; c &gt; -1) &#x2F;&#x2F; 向左下角        if (matrix[r][c] &#x3D;&#x3D; target)            return true;        else if (matrix[r][c] &gt; target)            c--;        else            r++;    return false;}



241 添加括号得到不同的结果对每一个符号，在他的两边添加括号的好的不同结果再计算。

    C++ 解答

1234567891011121314vector&lt;int&gt; diffWaysToCompute(string input) {    vector&lt;int&gt; output;    for (int i &#x3D; 0; i &lt; input.size(); i++) {        char token &#x3D; input[i];        if (!isdigit(token)) &#x2F;&#x2F; not digit            for (int a : diffWaysToCompute(input.substr(0, i))) &#x2F;&#x2F; 左半部分                for (int b : diffWaysToCompute(input.substr(i+1))) &#x2F;&#x2F; 右半部分                    output.push_back(token &#x3D;&#x3D; &#39;+&#39; ? a + b : token &#x3D;&#x3D; &#39;-&#39;? a - b: a *b); &#x2F;&#x2F; 两半部分之和    }    if (output.empty())        output.push_back(stoi(input));    return output;}



242 一个单词是否能由另一个变幻而来还是，对于 ASCII 字符，直接用数组代替字典

    C 解答

123456789101112bool isAnagram(char* s, char* t) {    char ss[26] &#x3D; {0};    char ts[26] &#x3D; {0};    while (*s) {        ss[*s - &#39;a&#39;]++;        s++;        ts[*t - &#39;a&#39;]++;        t++;    }    if (*t) return false;    return memcmp(ss, ts, sizeof(ss)) &#x3D;&#x3D; 0;}



243-256 Locked
257 二叉树左右路径典型的 DFS，发挥所有从根节点到叶节点的路径

    C++ 解答

12345678910111213141516171819vector&lt;string&gt; binaryTreePaths(TreeNode* root) {    vector&lt;string&gt; result;    if (!root) return result;    paths(result, &quot;&quot;, root);    return result;}void paths(vector&lt;string&gt;&amp; result, string path, TreeNode* root) {    if (path.empty())        path +&#x3D; to_string(root-&gt;val);    else        path +&#x3D; &quot;-&gt;&quot; + to_string(root-&gt;val);    if (root-&gt;left)        paths(result, path, root-&gt;left);    if (root-&gt;right)        paths(result, path, root-&gt;right);    if (!root-&gt;left &amp;&amp; !root-&gt;right)        result.push_back(path);}



258 把数字的每一位加起来，直到变成一个一位的数字这完全是一道数学题，对于每个进制的数字都有规律 (n - 1) % (x - 1) + 1。实际上是把 10 进制的转化为 9 进制数字

    C 解答

123int addDigits(int num) {    return (num - 1) % 9 + 1;}



259 Locked
260 给定一个数组，每个数字都是重复的，只有两个数字不是，找出这两个数字这道题很奇妙，依然可以使用 XOR 来解，首先遍历一遍，这时候由于有两个数字是不同的，那么一定结果不为 0，那么其中一个 bit 位一定是一个数字有，另一个数字没有。在遍历一遍，同时把数字分两组，一组是有这个 bit 位，一组没有。就得出了结果。

    C++ 解答

1234567891011121314vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) {    int r &#x3D; 0;    for (auto&amp; n : nums)        r ^&#x3D; n;    int bit &#x3D; r &amp; -r; &#x2F;&#x2F; last sig bit    vector&lt;int&gt; result &#x3D; {0, 0};    for (auto&amp; n : nums)        if (n &amp; bit)            result[0] ^&#x3D; n;        else            result[1] ^&#x3D; n;    return result;}



261 262 Locked
263 丑陋的数字，质数因子只含有 2,3,5 的数字按定义做就好了

    C 解答

12345678910111213141516bool isUgly(int n) {    if (n &lt;&#x3D; 0)        return false;    if (n &#x3D;&#x3D; 1)        return true;    while (n &gt; 1)        if (n % 2 &#x3D;&#x3D; 0)            n &#x2F;&#x3D; 2;        else if (n % 3 &#x3D;&#x3D; 0)            n &#x2F;&#x3D; 3;        else if (n % 5 &#x3D;&#x3D; 0)            n &#x2F;&#x3D; 5;        else            return false;    return true;}



264 找出第 n 个丑陋数字使用数列记录 n 个丑陋数字，每一个丑陋数字肯定是之前数字乘以 235 得到的，然后用三个指针分别指向上一个做乘法的数字，每次找出最小的一个

    C 解答

12345678910111213141516171819#define MIN(a,b) ((a)&lt;(b)?(a):(b))int nthUglyNumber(int n) {    if (n &lt;&#x3D; 0)        return -1;    if (n &lt; 6) &#x2F;&#x2F; 1..6 恰好都是        return n;    int s2 &#x3D; 0, s3 &#x3D; 0, s5 &#x3D; 0;    int* uglies[n];    uglies[0] &#x3D; 1;    for (int i &#x3D; 1; i &lt; n; i++) {        int c2 &#x3D; uglies[s2] * 2, c3 &#x3D; uglies[s3] * 3, c5 &#x3D; uglies[s5] * 5;        uglies[i] &#x3D; MIN(c2, MIN(c3, c5));        if (uglies[i] &#x3D;&#x3D; c2) s2++;        if (uglies[i] &#x3D;&#x3D; c3) s3++;        if (uglies[i] &#x3D;&#x3D; c5) s5++;    }    return uglies[n-1];}



268 丢失的数字，给定 0…n，丢失了一个，然后放在长度为 n 的数组之中，找出这个数字显然还是使用异或，注意 0 ^ x &#x3D;&#x3D; x，所以直接把 0 忽略就行了。把每个数字都和 i 异或，丢失的数字就出来了

    C 解答

123456int missingNumber(int* nums, int n) {    int result &#x3D; 0;    for (int i &#x3D; 0; i &lt; n; i++)        result &#x3D; result ^ (i + 1) ^ nums[i];    return result;}



269-272 Locked
273 数字转换为英语单词
    C++ 解答

12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution {public:    vector&lt;string&gt; digits &#x3D; {&quot;&quot;, &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;, &quot;Six&quot;, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;, &quot;Ten&quot;, &quot;Eleven&quot;, &quot;Twelve&quot;, &quot;Thirteen&quot;, &quot;Fourteen&quot;, &quot;Fifteen&quot;, &quot;Sixteen&quot;, &quot;Seventeen&quot;, &quot;Eighteen&quot;, &quot;Nineteen&quot;};    vector&lt;string&gt; tens &#x3D; {&quot;&quot;, &quot;&quot;, &quot;Twenty&quot;, &quot;Thirty&quot;, &quot;Forty&quot;, &quot;Fifty&quot;, &quot;Sixty&quot;, &quot;Seventy&quot;, &quot;Eighty&quot;, &quot;Ninety&quot;};    vector&lt;string&gt; seps &#x3D; {&quot;&quot;, &quot; Thousand &quot;, &quot; Million &quot;, &quot; Billion &quot;}; &#x2F;&#x2F; notice the trailing spaces    string numberToWords(int num) {        if (num &#x3D;&#x3D; 0)            return &quot;Zero&quot;;        if (num &lt; 0)            return &quot;Negative &quot; + numberToWords(-num);        int count &#x3D; 0;        string result;        while (num) {            if (num % 1000 !&#x3D; 0)                result &#x3D; s2word(num % 1000) + seps[count] + result;            num &#x2F;&#x3D; 1000;            count++;        }        &#x2F;&#x2F; removw unnecessary tailing space        if (isspace(result.back()))            result.resize(result.size() - 1);        return result;    }    string s2word(int num) {        string result;        if (num &gt;&#x3D; 100) {            result +&#x3D; digits[num&#x2F;100] + &quot; Hundred &quot;;            num %&#x3D; 100;        }        if (num &gt;&#x3D; 20) {            result +&#x3D; tens[num &#x2F; 10] + &quot; &quot;;            num %&#x3D; 10;        }        if (num &gt;&#x3D; 1 &amp;&amp; num &lt;&#x3D; 19)            result +&#x3D; digits[num];        &#x2F;&#x2F; remove tailing spaces        if (isspace(result.back()))            result.resize(result.size() - 1);        return result;    }};



274 H-IndexH-Index 的定义：一个科学家的 N 篇论文 h 个至少有 h 个引用，而且剩下的 N-h 篇论文都没有超过 h 个引用。

    C 解答

123456789101112131415161718192021int hIndex(int* cites, int n) {    int hs[n+1]; &#x2F;&#x2F; Hindex 不可能大于 N    for (int i &#x3D; 0; i &lt;&#x3D; n; i++)        hs[i] &#x3D; 0;    for (int i &#x3D; 0; i &lt; n; i++) {        if (cites[i] &gt; n)            hs[n]++;        else            hs[cites[i]]++;    }    for (int i &#x3D; n, papers &#x3D; 0; i &gt;&#x3D; 0; i--) { &#x2F;&#x2F; 从后往前，如果有符合条件的，那么就是 Hindex        papers +&#x3D; hs[i];        if (papers &gt;&#x3D; i)            return i;    }    return 0;}



275 H-index II，论文已经按照引用数量排序
    C 解答

12345678910111213int hIndex(int* citations, int n) {    int left &#x3D; 0, right &#x3D; n - 1;    while (left &lt;&#x3D; right) { &#x2F;&#x2F; 二分查找是小于等于        int mid &#x3D; left + (right - left) &#x2F; 2;        if (citations[mid] &#x3D;&#x3D; n - mid)            return citations[mid];        else if (citations[mid] &lt; n - mid)            left &#x3D; mid + 1;        else            right &#x3D; mid - 1;    }    return n - right - 1;}



276-277 Locked
278 第一个坏版本
    C 解答

123456789101112&#x2F;&#x2F; 实际上是 lower_bound 函数int firstBadVersion(int n) {    int left &#x3D; 0, right &#x3D; n; &#x2F;&#x2F; 记住 lower_bound 的 right 是 n    while (left &lt; right) {   &#x2F;&#x2F; 使用小于号        int mid &#x3D; left + (right - left) &#x2F; 2;        if (!isBadVersion(mid))            left &#x3D; mid + 1;        else            right &#x3D; mid;    }    return left;}



279 分解为平方数的和最多 4 个即可，尝试在三个以内是否可以。

    C 解答

1234567891011int numSquares(int n) {    int ub &#x3D; sqrt(n);    for (int a&#x3D;0; a&lt;&#x3D;ub; ++a) {        for (int b&#x3D;a; b&lt;&#x3D;ub; ++b) {            int c &#x3D; sqrt(n - a*a - b*b);            if (a*a + b*b + c*c &#x3D;&#x3D; n)                return !!a + !!b + !!c;        }    }    return 4;}



282 添加运算符使得算式成立
    C++ 解答

123456789101112131415161718192021vector&lt;string&gt; addOperators(string num, int target) {    vector&lt;string&gt; result;    if (num.size() &#x3D;&#x3D; 0)        return result;    dfs(num, target, result, num[0] - &#39;0&#39;, num.substr(0, 1), 1, 1);    return result;}void dfs(string num, int target, vector&lt;string&gt; &amp; v, long long last, string s, int idx, int left) {    if (idx &#x3D;&#x3D; num.length()){        if (target &#x3D;&#x3D; last*left)            v.push_back(s);        return;    } else {        if(last!&#x3D;0)            dfs(num, target,         v, last * 10 + num[idx] - &#39;0&#39;, s + num.substr(idx, 1), idx + 1, left); &#x2F;&#x2F; 尝试拼成 10        dfs(num, target,             v, num[idx] - &#39;0&#39;, s + &#39;*&#39; + num.substr(idx, 1), idx + 1, last*left);        dfs(num, target - left*last, v, num[idx] - &#39;0&#39;, s + &#39;+&#39; + num.substr(idx, 1), idx + 1, 1);        dfs(num, target - left*last, v, num[idx] - &#39;0&#39;, s + &#39;-&#39; + num.substr(idx, 1), idx + 1, -1);    }}



283 移动 0注意 swap 的使用

    C++ 解答

1234567void moveZeroes(vector&lt;int&gt;&amp; nums) {    int n &#x3D; 0;    for (int i &#x3D; 0; i &lt; nums.size(); i++) {        if (nums[i] !&#x3D; 0)            swap(nums[n++], nums[i]);    }}



284 Peek Iterator
    C++ 解答

12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;&#x2F; Below is the interface for Iterator, which is already defined for you.&#x2F;&#x2F; **DO NOT** modify the interface for Iterator.class Iterator {    struct Data;    Data* data;public:    Iterator(const vector&lt;int&gt;&amp; nums);    Iterator(const Iterator&amp; iter);    virtual ~Iterator();    &#x2F;&#x2F; Returns the next element in the iteration.    int next();    &#x2F;&#x2F; Returns true if the iteration has more elements.    bool hasNext() const;};class PeekingIterator : public Iterator {public:    PeekingIterator(const vector&lt;int&gt;&amp; nums) : Iterator(nums) {        &#x2F;&#x2F; Initialize any member here.        &#x2F;&#x2F; **DO NOT** save a copy of nums and manipulate it directly.        &#x2F;&#x2F; You should only use the Iterator interface methods.    }    &#x2F;&#x2F; Returns the next element in the iteration without advancing the iterator.    int peek() {        return Iterator(*this).next();    }    &#x2F;&#x2F; hasNext() and next() should behave the same as in the Iterator interface.    &#x2F;&#x2F; Override them if needed.    int next() {        return Iterator::next();    }    bool hasNext() const {        return Iterator::hasNext();    }};



285 ~ 286 Locked287 一个 n 的数组包含了 1…n-1 中的这些数字，证明一定存在重复，并找出这个重复使用抽屉原理可以证明一定存在重复。据说高纳德解这个问题花了四个小时。
我们把这个数组看做一个变幻方程 f(i) &#x3D; A[i]，把一些数字变幻到另一些，那么存在一个 i !&#x3D; j s.t. f(i) &#x3D;&#x3D; f(j).那么这个问题变成了链表求环的问题。对于链表，我们有 n &#x3D; n-&gt;next 遍历列表，对于这个序列，则是 n &#x3D; f(n)

    C 解答

12345678910111213141516int findDuplicate(int* nums, int n) {    &#x2F;&#x2F; 从 n-1 开始    int fast &#x3D; n - 1, slow &#x3D; n - 1;    do {        slow &#x3D; nums[slow] - 1; &#x2F;&#x2F; 减一是为了转化为坐标        fast &#x3D; nums[nums[fast] - 1] - 1;    } while (slow !&#x3D; fast);    fast &#x3D; n - 1;    do {        slow &#x3D; nums[slow] - 1;        fast &#x3D; nums[fast] - 1;    } while (slow !&#x3D; fast);    return slow + 1; &#x2F;&#x2F; 从坐标到数字}



288 Locked289 Conway’s Game of Life哈哈，机智，使用没有使用的第二个位存储下一代

    C 解答

1234567891011121314151617int max(int a, int b) {return a &gt; b ? a :b;}int min(int a, int b) {return a &lt; b ? a :b;}void gameOfLife(int** board, int row, int col) {    for (int i &#x3D; 0; i &lt; row; i++) {        for (int j &#x3D; 0; j &lt; col; j++) {            int count &#x3D; 0;            for (int m&#x3D;max(i-1, 0); m&lt;min(i+2, row); m++) &#x2F;&#x2F; 这里的 min，max 使用的太屌了                for (int n&#x3D;max(j-1, 0); n&lt;min(j+2, col); n++)                    count +&#x3D; (board[m][n] &amp; 1);            if (count &#x3D;&#x3D; 3 || count - board[i][j] &#x3D;&#x3D; 3) &#x2F;&#x2F; 当前为 0，周围为 3；or 当前为 1，周围为 2&#x2F;3 here                board[i][j] |&#x3D; 2;        }    }    for (int i &#x3D; 0; i &lt; row; i++)        for (int j &#x3D; 0; j &lt; col; j++)            board[i][j] &gt;&gt;&#x3D; 1;}



290 单词模式，给定一个模式 abba 等，判断单词是否是这个模式的。
    C++ 解答

12345678910111213bool wordPattern(string pattern, string str) {    map&lt;char, int&gt; chars;  &#x2F;&#x2F; 使用两个 map 纪录    map&lt;string, int&gt; words;    istringstream in(str);    int i &#x3D; 0, n &#x3D; pattern.size(); &#x2F;&#x2F; &#96;i&#96; is word count    for (string word; in &gt;&gt; word; i++) {        if (i &#x3D;&#x3D; n || chars[pattern[i]] !&#x3D; words[word]) &#x2F;&#x2F; 检查是否相等            return false;        chars[pattern[i]] &#x3D; words[word] &#x3D; i + 1; &#x2F;&#x2F; distinct non zero    }    return i &#x3D;&#x3D; n; &#x2F;&#x2F; 检查长度是否相等}



291 Locked292 Nim 游戏，每个人可以选择丢掉 1，2，3，最后一个操作者获胜显然，当我们遇到 4 的时候会输，其他情况都可以赢。

    C 解答

123bool canWinNim(int n) {    return n % 4 !&#x3D; 0;}



300 最长递增子序列最经典的动态规划题目

    Python 解答

123456789101112class Solution:    def lengthOfLIS(self, nums: List[int]) -&gt; int:        if not nums:            return 0        if len(nums) &#x3D;&#x3D; 1:            return 1        dp &#x3D; [1 for _ in range(len(nums))]        for i in range(len(nums)):            for j in range(i):                if nums[i] &gt; nums[j]:                    dp[i] &#x3D; max(dp[i], dp[j] + 1)        return max(*dp)



344 翻转字符串
    C 解答

123456789101112131415char* reverseString(char* s) {    char* start &#x3D; s;    char* e &#x3D; s;    while (*e) ++e;    e--;    char t;    while (s &lt; e) {        t &#x3D; *s;        *s &#x3D; *e;        *e &#x3D; t;        s++;        e--;    }    return start;}



347 出现最多的几个数字C 实在缺乏相关的基础数据结构，这道题用 JS 做了

    JavaScript 解答

1234567891011121314151617181920212223242526272829303132333435363738&#x2F;** * @param {number[]} nums * @param {number} k * @return {number[]} *&#x2F;let topKFrequent &#x3D; function(nums, k) {    let counter &#x3D; {};    for (let num of nums) {        if (num in counter) {            counter[num]++;        } else {            counter[num] &#x3D; 0;        }    }    let bucket &#x3D; [];    for (let num in counter) {        let rev_freq &#x3D; nums.length - counter[num] + 1;        if (rev_freq in bucket) {            bucket[rev_freq].push(num);        } else {            bucket[rev_freq] &#x3D; [num];        }    }    let rv &#x3D; [];    for (let bc of bucket) {        if (! Array.isArray(bc)) continue;        for (let num of bc) {            if (rv.length &#x3D;&#x3D; k)                return rv;            else                rv.push(parseInt(num))        }    }    return rv;};



349 两个数组中都出现的元素先排序，降低复杂度

    C 解答

1234567891011121314151617181920212223242526static int compare(const void* a, const void* b) {    return *(int*)a - *(int*)b;}int* intersection(int* A, int m, int* B, int n, int* k) {    qsort(A, m, sizeof(int), compare);    qsort(B, n, sizeof(int), compare);    int* C &#x3D; malloc((m + n) * sizeof(int));    *k &#x3D; 0;    int i &#x3D; 0;    int j &#x3D; 0;    while (i &lt; m &amp;&amp; j &lt; n) {        if (A[i] &#x3D;&#x3D; B[j]) {            if (*k &#x3D;&#x3D; 0)                C[(*k)++] &#x3D; A[i];            else if (C[*k - 1] !&#x3D; A[i])                C[(*k)++] &#x3D; A[i];            i++;            j++;        } else if (A[i] &lt; B[j]) {            i++;        } else {            j++;        }    }    return C;}




345 翻转一个字符串里面的元音字母使用两个指针，不过需要注意元音字母包括了大小写

    Python 解答

1234567891011121314151617181920212223class Solution:    def reverseVowels(self, s):        &quot;&quot;&quot;        :type s: str        :rtype: str        &quot;&quot;&quot;        if not s:            return s        vowels &#x3D; set(&quot;AEIOUaeiou&quot;)        s &#x3D; list(s)        i &#x3D; 0        j &#x3D; len(s) - 1        while True:            while s[i] not in vowels and i &lt; j:                i +&#x3D; 1            while s[j] not in vowels and i &lt; j:                j -&#x3D; 1            if i &gt;&#x3D; j:                break            s[i], s[j] &#x3D; s[j], s[i]            i +&#x3D; 1            j -&#x3D; 1        return &#39;&#39;.join(s)



371 两个数之和这道题要求不用 + 和 - 来计算出两个数之和，显然应该使用位运算，使用异或计算每一位的值，在使用或计算是否需要进位

    C 解答

1234567891011121314151617int getSum(int a, int b) {    int rv &#x3D; 0;    int carry &#x3D; 0;    for (int i &#x3D; 0; i &lt; 32; i++) {        int last_bit_of_a &#x3D; a &amp; 1;        int last_bit_of_b &#x3D; b &amp; 1;        rv |&#x3D; (last_bit_of_a ^ last_bit_of_b ^ carry) &lt;&lt; i;        carry &#x3D; (carry &amp; last_bit_of_a) | (carry &amp; last_bit_of_b) | (last_bit_of_a &amp; last_bit_of_b);        a &gt;&gt;&#x3D; 1;        b &gt;&gt;&#x3D; 1;    }    return rv;}



388使用栈的一道简单题目, 其实计算长度部分还可以优化

    Python 解答

1234567891011121314151617181920class Solution:    def lengthLongestPath(self, input: str) -&gt; int:        path &#x3D; []        ans &#x3D; 0        for name in input.split(&quot;\n&quot;):            l &#x3D; 0            for c in name:                if c &#x3D;&#x3D; &quot;\t&quot;:                    l +&#x3D; 1                else:                    break            if len(path) &gt; l:                for i in range(len(path) - l):                    path.pop()            path.append(name.strip(&quot;\t&quot;))            if &quot;.&quot; in name:                length &#x3D; sum([len(p) for p in path]) + len(path) - 1                ans &#x3D; max(ans, length)                print(path)        return ans



435 无重叠区间不要被题目迷惑，从反面开始思考，求去除多少个区间其实就是求最多有多少个有效区间

    Python 解答

12345678910class Solution:    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:        intervals.sort(key&#x3D;lambda x: x[1])        max_intervals &#x3D; 0        end &#x3D; float(&quot;-inf&quot;)        for interval in intervals:            if interval[0] &gt;&#x3D; end:                max_intervals +&#x3D; 1                end &#x3D; interval[1]        return len(intervals) - max_intervals



482 注册码格式化要求每 K 个字符添加一个 “-“, 如果不够的话，第一个分组可以不全。

    Python 解答

1234567891011121314class Solution:    def licenseKeyFormatting(self, S: str, K: int) -&gt; str:        key &#x3D; []        i &#x3D; 0        for c in reversed(S):            if c &#x3D;&#x3D; &quot;-&quot;:                continue            key.append(c.upper())            i +&#x3D; 1            if i % K &#x3D;&#x3D; 0:                key.append(&quot;-&quot;)        if key and key[-1] &#x3D;&#x3D; &quot;-&quot;:            key &#x3D; key[:-1]        return &quot;&quot;.join(reversed(key))



547 朋友圈UnionFind 的定义见第 200 题

    Python 解答

123456789class Solution:    def findCircleNum(self, M: List[List[int]]) -&gt; int:        n &#x3D; len(M)        uf &#x3D; UnionFind(n)        for i in range(n):            for j in range(i):                if M[i][j] &#x3D;&#x3D; 1:                    uf.union(i, j)        return uf.count



739单调栈的简单应用

    Python 解答

123456789101112class Solution:    def dailyTemperatures(self, T: List[int]) -&gt; List[int]:        stack &#x3D; []        ans &#x3D; [0] * len(T)        for i in range(len(T)-1, -1, -1):            # 如果当前温度大于当前最低温度            while stack and T[i] &gt;&#x3D; T[stack[-1]]:                stack.pop()            if stack:                ans[i] &#x3D; stack[-1] - i            stack.append(i)        return ans



864 矩形重叠
    Python 解答

123456class Solution:    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -&gt; bool:        # 注意要包含等于号        x_overlap &#x3D; not(rec1[0] &gt;&#x3D; rec2[2] or rec1[2] &lt;&#x3D; rec2[0])        y_overlap &#x3D; not(rec1[1] &gt;&#x3D; rec2[3] or rec1[3] &lt;&#x3D; rec2[1])        return x_overlap and y_overlap




904 找出包含了两个不同数字的最长子序列这道题的题目很坑爹，但是翻译过来其实要求很明确。解题思路也很简单，存储一下当前的最长序列就好了。

    C++ 解答

123456789101112131415161718192021222324252627282930313233&#96;&#96;&#96;&lt;&#x2F;details&gt;&lt;details&gt;    &lt;summary&gt;Rust 解答&lt;&#x2F;summary&gt;&#96;&#96;&#96;Rustuse std::collections::HashMap;use std::cmp::max;impl Solution {    pub fn total_fruit(tree: Vec&lt;i32&gt;) -&gt; i32 {        let mut i &#x3D; 0;        let mut res &#x3D; 0;        let mut counter &#x3D; HashMap::new();        for (j, el) in tree.iter().enumerate() {            *counter.entry(el).or_insert(0) +&#x3D; 1;            while counter.len() &gt; 2 {                *counter.get_mut(&amp;tree[i]).unwrap() -&#x3D; 1;                if let Some(x) &#x3D; counter.get(&amp;tree[i]) {                    if *x &#x3D;&#x3D; 0 {                        counter.remove(&amp;tree[i]);                    }                }                i +&#x3D; 1;            }            res &#x3D; max(res, j - i + 1);        }        res as i32    }}



986 区间列表的交集tags: #interval

    Python 解答

1234567891011121314class Solution:    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -&gt; List[List[int]]:        i, j &#x3D; 0, 0        ans &#x3D; []        while i &lt; len(A) and j &lt; len(B):            lo &#x3D; max(A[i][0], B[j][0])            hi &#x3D; min(A[i][1], B[j][1])            if lo &lt;&#x3D; hi:                ans.append((lo, hi))            if A[i][1] &lt; B[j][1]:                i +&#x3D; 1            else:                j +&#x3D; 1        return ans



929 唯一邮件地址类似 Gmail 的规则，. 去掉，+ 后面的也去掉。但是要注意域名中的 . 不能去掉

    Python 解答

123456789101112131415class Solution:    def normalize(self, username: str) -&gt; str:        username &#x3D; username.replace(&#39;.&#39;, &quot;&quot;)        # 使用 split 更好，懒得改了        username &#x3D; re.sub(r&quot;\+.*$&quot;, &quot;&quot;, username)        return username    def numUniqueEmails(self, emails: List[str]) -&gt; int:        unique_emails &#x3D; set()        for email in emails:            username, domain &#x3D; email.split(&quot;@&quot;)            username &#x3D; self.normalize(username)            # print(username, domain)            unique_emails.add(f&quot;{username}@{domain}&quot;)        return len(unique_emails)



970 强力数字暴力解法

    python 解答

1234567891011121314import mathclass Solution:    def powerfulIntegers(self, x: int, y: int, bound: int) -&gt; List[int]:        if bound &lt;&#x3D; 0:            return []        ans &#x3D; set()        limit &#x3D; int(math.log2(bound)) + 1        for i in range(limit):            for j in range(limit):                v &#x3D; x ** i + y ** j                if v &lt;&#x3D; bound:                    ans.add(v)        return list(ans)



1272 删除区间
    python 解答

12345678910111213class Solution:    def removeInterval(self, intervals: List[List[int]], toBeRemoved: List[int]) -&gt; List[List[int]]:        lo, hi &#x3D; toBeRemoved        ans &#x3D; []        for x, y in intervals:            if y &lt; lo or x &gt; hi:                ans.append([x, y])            else:                if lo &gt; x:                    ans.append([x, lo])                if hi &lt; y:                    ans.append([hi, y])        return ans



1317 将整数转换为两个无零整数的和
    python 解答

1234567class Solution:    def getNoZeroIntegers(self, n: int) -&gt; List[int]:        for a in range(1, n):            b &#x3D; n - a            if &quot;0&quot; not in str(a) and &quot;0&quot; not in str(b):                return [a, b]        return []



1389 按既定顺序创建目标数组
    Python 解答

123456class Solution:    def createTargetArray(self, nums: List[int], index: List[int]) -&gt; List[int]:        target &#x3D; []        for n, i in zip(nums, index):            target &#x3D; target[:i] + [n] + target[i:]        return target



1390 四因数解释见注释，这道题还是很坑的。不过其实也很简单，四个因数就是能够分解成两个质数乘积或者是立方数。
比如：

21 &#x3D; 3 * 7
8 &#x3D; 2 * 4


    py 解答

123456789101112131415161718192021222324252627282930313233343536class Solution:    def sumFourDivisors(self, nums) -&gt; int:        if not nums:            return 0        if len(nums) &#x3D;&#x3D; 1:            upper &#x3D; nums[0]        else:            upper &#x3D; max(*nums)        # 首先在这里筛选素数        isPrim &#x3D; [True for _ in range(upper)]        i &#x3D; 2        while i * i &lt; upper:            if isPrim[i]:                j &#x3D; i * i                while j &lt; upper:                    isPrim[j] &#x3D; False                    j +&#x3D; i            i +&#x3D; 1        # 把素数都提取出来        prims &#x3D; [i for i in range(2, upper) if isPrim[i]]        ans &#x3D; 0        for num in nums:            for prim in prims:                # 已经不可能了，后续不算了                if prim * prim &gt; num:                    break                # 立方数是符合的，这个比较坑，开始没想到，比如 8                if prim * prim * prim &#x3D;&#x3D; num:                    ans +&#x3D; (1 + num + prim + prim * prim)                    break                # 可以分解成两个质数乘积                if num % prim &#x3D;&#x3D; 0 and isPrim[num &#x2F;&#x2F; prim] and prim * prim !&#x3D; num:                    ans +&#x3D; (1 + num + prim + num &#x2F;&#x2F; prim)                    break        return ans





















</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E"><span class="nav-number"></span> <span class="nav-text">一、编程之美</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%E5%B0%86%E5%B8%85%E9%97%AE%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">1.2 中国象棋将帅问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-14-%E8%BF%9E%E8%BF%9E%E7%9C%8B"><span class="nav-number"></span> <span class="nav-text">1.14 连连看</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-2-6-LeetCode"><span class="nav-number"></span> <span class="nav-text">2.1 - 2.6 LeetCode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">2.7 最大公约数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-%E7%9C%8B%E4%B8%8B%E8%AE%B2%E8%A7%A3"><span class="nav-number"></span> <span class="nav-text">2.8 看下讲解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-9-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-number"></span> <span class="nav-text">2.9 斐波那契数列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-11-%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9%E9%97%AE%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">2.11 最近点对问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-12-2-14-LeetCode-2-15-Cracking-2-16-2-17-LeetCode"><span class="nav-number"></span> <span class="nav-text">2.12-2.14 LeetCode 2.15 Cracking 2.16 2.17 LeetCode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-18-%E6%95%B0%E7%BB%84%E5%88%86%E5%89%B2"><span class="nav-number"></span> <span class="nav-text">2.18 数组分割</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-19-LeetCode"><span class="nav-number"></span> <span class="nav-text">2.19 LeetCode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E6%9C%89%E6%97%B6%E9%97%B4%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E5%86%99%E4%B8%80%E4%B8%8B"><span class="nav-number"></span> <span class="nav-text">3.1 有时间可以尝试写一下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E5%AF%B9%E5%BA%94%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D"><span class="nav-number"></span> <span class="nav-text">3.2 电话号码对应英文单词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-Edit-Distance"><span class="nav-number"></span> <span class="nav-text">3.3 Edit Distance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9"><span class="nav-number"></span> <span class="nav-text">3.4 删除链表节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E6%9C%80%E7%9F%AD%E6%91%98%E8%A6%81%E7%9A%84%E7%94%9F%E6%88%90"><span class="nav-number"></span> <span class="nav-text">3.5 最短摘要的生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4"><span class="nav-number"></span> <span class="nav-text">3.6 判断两个链表是否相交</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-%E9%98%9F%E5%88%97%E4%B8%AD%E5%8F%96%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">3.7 队列中取最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E8%BF%9C%E8%B7%9D%E7%A6%BB"><span class="nav-number"></span> <span class="nav-text">3.8 二叉树中两个节点之间的最远距离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-9-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number"></span> <span class="nav-text">3.9 重建二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-10-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number"></span> <span class="nav-text">3.10 层序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-11-%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">3.11 注意问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E9%87%91%E5%88%9A"><span class="nav-number"></span> <span class="nav-text">4.1 金刚</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E7%93%B7%E7%A0%96%E8%A6%86%E7%9B%96%E5%9C%B0%E6%9D%BF"><span class="nav-number"></span> <span class="nav-text">4.2 瓷砖覆盖地板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-Catalan%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">4.3  Catalan数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E4%B8%89%E8%A7%92%E5%BD%A2%E5%86%85%E9%83%A8"><span class="nav-number"></span> <span class="nav-text">4.4 点是否在三角形内部</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-%E7%A3%81%E5%B8%A6%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E4%BC%98%E5%8C%96"><span class="nav-number"></span> <span class="nav-text">4.5 磁带文件存储优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-%E6%A1%B6%E4%B8%AD%E5%8F%96%E9%BB%91%E7%99%BD%E7%90%83"><span class="nav-number"></span> <span class="nav-text">4.6 桶中取黑白球</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7-%E8%9A%82%E8%9A%81%E7%88%AC%E6%9D%86"><span class="nav-number"></span> <span class="nav-text">4.7 蚂蚁爬杆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-8-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="nav-number"></span> <span class="nav-text">4.8 三角形测试用例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-10-%E6%95%B0%E5%AD%97%E5%93%91%E8%B0%9C"><span class="nav-number"></span> <span class="nav-text">4.10 数字哑谜</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-11-%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E6%A6%82%E7%8E%87"><span class="nav-number"></span> <span class="nav-text">4.11 扫雷游戏的概率</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81C-x2F-C-%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E8%80%83%E7%82%B9"><span class="nav-number"></span> <span class="nav-text">二、C&#x2F;C++基本算法考点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E4%B8%8D%E5%90%8C"><span class="nav-number"></span> <span class="nav-text">1.1 确定一个字符串中所有数字是否完全不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E5%AE%9E%E7%8E%B0reverse-char-s"><span class="nav-number"></span> <span class="nav-text">1.2 实现reverse(char* s)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E8%AF%8D%E6%98%AF%E5%90%A6%E6%98%AF%E5%8F%98%E4%BD%8D%E8%AF%8D-Anagram"><span class="nav-number"></span> <span class="nav-text">1.3 判断两个词是否是变位词(Anagram)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC%E5%85%A8%E9%83%A8%E6%9B%BF%E6%8D%A2%E4%B8%BA-20%EF%BC%8C%E5%81%87%E8%AE%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%93%E5%B0%BE%E6%9C%89%E8%B6%B3%E5%A4%9F%E7%A9%BA%E9%97%B4"><span class="nav-number"></span> <span class="nav-text">1.4 编写一个方法，将字符串中的空格全部替换为%20，假设字符串结尾有足够空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2-aabcccccaaa-gt-a2b1c5a3%E5%A6%82%E6%9E%9C%E5%8E%8B%E7%BC%A9%E5%90%8E%E5%8F%98%E7%9F%AD%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%8E%8B%E7%BC%A9%E5%90%8E%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number"></span> <span class="nav-text">1.5 压缩字符串 aabcccccaaa -&gt; a2b1c5a3如果压缩后变短，返回压缩后的字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-%E7%BB%99%E5%AE%9A%E4%B8%80%E5%B9%85%E7%94%B1N%EF%BC%8AN%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%9B%BE%E5%83%8F%EF%BC%8C%E9%A1%BA%E6%97%B6%E9%92%88%E6%97%8B%E8%BD%AC90%E5%BA%A6"><span class="nav-number"></span> <span class="nav-text">1.6 给定一幅由N＊N矩阵表示的图像，顺时针旋转90度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-%E8%8B%A5m%EF%BC%8An%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%BA0%EF%BC%8C%E5%B0%B1%E6%8A%8A%E8%BF%99%E4%B8%80%E8%A1%8C%E5%92%8C%E8%BF%99%E4%B8%80%E5%88%97%E9%83%BD%E6%B8%85%E9%9B%B6"><span class="nav-number"></span> <span class="nav-text">1.7 若m＊n矩阵中某个元素为0，就把这一行和这一列都清零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-%E7%BB%99%E5%AE%9A%E6%96%B9%E6%B3%95isSubstring-%EF%BC%8C%E5%88%A4%E6%96%ADs1%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%94%B1s2%E6%97%8B%E8%BD%AC%E7%BB%84%E6%88%90"><span class="nav-number"></span> <span class="nav-text">1.8 给定方法isSubstring()，判断s1是不是可以由s2旋转组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E7%A7%BB%E9%99%A4%E6%9C%AA%E6%8E%92%E5%BA%8F%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9"><span class="nav-number"></span> <span class="nav-text">2.1 移除未排序列表中的重复节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%EF%BC%8C%E6%89%BE%E5%87%BA%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-number"></span> <span class="nav-text">2.2 实现一个算法，找出链表中倒数第K个元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E5%88%A0%E9%99%A4%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E5%81%87%E8%AE%BE%E4%BD%A0%E5%8F%AA%E6%9C%89%E8%AE%BF%E9%97%AE%E8%AF%A5%E8%8A%82%E7%82%B9%E7%9A%84%E6%9D%83%E9%99%90"><span class="nav-number"></span> <span class="nav-text">2.3 删除单向链表中的某个节点，假设你只有访问该节点的权限</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E4%BB%A5%E7%BB%99%E5%AE%9A%E7%9A%84%E5%80%BCx%E5%88%86%E5%89%B2%E5%88%97%E8%A1%A8%EF%BC%8C%E4%BD%BF%E5%BE%97%E5%B0%8F%E4%BA%8Ex%E7%9A%84%E5%85%83%E7%B4%A0%E9%83%BD%E6%8E%92%E5%9C%A8x%E7%9A%84%E5%89%8D%E9%9D%A2"><span class="nav-number"></span> <span class="nav-text">2.4 以给定的值x分割列表，使得小于x的元素都排在x的前面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%8C%E6%AF%8F%E4%B8%AA%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E5%AD%98%E6%94%BE%E4%B8%80%E4%BD%8D%E6%95%B0%E5%AD%97%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%98%AF%E5%8F%8D%E5%90%91%E5%AD%98%E6%94%BE%E7%9A%84%EF%BC%8C%E6%B1%82%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%92%8C"><span class="nav-number"></span> <span class="nav-text">2.5 给定一个链表，每个链表节点存放一位数字，并且是反向存放的，求两个链表的和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%9C%89%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%8C%E6%89%BE%E5%88%B0%E7%8E%AF%E7%9A%84%E5%BC%80%E5%A4%B4"><span class="nav-number"></span> <span class="nav-text">2.6 给定一个有环链表，找到环的开头</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%98%AF%E5%9B%9E%E6%96%87-Palindrome"><span class="nav-number"></span> <span class="nav-text">2.7 判断链表是否是回文(Palindrome)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B03%E4%B8%AA%E6%A0%88"><span class="nav-number"></span> <span class="nav-text">3.1 如何用一个数组实现3个栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%A0%88%EF%BC%8C%E6%94%AF%E6%8C%81min%E6%96%B9%E6%B3%95%EF%BC%8C%E8%BF%94%E5%9B%9E%E6%A0%88%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">3.2 设计一个栈，支持min方法，返回栈中的最小值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E5%AE%9E%E7%8E%B0SetOfStacks%EF%BC%8C%E7%94%B1%E5%A4%9A%E4%B8%AA%E6%A0%88%E7%BB%84%E6%88%90"><span class="nav-number"></span> <span class="nav-text">3.3 实现SetOfStacks，由多个栈组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E6%B1%89%E8%AF%BA%E5%A1%94"><span class="nav-number"></span> <span class="nav-text">3.4 汉诺塔</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97"><span class="nav-number"></span> <span class="nav-text">3.5 使用两个栈模拟一个队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E5%AF%B9%E6%A0%88%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%EF%BC%8C%E9%A2%9D%E5%A4%96%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%AA%E8%83%BD%E4%BD%BF%E7%94%A8%E6%A0%88"><span class="nav-number"></span> <span class="nav-text">3.6 对栈进行排序，额外的数据只能使用栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E6%A3%80%E6%9F%A5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%B9%B3%E8%A1%A1-%E4%BB%BB%E6%84%8F%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E9%AB%98%E5%BA%A6%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%871"><span class="nav-number"></span> <span class="nav-text">4.1 检查二叉树是否平衡: 任意两个节点之间的高度差不超过1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%9C%89%E5%90%91%E5%9B%BE%EF%BC%8C%E6%89%BE%E5%87%BA%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%B8%80%E6%9D%A1%E8%B7%AF%E5%BE%84"><span class="nav-number"></span> <span class="nav-text">4.2 给定一个有向图，找出两个节点之间是否存在一条路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%8C%E5%85%83%E7%B4%A0%E5%90%84%E4%B8%8D%E7%9B%B8%E5%90%8C%E4%B8%94%E6%8C%89%E5%8D%87%E5%BA%8F%E6%8E%92%E5%88%97%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E9%A2%97%E9%AB%98%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="nav-number"></span> <span class="nav-text">4.3 给定一个有序数组，元素各不相同且按升序排列，创建一颗高度最小的二叉查找树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E7%BB%99%E5%AE%9A%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E5%88%9B%E5%BB%BA%E5%B1%82%E5%BA%8F%E8%AE%BF%E9%97%AE%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-number"></span> <span class="nav-text">4.4 给定一棵二叉树，创建层序访问的链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-%E6%A3%80%E6%9F%A5%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="nav-number"></span> <span class="nav-text">4.5 检查一棵二叉树是否为二叉查找树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-%E6%89%BE%E5%88%B0%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9-%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%A7-%EF%BC%8C%E5%81%87%E8%AE%BE%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E9%83%BD%E6%9C%89%E6%8C%87%E5%90%91%E7%88%B6%E8%8A%82%E7%82%B9%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-number"></span> <span class="nav-text">4.6 找到二叉查找树指定节点的下一个节点(中序后继)，假设每个节点都有指向父节点的指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7-%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number"></span> <span class="nav-text">4.7 查找二叉树的公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-8-%E5%8F%88%E4%B8%A4%E6%A3%B5%E9%9D%9E%E5%B8%B8%E5%A4%A7%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9AT1-%E6%9C%89%E5%87%A0%E7%99%BE%E4%B8%87%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8CT2%EF%BC%8C%E6%9C%89%E5%87%A0%E7%99%BE%E4%B8%AA%E8%8A%82%E7%82%B9%E3%80%82%E5%88%A4%E6%96%ADT2%E6%98%AF%E5%90%A6%E6%98%AFT1%E7%9A%84%E5%AD%90%E6%A0%91"><span class="nav-number"></span> <span class="nav-text">4.8 又两棵非常大的二叉树：T1 有几百万个节点，T2，有几百个节点。判断T2是否是T1的子树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-9-%E6%89%93%E5%8D%B0%E8%8A%82%E7%82%B9%E6%95%B0%E5%80%BC%E6%80%BB%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%8C%E8%B7%AF%E5%BE%84%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%BB%BB%E6%84%8F%E8%8A%82%E7%82%B9%E5%BC%80%E5%A7%8B%EF%BC%8C%E4%BB%BB%E6%84%8F%E8%8A%82%E7%82%B9%E7%BB%93%E6%9D%9F"><span class="nav-number"></span> <span class="nav-text">4.9 打印节点数值总和为给定值的路径，路径可以从任意节点开始，任意节点结束</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B0n%EF%BC%8C%E5%92%8C%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97m%EF%BC%8C%E7%84%B6%E5%90%8E%E7%BB%99%E5%AE%9A%E5%8C%BA%E9%97%B4-i-j-%EF%BC%8C%E5%8C%BA%E9%97%B4%E4%BF%9D%E8%AF%81%E5%8F%AF%E4%BB%A5%E5%A4%A7%E4%BA%8Em%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%95%BF%E5%BA%A6%EF%BC%8C%E6%8A%8Am%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%8F%92%E5%85%A5%E5%88%B0n%E7%9A%84%E5%8C%BA%E9%97%B4%E5%86%85"><span class="nav-number"></span> <span class="nav-text">5.1 给定一个数n，和另一个数字m，然后给定区间(i, j)，区间保证可以大于m的二进制长度，把m的二进制表示插入到n的区间内</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA0%E5%92%8C1%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AE%9E%E6%95%B0%EF%BC%8C%E6%89%93%E5%8D%B0%E4%BB%96%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%EF%BC%8C%E5%A6%82%E6%9E%9C32%E4%BD%8D%E4%BB%A5%E5%86%85%E6%97%A0%E6%B3%95%E8%A1%A8%E7%A4%BA%EF%BC%8C%E6%89%93%E5%8D%B0error"><span class="nav-number"></span> <span class="nav-text">5.2 给定一个0和1之间的实数，打印他的二进制表示，如果32位以内无法表示，打印error</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B4%E6%95%B0%EF%BC%8C%E6%89%BE%E5%87%BA%E5%92%8C%E5%85%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E4%B8%80%E7%9A%84%E6%95%B0%E5%AD%97%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%9C%80%E6%8E%A5%E8%BF%91%EF%BC%8C%E4%B8%80%E5%85%B1%E4%B8%A4%E4%B8%AA"><span class="nav-number"></span> <span class="nav-text">5.3 给定一个正整数，找出和其二进制表示中一的数字相同的数字，并且最接近，一共两个</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E8%A7%A3%E9%87%8An-amp-n-10-0"><span class="nav-number"></span> <span class="nav-text">5.4 解释n &amp; (n-10) &#x3D;&#x3D; 0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-A%E5%92%8CB%E4%B9%8B%E9%97%B4%E6%9C%89%E5%A4%9A%E5%B0%91%E4%BD%8D%E4%B8%8D%E7%9B%B8%E5%90%8C-x2F-%E9%9C%80%E8%A6%81%E6%94%B9%E5%8F%98%E5%A4%9A%E5%B0%91%E4%BD%8D%EF%BC%8C%E6%89%8D%E8%83%BD%E6%8A%8AA%E5%8F%98%E6%88%90B"><span class="nav-number"></span> <span class="nav-text">5.5 A和B之间有多少位不相同&#x2F;需要改变多少位，才能把A变成B</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-%E4%BA%A4%E6%8D%A2%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E5%A5%87%E6%95%B0%E4%BD%8D%E5%92%8C%E5%81%B6%E6%95%B0%E4%BD%8D"><span class="nav-number"></span> <span class="nav-text">5.6 交换一个整数的奇数位和偶数位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8-%E5%8D%95%E8%89%B2%E5%B1%8F%E5%B9%95%E5%AD%98%E8%B4%AE%E5%9C%A8%E4%B8%80%E7%BB%B4%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E4%B8%AD%EF%BC%8C%E6%AF%8F%E4%B8%AA%E5%AD%97%E8%8A%82%E5%AD%98%E5%82%A8%E5%85%AB%E4%B8%AA%E5%83%8F%E7%B4%A0%EF%BC%8C%E5%B1%8F%E5%B9%95%E5%AE%BD%E5%BA%A6%E4%B8%BAw-px%EF%BC%8C%E7%BB%98%E5%88%B6%E4%BB%8Ex1%E5%88%B0%E8%BE%BEx2%E7%9A%84%E6%B0%B4%E5%B9%B3%E7%BA%BF"><span class="nav-number"></span> <span class="nav-text">5.8 单色屏幕存贮在一维字节数组中，每个字节存储八个像素，屏幕宽度为w px，绘制从x1到达x2的水平线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E7%BB%99%E5%AE%9A%E7%9B%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9A%84%E4%B8%A4%E6%9D%A1%E7%BA%BF%EF%BC%8C%E7%A1%AE%E5%AE%9A%E4%BB%96%E4%BB%AC%E4%BC%9A%E4%B8%8D%E4%BC%9A%E7%9B%B8%E4%BA%A4"><span class="nav-number"></span> <span class="nav-text">6.1 给定直角坐标系的两条线，确定他们会不会相交</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E5%8F%AA%E4%BD%BF%E7%94%A8%E5%8A%A0%E5%8F%B7%E5%AE%9E%E7%8E%B0%E5%87%8F%E6%B3%95%E5%92%8C%E4%B9%98%E9%99%A4%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">6.2 只使用加号实现减法和乘除法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E6%89%BE%E5%87%BA%E7%AC%ACk%E4%B8%AA%E4%B8%91%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">6.3 找出第k个丑数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E5%B0%8F%E5%AD%A9%E4%B8%8A%E6%A5%BC%E6%A2%AF%EF%BC%8C%E6%A5%BC%E6%A2%AF%E6%9C%89n%E9%98%B6%EF%BC%8C%E5%B0%8F%E5%AD%A9%E5%8F%AF%E4%BB%A5%E4%B8%80%E6%AC%A1%E4%B8%8A1%EF%BC%8C2%EF%BC%8C3%E6%AD%A5%EF%BC%8C%E8%AF%B7%E9%97%AE%E4%B8%80%E5%85%B1%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">7.1 小孩上楼梯，楼梯有n阶，小孩可以一次上1，2，3步，请问一共有多少种方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-%E8%AE%BE%E8%AE%A1%E4%B8%80%E7%A7%8D%E7%AE%97%E6%B3%95%EF%BC%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8F%AA%E8%83%BD%E5%90%91%E5%8F%B3%E5%90%91%E4%B8%8B%E7%A7%BB%E5%8A%A8%EF%BC%8C%E4%BB%8E-0-0-%E7%A7%BB%E5%8A%A8%E5%88%B0-x-y-%E6%9C%89%E5%87%A0%E7%A7%8D%E8%B5%B0%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">8.1 设计一种算法，机器人只能向右向下移动，从(0, 0)移动到(x, y)有几种走法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-%E5%9C%A8%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84A-0%E2%80%A6n-1-%E4%B8%AD%E5%AD%98%E5%9C%A8A-i-x3D-x3D-i%EF%BC%8C%E6%89%BE%E5%87%BA%E8%AF%A5%E6%95%B0%E5%AD%97%E3%80%82%E5%A6%82%E6%9E%9C%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%80%BC%EF%BC%8C%E5%8F%88%E8%AF%A5%E5%A6%82%E4%BD%95%E5%81%9A"><span class="nav-number"></span> <span class="nav-text">9.1 在有序数组A[0…n-1]中存在A[i] &#x3D;&#x3D; i，找出该数字。如果存在重复值，又该如何做</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86"><span class="nav-number"></span> <span class="nav-text">9.2 返回一个集合的所有子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number"></span> <span class="nav-text">9.3 全排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-%E7%94%9F%E6%88%90n%E5%AF%B9%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%85%A8%E9%83%A8%E6%9C%89%E6%95%88%E9%9B%86%E5%90%88"><span class="nav-number"></span> <span class="nav-text">9.4 生成n对括号的全部有效集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-5-%E5%AE%9E%E7%8E%B0%E5%A1%AB%E5%85%85%E9%A2%9C%E8%89%B2%E5%8A%9F%E8%83%BD"><span class="nav-number"></span> <span class="nav-text">9.5 实现填充颜色功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-6-%E7%BB%99%E5%AE%9A%E6%95%B0%E9%87%8F%E4%B8%8D%E9%99%90%E7%9A%84%E7%A1%AC%E5%B8%81%EF%BC%8C%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81%E8%AE%A1%E7%AE%97%E6%9C%89%E5%87%A0%E7%A7%8D%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">9.6 给定数量不限的硬币，编写代码计算有几种表示方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-7-N-Queen%E9%97%AE%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">9.7 N-Queen问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-8-%E7%BB%99%E4%BD%A0%E4%B8%80%E5%A0%86%E7%AE%B1%E5%AD%90%EF%BC%8C%E4%B8%8A%E9%9D%A2%E7%9A%84%E7%AE%B1%E5%AD%90%E7%9A%84%E9%95%BF%E5%AE%BD%E9%AB%98%E8%A6%81%E6%B1%82%E5%B0%8F%E4%BA%8E%E4%B8%8B%E9%9D%A2%E7%9A%84%E7%AE%B1%E5%AD%90%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E6%90%AD%E5%87%BA%E6%9C%80%E9%AB%98%E7%9A%84%E7%AE%B1%E5%AD%90"><span class="nav-number"></span> <span class="nav-text">9.8 给你一堆箱子，上面的箱子的长宽高要求小于下面的箱子，实现一个方法，搭出最高的箱子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number"></span> <span class="nav-text">10.1 合并两个有序数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-%E5%AF%B9%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%8A%8A%E5%8F%98%E4%BD%8D%E8%AF%8D-Anagram-%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="nav-number"></span> <span class="nav-text">11.1 对一个字符串数组排序，把变位词(Anagram)放在一起</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-%E5%9C%A8%E5%B7%B2%E7%BB%8F%E8%A2%AB%E6%97%8B%E8%BD%AC%E8%BF%87%E7%9A%84%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%EF%BC%8C%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="nav-number"></span> <span class="nav-text">11.2 在已经被旋转过的排序数组中，查找元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3-%E6%9C%89%E4%B8%80%E4%B8%AA20GB%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E6%AF%8F%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8E%92%E5%BA%8F"><span class="nav-number"></span> <span class="nav-text">11.3 有一个20GB的文件，每行一个字符串，如何排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-%E4%BD%BF%E7%94%A8-C-%E5%86%99%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E6%89%93%E5%8D%B0%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E5%90%8E-K-%E8%A1%8C"><span class="nav-number"></span> <span class="nav-text">12.1 使用 C++ 写个方法，打印输入文件的最后 K 行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-%E7%BC%96%E5%86%99malloc-aligned"><span class="nav-number"></span> <span class="nav-text">12.2 编写malloc_aligned</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-malloc2d%E5%87%BD%E6%95%B0%EF%BC%8C%E5%88%86%E9%85%8D%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%8C%E8%BF%94%E5%9B%9Eint-%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87a-i-j-%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%B0%BD%E9%87%8F%E5%B0%91%E8%B0%83%E7%94%A8malloc"><span class="nav-number"></span> <span class="nav-text">12.3 malloc2d函数，分配二维数组，返回int**可以通过a[i][j]访问，并且尽量少调用malloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-4-%E4%B8%8D%E7%94%A8%E4%B8%AD%E9%97%B4%E5%8F%98%E9%87%8F%EF%BC%8C%E7%9B%B4%E6%8E%A5%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">12.4 不用中间变量，直接交换两个数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-1-n-%E7%BB%93%E5%B0%BE%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E9%9B%B6"><span class="nav-number"></span> <span class="nav-text">13.1 n! 结尾有多少个零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-2-%E6%89%BE%E5%87%BA%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E4%B8%AD%E8%BE%83%E5%A4%A7%E7%9A%84%E4%B8%80%E4%B8%AA%EF%BC%8C%E4%BD%86%E4%B8%8D%E5%BE%97%E4%BD%BF%E7%94%A8%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5"><span class="nav-number"></span> <span class="nav-text">13.2 找出两个数字中较大的一个，但不得使用判断语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-3-%E6%8A%8A%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D"><span class="nav-number"></span> <span class="nav-text">13.3 把数字转换为英文单词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-4-%E6%8A%8A%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%B1%89%E8%AF%AD%E5%8F%A5%E5%AD%90"><span class="nav-number"></span> <span class="nav-text">13.4 把数字转换为汉语句子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-5-%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%88%97%E5%92%8C"><span class="nav-number"></span> <span class="nav-text">13.5 数组最大序列和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-6-%E7%BB%99%E5%AE%9A%E4%BA%A7%E7%94%9F%E6%95%B0%E5%AD%97%E6%A6%82%E7%8E%87%E7%9B%B8%E5%90%8C%E7%9A%84rand5-%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95rand7-%EF%BC%8C%E8%A6%81%E6%B1%82%E4%BA%A7%E7%94%9F%E6%AF%8F%E4%B8%AA%E6%95%B0%E5%AD%97%E7%9A%84%E6%A6%82%E7%8E%87%E7%9B%B8%E5%90%8C"><span class="nav-number"></span> <span class="nav-text">13.6 给定产生数字概率相同的rand5()，实现一个方法rand7()，要求产生每个数字的概率相同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-7-%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%8C%E6%98%AF%E7%9A%84%E4%BB%96%E4%BB%AC%E7%9A%84%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">13.7 在数组中找到两个数字，是的他们的和为指定的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-8-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number"></span> <span class="nav-text">13.8 把二叉树转化为双向链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2-%E5%AE%9E%E7%8E%B0%E5%8A%A0%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">14.2 实现加法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-2-%E5%AE%8C%E7%BE%8E%E6%B4%97%E7%89%8C%EF%BC%8C%E4%BD%BF%E5%BE%97%E4%B8%80%E5%89%AF%E7%89%8C%E4%B8%AD%E4%BB%BB%E6%84%8F%E4%B8%80%E7%A7%8D%E6%8E%92%E5%88%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%A6%82%E7%8E%87%E9%83%BD%E7%9B%B8%E7%AD%89"><span class="nav-number"></span> <span class="nav-text">15.2 完美洗牌，使得一副牌中任意一种排列出现的概率都相等</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-1-%E4%BB%8En%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E9%80%89%E5%87%BAm%E4%B8%AA%EF%BC%8C%E8%A6%81%E6%B1%82%E8%A2%AB%E9%80%89%E4%B8%AD%E6%A6%82%E7%8E%87%E4%B8%80%E6%A0%B7"><span class="nav-number"></span> <span class="nav-text">16.1 从n个数组中选出m个，要求被选中概率一样</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-2-%E5%B0%8F%E4%BA%8E-n-%E7%9A%84%E6%95%B0%E5%AD%97%E4%B8%AD%E5%87%BA%E7%8E%B02%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">16.2 小于 n 的数字中出现2的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-3-%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95%E9%97%AE%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">16.3 矩阵链乘法问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-4-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%90%88%E6%B3%95%E5%9C%B0%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97"><span class="nav-number"></span> <span class="nav-text">16.4 判断是否是合法地出栈序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="nav-number"></span> <span class="nav-text">16.5 二叉树的非递归遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number"></span> <span class="nav-text">三、树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number"></span> <span class="nav-text">前序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%89%88"><span class="nav-number"></span> <span class="nav-text">递归版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%89%88"><span class="nav-number"></span> <span class="nav-text">非递归版</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number"></span> <span class="nav-text">中序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%89%88-1"><span class="nav-number"></span> <span class="nav-text">递归版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%89%88-1"><span class="nav-number"></span> <span class="nav-text">非递归版</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86"><span class="nav-number"></span> <span class="nav-text">后续遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%89%88-2"><span class="nav-number"></span> <span class="nav-text">递归版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%89%88-2"><span class="nav-number"></span> <span class="nav-text">非递归版</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number"></span> <span class="nav-text">参考资料</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81LeetCode-%E7%AA%81%E5%87%BB%E6%89%8B%E5%86%8C"><span class="nav-number"></span> <span class="nav-text">四、LeetCode 突击手册</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%87%BA%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E4%BD%BF%E5%BE%97%E4%BB%96%E4%BB%AC%E7%9A%84%E5%92%8C%E6%98%AF%E7%BB%99%E5%AE%9A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">1 从数组中找出两个数字使得他们的和是给定的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BB%99%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%EF%BC%8C%E6%95%B0%E5%AD%97%E5%9C%A8%E5%85%B6%E4%B8%AD%E6%8C%89%E4%BD%8E%E4%BD%8D%E5%88%B0%E9%AB%98%E4%BD%8D%E5%AD%98%E5%82%A8%EF%BC%8C%E6%B1%82%E4%BB%96%E4%BB%AC%E7%9A%84%E5%92%8C"><span class="nav-number"></span> <span class="nav-text">2 给两个列表，数字在其中按低位到高位存储，求他们的和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2"><span class="nav-number"></span> <span class="nav-text">3 最长不重复子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">4 找到两个排序数组的中位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number"></span> <span class="nav-text">5 最长回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-ZigZag-%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%B0%E5%BC%AF%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E6%8C%89%E8%A1%8C%E8%BE%93%E5%87%BA"><span class="nav-number"></span> <span class="nav-text">6 ZigZag 字符串，把字符串掰弯，然后再按行输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E7%BF%BB%E8%BD%AC%E6%95%B0%E5%AD%97%EF%BC%8C%E6%BA%A2%E5%87%BA%E8%BF%94%E5%9B%9E-0"><span class="nav-number"></span> <span class="nav-text">7 翻转数字，溢出返回 0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%AE%9E%E7%8E%B0-atoi"><span class="nav-number"></span> <span class="nav-text">8 实现 atoi</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E6%98%AF%E5%90%A6%E6%98%AF%E5%9B%9E%E6%96%87%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">9 是否是回文数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number"></span> <span class="nav-text">10 正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number"></span> <span class="nav-text">11 盛最多水的容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">12 十进制转换为罗马数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E4%B8%BA%E5%8D%81%E8%BF%9B%E5%88%B6"><span class="nav-number"></span> <span class="nav-text">13 罗马数字转为十进制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="nav-number"></span> <span class="nav-text">14 最长公共前缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%87%BA%E4%B8%89%E4%B8%AA%E6%95%B0%E4%BD%BF%E5%BE%97%E4%BB%96%E4%BB%AC%E7%9A%84%E5%92%8C%E6%98%AF-0"><span class="nav-number"></span> <span class="nav-text">15 从数组中找出三个数使得他们的和是 0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%89%E4%B8%AA%E6%95%B0%E5%AD%97%E4%BD%BF%E5%BE%97%E4%BB%96%E4%BB%AC%E5%BE%97%E5%92%8C%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%9A%84%E6%8E%A5%E8%BF%91%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97%EF%BC%8C%E5%81%87%E8%AE%BE%E7%BB%93%E6%9E%9C%E5%94%AF%E4%B8%80"><span class="nav-number"></span> <span class="nav-text">16 在数组中找到三个数字使得他们得和尽可能的接近给定数字，假设结果唯一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E7%94%9F%E6%88%90%E7%94%B5%E8%AF%9D%E9%94%AE%E7%9B%98%E6%8C%89%E9%94%AE%E6%95%B0%E5%AD%97%E5%AF%B9%E5%BA%94%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E4%B8%8D%E9%99%90%E5%88%B6%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-number"></span> <span class="nav-text">17 生成电话键盘按键数字对应的所有可能的字符串，不限制返回结果的顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-4Sum"><span class="nav-number"></span> <span class="nav-text">18 4Sum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC-k-%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number"></span> <span class="nav-text">19 删除链表中倒数第 k 的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E5%88%A4%E5%AE%9A%E7%BB%99%E5%AE%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%98%AF%E5%90%88%E6%B3%95%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97%EF%BC%8C%E5%8F%AF%E8%83%BD%E5%8C%85%E6%8B%AC%E5%A4%A7%E4%B8%AD%E5%B0%8F%E4%B8%89%E7%B1%BB"><span class="nav-number"></span> <span class="nav-text">20 判定给定的字符串是否是合法的括号序列，可能包括大中小三类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E5%B7%B2%E7%BB%8F%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-number"></span> <span class="nav-text">21 合并两个已经排序的链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97-n-%E7%94%9F%E6%88%90%E6%89%80%E6%9C%89%E5%90%88%E6%B3%95%E7%9A%84-n-%E4%B8%AA%E6%8B%AC%E5%8F%B7%E7%BB%84%E6%88%90%E7%9A%84%E5%BA%8F%E5%88%97"><span class="nav-number"></span> <span class="nav-text">22 给定数字 n, 生成所有合法的 n 个括号组成的序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-%E5%90%88%E5%B9%B6-K-%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%97%E8%A1%A8"><span class="nav-number"></span> <span class="nav-text">23 合并 K 个排序的列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%8C%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E7%9B%B8%E9%82%BB%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">24 给定一个链表，交换两个相邻节点的值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%8C%E6%8A%8A%E7%9B%B8%E9%82%BB%E7%9A%84-k-%E4%B8%AA%E8%8A%82%E7%82%B9%E5%8F%8D%E8%BD%AC"><span class="nav-number"></span> <span class="nav-text">25 给定一个链表，把相邻的 k 个节点反转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="nav-number"></span> <span class="nav-text">26 删除排序数组中的重复项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number"></span> <span class="nav-text">27 删除元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-%E5%AE%9E%E7%8E%B0-strstr-%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8D%B3%E6%9F%A5%E6%89%BE%E5%AD%90%E4%B8%B2"><span class="nav-number"></span> <span class="nav-text">28 实现 strstr 函数，即查找子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-%E7%BB%99%E5%AE%9A%E8%BF%9E%E4%B8%AA%E6%95%B4%E6%95%B0%EF%BC%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%B9%98%E6%B3%95%E5%92%8C%E9%99%A4%E6%B3%95%E8%AE%A1%E7%AE%97%E9%99%A4%E6%B3%95%E3%80%82"><span class="nav-number"></span> <span class="nav-text">29 给定连个整数，不使用乘法和除法计算除法。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-%E5%8C%85%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2"><span class="nav-number"></span> <span class="nav-text">30 包串联所有单词的子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%8C%E4%B8%8B%E4%B8%80%E4%B8%AA"><span class="nav-number"></span> <span class="nav-text">31 全排列，下一个</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%8B%AC%E5%8F%B7%E6%9E%84%E6%88%90%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%BE%E5%87%BA%E6%9C%80%E9%95%BF%E7%9A%84%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97"><span class="nav-number"></span> <span class="nav-text">32 从一个括号构成的字符串中找出最长的合法括号序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-%E5%9C%A8%E6%8E%92%E5%BA%8F%E5%90%8E%E5%8F%88%E8%A2%AB%E5%8F%8D%E8%BD%AC%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%90%9C%E7%B4%A2"><span class="nav-number"></span> <span class="nav-text">33 在排序后又被反转的数组中搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-number"></span> <span class="nav-text">34 在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E6%89%BE%E5%88%B0%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%BA%94%E8%AF%A5%E6%8F%92%E5%85%A5%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number"></span> <span class="nav-text">35 二分查找数字，如果没有找到，返回应该插入的位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-%E5%90%88%E6%B3%95%E6%95%B0%E7%8B%AC%EF%BC%8C%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%8B%AC%E8%A1%A8%EF%BC%8C%E5%88%A4%E5%AE%9A%E5%BD%93%E5%89%8D%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">36 合法数独，给定一个数独表，判定当前是否合法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-%E6%B1%82%E8%A7%A3%E6%95%B0%E7%8B%AC"><span class="nav-number"></span> <span class="nav-text">37 求解数独</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-%E6%95%B0%E6%95%B0%E5%B9%B6%E8%AF%B4%E5%87%BA%E6%9D%A5"><span class="nav-number"></span> <span class="nav-text">38 数数并说出来</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%EF%BC%8C%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E6%89%BE%E5%87%BA%E5%92%8C%E4%B8%BA-target-%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%8C%E6%95%B0%E5%AD%97%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%AC%A1%EF%BC%8C%E9%9B%86%E5%90%88%E4%B8%AD%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">39 给定一个集合，在集合中找出和为 target 的数字，数字可以使用多次，集合中没有重复数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40-%E5%90%8C%E4%B8%8A%E9%A2%98%E4%B8%80%E6%A0%B7%EF%BC%8C%E4%BD%86%E6%98%AF%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E5%8F%AA%E8%83%BD%E4%BD%BF%E7%94%A8%E4%B8%80%E6%AC%A1%EF%BC%8C%E5%B9%B6%E4%B8%94%E9%9B%86%E5%90%88%E4%B8%AD%E6%9C%89%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">40 同上题一样，但是集合中的数字只能使用一次，并且集合中有重复数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#41-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%8C%E6%89%BE%E5%88%B0%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">41 给定一个数组，找到第一个缺失的正数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA%E6%9F%B1%E5%AD%90%E7%9A%84%E9%AB%98%E5%BA%A6%EF%BC%8C%E6%B1%82%E8%83%BD%E5%AD%98%E8%B4%AE%E7%9A%84%E9%9B%A8%E6%B0%B4%E7%9A%84%E6%80%BB%E9%87%8F"><span class="nav-number"></span> <span class="nav-text">42 给定一个数组表示柱子的高度，求能存贮的雨水的总量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-%E7%BB%99%E5%AE%9A%E4%B8%A4%E4%B8%AA%E4%BB%BB%E6%84%8F%E9%95%BF%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E4%BB%A3%E8%A1%A8%E4%BB%96%E4%BB%AC%E7%9B%B8%E4%B9%98%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="nav-number"></span> <span class="nav-text">43 给定两个任意长的字符串，返回一个字符串，代表他们相乘的结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#44-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D%EF%BC%8C-%E4%BB%A3%E8%A1%A8%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%EF%BC%8C-%E4%BB%A3%E8%A1%A8%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="nav-number"></span> <span class="nav-text">44 通配符匹配，? 代表任意一个字符，*代表任意一个或多个字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%EF%BC%8C%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%8C%E6%AF%8F%E4%B8%AA%E6%95%B0%E5%AD%97%E6%98%AF%E5%9C%A8%E8%AF%A5%E4%BD%8D%E7%BD%AE%E5%8F%AF%E4%BB%A5%E5%90%91%E5%89%8D%E7%A7%BB%E5%8A%A8%E7%9A%84%E8%B7%9D%E7%A6%BB%EF%BC%8C%E8%BF%94%E5%9B%9E%E6%9C%80%E5%B0%91%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E6%AC%A1%E6%89%8D%E8%83%BD%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9"><span class="nav-number"></span> <span class="nav-text">45 跳跃游戏，给定一个数组，每个数字是在该位置可以向前移动的距离，返回最少需要多少次才能到达终点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#46-%E7%94%9F%E6%88%90%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number"></span> <span class="nav-text">46 生成全排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#47-%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%8C%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number"></span> <span class="nav-text">47 全排列，数组中有重复元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#48-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AAn-n%E7%9A%84%E5%9B%BE%E5%83%8F%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F%EF%BC%8C%E9%A1%BA%E6%97%B6%E9%92%88%E6%97%8B%E8%BD%AC-90-%E5%BA%A6"><span class="nav-number"></span> <span class="nav-text">48 给定一个n*n的图像旋转图像，顺时针旋转 90 度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#49-%E7%BB%99%E5%AE%9A%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%EF%BC%8C%E6%8A%8A%E4%BB%96%E4%BB%AC%E6%8C%89%E7%85%A7-Anagram-%E5%88%86%E7%BB%84"><span class="nav-number"></span> <span class="nav-text">49 给定字符数组，把他们按照 Anagram 分组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#50-%E5%AE%9E%E7%8E%B0-pow-x-n"><span class="nav-number"></span> <span class="nav-text">50 实现 pow(x, n)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#51-N-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">51 N 皇后问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#52-N-%E7%9A%87%E5%90%8E%E4%B8%80%E5%85%B1%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E8%A7%A3"><span class="nav-number"></span> <span class="nav-text">52 N 皇后一共有多少个解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C"><span class="nav-number"></span> <span class="nav-text">53 最大子序列和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#54-%E9%A1%BA%E6%97%B6%E9%92%88%E8%9E%BA%E6%97%8B%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="nav-number"></span> <span class="nav-text">54 顺时针螺旋打印矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#55-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%8C%E6%AF%8F%E4%B8%AA%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E5%9C%A8%E5%BD%93%E5%89%8D%E6%AD%A5%E5%8F%AF%E4%BB%A5%E7%A7%BB%E5%8A%A8%E7%9A%84%E8%B7%9D%E7%A6%BB%EF%BC%8C%E8%BF%94%E5%9B%9E%E6%98%AF%E4%B8%8D%E6%98%AF%E8%83%BD%E5%A4%9F%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9"><span class="nav-number"></span> <span class="nav-text">55 给定一个数组，每个数字表示在当前步可以移动的距离，返回是不是能够到达终点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#56-%E5%90%88%E5%B9%B6%E5%BA%8F%E5%88%97%EF%BC%8C%E7%BB%99%E5%AE%9A%E4%B8%80%E7%BB%84%E5%BA%8F%E5%88%97%EF%BC%8C%E6%8A%8A%E5%85%B6%E4%B8%AD%E9%87%8D%E5%8F%A0%E7%9A%84%E5%BA%8F%E5%88%97%E5%90%88%E5%B9%B6"><span class="nav-number"></span> <span class="nav-text">56 合并序列，给定一组序列，把其中重叠的序列合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#57-%E6%B7%BB%E5%8A%A0%E5%BA%8F%E5%88%97%EF%BC%8C%E7%BB%99%E5%AE%9A%E4%B8%80%E7%BB%84%E5%B7%B2%E7%BB%8F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%8F%E5%88%97%EF%BC%8C%E5%90%91%E5%85%B6%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E5%BA%8F%E5%88%97%EF%BC%8C%E9%9C%80%E8%A6%81%E5%90%88%E5%B9%B6%E7%9A%84%E5%90%88%E5%B9%B6"><span class="nav-number"></span> <span class="nav-text">57 添加序列，给定一组已经排序的序列，向其中插入一个序列，需要合并的合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#58-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E6%B1%82%E5%85%B6%E4%B8%AD%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-number"></span> <span class="nav-text">58 给定一个字符串，求其中最后一个单词的长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#59-%E7%BB%99%E5%AE%9A-n%EF%BC%8C%E6%8A%8A-1-2-3-%E2%80%A6-%E8%9E%BA%E6%97%8B%E6%89%93%E5%8D%B0%E5%88%B0%E7%9F%A9%E9%98%B5%E4%B8%AD"><span class="nav-number"></span> <span class="nav-text">59 给定 n，把 1, 2, 3 … 螺旋打印到矩阵中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#60-%E7%BB%99%E5%AE%9A-n-%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%8C%E6%89%BE%E5%87%BA%E7%AC%AC-k-%E4%B8%AA-Permutation"><span class="nav-number"></span> <span class="nav-text">60 给定 n 个数字，找出第 k 个 Permutation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#61-%E6%8A%8A%E5%88%97%E8%A1%A8%E6%97%8B%E8%BD%AC%E5%88%B0%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%BD%8D"><span class="nav-number"></span> <span class="nav-text">61 把列表旋转到倒数第 k 位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#62-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AAm-n%E7%9A%84%E7%9F%A9%E9%98%B5%EF%BC%8C%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E6%96%B9%E6%B3%95%E4%BB%8E%E5%B7%A6%E4%B8%8A%E8%A7%92%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%8F%B3%E4%B8%8B%E8%A7%92"><span class="nav-number"></span> <span class="nav-text">62 给定一个m*n的矩阵，有多少种方法从左上角移动到右下角</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#63-%E5%90%8C%E4%B8%8A%E9%A2%98%EF%BC%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E5%9C%A8%E4%B8%80%E4%BA%9B%E4%BD%8D%E7%BD%AE%E6%98%AF%E6%9C%89%E9%9A%9C%E7%A2%8D%E7%89%A9%E7%9A%84"><span class="nav-number"></span> <span class="nav-text">63 同上题，区别是在一些位置是有障碍物的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AAm-n%E7%9F%A9%E9%98%B5%EF%BC%8C%E6%AF%8F%E4%B8%AA%E6%95%B0%E5%AD%97%E4%BB%A3%E8%A1%A8%E7%BB%8F%E8%BF%87%E8%AF%A5%E5%A4%84%E7%9A%84%E8%80%97%E8%B4%B9%EF%BC%8C%E6%89%BE%E5%87%BA%E4%B8%80%E6%9D%A1%E8%80%97%E8%B4%B9%E6%9C%80%E5%B0%8F%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number"></span> <span class="nav-text">64 给定一个m*n矩阵，每个数字代表经过该处的耗费，找出一条耗费最小的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#65-%E5%88%A4%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%98%AF%E5%90%88%E6%B3%95%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%8C%E5%8C%85%E6%8B%AC%E4%BA%86%E6%AD%A3%E8%B4%9F%E5%8F%B7%EF%BC%8C%E5%B0%8F%E6%95%B0%E7%82%B9%EF%BC%8Ce%E7%AD%89"><span class="nav-number"></span> <span class="nav-text">65 判定一个字符串是否是合法的数字，包括了正负号，小数点，e等</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#66-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%8A%A0-1-%E5%90%8E%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">66 给定一个字符串代表的数字，返回加 1 后的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#67-%E7%BB%99%E5%AE%9A%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%A3%E8%A1%A8%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%BB%96%E4%BB%AC%E7%9B%B8%E5%8A%A0%E7%9A%84%E5%92%8C"><span class="nav-number"></span> <span class="nav-text">67 给定两个字符串代表的二进制数字，返回他们相加的和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#68-%E6%96%87%E5%AD%97%E5%AF%B9%E9%BD%90"><span class="nav-number"></span> <span class="nav-text">68 文字对齐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#69-%E7%BB%99%E5%AE%9A%E6%95%B4%E6%95%B0-x%EF%BC%8C%E6%B1%82-sqrt-x"><span class="nav-number"></span> <span class="nav-text">69 给定整数 x，求 sqrt(x)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#70-%E7%88%AC%E6%A2%AF%E5%AD%90%EF%BC%8C%E4%B8%80%E6%AC%A1%E5%8F%AF%E4%BB%A5%E7%88%AC%E4%B8%80%E6%AD%A5%E6%88%96%E8%80%85%E4%B8%A4%E6%AD%A5%EF%BC%8C%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E7%88%AC%E5%AE%8C%E6%A2%AF%E5%AD%90"><span class="nav-number"></span> <span class="nav-text">70 爬梯子，一次可以爬一步或者两步，有几种方法爬完梯子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#71-%E7%AE%80%E5%8C%96-Unix-%E8%B7%AF%E5%BE%84%EF%BC%8C%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86-%E5%92%8C%E5%A4%9A%E4%B8%AA%E6%96%9C%E6%9D%A0%E7%AD%89%E6%83%85%E5%86%B5"><span class="nav-number"></span> <span class="nav-text">71 简化 Unix 路径，需要处理., .. 和多个斜杠等情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%8C%E5%85%81%E8%AE%B8%E6%9B%BF%E6%8D%A2%EF%BC%8C%E5%88%A0%E9%99%A4%EF%BC%8C%E6%8F%92%E5%85%A5%E4%B8%89%E7%A7%8D%E6%93%8D%E4%BD%9C"><span class="nav-number"></span> <span class="nav-text">72 编辑距离，允许替换，删除，插入三种操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#73-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%9F%A9%E9%98%B5%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%BA%E9%9B%B6%EF%BC%8C%E6%8A%8A%E6%89%80%E5%9C%A8%E7%9A%84%E8%A1%8C%E5%92%8C%E6%89%80%E5%9C%A8%E7%9A%84%E5%88%97%E9%83%BD%E8%AE%BE%E4%B8%BA%E9%9B%B6"><span class="nav-number"></span> <span class="nav-text">73 给定一个矩阵，如果某个元素为零，把所在的行和所在的列都设为零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#74-%E6%90%9C%E7%B4%A2%E7%9F%A9%E9%98%B5%EF%BC%8C%E7%9F%A9%E9%98%B5%E6%AF%8F%E8%A1%8C%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E4%BE%9D%E6%AC%A1%E5%A2%9E%E5%A4%A7%EF%BC%8C%E6%AF%8F%E8%A1%8C%E9%83%BD%E6%AF%94%E4%B8%8A%E4%B8%80%E8%A1%8C%E5%A4%A7"><span class="nav-number"></span> <span class="nav-text">74 搜索矩阵，矩阵每行从左到右依次增大，每行都比上一行大</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#75-%E9%A2%9C%E8%89%B2%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%AF%8F%E4%B8%AA%E7%89%A9%E4%BD%93%E6%9C%89%E9%A2%9C%E8%89%B2%E5%B1%9E%E6%80%A7%EF%BC%8C%E6%8A%8A%E4%BB%96%E4%BB%AC%E6%8C%89%E7%85%A7-RGB-%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%BA%8F-%F0%9F%87%B3%F0%9F%87%B1%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">75 颜色排序，每个物体有颜色属性，把他们按照 RGB 的顺序排序 (🇳🇱国旗问题）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#77-%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97-n-%E5%92%8C-k%EF%BC%8C%E7%94%9F%E6%88%90%E4%BB%8E-n-%E4%B8%AD%E5%8F%96%E5%87%BA-k-%E4%B8%AA%E6%95%B0%E5%AD%97%E7%9A%84%E6%89%80%E6%9C%89%E6%83%85%E5%86%B5"><span class="nav-number"></span> <span class="nav-text">77 给定数字 n 和 k，生成从 n 中取出 k 个数字的所有情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#78-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%EF%BC%8C%E6%89%BE%E5%88%B0%E5%AE%83%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86"><span class="nav-number"></span> <span class="nav-text">78 给定一个集合，找到它的所有子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#79-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E4%BA%8C%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%EF%BC%8C%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E6%98%AF%E5%90%A6%E8%83%BD%E5%A4%9F%E6%9C%89%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%AD%97%E6%AF%8D%E6%9E%84%E6%88%90%EF%BC%8C%E4%B8%8D%E8%83%BD%E4%BA%A4%E5%8F%89"><span class="nav-number"></span> <span class="nav-text">79 给定一个二维字符数组，查找一个单词是否能够有连续的字母构成，不能交叉</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#80-%E4%BB%8E%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%8C%E4%BD%86%E6%98%AF%E5%85%81%E8%AE%B8%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1"><span class="nav-number"></span> <span class="nav-text">80 从排序数组中删除重复元素，但是允许一个元素重复出现两次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#81-%E5%9C%A8%E8%A2%AB%E7%BF%BB%E8%BD%AC%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%EF%BC%8C%E5%8F%AF%E8%83%BD%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number"></span> <span class="nav-text">81 在被翻转的数组中查找元素，可能包含重复元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#82-%E4%BB%8E%E5%B7%B2%E7%BB%8F%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E9%87%8D%E5%A4%8D%E8%BF%87%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E5%8F%AA%E7%95%99%E4%B8%8B%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number"></span> <span class="nav-text">82 从已经排序的链表中删除所有重复过的元素，只留下只出现一次的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#83-%E4%BB%8E%E5%B7%B2%E7%BB%8F%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E9%87%8D%E5%A4%8D%E8%BF%87%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E4%BD%86%E6%98%AF%E9%87%8D%E5%A4%8D%E8%BF%87%E7%9A%84%E4%B9%9F%E7%95%99%E4%B8%8B%E4%B8%80%E4%B8%AA%EF%BC%8C%E5%8D%B3%EF%BC%8C%E4%BD%BF%E6%96%B0%E9%93%BE%E8%A1%A8%E4%B8%8D%E9%87%8D%E5%A4%8D"><span class="nav-number"></span> <span class="nav-text">83 从已经排序的链表中删除所有重复过的元素，但是重复过的也留下一个，即，使新链表不重复</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#84-%E5%9C%A8%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2"><span class="nav-number"></span> <span class="nav-text">84 在柱状图中查找最大的矩形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#85-%E6%9C%80%E5%A4%A7%E7%9A%84%E9%95%BF%E6%96%B9%E5%BD%A2"><span class="nav-number"></span> <span class="nav-text">85 最大的长方形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#86-%E9%93%BE%E8%A1%A8%E5%88%86%E5%8C%BA%EF%BC%8C%E8%A6%81%E6%B1%82%E6%8A%8A%E5%B0%8F%E4%BA%8E%E6%9F%90%E4%B8%AA%E5%80%BC%E5%BE%97%E5%85%83%E7%B4%A0%E5%85%A8%E9%83%BD%E6%94%BE%E5%88%B0%E5%89%8D%E9%9D%A2"><span class="nav-number"></span> <span class="nav-text">86 链表分区，要求把小于某个值得元素全都放到前面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#87-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%8C%BA%E5%90%8E%EF%BC%8C%E4%BA%A4%E6%8D%A2%E5%BE%97%E5%88%B0%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number"></span> <span class="nav-text">87 把字符串分区后，交换得到的字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#88-%E5%90%88%E5%B9%B6%E5%B7%B2%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%8C%E8%A6%81%E6%B1%82%E5%90%88%E5%B9%B6%E5%88%B0%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%A9%BA%E9%97%B4%E8%BE%83%E5%A4%A7%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD"><span class="nav-number"></span> <span class="nav-text">88 合并已排序数组，要求合并到其中一个空间较大的数组中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#89-%E7%94%9F%E6%88%90%E6%A0%BC%E9%9B%B7%E7%A0%81-Gray-Code"><span class="nav-number"></span> <span class="nav-text">89 生成格雷码 (Gray Code)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#90-%E7%94%B1%E7%BB%99%E5%AE%9A%E5%85%83%E7%B4%A0%E7%94%9F%E6%88%90%E5%AD%90%E9%9B%86%EF%BC%8C%E5%8F%AF%E8%83%BD%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number"></span> <span class="nav-text">90 由给定元素生成子集，可能包含重复元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#91-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%8F%AA%E5%8C%85%E5%90%AB-1-9%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%A8-1-26-%E4%BB%A3%E8%A1%A8%E5%AD%97%E6%AF%8D%EF%BC%8C%E6%B1%82%E5%87%BA%E4%BB%8E%E5%85%B6%E4%B8%AD%E8%83%BD%E9%83%BD%E5%BE%97%E5%88%B0%E5%A4%9A%E5%B0%91%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number"></span> <span class="nav-text">91 给定一个数组只包含 1-9，可以用 1-26 代表字母，求出从其中能都得到多少字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#92-%E5%9C%A8%E7%BB%99%E5%AE%9A%E5%8C%BA%E9%97%B4%E4%B8%8A%E7%BF%BB%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="nav-number"></span> <span class="nav-text">92 在给定区间上翻转数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#93-%E6%81%A2%E5%A4%8D-IP-%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E9%80%82%E5%BD%93%E6%8F%92%E5%85%A5%E7%82%B9%EF%BC%8C%E4%B8%80%E5%85%B1%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%9E%84%E6%88%90-IP-%E5%9C%B0%E5%9D%80"><span class="nav-number"></span> <span class="nav-text">93 恢复 IP 地址，给定一个字符串，适当插入点，一共有多少种方式构成 IP 地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#94-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number"></span> <span class="nav-text">94 中序遍历二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#95-%E7%94%9F%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E5%90%8C%E4%B8%8B%E9%A2%98%E4%B8%80%E6%A0%B7"><span class="nav-number"></span> <span class="nav-text">95 生成二叉树，同下题一样</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#96-%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97-n%EF%BC%8C%E4%BB%8E-1-%E5%88%B0-n-%E4%BD%9C%E4%B8%BA%E8%8A%82%E7%82%B9%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%94%9F%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number"></span> <span class="nav-text">96 给定数字 n，从 1 到 n 作为节点有多少种方式生成二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#97-%E7%BB%99%E5%AE%9A%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E5%8F%89%E6%98%AF%E5%90%A6%E8%83%BD%E5%A4%9F%E6%9E%84%E6%88%90%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number"></span> <span class="nav-text">97 给定两个字符串交叉是否能够构成第三个字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">98 验证二叉搜索树是否合法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#99-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E6%9C%89%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E8%A2%AB%E8%B0%83%E6%8D%A2%E4%BA%86%EF%BC%8C%E6%89%BE%E5%87%BA%E8%BF%99%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E5%B9%B6%E6%81%A2%E5%A4%8D%E8%AF%A5%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number"></span> <span class="nav-text">99 在二叉搜索树中有两个节点被调换了，找出这两个节点，并恢复该二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#100-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="nav-number"></span> <span class="nav-text">100 判断是否是相同的树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#101-%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B7%A6%E5%8F%B3%E5%AF%B9%E7%A7%B0%E7%9A%84%E6%A0%91"><span class="nav-number"></span> <span class="nav-text">101 判断是不是左右对称的树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number"></span> <span class="nav-text">102 二叉树层序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#103-%E4%BA%8C%E5%8F%89%E6%A0%91-ZigZag-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number"></span> <span class="nav-text">103 二叉树 ZigZag 层序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#104-%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number"></span> <span class="nav-text">104 树的最大深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%94%9F%E6%88%90%E7%94%9F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number"></span> <span class="nav-text">105 从前序遍历和中序遍历生成生二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%94%9F%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number"></span> <span class="nav-text">106 从中序遍历和后序遍历生成二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#107-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%8C%E4%BD%86%E8%A6%81%E7%94%9F%E6%88%90%E7%BF%BB%E8%BD%AC%E7%9A%84%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="nav-number"></span> <span class="nav-text">107 二叉树层序遍历，但要生成翻转的遍历序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#108-%E6%8A%8A%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number"></span> <span class="nav-text">108 把排序数组转化为二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#109-%E6%8A%8A%E6%8E%92%E5%BA%8F%E5%88%97%E8%A1%A8%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number"></span> <span class="nav-text">109 把排序列表转化为二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number"></span> <span class="nav-text">110 平衡二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6"><span class="nav-number"></span> <span class="nav-text">111 二叉树最小高度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#112-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%AA%E6%95%B0%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number"></span> <span class="nav-text">112 二叉树中是否存在和为某个数的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#113-%E6%8E%A5%E4%B8%8A%E9%A2%98%EF%BC%8C%E6%8A%8A%E8%BF%99%E4%B8%AA%E8%B7%AF%E5%BE%84%E6%89%BE%E5%87%BA%E6%9D%A5"><span class="nav-number"></span> <span class="nav-text">113 接上题，把这个路径找出来</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#114-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%81%E5%B9%B3%E6%88%90%E5%88%97%E8%A1%A8"><span class="nav-number"></span> <span class="nav-text">114 把二叉树扁平成列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#115-%E9%80%9A%E8%BF%87%E5%88%A0%E6%8E%89%E4%B8%80%E4%BA%9B%E5%AD%97%E6%AF%8D%E5%BE%97%E5%88%B0%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%8C%E9%97%AE%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E6%96%B9%E6%B3%95%E8%83%BD%E5%A4%9F%E5%BE%97%E5%88%B0%E5%AD%90%E5%BA%8F%E5%88%97%E5%91%A2"><span class="nav-number"></span> <span class="nav-text">115 通过删掉一些字母得到子序列，问有多少种方法能够得到子序列呢</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#116-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%8A%8A%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E6%8C%87%E5%90%91%E4%BB%96%E8%BF%99%E4%B8%80%E5%B1%82%E7%9A%84%E5%8F%B3%E9%9D%A2%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number"></span> <span class="nav-text">116 完全二叉树中把每个节点指向他这一层的右面的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#117-%E5%90%8C%E4%B8%8A%E9%A2%98%EF%BC%8C%E4%BD%86%E6%98%AF%E6%98%AF%E4%BB%BB%E6%84%8F%E7%9A%84%F0%9F%8C%B2"><span class="nav-number"></span> <span class="nav-text">117 同上题，但是是任意的🌲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="nav-number"></span> <span class="nav-text">118 杨辉三角</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#119-%E8%BF%94%E5%9B%9E%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E7%9A%84%E7%AC%AC-k-%E8%A1%8C"><span class="nav-number"></span> <span class="nav-text">119 返回杨辉三角的第 k 行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#120-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BC%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E5%BD%A2%E7%8A%B6%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%8C%E6%B1%82%E4%BB%8E%E9%A1%B6%E9%83%A8%E5%88%B0%E5%BA%95%E9%83%A8%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number"></span> <span class="nav-text">120 给定一个类似杨辉三角形状的数组，求从顶部到底部的最短路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%8C%E5%8F%AA%E8%83%BD%E4%BA%A4%E6%98%93%E4%B8%80%E6%AC%A1"><span class="nav-number"></span> <span class="nav-text">121 买卖股票最佳时机，只能交易一次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%BB%E6%84%8F%E5%A4%9A%E6%AF%94%E4%BA%A4%E6%98%93"><span class="nav-number"></span> <span class="nav-text">122 买卖股票的最佳时机，可以做任意多比交易</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#123-%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93%EF%BC%8C%E9%99%90%E5%88%B6%E5%8F%AA%E8%83%BD%E4%BA%A4%E6%98%93%E4%B8%A4%E8%82%A1"><span class="nav-number"></span> <span class="nav-text">123 股票交易，限制只能交易两股</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E6%9C%80%E5%A4%A7%E5%92%8C%EF%BC%8C%E8%B7%AF%E5%BE%84%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E5%BC%80%E5%A7%8B%E5%88%B0%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%BB%93%E6%9D%9F"><span class="nav-number"></span> <span class="nav-text">124 二叉树路径最大和，路径可以从任意一个节点开始到任意一个节点结束</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#125-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%8F%AA%E8%80%83%E8%99%91%E5%AD%97%E6%AF%8D%E5%92%8C%E6%95%B0%E5%AD%97%EF%BC%8C%E5%BF%BD%E7%95%A5%E5%A4%A7%E5%B0%8F%E5%86%99%EF%BC%8C%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number"></span> <span class="nav-text">125 给定一个字符串，只考虑字母和数字，忽略大小写，判断是否是回文字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#127-%E5%8D%95%E8%AF%8D%E6%A2%AF%E5%AD%90"><span class="nav-number"></span> <span class="nav-text">127 单词梯子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#128-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number"></span> <span class="nav-text">128 最长递增子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#129-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%8F%AA%E6%9C%89-0-9-%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%92%8C"><span class="nav-number"></span> <span class="nav-text">129 二叉树中只有 0-9 找出所有根节点到子节点的和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#130-%E6%8A%8A%E6%89%80%E6%9C%89%E8%A2%AB%E5%8C%85%E5%9B%B4%E7%9A%84-O-%E7%BD%AE%E4%B8%BA-X"><span class="nav-number"></span> <span class="nav-text">130 把所有被包围的 O 置为 X</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#131-%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E7%BB%84%EF%BC%8C%E6%98%AF%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%AD%97%E4%B8%B2%E9%83%BD%E6%98%AF%E5%9B%9E%E6%96%87%EF%BC%8C%E8%BF%94%E5%9B%9E%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E5%88%86%E7%BB%84"><span class="nav-number"></span> <span class="nav-text">131 对字符串分组，是的每个字串都是回文，返回所有可能的分组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#132-%E5%A6%82%E4%B8%8A%E9%A2%98%EF%BC%8C%E6%89%BE%E5%87%BA%E6%9C%80%E5%B0%91%E9%9C%80%E8%A6%81%E5%88%86%E7%BB%84%E5%87%A0%E6%AC%A1"><span class="nav-number"></span> <span class="nav-text">132 如上题，找出最少需要分组几次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#133-%E5%A4%8D%E5%88%B6%E6%9C%89%E5%90%91%E5%9B%BE"><span class="nav-number"></span> <span class="nav-text">133 复制有向图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#134-%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="nav-number"></span> <span class="nav-text">134 加油站</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#135-%E7%B3%96%E5%9D%97%EF%BC%8C%E6%88%90%E7%BB%A9%E9%AB%98%E7%9A%84%E9%9C%80%E8%A6%81%E6%AF%94%E4%BB%96%E8%BA%AB%E8%BE%B9%E6%88%90%E7%BB%A9%E4%BD%8E%E7%9A%84%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%B3%96"><span class="nav-number"></span> <span class="nav-text">135 糖块，成绩高的需要比他身边成绩低的获得更多的糖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#136-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">136 找出数组中只出现一次的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#137-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%EF%BC%8C%E6%89%80%E6%9C%89%E6%95%B0%E5%AD%97%E9%83%BD%E5%87%BA%E7%8E%B0%E4%B8%89%E6%AC%A1%EF%BC%8C%E9%99%A4%E4%BA%86%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E4%BB%A5%E5%A4%96%EF%BC%8C%E6%89%BE%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">137 一个数组中，所有数字都出现三次，除了一个数字以外，找出这个数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#138-%E5%A4%8D%E5%88%B6%E5%A4%8D%E6%9D%82%E7%BB%93%E6%9E%84%E9%93%BE%E8%A1%A8"><span class="nav-number"></span> <span class="nav-text">138 复制复杂结构链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#139-%E6%9F%A5%E6%89%BE%E5%8D%95%E8%AF%8D%E6%98%AF%E5%90%A6%E8%83%BD%E7%BB%84%E6%88%90%E5%8F%A5%E5%AD%90"><span class="nav-number"></span> <span class="nav-text">139 查找单词是否能组成句子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#141-%E5%88%97%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF"><span class="nav-number"></span> <span class="nav-text">141 列表是否有环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#142-%E5%88%97%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%9C%89%E6%89%BE%E5%88%B0%E7%8E%AF%E7%9A%84%E5%BC%80%E5%A7%8B"><span class="nav-number"></span> <span class="nav-text">142 列表是否有环？如果有找到环的开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#144-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number"></span> <span class="nav-text">144 前序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number"></span> <span class="nav-text">145 二叉树的后序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#146-LRU-%E7%BC%93%E5%AD%98"><span class="nav-number"></span> <span class="nav-text">146 LRU 缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#147-%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number"></span> <span class="nav-text">147 链表插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%8C%E8%A6%81%E6%B1%82%E8%BE%BE%E5%88%B0-O-nlogn-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number"></span> <span class="nav-text">148 排序链表，要求达到 O(nlogn) 时间复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#149-%E5%9C%A8%E5%90%8C%E4%B8%80%E6%9D%A1%E7%BA%BF%E4%B8%8A%E7%9A%84%E7%82%B9%E6%9C%80%E5%A4%9A%E7%9A%84%E7%BA%BF"><span class="nav-number"></span> <span class="nav-text">149 在同一条线上的点最多的线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#150-%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">150 后缀表达式求值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#151-%E5%8F%8D%E8%BD%AC%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F"><span class="nav-number"></span> <span class="nav-text">151 反转句子中的单词顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#152-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E4%B9%98%E7%A7%AF"><span class="nav-number"></span> <span class="nav-text">152 最大子序列乘积</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#153-%E5%9C%A8%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">153 在旋转数组中查找最小值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#154-%E5%9C%A8%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%9C%80%E5%B0%8F%E5%80%BC%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%9C%89%E9%87%8D%E5%A4%8D"><span class="nav-number"></span> <span class="nav-text">154 在旋转数组中查找最小值，可能有重复</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#155-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%A0%88%EF%BC%8C%E5%9C%A8%E6%99%AE%E9%80%9A%E6%A0%88%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E6%94%AF%E6%8C%81-getmin-%E6%93%8D%E4%BD%9C"><span class="nav-number"></span> <span class="nav-text">155 设计一个栈，在普通栈的基础上支持 getmin 操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#160-%E6%B1%82%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BA%A4%E5%8F%89%E7%82%B9"><span class="nav-number"></span> <span class="nav-text">160 求两个链表的交叉点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#162-%E6%89%BE%E5%88%B0%E6%9E%81%E5%A4%A7%E5%80%BC%EF%BC%8C%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%9E%81%E5%A4%A7%E5%80%BC%EF%BC%8C%E6%89%BE%E5%88%B0%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E5%8D%B3%E5%8F%AF%EF%BC%8C%E7%BB%99%E5%AE%9A%E6%95%B0%E7%BB%84%E4%B8%AD-A-i-x3D-A-i-1"><span class="nav-number"></span> <span class="nav-text">162  找到极大值，给定一个数组，可能有多个极大值，找到任意一个即可，给定数组中 A[i] !&#x3D; A[i+1]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#164-%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9B%B8%E5%B7%AE%E6%9C%80%E5%A4%A7%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE"><span class="nav-number"></span> <span class="nav-text">164 未排序数组中相差最大的两个数之间的差</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#165-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7%E5%A4%A7%E5%B0%8F"><span class="nav-number"></span> <span class="nav-text">165 比较版本号大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#166-%E5%88%86%E6%95%B0%E7%94%9F%E6%88%90%E5%B0%8F%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">166 分数生成小数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#168-%E7%94%9F%E6%88%90-Excel-%E8%A1%A8%E6%A0%BC%E6%A0%87%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">168 生成 Excel 表格标题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#169-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%8C%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E7%9A%84%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E8%B6%85%E8%BF%87%E4%BA%86%E4%B8%80%E5%8D%8A%EF%BC%8C%E6%89%BE%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">169 给定一个数组，有一个数字的出现频率超过了一半，找出这个数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#171-Excel-%E6%A0%87%E9%A2%98%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">171 Excel 标题转换为数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#172-%E9%98%B6%E4%B9%98%E4%B8%AD%E8%83%BD%E6%9C%89%E5%87%A0%E4%B8%AA-0"><span class="nav-number"></span> <span class="nav-text">172 阶乘中能有几个 0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#173-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number"></span> <span class="nav-text">173 二叉树中序遍历迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#174-%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F"><span class="nav-number"></span> <span class="nav-text">174 地下城游戏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#175-178-Missing"><span class="nav-number"></span> <span class="nav-text">175-178 Missing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#179-%E6%9C%80%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">179 最大的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#180-185-Missing"><span class="nav-number"></span> <span class="nav-text">180-185 Missing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#187-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89-10-%E4%B8%AA%E5%AD%97%E6%AF%8D%E5%94%B1%E7%9A%84%E9%87%8D%E5%A4%8D-DNA-%E5%BA%8F%E5%88%97"><span class="nav-number"></span> <span class="nav-text">187 找到所有 10 个字母唱的重复 DNA 序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#189-%E7%BF%BB%E8%BD%AC%E6%A0%91%E7%BB%84"><span class="nav-number"></span> <span class="nav-text">189 翻转树组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#190-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA"><span class="nav-number"></span> <span class="nav-text">190 翻转二进制表示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#191-%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">191 数字二进制表示中 1 的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#198-%E6%9C%89%E4%B8%80%E6%8E%92%E6%88%BF%E5%AD%90%EF%BC%8C%E6%AF%8F%E4%B8%AA%E6%88%BF%E5%AD%90%E4%B8%AD%E9%83%BD%E6%9C%89%E4%B8%80%E5%AE%9A%E8%B4%A2%E4%BA%A7%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B8%8D%E8%83%BD%E5%81%B7%E7%9B%B8%E9%82%BB%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%88%BF%E5%AD%90%EF%BC%8C%E6%B1%82%E8%83%BD%E5%81%B7%E5%88%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">198  有一排房子，每个房子中都有一定财产，但是不能偷相邻的两个房子，求能偷到的最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#199-%E4%BB%8E%E5%8F%B3%E8%BE%B9%E7%9C%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%95%88%E6%9E%9C"><span class="nav-number"></span> <span class="nav-text">199 从右边看二叉树的效果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#200-%E6%89%BE%E5%87%BA%E5%B0%8F%E5%B2%9B%E7%9A%84%E6%95%B0%E9%87%8F"><span class="nav-number"></span> <span class="nav-text">200 找出小岛的数量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#201-%E7%BB%99%E5%AE%9A%E5%8C%BA%E9%97%B4%E5%86%85%EF%BC%8C%E6%89%80%E6%9C%89%E6%95%B0%E5%AD%97-AND-%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="nav-number"></span> <span class="nav-text">201 给定区间内，所有数字 AND 的结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#202-%E5%BF%AB%E4%B9%90%E6%95%B0%E5%AD%97%EF%BC%8C%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97%E5%B9%B3%E6%96%B9%E7%9B%B8%E5%8A%A0%E5%BE%97%E5%88%B0%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%80%E5%90%8E%E7%AD%89%E4%BA%8E-1"><span class="nav-number"></span> <span class="nav-text">202 快乐数字，各位数字平方相加得到下一个数字，如果最后等于 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#203-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%BB%99%E5%AE%9A%E7%9A%84%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">203 删除链表中给定的值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#204-%E6%89%BE%E5%87%BA%E7%B4%A0%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">204 找出素数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E4%BD%9C-word-pattern-%E7%9A%84%E7%AE%80%E5%8C%96"><span class="nav-number"></span> <span class="nav-text">205 同构字符串，可以看作 word pattern 的简化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number"></span> <span class="nav-text">206 反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#207-%E6%A0%87%E5%87%86%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number"></span> <span class="nav-text">207 标准的拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#208-%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BC%80%E6%A0%91"><span class="nav-number"></span> <span class="nav-text">208 实现前缀树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#209-%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84%E4%BD%BF%E5%BE%97%E5%92%8C%E5%A4%A7%E4%BA%8E%E6%9F%90%E4%B8%AA%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">209 最短子数组使得和大于某个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#210-Course-Schedule-II"><span class="nav-number"></span> <span class="nav-text">210 Course Schedule II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#211-%E6%B7%BB%E5%8A%A0%E5%92%8C%E6%90%9C%E7%B4%A2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number"></span> <span class="nav-text">211 添加和搜索字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#212-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="nav-number"></span> <span class="nav-text">212 单词搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#213-%E5%B0%8F%E5%81%B7%E5%81%B7%E7%8E%AF%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="nav-number"></span> <span class="nav-text">213 小偷偷环状数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#214-%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E7%BB%99%E6%8C%87%E5%AE%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%AF%8D%E8%8E%B7%E5%BE%97%E5%9B%9E%E6%96%87"><span class="nav-number"></span> <span class="nav-text">214 最短回文字符串，给指定的字符串添加字母获得回文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%AC-k-%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">215 数组中第 k 大的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#216-%E6%89%BE%E5%88%B0-k-%E4%B8%AA%E6%95%B0%E5%AD%97-1%E2%80%A69-%EF%BC%8C%E4%BD%BF%E5%BE%97%E4%BB%96%E4%BB%AC%E7%9A%84%E5%92%8C%E6%98%AF-n"><span class="nav-number"></span> <span class="nav-text">216 找到 k 个数字 [1…9]，使得他们的和是 n</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#217-%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">217 包含重复数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#218-%E8%8E%B7%E5%BE%97%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%90%88%E9%83%A8%E5%88%86%E7%9A%84%E6%8B%90%E7%82%B9"><span class="nav-number"></span> <span class="nav-text">218 获得矩形重合部分的拐点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#219-%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%B8%A4%E4%B8%AA%E7%9A%84%E5%9D%90%E6%A0%87%E4%B8%8D%E8%B6%85%E8%BF%87-k"><span class="nav-number"></span> <span class="nav-text">219 包含重复数字，并且两个的坐标不超过 k</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#220-%E5%90%8C%E4%B8%8A%E4%B8%80%E9%A2%98%EF%BC%8C%E5%90%8C%E6%97%B6%E4%BF%9D%E8%AF%81%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E4%B9%8B%E9%97%B4%E5%B0%8F%E4%BA%8E-t"><span class="nav-number"></span> <span class="nav-text">220 同上一题，同时保证两个数字之间小于 t</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#221-%E6%89%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="nav-number"></span> <span class="nav-text">221 找到最大的正方形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#222-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%85%A8%E6%A0%91%EF%BC%8C%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E9%87%8F%E3%80%82"><span class="nav-number"></span> <span class="nav-text">222 给定一个完全树，计算节点的数量。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#223-%E6%89%BE%E5%87%BA%E4%B8%A4%E4%B8%AA%E9%95%BF%E6%96%B9%E5%BD%A2%E8%A6%86%E7%9B%96%E7%9A%84%E9%9D%A2%E7%A7%AF"><span class="nav-number"></span> <span class="nav-text">223 找出两个长方形覆盖的面积</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#224-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%8C%85%E5%90%AB%E5%8A%A0%E5%87%8F%E5%92%8C%E6%8B%AC%E5%8F%B7%EF%BC%8C%E8%AE%A1%E7%AE%97%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">224 给定一个字符串，包含加减和括号，计算值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#225-%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F%E6%A0%88"><span class="nav-number"></span> <span class="nav-text">225 使用队列模拟栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#226-%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number"></span> <span class="nav-text">226 反转二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#227-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB-%E8%AE%A1%E7%AE%97%E4%BB%96%E7%9A%84%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">227 给定一个字符串包含 +-*&#x2F; 计算他的值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#228-%E8%81%9A%E5%90%88%E5%8C%BA%E9%97%B4%EF%BC%8C%E7%BB%99%E5%AE%9A%E4%B8%80%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%8C%E6%8A%8A%E7%9B%B8%E9%82%BB%E7%9A%84%E6%95%B0%E5%AD%97%E7%94%A8%E5%8C%BA%E9%97%B4%E8%A1%A8%E7%A4%BA"><span class="nav-number"></span> <span class="nav-text">228 聚合区间，给定一排序数组，把相邻的数字用区间表示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#229-%E6%89%BE%E5%87%BA%E8%B6%85%E8%BF%87%E4%B8%89%E5%88%86%E4%B9%8B%E4%B8%80%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number"></span> <span class="nav-text">229 找出超过三分之一的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#230-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC-k-%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">230 二叉树中第 k 小的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#231-2-%E7%9A%84%E6%AC%A1%E6%96%B9"><span class="nav-number"></span> <span class="nav-text">231 2 的次方</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#232-%E4%BD%BF%E7%94%A8%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97"><span class="nav-number"></span> <span class="nav-text">232 使用栈模拟队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#233-%E5%B0%8F%E4%BA%8E-n-%E7%9A%84%E6%95%B0%E5%AD%97%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">233 小于 n 的数字中 1 的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#234-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%98%AF%E5%9B%9E%E6%96%87"><span class="nav-number"></span> <span class="nav-text">234 判断一个链表是否是回文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number"></span> <span class="nav-text">235 二叉搜索树公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number"></span> <span class="nav-text">236 二叉树公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number"></span> <span class="nav-text">237 删除链表中的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#238-%E6%95%B0%E7%BB%84%E9%99%A4%E4%BA%86%E8%87%AA%E5%B7%B1%E4%BB%A5%E5%A4%96%E7%9A%84%E4%B9%98%E7%A7%AF%EF%BC%8C%E8%A7%84%E5%AE%9A%E4%B8%8D%E8%83%BD%E7%94%A8%E9%99%A4%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">238 数组除了自己以外的乘积，规定不能用除法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%8C%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%AE%83%E7%A7%BB%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">239 滑动窗口最大值，给定一个滑动窗口，返回它移动过程中的最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#240-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%9F%A9%E9%98%B5%EF%BC%8C%E6%AF%8F%E8%A1%8C%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E9%83%BD%E6%98%AF%E5%A2%9E%E5%A4%A7%E7%9A%84%EF%BC%8C%E6%AF%8F%E4%B8%80%E5%88%97%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E9%83%BD%E6%98%AF%E5%A2%9E%E5%A4%A7%E7%9A%84%EF%BC%8C%E6%89%BE%E5%87%BA%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="nav-number"></span> <span class="nav-text">240 给定一个矩阵，每行从左到右都是增大的，每一列从上到下都是增大的，找出给定数字是否存在</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#241-%E6%B7%BB%E5%8A%A0%E6%8B%AC%E5%8F%B7%E5%BE%97%E5%88%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="nav-number"></span> <span class="nav-text">241 添加括号得到不同的结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#242-%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E6%98%AF%E5%90%A6%E8%83%BD%E7%94%B1%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%8F%98%E5%B9%BB%E8%80%8C%E6%9D%A5"><span class="nav-number"></span> <span class="nav-text">242 一个单词是否能由另一个变幻而来</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A6%E5%8F%B3%E8%B7%AF%E5%BE%84"><span class="nav-number"></span> <span class="nav-text">257 二叉树左右路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#258-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%9A%84%E6%AF%8F%E4%B8%80%E4%BD%8D%E5%8A%A0%E8%B5%B7%E6%9D%A5%EF%BC%8C%E7%9B%B4%E5%88%B0%E5%8F%98%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">258 把数字的每一位加起来，直到变成一个一位的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#260-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%8C%E6%AF%8F%E4%B8%AA%E6%95%B0%E5%AD%97%E9%83%BD%E6%98%AF%E9%87%8D%E5%A4%8D%E7%9A%84%EF%BC%8C%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E4%B8%8D%E6%98%AF%EF%BC%8C%E6%89%BE%E5%87%BA%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">260 给定一个数组，每个数字都是重复的，只有两个数字不是，找出这两个数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#263-%E4%B8%91%E9%99%8B%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%8C%E8%B4%A8%E6%95%B0%E5%9B%A0%E5%AD%90%E5%8F%AA%E5%90%AB%E6%9C%89-2-3-5-%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">263 丑陋的数字，质数因子只含有 2,3,5 的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#264-%E6%89%BE%E5%87%BA%E7%AC%AC-n-%E4%B8%AA%E4%B8%91%E9%99%8B%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">264 找出第 n 个丑陋数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#268-%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%8C%E7%BB%99%E5%AE%9A-0%E2%80%A6n%EF%BC%8C%E4%B8%A2%E5%A4%B1%E4%BA%86%E4%B8%80%E4%B8%AA%EF%BC%8C%E7%84%B6%E5%90%8E%E6%94%BE%E5%9C%A8%E9%95%BF%E5%BA%A6%E4%B8%BA-n-%E7%9A%84%E6%95%B0%E7%BB%84%E4%B9%8B%E4%B8%AD%EF%BC%8C%E6%89%BE%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">268 丢失的数字，给定 0…n，丢失了一个，然后放在长度为 n 的数组之中，找出这个数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#273-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D"><span class="nav-number"></span> <span class="nav-text">273 数字转换为英语单词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#274-H-Index"><span class="nav-number"></span> <span class="nav-text">274 H-Index</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#275-H-index-II%EF%BC%8C%E8%AE%BA%E6%96%87%E5%B7%B2%E7%BB%8F%E6%8C%89%E7%85%A7%E5%BC%95%E7%94%A8%E6%95%B0%E9%87%8F%E6%8E%92%E5%BA%8F"><span class="nav-number"></span> <span class="nav-text">275 H-index II，论文已经按照引用数量排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%9D%8F%E7%89%88%E6%9C%AC"><span class="nav-number"></span> <span class="nav-text">278 第一个坏版本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#279-%E5%88%86%E8%A7%A3%E4%B8%BA%E5%B9%B3%E6%96%B9%E6%95%B0%E7%9A%84%E5%92%8C"><span class="nav-number"></span> <span class="nav-text">279 分解为平方数的和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#282-%E6%B7%BB%E5%8A%A0%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BD%BF%E5%BE%97%E7%AE%97%E5%BC%8F%E6%88%90%E7%AB%8B"><span class="nav-number"></span> <span class="nav-text">282 添加运算符使得算式成立</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#283-%E7%A7%BB%E5%8A%A8-0"><span class="nav-number"></span> <span class="nav-text">283 移动 0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#284-Peek-Iterator"><span class="nav-number"></span> <span class="nav-text">284 Peek Iterator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#285-286-Locked"><span class="nav-number"></span> <span class="nav-text">285 ~ 286 Locked</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#287-%E4%B8%80%E4%B8%AA-n-%E7%9A%84%E6%95%B0%E7%BB%84%E5%8C%85%E5%90%AB%E4%BA%86-1%E2%80%A6n-1-%E4%B8%AD%E7%9A%84%E8%BF%99%E4%BA%9B%E6%95%B0%E5%AD%97%EF%BC%8C%E8%AF%81%E6%98%8E%E4%B8%80%E5%AE%9A%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%EF%BC%8C%E5%B9%B6%E6%89%BE%E5%87%BA%E8%BF%99%E4%B8%AA%E9%87%8D%E5%A4%8D"><span class="nav-number"></span> <span class="nav-text">287 一个 n 的数组包含了 1…n-1 中的这些数字，证明一定存在重复，并找出这个重复</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#288-Locked"><span class="nav-number"></span> <span class="nav-text">288 Locked</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#289-Conway%E2%80%99s-Game-of-Life"><span class="nav-number"></span> <span class="nav-text">289 Conway’s Game of Life</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#290-%E5%8D%95%E8%AF%8D%E6%A8%A1%E5%BC%8F%EF%BC%8C%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%BC%8F-abba-%E7%AD%89%EF%BC%8C%E5%88%A4%E6%96%AD%E5%8D%95%E8%AF%8D%E6%98%AF%E5%90%A6%E6%98%AF%E8%BF%99%E4%B8%AA%E6%A8%A1%E5%BC%8F%E7%9A%84%E3%80%82"><span class="nav-number"></span> <span class="nav-text">290 单词模式，给定一个模式 abba 等，判断单词是否是这个模式的。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#291-Locked"><span class="nav-number"></span> <span class="nav-text">291 Locked</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#292-Nim-%E6%B8%B8%E6%88%8F%EF%BC%8C%E6%AF%8F%E4%B8%AA%E4%BA%BA%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%E4%B8%A2%E6%8E%89-1%EF%BC%8C2%EF%BC%8C3%EF%BC%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E8%80%85%E8%8E%B7%E8%83%9C"><span class="nav-number"></span> <span class="nav-text">292 Nim 游戏，每个人可以选择丢掉 1，2，3，最后一个操作者获胜</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number"></span> <span class="nav-text">300 最长递增子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#344-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number"></span> <span class="nav-text">344 翻转字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#347-%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%87%A0%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">347 出现最多的几个数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E9%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number"></span> <span class="nav-text">349 两个数组中都出现的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#345-%E7%BF%BB%E8%BD%AC%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E9%9D%A2%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D"><span class="nav-number"></span> <span class="nav-text">345 翻转一个字符串里面的元音字母</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#371-%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number"></span> <span class="nav-text">371 两个数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#388"><span class="nav-number"></span> <span class="nav-text">388</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="nav-number"></span> <span class="nav-text">435 无重叠区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#482-%E6%B3%A8%E5%86%8C%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-number"></span> <span class="nav-text">482 注册码格式化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#547-%E6%9C%8B%E5%8F%8B%E5%9C%88"><span class="nav-number"></span> <span class="nav-text">547 朋友圈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#739"><span class="nav-number"></span> <span class="nav-text">739</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#864-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0"><span class="nav-number"></span> <span class="nav-text">864 矩形重叠</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#904-%E6%89%BE%E5%87%BA%E5%8C%85%E5%90%AB%E4%BA%86%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E6%95%B0%E5%AD%97%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number"></span> <span class="nav-text">904 找出包含了两个不同数字的最长子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#986-%E5%8C%BA%E9%97%B4%E5%88%97%E8%A1%A8%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="nav-number"></span> <span class="nav-text">986 区间列表的交集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#929-%E5%94%AF%E4%B8%80%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80"><span class="nav-number"></span> <span class="nav-text">929 唯一邮件地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#970-%E5%BC%BA%E5%8A%9B%E6%95%B0%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">970 强力数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1272-%E5%88%A0%E9%99%A4%E5%8C%BA%E9%97%B4"><span class="nav-number"></span> <span class="nav-text">1272 删除区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1317-%E5%B0%86%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%B8%A4%E4%B8%AA%E6%97%A0%E9%9B%B6%E6%95%B4%E6%95%B0%E7%9A%84%E5%92%8C"><span class="nav-number"></span> <span class="nav-text">1317 将整数转换为两个无零整数的和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1389-%E6%8C%89%E6%97%A2%E5%AE%9A%E9%A1%BA%E5%BA%8F%E5%88%9B%E5%BB%BA%E7%9B%AE%E6%A0%87%E6%95%B0%E7%BB%84"><span class="nav-number"></span> <span class="nav-text">1389 按既定顺序创建目标数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1390-%E5%9B%9B%E5%9B%A0%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">1390 四因数</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Alexander Ezharjan</p>
  <div class="site-description" itemprop="description">This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/Blog/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/Blog/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alexander Ezharjan</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/Blog/lib/anime.min.js"></script>
  <script src="/Blog/lib/velocity/velocity.min.js"></script>
  <script src="/Blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/Blog/js/utils.js"></script>

<script src="/Blog/js/motion.js"></script>


<script src="/Blog/js/schemes/muse.js"></script>


<script src="/Blog/js/next-boot.js"></script>




  




  
<script src="/Blog/js/local-search.js"></script>













  

  

</body>
</html>
