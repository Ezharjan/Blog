<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/Blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/Blog/css/main.css">


<link rel="stylesheet" href="/Blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ezharjan.github.io","root":"/Blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="编者：艾孜尔江  1. ECMAScirpt 6 简介ESMAScript 6 是javascript 2016年发布的新标准。 2. let和const命令2.1 let命令基本用法let 声明的变量只在代码块中有效。 123&amp;#123;  let a &#x3D; 10;&amp;#125; for 循环的计数器，就很适合使用let命令。此时计数器i只在循环体内有效。 另外，循环语句部分的变量和循环体内部的变量">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6入门">
<meta property="og:url" content="https://ezharjan.github.io/Blog/2022/05/15/ES6%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name">
<meta property="og:description" content="编者：艾孜尔江  1. ECMAScirpt 6 简介ESMAScript 6 是javascript 2016年发布的新标准。 2. let和const命令2.1 let命令基本用法let 声明的变量只在代码块中有效。 123&amp;#123;  let a &#x3D; 10;&amp;#125; for 循环的计数器，就很适合使用let命令。此时计数器i只在循环体内有效。 另外，循环语句部分的变量和循环体内部的变量">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ezharjan.github.io/Blog/Blog/2022/05/15/ES6%E5%85%A5%E9%97%A8/%E7%BB%B4%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E9%94%AE%E7%9B%98%E5%AF%B9%E5%BA%94%E5%9B%BE.jpg">
<meta property="article:published_time" content="2022-05-15T11:33:20.000Z">
<meta property="article:modified_time" content="2024-04-06T13:13:07.793Z">
<meta property="article:author" content="Alexander Ezharjan">
<meta property="article:tag" content="Software, Lab, Engineer, Game Engine, Alexander, Ezharjan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ezharjan.github.io/Blog/Blog/2022/05/15/ES6%E5%85%A5%E9%97%A8/%E7%BB%B4%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E9%94%AE%E7%9B%98%E5%AF%B9%E5%BA%94%E5%9B%BE.jpg">

<link rel="canonical" href="https://ezharjan.github.io/Blog/2022/05/15/ES6%E5%85%A5%E9%97%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>ES6入门 | </title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/Blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title"></h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Blog By Alexander</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/Blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/Blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ezharjan.github.io/Blog/2022/05/15/ES6%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Alexander Ezharjan">
      <meta itemprop="description" content="This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ES6入门
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-15 19:33:20" itemprop="dateCreated datePublished" datetime="2022-05-15T19:33:20+08:00">2022-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-04-06 21:13:07" itemprop="dateModified" datetime="2024-04-06T21:13:07+08:00">2024-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h6 align="center">编者：艾孜尔江<h6>

<h1 id="1-ECMAScirpt-6-简介"><a href="#1-ECMAScirpt-6-简介" class="headerlink" title="1. ECMAScirpt 6 简介"></a>1. ECMAScirpt 6 简介</h1><p>ESMAScript 6 是javascript 2016年发布的新标准。</p>
<h1 id="2-let和const命令"><a href="#2-let和const命令" class="headerlink" title="2. let和const命令"></a>2. let和const命令</h1><h3 id="2-1-let命令"><a href="#2-1-let命令" class="headerlink" title="2.1 let命令"></a>2.1 let命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>let</code> 声明的变量只在代码块中有效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  let a = 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for</code> 循环的计数器，就很适合使用<code>let</code>命令。此时计数器i只在循环体内有效。</p>
<p>另外，循环语句部分的变量和循环体内部的变量是分离的。</p>
<h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><p><code>let</code> 声明的变量不可以在声明之前被使用。否则会抛出错误。</p>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>只要一个代码块中使用了<code>let</code>声明一个变量，则它的全局同名变量在该代码块中不可用。</p>
<p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  // TDZ开始</span><br><span class="line">  tmp = &#x27;abc&#x27;; // ReferenceError</span><br><span class="line">  console.log(tmp); // ReferenceError</span><br><span class="line"></span><br><span class="line">  let tmp; // TDZ结束</span><br><span class="line">  console.log(tmp); // undefined</span><br><span class="line"></span><br><span class="line">  tmp = 123;</span><br><span class="line">  console.log(tmp); // 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>
<h3 id="2-2块级作用域"><a href="#2-2块级作用域" class="headerlink" title="2.2块级作用域"></a>2.2块级作用域</h3><h4 id="为什么需要块级作用域？"><a href="#为什么需要块级作用域？" class="headerlink" title="为什么需要块级作用域？"></a>为什么需要块级作用域？</h4><ol>
<li>内层变量可能会覆盖外层变量。</li>
<li>用来计数的循环变量泄露为全局变量。</li>
</ol>
<h4 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h4><p><code>let</code>实际上为 JavaScript 新增了块级作用域。</p>
<p>ES6 允许块级作用域的任意嵌套。</p>
<p>内层作用域可以定义外层作用域的同名变量。</p>
<p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// IIFE 写法</span><br><span class="line">(function () &#123;</span><br><span class="line">  var tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">// 块级作用域写法</span><br><span class="line">&#123;</span><br><span class="line">  let tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h4><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p>
<p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</p>
<p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明语句</span><br><span class="line">&#123;</span><br><span class="line">  let a = &#x27;secret&#x27;;</span><br><span class="line">  function f() &#123;</span><br><span class="line">    return a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">&#123;</span><br><span class="line">  let a = &#x27;secret&#x27;;</span><br><span class="line">  let f = function () &#123;</span><br><span class="line">    return a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p>
<h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h3><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在Node指的是<code>global</code>对象。</p>
<p>ES6为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<h3 id="global对象"><a href="#global对象" class="headerlink" title="global对象"></a>global对象</h3><p>垫片库<code>system.global</code>模拟了这个提案，可以在所有环境拿到<code>global</code>。</p>
<h1 id="3-变量的解构赋值"><a href="#3-变量的解构赋值" class="headerlink" title="3.变量的解构赋值"></a>3.变量的解构赋值</h1><h3 id="3-1数组的结构赋值"><a href="#3-1数组的结构赋值" class="headerlink" title="3.1数组的结构赋值"></a>3.1数组的结构赋值</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [a, b, c] = [1, 2, 3];</span><br></pre></td></tr></table></figure>
<p>解构赋值允许指定默认值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let [foo = true] = [];</span><br><span class="line">foo // true</span><br><span class="line"></span><br><span class="line">let [x, y = &#x27;b&#x27;] = [&#x27;a&#x27;]; // x=&#x27;a&#x27;, y=&#x27;b&#x27;</span><br><span class="line">let [x, y = &#x27;b&#x27;] = [&#x27;a&#x27;, undefined]; // x=&#x27;a&#x27;, y=&#x27;b&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="3-2对象的解构赋值"><a href="#3-2对象的解构赋值" class="headerlink" title="3.2对象的解构赋值"></a>3.2对象的解构赋值</h3><p>解构不仅可以用于数组，还可以用于对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">foo // &quot;aaa&quot;</span><br><span class="line">bar // &quot;bbb&quot;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-字符串的解构赋值"><a href="#3-3-字符串的解构赋值" class="headerlink" title="3.3 字符串的解构赋值"></a>3.3 字符串的解构赋值</h3><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const [a, b, c, d, e] = &#x27;hello&#x27;;</span><br><span class="line">a // &quot;h&quot;</span><br><span class="line">b // &quot;e&quot;</span><br><span class="line">c // &quot;l&quot;</span><br><span class="line">d // &quot;l&quot;</span><br><span class="line">e // &quot;o&quot;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-数值和布尔值的解构赋值"><a href="#3-4-数值和布尔值的解构赋值" class="headerlink" title="3.4 数值和布尔值的解构赋值"></a>3.4 数值和布尔值的解构赋值</h3><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let &#123;toString: s&#125; = 123;</span><br><span class="line">s === Number.prototype.toString // true</span><br><span class="line"></span><br><span class="line">let &#123;toString: s&#125; = true;</span><br><span class="line">s === Boolean.prototype.toString // true</span><br></pre></td></tr></table></figure>
<h3 id="3-5-函数参数的解构赋值"><a href="#3-5-函数参数的解构赋值" class="headerlink" title="3.5 函数参数的解构赋值"></a>3.5 函数参数的解构赋值</h3><p>函数的参数也可以使用解构赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add([x, y])&#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([1, 2]); // 3</span><br></pre></td></tr></table></figure>
<h3 id="3-6-用途"><a href="#3-6-用途" class="headerlink" title="3.6 用途"></a>3.6 用途</h3><ol>
<li>交换变量的值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let x = 1;</span><br><span class="line">let y = 2;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>
2.从函数返回多个值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 返回一个数组</span><br><span class="line"></span><br><span class="line">function example() &#123;</span><br><span class="line">  return [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">let [a, b, c] = example();</span><br><span class="line"></span><br><span class="line">// 返回一个对象</span><br><span class="line"></span><br><span class="line">function example() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    foo: 1,</span><br><span class="line">    bar: 2</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>
3.函数参数的定义<br>解构赋值可以方便地将一组参数与变量名对应起来。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 参数是一组有次序的值</span><br><span class="line">function f([x, y, z]) &#123; ... &#125;</span><br><span class="line">f([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// 参数是一组无次序的值</span><br><span class="line">function f(&#123;x, y, z&#125;) &#123; ... &#125;</span><br><span class="line">f(&#123;z: 3, y: 2, x: 1&#125;);</span><br></pre></td></tr></table></figure></li>
<li>提取JSON数据<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let jsonData = &#123;</span><br><span class="line">  id: 42,</span><br><span class="line">  status: &quot;OK&quot;,</span><br><span class="line">  data: [867, 5309]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; id, status, data: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line">console.log(id, status, number);</span><br><span class="line">// 42, &quot;OK&quot;, [867, 5309]</span><br></pre></td></tr></table></figure></li>
<li>函数参数的默认值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = function (url, &#123;</span><br><span class="line">  async = true,</span><br><span class="line">  beforeSend = function () &#123;&#125;,</span><br><span class="line">  cache = true,</span><br><span class="line">  complete = function () &#123;&#125;,</span><br><span class="line">  crossDomain = false,</span><br><span class="line">  global = true,</span><br><span class="line">  // ... more config</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  // ... do stuff</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
6.遍历map结构<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map();</span><br><span class="line">map.set(&#x27;first&#x27;, &#x27;hello&#x27;);</span><br><span class="line">map.set(&#x27;second&#x27;, &#x27;world&#x27;);</span><br><span class="line"></span><br><span class="line">for (let [key, value] of map) &#123;</span><br><span class="line">  console.log(key + &quot; is &quot; + value);</span><br><span class="line">&#125;</span><br><span class="line">// first is hello</span><br><span class="line">// second is world</span><br></pre></td></tr></table></figure></li>
<li>输入模块的指定方法<br>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="4-字符串的扩展"><a href="#4-字符串的扩展" class="headerlink" title="4. 字符串的扩展"></a>4. 字符串的扩展</h1><h3 id="4-1字符的Unicode表示法"><a href="#4-1字符的Unicode表示法" class="headerlink" title="4.1字符的Unicode表示法"></a>4.1字符的Unicode表示法</h3><p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;\u&#123;20BB7&#125;&quot;</span><br><span class="line">// &quot;𠮷&quot;</span><br><span class="line"></span><br><span class="line">&quot;\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;&quot;</span><br><span class="line">// &quot;ABC&quot;</span><br><span class="line"></span><br><span class="line">let hello = 123;</span><br><span class="line">hell\u&#123;6F&#125; // 123</span><br><span class="line"></span><br><span class="line">&#x27;\u&#123;1F680&#125;&#x27; === &#x27;\uD83D\uDE80&#x27;</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
<h3 id="4-2-codePointAt"><a href="#4-2-codePointAt" class="headerlink" title="4.2 codePointAt()"></a>4.2 codePointAt()</h3><p>ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = &#x27;𠮷a&#x27;;</span><br><span class="line"></span><br><span class="line">s.codePointAt(0) // 134071</span><br><span class="line">s.codePointAt(1) // 57271</span><br><span class="line">s.codePointAt(2) // 97</span><br></pre></td></tr></table></figure>
<h3 id="4-3-String-fromCodePoint"><a href="#4-3-String-fromCodePoint" class="headerlink" title="4.3 String.fromCodePoint()"></a>4.3 String.fromCodePoint()</h3><p>ES5提供String.fromCharCode方法，用于从码点返回对应字符。</p>
<h3 id="4-4-字符串的遍历器接口"><a href="#4-4-字符串的遍历器接口" class="headerlink" title="4.4 字符串的遍历器接口"></a>4.4 字符串的遍历器接口</h3><p>ES6为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (let codePoint of &#x27;foo&#x27;) &#123;</span><br><span class="line">  console.log(codePoint)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-at"><a href="#4-5-at" class="headerlink" title="4.5 at()"></a>4.5 at()</h3><p>ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。</p>
<h3 id="4-7-includes-startsWith-endsWith"><a href="#4-7-includes-startsWith-endsWith" class="headerlink" title="4.7 includes(), startsWith(), endsWith()"></a>4.7 includes(), startsWith(), endsWith()</h3><ul>
<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>
</ul>
<h3 id="4-8-repeat"><a href="#4-8-repeat" class="headerlink" title="4.8 repeat()"></a>4.8 repeat()</h3><p>repeat方法返回一个新字符串，表示将原字符串重复n次。</p>
<h3 id="4-9-padStart-，padEnd"><a href="#4-9-padStart-，padEnd" class="headerlink" title="4.9 padStart()，padEnd()"></a>4.9 padStart()，padEnd()</h3><p>ES2017引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</p>
<h3 id="4-10-模板字符串"><a href="#4-10-模板字符串" class="headerlink" title="4.10 模板字符串"></a>4.10 模板字符串</h3><p>模板字符串（template string）是增强版的字符串，用反引号（&#96;）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 普通字符串</span><br><span class="line">`In JavaScript &#x27;\n&#x27; is a line-feed.`</span><br><span class="line"></span><br><span class="line">// 多行字符串</span><br><span class="line">`In JavaScript this is</span><br><span class="line"> not legal.`</span><br><span class="line"></span><br><span class="line">console.log(`string text line 1</span><br><span class="line">string text line 2`);</span><br><span class="line"></span><br><span class="line">// 字符串中嵌入变量</span><br><span class="line">var name = &quot;Bob&quot;, time = &quot;today&quot;;</span><br><span class="line">`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`</span><br></pre></td></tr></table></figure>

<p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<ul>标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。</ul></p>
<p>模板字符串中嵌入变量，需要将变量名写在${}之中。<br>模板字符串之中还能调用函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br></pre></td></tr></table></figure>

<h3 id="4-12-标签模板"><a href="#4-12-标签模板" class="headerlink" title="4.12 标签模板"></a>4.12 标签模板</h3><h3 id="4-13-String-raw"><a href="#4-13-String-raw" class="headerlink" title="4.13 String.raw()"></a>4.13 String.raw()</h3><p>String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</p>
<h1 id="5-正则的扩展（跳过）"><a href="#5-正则的扩展（跳过）" class="headerlink" title="5. 正则的扩展（跳过）"></a>5. 正则的扩展（跳过）</h1><h1 id="6-数值的扩展"><a href="#6-数值的扩展" class="headerlink" title="6. 数值的扩展"></a>6. 数值的扩展</h1><h3 id="6-1-二进制和八进制表示法"><a href="#6-1-二进制和八进制表示法" class="headerlink" title="6.1 二进制和八进制表示法"></a>6.1 二进制和八进制表示法</h3><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。</p>
<h3 id="6-2-Number-isFinite-Number-isNaN"><a href="#6-2-Number-isFinite-Number-isNaN" class="headerlink" title="6.2 Number.isFinite(), Number.isNaN()"></a>6.2 Number.isFinite(), Number.isNaN()</h3><p>Number.isFinite()用来检查一个数值是否为有限的（finite）。<br>Number.isNaN()用来检查一个值是否为NaN。</p>
<h1 id="7-函数的扩展"><a href="#7-函数的扩展" class="headerlink" title="7. 函数的扩展"></a>7. 函数的扩展</h1><h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数变量是默认声明的，所以不能用let或const再次声明。</p>
<h3 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h3><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h3><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<h3 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h3><p>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</p>
<p>这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest 参数也不会计入length属性。</p>
<p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throwIfMissing</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Missing parameter&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">mustBeProvided = throwIfMissing()</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> mustBeProvided;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><p>ES6 引入 rest 参数（<strong>形式为…变量名</strong>），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...values</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><p>函数的name属性，返回该函数的函数名。</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6 允许使用“箭头”（&#x3D;&gt;）定义函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">f</span> = v =&gt; v;</span><br></pre></td></tr></table></figure>
<p>第一个v为参数，第二个v为返回值。</p>
<p>箭头函数的一个用处是简化回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure>
<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">g</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>
<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>
<h3 id="函数参数的尾逗号"><a href="#函数参数的尾逗号" class="headerlink" title="函数参数的尾逗号"></a>函数参数的尾逗号</h3><p>ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。</p>
<h1 id="8-数组的扩展"><a href="#8-数组的扩展" class="headerlink" title="8. 数组的扩展"></a>8. 数组的扩展</h1><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">v, w, x, y, z</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"><span class="title function_">f</span>(-<span class="number">1</span>, ...args, <span class="number">2</span>, ...[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="替代数组的apply方法"><a href="#替代数组的apply方法" class="headerlink" title="替代数组的apply方法"></a>替代数组的apply方法</h3><p>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="title function_">f</span>(...args);</span><br></pre></td></tr></table></figure>

<h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><h4 id="1-合并数组"><a href="#1-合并数组" class="headerlink" title="1. 合并数组"></a>1. 合并数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5的合并数组</span></span><br><span class="line">arr1.<span class="title function_">concat</span>(arr2, arr3);</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h4 id="2-与结构赋值结合"><a href="#2-与结构赋值结合" class="headerlink" title="2. 与结构赋值结合"></a>2. 与结构赋值结合</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h4 id="3-函数的返回值"><a href="#3-函数的返回值" class="headerlink" title="3. 函数的返回值"></a>3. 函数的返回值</h4><p>JavaScript 的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。</p>
<h4 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4. 字符串"></a>4. 字符串</h4><p>扩展运算符还可以将字符串转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure>

<h4 id="5-实现了Iterator接口的对象"><a href="#5-实现了Iterator接口的对象" class="headerlink" title="5. 实现了Iterator接口的对象"></a>5. 实现了Iterator接口的对象</h4><p>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> array = [...nodeList];</span><br></pre></td></tr></table></figure>
<p>上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。</p>
<h3 id="Array-form"><a href="#Array-form" class="headerlink" title="Array.form()"></a>Array.form()</h3><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于\uFFFF的Unicode字符，算作两个字符的bug。</p>
<h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of( )"></a>Array.of( )</h3><p>Array.of方法用于将一组值，转换为数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>).<span class="property">length</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="数组示例的copyWithin"><a href="#数组示例的copyWithin" class="headerlink" title="数组示例的copyWithin()"></a>数组示例的copyWithin()</h3><p>数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">copyWithin</span>(target, start = <span class="number">0</span>, end = <span class="variable language_">this</span>.<span class="property">length</span>)</span><br></pre></td></tr></table></figure>
<p>它接受三个参数。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ul>
<p>这三个参数都应该是数值，如果不是，会自动转为数值。</p>
<h3 id="数组实例的find-和findIndex"><a href="#数组实例的find-和findIndex" class="headerlink" title="数组实例的find()和findIndex()"></a>数组实例的find()和findIndex()</h3><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].<span class="title function_">find</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure>
<p>上面代码找出数组中第一个小于0的成员。</p>
<p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>
<h3 id="数组实例的fill"><a href="#数组实例的fill" class="headerlink" title="数组实例的fill()"></a>数组实例的fill()</h3><p>fill方法使用给定值，填充一个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_">fill</span>(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure>
<h3 id="数组实例的entries-keys-values"><a href="#数组实例的entries-keys-values" class="headerlink" title="数组实例的entries(),keys(),values()"></a>数组实例的entries(),keys(),values()</h3><p>ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="数组实例的includes"><a href="#数组实例的includes" class="headerlink" title="数组实例的includes()"></a>数组实例的includes()</h3><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="title class_">NaN</span>].<span class="title function_">includes</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h3><p>数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。</p>
<p>ES6 则是明确将空位转为undefined。</p>
<p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
<h1 id="9-对象的扩展"><a href="#9-对象的扩展" class="headerlink" title="9. 对象的扩展"></a>9. 对象的扩展</h1><h3 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h3><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;</span><br><span class="line">baz <span class="comment">// &#123;foo: &quot;bar&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h3><p>ES6 允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法的name属性"><a href="#方法的name属性" class="headerlink" title="方法的name属性"></a>方法的name属性</h3><p>函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="property">sayName</span>.<span class="property">name</span>   <span class="comment">// &quot;sayName&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。</p>
<h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致。</p>
<p>不同之处只有两个：一是+0不等于-0，二是NaN等于自身。</p>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>
<p>Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。</p>
<p>Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。</p>
<p>Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>
<h4 id="Object-assign-的用途"><a href="#Object-assign-的用途" class="headerlink" title="Object.assign()的用途"></a>Object.assign()的用途</h4><ol>
<li>为对象添加属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>为对象添加方法</li>
<li>克隆对象</li>
<li>合并多个对象</li>
<li>为属性制定默认值</li>
</ol>
<h3 id="属性的可枚举性"><a href="#属性的可枚举性" class="headerlink" title="属性的可枚举性"></a>属性的可枚举性</h3><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</p>
<p>描述对象的enumerable属性，称为”可枚举性“，如果该属性为false，就表示某些操作会忽略当前属性。</p>
<p>ES5 有三个操作会忽略enumerable为false的属性。</p>
<ul>
<li>for…in循环：只遍历对象自身的和继承的可枚举的属性</li>
<li>Object.keys()：返回对象自身的所有可枚举的属性的键名</li>
<li>JSON.stringify()：只串行化对象自身的可枚举的属性</li>
</ul>
<p>ES6 新增了一个操作Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</p>
<h3 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h3><p>ES6 一共有5种方法可以遍历对象的属性。</p>
<ol>
<li>for in</li>
<li>Object.keys(obj)</li>
<li>Object.getOwnPropertyNames(obj)</li>
<li>Object.getOwnPropertySymbols(obj)</li>
<li>Reflect.ownKeys(obj)</li>
</ol>
<h3 id="proto-属性，"><a href="#proto-属性，" class="headerlink" title="__proto__属性，"></a>__proto__属性，</h3><p>__proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es6的写法</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="property">__proto__</span> = someOtherObj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es5的写法</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(someOtherObj);</span><br><span class="line">obj.<span class="property">method</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<p>无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。</p>
<h3 id="Object-keys-Object-values-Object-entries"><a href="#Object-keys-Object-values-Object-entries" class="headerlink" title="Object.keys(),Object.values(),Object.entries()"></a>Object.keys(),Object.values(),Object.entries()</h3><p>ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for…of循环使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="title class_">Object</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="title function_">values</span>(obj)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>([key, value]); <span class="comment">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p>
<p>Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>
<h3 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h3><h5 id="1-解构赋值"><a href="#1-解构赋值" class="headerlink" title="1. 解构赋值"></a>1. 解构赋值</h5><p>对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure>
<p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p>
<h5 id="2-扩展运算符"><a href="#2-扩展运算符" class="headerlink" title="2. 扩展运算符"></a>2. 扩展运算符</h5><p>扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p>ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">bar</span>() &#123; <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line"><span class="comment">// &#123; foo:</span></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"><span class="comment">//    &#123; get: [Function: bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Null传导运算符"><a href="#Null传导运算符" class="headerlink" title="Null传导运算符"></a>Null传导运算符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = message?.<span class="property">body</span>?.<span class="property">user</span>?.<span class="property">firstName</span> || <span class="string">&#x27;default&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码有三个?.运算符，只要其中一个返回null或undefined，就不再往下运算，而是返回undefined。</p>
<h1 id="10-Symbol"><a href="#10-Symbol" class="headerlink" title="10. Symbol"></a>10. Symbol</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<p>Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s</span><br><span class="line"><span class="comment">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意，Symbol函数前不能使用new命令，否则会报错。</p>
<h3 id="作为属性名的Symbol"><a href="#作为属性名的Symbol" class="headerlink" title="作为属性名的Symbol"></a>作为属性名的Symbol</h3><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello!&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p>
<p>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
<p>还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</p>
<h3 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h3><p>Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。</p>
<p>Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="title class_">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="title class_">Symbol</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">obj[b] = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objectSymbols = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols</span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-for-Symbol-keyFor"><a href="#Symbol-for-Symbol-keyFor" class="headerlink" title="Symbol.for( ),Symbol.keyFor( )"></a>Symbol.for( ),Symbol.keyFor( )</h3><p>有时，我们希望重新使用同一个Symbol值，<code>Symbol.for</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol.for()</code>与S<code>ymbol()</code>这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。</p>
<p><code>Symbol.keyFor</code>方法返回一个已登记的 Symbol 类型值的key。</p>
<h3 id="内置的symbol值"><a href="#内置的symbol值" class="headerlink" title="内置的symbol值"></a>内置的symbol值</h3><p>除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。</p>
<h1 id="11-set和map数据结构"><a href="#11-set和map数据结构" class="headerlink" title="11. set和map数据结构"></a>11. set和map数据结构</h1><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h5 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h5><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p>Set 本身是一个构造函数，用来生成 Set 数据结构。</p>
<p>Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line">[...set]</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br><span class="line">items.<span class="property">size</span> <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例三</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">divs</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="title function_">divs</span>());</span><br><span class="line">set.<span class="property">size</span> <span class="comment">// 56</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="title function_">divs</span>().<span class="title function_">forEach</span>(<span class="function"><span class="params">div</span> =&gt;</span> set.<span class="title function_">add</span>(div));</span><br><span class="line">set.<span class="property">size</span> <span class="comment">// 56</span></span><br></pre></td></tr></table></figure>
<p>向Set加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（&#x3D;&#x3D;&#x3D;），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。</p>
<p>另外，两个对象总是不相等的。</p>
<h5 id="set实例的属性和方法"><a href="#set实例的属性和方法" class="headerlink" title="set实例的属性和方法"></a>set实例的属性和方法</h5><p>Set 结构的实例有以下属性。</p>
<ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是Set函数。</li>
<li><code>Set.prototype.size</code>：返回Set实例的成员总数。</li>
</ul>
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>
<ul>
<li><code>add(value)</code>：添加某个值，返回Set结构本身。</li>
<li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。</li>
<li><code>clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<h5 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h5><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p>
<p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>WeakSet 是一个构造函数，可以使用new命令，创建 WeakSet 数据结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br></pre></td></tr></table></figure>
<p>WeakSet 结构有以下三个方法。</p>
<ul>
<li>WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。</li>
<li>WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。</li>
<li>WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li>
</ul>
<p>WeakSet没有size属性，没有办法遍历它的成员。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h5 id="基本含义和用法"><a href="#基本含义和用法" class="headerlink" title="基本含义和用法"></a>基本含义和用法</h5><p>它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。</p>
<h5 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h5><ol>
<li>size属性<br> size属性返回 Map 结构的成员总数。</li>
<li>set(key, value)<br> set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。</li>
<li>get(key)<br> get方法读取key对应的键值，如果找不到key，返回undefined。</li>
<li>has(key)<br> has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li>
<li>delete(key)<br> delete方法删除某个键，返回true。如果删除失败，返回false。</li>
<li>clear()<br> clear方法清除所有成员，没有返回值。</li>
</ol>
<h5 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h5><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p>
<ul>
<li>keys()：返回键名的遍历器。</li>
<li>values()：返回键值的遍历器。</li>
<li>entries()：返回所有成员的遍历器。</li>
<li>forEach()：遍历 Map 的所有成员。</li>
</ul>
<p>结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。</p>
<h5 id="与其他数据结构的相互转换"><a href="#与其他数据结构的相互转换" class="headerlink" title="与其他数据结构的相互转换"></a>与其他数据结构的相互转换</h5><ol>
<li>map转换为数组</li>
<li>数组转换为map</li>
<li>map转换为对象</li>
<li>对象转换为map</li>
<li>map转换为json</li>
<li>JSON转换为map</li>
</ol>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</p>
<p>WeakMap的键名所指向的对象，不计入垃圾回收机制。</p>
<h1 id="12-Proxy"><a href="#12-Proxy" class="headerlink" title="12. Proxy"></a>12. Proxy</h1><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<h3 id="Proxy可以拦截的操作"><a href="#Proxy可以拦截的操作" class="headerlink" title="Proxy可以拦截的操作"></a>Proxy可以拦截的操作</h3><ol>
<li>get()<br> get方法用于拦截某个属性的读取操作。</li>
<li>set()<br> set方法用来拦截某个属性的赋值操作。</li>
<li>apply()<br> apply方法拦截函数的调用、call和apply操作。</li>
<li>has()<br> has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。</li>
<li>construct()<br> construct方法用于拦截new命令</li>
<li>deleteProperty()<br> deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。</li>
<li>defineProperty()<br> defineProperty方法拦截了Object.defineProperty操作。</li>
<li>getOwnPropertyDescriptors()<br> <code>getOwnPropertyDescriptor</code>方法拦截<code>Object.getOwnPropertyDescriptor()</code>，返回一个属性描述对象或者undefined。</li>
<li>getPrototypeOf()<br> getPrototypeOf方法主要用来拦截获取对象原型。</li>
<li>isExtensible()<br>isExtensible方法拦截Object.isExtensible操作。</li>
<li>ownKeys()<br>ownKeys方法用来拦截对象自身属性的读取操作。</li>
<li>preventExtensions()<br>preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。</li>
<li>setProrypeOf()<br>setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。</li>
</ol>
<h3 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h3><p>Proxy.revocable方法返回一个可取消的 Proxy 实例。</p>
<h1 id="13-Reflect"><a href="#13-Reflect" class="headerlink" title="13. Reflect"></a>13. Reflect</h1><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。</p>
<p>（1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</p>
<p>（2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</p>
<p>（3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</p>
<p>（4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</p>
<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2. 静态方法"></a>2. 静态方法</h3><ul>
<li>Reflect.apply(target,thisArg,args)</li>
<li>Reflect.construct(target,args)</li>
<li>Reflect.get(target,name,receiver)</li>
<li>Reflect.set(target,name,value,receiver)</li>
<li>Reflect.defineProperty(target,name,desc)</li>
<li>Reflect.deleteProperty(target,name)</li>
<li>Reflect.has(target,name)</li>
<li>Reflect.ownKeys(target)</li>
<li>Reflect.isExtensible(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.getOwnPropertyDescriptor(target, name)</li>
<li>Reflect.getPrototypeOf(target)</li>
<li>Reflect.setPrototypeOf(target, prototype)</li>
</ul>
<h1 id="14-Promise对象"><a href="#14-Promise对象" class="headerlink" title="14. Promise对象"></a>14. Promise对象</h1><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p>Promise对象有以下两个特点。</p>
<p>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。</p>
<p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/posts.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> json.<span class="property">post</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;/posts.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生错误！&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure>
<p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。</p>
<h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsPromise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>($.<span class="title function_">ajax</span>(<span class="string">&#x27;/whatever.json&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。</p>
<h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。</p>
<h3 id="两个有用的附加方法"><a href="#两个有用的附加方法" class="headerlink" title="两个有用的附加方法"></a>两个有用的附加方法</h3><h5 id="done"><a href="#done" class="headerlink" title="done()"></a>done()</h5><p>Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</p>
<h5 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h5><p>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>
<h1 id="15-Iterator-和-for…of循环"><a href="#15-Iterator-和-for…of循环" class="headerlink" title="15. Iterator 和 for…of循环"></a>15. Iterator 和 for…of循环</h1><h3 id="Iterator的概念"><a href="#Iterator的概念" class="headerlink" title="Iterator的概念"></a>Iterator的概念</h3><p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。</p>
<h3 id="默认Iterator接口"><a href="#默认Iterator接口" class="headerlink" title="默认Iterator接口"></a>默认Iterator接口</h3><p>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是”可遍历的“（iterable）。</p>
<p>ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。</p>
<p>原生具备 Iterator 接口的数据结构如下。</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
</ul>
<h3 id="调用Iterator的场合"><a href="#调用Iterator的场合" class="headerlink" title="调用Iterator的场合"></a>调用Iterator的场合</h3><p>有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for…of循环，还有几个别的场合。</p>
<ol>
<li>解构赋值</li>
<li>扩展运算符</li>
<li>yield<br> yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</li>
<li>数组作为参数的场合<ul>
<li>for…of</li>
<li>Array.from()</li>
<li>Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])）</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
</li>
</ol>
<h3 id="字符串的Iterator接口"><a href="#字符串的Iterator接口" class="headerlink" title="字符串的Iterator接口"></a>字符串的Iterator接口</h3><p>字符串是一个类似数组的对象，也原生具有 Iterator 接口。</p>
<h3 id="Iterator接口和Generator函数"><a href="#Iterator接口和Generator函数" class="headerlink" title="Iterator接口和Generator函数"></a>Iterator接口和Generator函数</h3><p>Symbol.iterator方法的最简单实现，还是使用下一章要介绍的Generator函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myIterable[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者采用下面的简洁写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历器对象的return-throw"><a href="#遍历器对象的return-throw" class="headerlink" title="遍历器对象的return(),throw()"></a>遍历器对象的return(),throw()</h3><p>遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。</p>
<p>return方法的使用场合是，如果for…of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。</p>
<h3 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h3><p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。</p>
<p>一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。</p>
<p>for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p>
<h1 id="16-Generator函数的语法"><a href="#16-Generator函数的语法" class="headerlink" title="16. Generator函数的语法"></a>16. Generator函数的语法</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p>
<p>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</p>
<h3 id="yield表达式"><a href="#yield表达式" class="headerlink" title="yield表达式"></a>yield表达式</h3><p>由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。</p>
<h1 id="18-async函数"><a href="#18-async函数" class="headerlink" title="18. async函数"></a>18. async函数</h1><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。<br>（1）内置执行器。</p>
<p>Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</p>
<p><code>var result = asyncReadFile();</code><br>上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。</p>
<p>（2）更好的语义。</p>
<p>async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p>
<p>（3）更广的适用性。</p>
<p>co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p>
<p>（4）返回值是 Promise。</p>
<p>async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</p>
<p>进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</p>
<h3 id="基本用法-3"><a href="#基本用法-3" class="headerlink" title="基本用法"></a>基本用法</h3><p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<h1 id="19-Class基本语法"><a href="#19-Class基本语法" class="headerlink" title="19. Class基本语法"></a>19. Class基本语法</h1><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。</p>
<p>基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。</p>
<h1 id="20-class的继承"><a href="#20-class的继承" class="headerlink" title="20. class的继承"></a>20. class的继承</h1><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>
<h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>Object.getPrototypeOf方法可以用来从子类上获取父类。</p>
<h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><p>第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。</p>
<p>第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<h3 id="类的prototype属性和-proto-属性"><a href="#类的prototype属性和-proto-属性" class="headerlink" title="类的prototype属性和__proto__属性"></a>类的prototype属性和__proto__属性</h3><p>大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。</p>
<p>（1）子类的__proto__属性，表示构造函数的继承，总是指向父类。</p>
<p>（2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。</p>
<h1 id="21-修饰器"><a href="#21-修饰器" class="headerlink" title="21. 修饰器"></a>21. 修饰器</h1><h3 id="类的修饰"><a href="#类的修饰" class="headerlink" title="类的修饰"></a>类的修饰</h3><p>修饰器（Decorator）是一个函数，用来修改类的行为。</p>
<h1 id="22-Module语法"><a href="#22-Module语法" class="headerlink" title="22. Module语法"></a>22. Module语法</h1><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="严格模式-1"><a href="#严格模式-1" class="headerlink" title="严格模式"></a>严格模式</h3><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。</p>
<h3 id="export命令"><a href="#export命令" class="headerlink" title="export命令"></a>export命令</h3><p>模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。</p>
<h3 id="import命令"><a href="#import命令" class="headerlink" title="import命令"></a>import命令</h3><p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;firstName, lastName, year&#125; <span class="keyword">from</span> <span class="string">&#x27;./profile&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  element.<span class="property">textContent</span> = firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h3><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。</p>
<h3 id="export-default命令"><a href="#export-default命令" class="headerlink" title="export default命令"></a>export default命令</h3><p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。</p>
<h1 id="23-Module的加载实现"><a href="#23-Module的加载实现" class="headerlink" title="23. Module的加载实现"></a>23. Module的加载实现</h1><h3 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h3><p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>defer是“渲染完再执行”，async是“下载完就执行”。</p>
<h5 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h5><p>浏览器加载 ES6 模块，也使用&lt;script&gt;标签，但是要加入type&#x3D;”module”属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;foo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&quot;./utils.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// other code</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="24-编程风格"><a href="#24-编程风格" class="headerlink" title="24. 编程风格"></a>24. 编程风格</h1><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><ol>
<li>let取代var</li>
<li>全局常量和线程安全<br> 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。</li>
</ol>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</p>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><ol>
<li>使用数组成员对变量赋值时，优先使用解构赋值。</li>
<li>函数的参数如果是对象的成员，优先使用解构赋值。</li>
</ol>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</p>
<p>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用<code>Object.assign</code>方法。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>使用扩展运算符（…）拷贝数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> itemsCopy = [...items];</span><br></pre></td></tr></table></figure>

<p>使用Array.from方法，将类似数组的对象转为数组。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol>
<li>立即执行函数可以写成箭头函数的形式。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Welcome to the Internet.&#x27;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
<li>箭头函数取代Function.prototype.bind，不应再用self&#x2F;_this&#x2F;that绑定 this。</li>
<li>不要在函数体内使用arguments变量，使用rest运算符（…）代替。</li>
<li>使用默认值语法设置函数参数的默认值。</li>
</ol>
<h3 id="map结构"><a href="#map结构" class="headerlink" title="map结构"></a>map结构</h3><p>注意区分Object和Map，只有模拟现实世界的实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制。</p>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。</p>
<p>使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。</p>
<br>
<br>
<br>
<br>
<br>

<h1 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h1><p><img src="/Blog/Blog/2022/05/15/ES6%E5%85%A5%E9%97%A8/%E7%BB%B4%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E9%94%AE%E7%9B%98%E5%AF%B9%E5%BA%94%E5%9B%BE.jpg" alt="输入法"></p>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></h6></h6>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Blog/2022/05/15/%E6%95%99%E8%B5%84%E9%9D%A2%E7%BB%8F/" rel="prev" title="教资面经">
      <i class="fa fa-chevron-left"></i> 教资面经
    </a></div>
      <div class="post-nav-item">
    <a href="/Blog/2022/10/16/MOSES%E5%85%A5%E9%97%A8/" rel="next" title="MOSES入门">
      MOSES入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">编者：艾孜尔江

1. ECMAScirpt 6 简介ESMAScript 6 是javascript 2016年发布的新标准。
2. let和const命令2.1 let命令基本用法let 声明的变量只在代码块中有效。
123{  let a &#x3D; 10;}
for 循环的计数器，就很适合使用let命令。此时计数器i只在循环体内有效。
另外，循环语句部分的变量和循环体内部的变量是分离的。
不存在变量提升let 声明的变量不可以在声明之前被使用。否则会抛出错误。
暂时性死区只要一个代码块中使用了let声明一个变量，则它的全局同名变量在该代码块中不可用。
总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。
1234567891011if (true) {  &#x2F;&#x2F; TDZ开始  tmp &#x3D; &#39;abc&#39;; &#x2F;&#x2F; ReferenceError  console.log(tmp); &#x2F;&#x2F; ReferenceError  let tmp; &#x2F;&#x2F; TDZ结束  console.log(tmp); &#x2F;&#x2F; undefined  tmp &#x3D; 123;  console.log(tmp); &#x2F;&#x2F; 123}
不允许重复声明let不允许在相同作用域内，重复声明同一个变量。
2.2块级作用域为什么需要块级作用域？
内层变量可能会覆盖外层变量。
用来计数的循环变量泄露为全局变量。

ES6 的块级作用域let实际上为 JavaScript 新增了块级作用域。
ES6 允许块级作用域的任意嵌套。
内层作用域可以定义外层作用域的同名变量。
块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。
1234567891011&#x2F;&#x2F; IIFE 写法(function () {  var tmp &#x3D; ...;  ...}());&#x2F;&#x2F; 块级作用域写法{  let tmp &#x3D; ...;  ...}
块级作用域与函数声明ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。
123456789101112131415&#x2F;&#x2F; 函数声明语句{  let a &#x3D; &#39;secret&#39;;  function f() {    return a;  }}&#x2F;&#x2F; 函数表达式{  let a &#x3D; &#39;secret&#39;;  let f &#x3D; function () {    return a;  };}
const命令const声明一个只读的常量。一旦声明，常量的值就不能改变。
const的作用域与let命令相同：只在声明所在的块级作用域内有效。
顶层对象的属性顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。
ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。
global对象垫片库system.global模拟了这个提案，可以在所有环境拿到global。
3.变量的解构赋值3.1数组的结构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。
1let [a, b, c] &#x3D; [1, 2, 3];
解构赋值允许指定默认值
12345let [foo &#x3D; true] &#x3D; [];foo &#x2F;&#x2F; truelet [x, y &#x3D; &#39;b&#39;] &#x3D; [&#39;a&#39;]; &#x2F;&#x2F; x&#x3D;&#39;a&#39;, y&#x3D;&#39;b&#39;let [x, y &#x3D; &#39;b&#39;] &#x3D; [&#39;a&#39;, undefined]; &#x2F;&#x2F; x&#x3D;&#39;a&#39;, y&#x3D;&#39;b&#39;
3.2对象的解构赋值解构不仅可以用于数组，还可以用于对象。
123let { foo, bar } &#x3D; { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };foo &#x2F;&#x2F; &quot;aaa&quot;bar &#x2F;&#x2F; &quot;bbb&quot;
3.3 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。
123456const [a, b, c, d, e] &#x3D; &#39;hello&#39;;a &#x2F;&#x2F; &quot;h&quot;b &#x2F;&#x2F; &quot;e&quot;c &#x2F;&#x2F; &quot;l&quot;d &#x2F;&#x2F; &quot;l&quot;e &#x2F;&#x2F; &quot;o&quot;
3.4 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
12345let {toString: s} &#x3D; 123;s &#x3D;&#x3D;&#x3D; Number.prototype.toString &#x2F;&#x2F; truelet {toString: s} &#x3D; true;s &#x3D;&#x3D;&#x3D; Boolean.prototype.toString &#x2F;&#x2F; true
3.5 函数参数的解构赋值函数的参数也可以使用解构赋值。
12345function add([x, y]){  return x + y;}add([1, 2]); &#x2F;&#x2F; 3
3.6 用途
交换变量的值1234let x &#x3D; 1;let y &#x3D; 2;[x, y] &#x3D; [y, x];
2.从函数返回多个值12345678910111213141516&#x2F;&#x2F; 返回一个数组function example() {  return [1, 2, 3];}let [a, b, c] &#x3D; example();&#x2F;&#x2F; 返回一个对象function example() {  return {    foo: 1,    bar: 2  };}let { foo, bar } &#x3D; example();
3.函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来。1234567&#x2F;&#x2F; 参数是一组有次序的值function f([x, y, z]) { ... }f([1, 2, 3]);&#x2F;&#x2F; 参数是一组无次序的值function f({x, y, z}) { ... }f({z: 3, y: 2, x: 1});
提取JSON数据12345678910let jsonData &#x3D; {  id: 42,  status: &quot;OK&quot;,  data: [867, 5309]};let { id, status, data: number } &#x3D; jsonData;console.log(id, status, number);&#x2F;&#x2F; 42, &quot;OK&quot;, [867, 5309]
函数参数的默认值1234567891011jQuery.ajax &#x3D; function (url, {  async &#x3D; true,  beforeSend &#x3D; function () {},  cache &#x3D; true,  complete &#x3D; function () {},  crossDomain &#x3D; false,  global &#x3D; true,  &#x2F;&#x2F; ... more config}) {  &#x2F;&#x2F; ... do stuff};
6.遍历map结构123456789var map &#x3D; new Map();map.set(&#39;first&#39;, &#39;hello&#39;);map.set(&#39;second&#39;, &#39;world&#39;);for (let [key, value] of map) {  console.log(key + &quot; is &quot; + value);}&#x2F;&#x2F; first is hello&#x2F;&#x2F; second is world
输入模块的指定方法加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。1const { SourceMapConsumer, SourceNode } &#x3D; require(&quot;source-map&quot;);

4. 字符串的扩展4.1字符的Unicode表示法ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。
1234567891011&quot;\u{20BB7}&quot;&#x2F;&#x2F; &quot;𠮷&quot;&quot;\u{41}\u{42}\u{43}&quot;&#x2F;&#x2F; &quot;ABC&quot;let hello &#x3D; 123;hell\u{6F} &#x2F;&#x2F; 123&#39;\u{1F680}&#39; &#x3D;&#x3D;&#x3D; &#39;\uD83D\uDE80&#39;&#x2F;&#x2F; true
4.2 codePointAt()ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。
12345var s &#x3D; &#39;𠮷a&#39;;s.codePointAt(0) &#x2F;&#x2F; 134071s.codePointAt(1) &#x2F;&#x2F; 57271s.codePointAt(2) &#x2F;&#x2F; 97
4.3 String.fromCodePoint()ES5提供String.fromCharCode方法，用于从码点返回对应字符。
4.4 字符串的遍历器接口ES6为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历。
123for (let codePoint of &#39;foo&#39;) {  console.log(codePoint)}

4.5 at()ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。
4.7 includes(), startsWith(), endsWith()
includes()：返回布尔值，表示是否找到了参数字符串。
startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。
endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。

4.8 repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。
4.9 padStart()，padEnd()ES2017引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。
4.10 模板字符串模板字符串（template string）是增强版的字符串，用反引号（&#96;）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。
12345678910111213&#x2F;&#x2F; 普通字符串&#96;In JavaScript &#39;\n&#39; is a line-feed.&#96;&#x2F;&#x2F; 多行字符串&#96;In JavaScript this is not legal.&#96;console.log(&#96;string text line 1string text line 2&#96;);&#x2F;&#x2F; 字符串中嵌入变量var name &#x3D; &quot;Bob&quot;, time &#x3D; &quot;today&quot;;&#96;Hello ${name}, how are you ${time}?&#96;

上面代码中，所有模板字符串的空格和换行，都是被保留的，比如标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。
模板字符串中嵌入变量，需要将变量名写在${}之中。模板字符串之中还能调用函数。
12345function fn() {  return &quot;Hello World&quot;;}&#96;foo ${fn()} bar&#96;

4.12 标签模板4.13 String.raw()String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。
5. 正则的扩展（跳过）6. 数值的扩展6.1 二进制和八进制表示法ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。
6.2 Number.isFinite(), Number.isNaN()Number.isFinite()用来检查一个数值是否为有限的（finite）。Number.isNaN()用来检查一个值是否为NaN。
7. 函数的扩展函数参数的默认值ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。
123function log(x, y &#x3D; &#39;World&#39;) {  console.log(x, y);}
参数变量是默认声明的，所以不能用let或const再次声明。
与解构赋值默认值结合使用参数默认值可以与解构赋值的默认值，结合起来使用。
123function foo({x, y &#x3D; 5}) {  console.log(x, y);}

参数默认值的位置通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。
函数的length属性指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest 参数也不会计入length属性。
如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。
作用域一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。
应用利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。
1234567function throwIfMissing() {  throw new Error(&#39;Missing parameter&#39;);}function foo(mustBeProvided &#x3D; throwIfMissing()) {  return mustBeProvided;}

rest参数ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。
1234567891011function add(...values) {  let sum &#x3D; 0;  for (var val of values) {    sum +&#x3D; val;  }  return sum;}add(2, 5, 3) &#x2F;&#x2F; 10

严格模式ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。
name属性函数的name属性，返回该函数的函数名。
箭头函数ES6 允许使用“箭头”（&#x3D;&gt;）定义函数。
1var f &#x3D; v &#x3D;&gt; v;
第一个v为参数，第二个v为返回值。
箭头函数的一个用处是简化回调函数。
1234567&#x2F;&#x2F; 正常函数写法[1,2,3].map(function (x) {  return x * x;});&#x2F;&#x2F; 箭头函数写法[1,2,3].map(x &#x3D;&gt; x * x);
尾调用优化尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。
123function f(x){  return g(x);}
尾调用之所以与其他调用不同，就在于它的特殊的调用位置。
我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。
尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。
尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。
递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。
由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。
函数参数的尾逗号ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。
8. 数组的扩展扩展运算符扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
扩展运算符与正常的函数参数可以结合使用，非常灵活。
123function f(v, w, x, y, z) { }var args &#x3D; [0, 1];f(-1, ...args, 2, ...[3]);

替代数组的apply方法由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。
12345678910111213&#x2F;&#x2F; ES5 的写法function f(x, y, z) {  &#x2F;&#x2F; ...}var args &#x3D; [0, 1, 2];f.apply(null, args);&#x2F;&#x2F; ES6的写法function f(x, y, z) {  &#x2F;&#x2F; ...}var args &#x3D; [0, 1, 2];f(...args);

扩展运算符的应用1. 合并数组1234567&#x2F;&#x2F; ES5的合并数组arr1.concat(arr2, arr3);&#x2F;&#x2F; [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]&#x2F;&#x2F; ES6的合并数组[...arr1, ...arr2, ...arr3]&#x2F;&#x2F; [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]

2. 与结构赋值结合123const [first, ...rest] &#x3D; [1, 2, 3, 4, 5];first &#x2F;&#x2F; 1rest  &#x2F;&#x2F; [2, 3, 4, 5]

3. 函数的返回值JavaScript 的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。
4. 字符串扩展运算符还可以将字符串转为真正的数组。
12[...&#39;hello&#39;]&#x2F;&#x2F; [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]

5. 实现了Iterator接口的对象任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。
12var nodeList &#x3D; document.querySelectorAll(&#39;div&#39;);var array &#x3D; [...nodeList];
上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。
Array.form()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。
123456789101112let arrayLike &#x3D; {    &#39;0&#39;: &#39;a&#39;,    &#39;1&#39;: &#39;b&#39;,    &#39;2&#39;: &#39;c&#39;,    length: 3};&#x2F;&#x2F; ES5的写法var arr1 &#x3D; [].slice.call(arrayLike); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&#x2F;&#x2F; ES6的写法let arr2 &#x3D; Array.from(arrayLike); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于\uFFFF的Unicode字符，算作两个字符的bug。
Array.of( )Array.of方法用于将一组值，转换为数组。
123Array.of(3, 11, 8) &#x2F;&#x2F; [3,11,8]Array.of(3) &#x2F;&#x2F; [3]Array.of(3).length &#x2F;&#x2F; 1

数组示例的copyWithin()数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。
1Array.prototype.copyWithin(target, start &#x3D; 0, end &#x3D; this.length)
它接受三个参数。

target（必需）：从该位置开始替换数据。
start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。
end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。

这三个参数都应该是数值，如果不是，会自动转为数值。
数组实例的find()和findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。
12[1, 4, -5, 10].find((n) &#x3D;&gt; n &lt; 0)&#x2F;&#x2F; -5
上面代码找出数组中第一个小于0的成员。
数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。
数组实例的fill()fill方法使用给定值，填充一个数组。
12[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)&#x2F;&#x2F; [7, 7, 7]
数组实例的entries(),keys(),values()ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。
1234567891011121314151617for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) {  console.log(index);}&#x2F;&#x2F; 0&#x2F;&#x2F; 1for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) {  console.log(elem);}&#x2F;&#x2F; &#39;a&#39;&#x2F;&#x2F; &#39;b&#39;for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) {  console.log(index, elem);}&#x2F;&#x2F; 0 &quot;a&quot;&#x2F;&#x2F; 1 &quot;b&quot;

数组实例的includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。
123[1, 2, 3].includes(2)     &#x2F;&#x2F; true[1, 2, 3].includes(4)     &#x2F;&#x2F; false[1, 2, NaN].includes(NaN) &#x2F;&#x2F; true

数组的空位数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。
ES6 则是明确将空位转为undefined。
由于空位的处理规则非常不统一，所以建议避免出现空位。
9. 对象的扩展属性的简洁表示法ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。
123456var foo &#x3D; &#39;bar&#39;;var baz &#x3D; {foo};baz &#x2F;&#x2F; {foo: &quot;bar&quot;}&#x2F;&#x2F; 等同于var baz &#x3D; {foo: foo};

属性名表达式ES6 允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。
123456let propKey &#x3D; &#39;foo&#39;;let obj &#x3D; {  [propKey]: true,  [&#39;a&#39; + &#39;bc&#39;]: 123};

方法的name属性函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。
1234567const person &#x3D; {  sayName() {    console.log(&#39;hello!&#39;);  },};person.sayName.name   &#x2F;&#x2F; &quot;sayName&quot;
如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。
Object.is()ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致。
不同之处只有两个：一是+0不等于-0，二是NaN等于自身。
Object.assign()Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。
1234567var target &#x3D; { a: 1 };var source1 &#x3D; { b: 2 };var source2 &#x3D; { c: 3 };Object.assign(target, source1, source2);target &#x2F;&#x2F; {a:1, b:2, c:3}
Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。
Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。
Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。
Object.assign()的用途
为对象添加属性12345class Point {  constructor(x, y) {    Object.assign(this, {x, y});  }}
为对象添加方法
克隆对象
合并多个对象
为属性制定默认值

属性的可枚举性对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。
描述对象的enumerable属性，称为”可枚举性“，如果该属性为false，就表示某些操作会忽略当前属性。
ES5 有三个操作会忽略enumerable为false的属性。

for…in循环：只遍历对象自身的和继承的可枚举的属性
Object.keys()：返回对象自身的所有可枚举的属性的键名
JSON.stringify()：只串行化对象自身的可枚举的属性

ES6 新增了一个操作Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。
属性的遍历ES6 一共有5种方法可以遍历对象的属性。

for in
Object.keys(obj)
Object.getOwnPropertyNames(obj)
Object.getOwnPropertySymbols(obj)
Reflect.ownKeys(obj)

__proto__属性，__proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。
123456789&#x2F;&#x2F; es6的写法var obj &#x3D; {  method: function() { ... }};obj.__proto__ &#x3D; someOtherObj;&#x2F;&#x2F; es5的写法var obj &#x3D; Object.create(someOtherObj);obj.method &#x3D; function() { ... };
无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。
Object.keys(),Object.values(),Object.entries()ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for…of循环使用。
1234567891011121314let {keys, values, entries} &#x3D; Object;let obj &#x3D; { a: 1, b: 2, c: 3 };for (let key of keys(obj)) {    console.log(key); &#x2F;&#x2F; &#39;a&#39;, &#39;b&#39;, &#39;c&#39;}for (let value of values(obj)) {    console.log(value); &#x2F;&#x2F; 1, 2, 3}for (let [key, value] of entries(obj)) {    console.log([key, value]); &#x2F;&#x2F; [&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]}
Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。
Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。
对象的扩展运算符1. 解构赋值对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。
1234let { x, y, ...z } &#x3D; { x: 1, y: 2, a: 3, b: 4 };x &#x2F;&#x2F; 1y &#x2F;&#x2F; 2z &#x2F;&#x2F; { a: 3, b: 4 }
注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。
2. 扩展运算符扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。
123let z &#x3D; { a: 3, b: 4 };let n &#x3D; { ...z };n &#x2F;&#x2F; { a: 3, b: 4 }

Object.getOwnPropertyDescriptors()ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。
12345678910111213141516const obj &#x3D; {  foo: 123,  get bar() { return &#39;abc&#39; }};Object.getOwnPropertyDescriptors(obj)&#x2F;&#x2F; { foo:&#x2F;&#x2F;    { value: 123,&#x2F;&#x2F;      writable: true,&#x2F;&#x2F;      enumerable: true,&#x2F;&#x2F;      configurable: true },&#x2F;&#x2F;   bar:&#x2F;&#x2F;    { get: [Function: bar],&#x2F;&#x2F;      set: undefined,&#x2F;&#x2F;      enumerable: true,&#x2F;&#x2F;      configurable: true } }

Null传导运算符1const firstName &#x3D; message?.body?.user?.firstName || &#39;default&#39;;

上面代码有三个?.运算符，只要其中一个返回null或undefined，就不再往下运算，而是返回undefined。
10. Symbol概述ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。
Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。
1234let s &#x3D; Symbol();typeof s&#x2F;&#x2F; &quot;symbol&quot;

注意，Symbol函数前不能使用new命令，否则会报错。
作为属性名的Symbol由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。
1234567891011121314151617var mySymbol &#x3D; Symbol();&#x2F;&#x2F; 第一种写法var a &#x3D; {};a[mySymbol] &#x3D; &#39;Hello!&#39;;&#x2F;&#x2F; 第二种写法var a &#x3D; {  [mySymbol]: &#39;Hello!&#39;};&#x2F;&#x2F; 第三种写法var a &#x3D; {};Object.defineProperty(a, mySymbol, { value: &#39;Hello!&#39; });&#x2F;&#x2F; 以上写法都得到同样结果a[mySymbol] &#x2F;&#x2F; &quot;Hello!&quot;
注意，Symbol 值作为对象属性名时，不能用点运算符。
同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。
还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。
属性名的遍历Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。
Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。
1234567891011var obj &#x3D; {};var a &#x3D; Symbol(&#39;a&#39;);var b &#x3D; Symbol(&#39;b&#39;);obj[a] &#x3D; &#39;Hello&#39;;obj[b] &#x3D; &#39;World&#39;;var objectSymbols &#x3D; Object.getOwnPropertySymbols(obj);objectSymbols&#x2F;&#x2F; [Symbol(a), Symbol(b)]

Symbol.for( ),Symbol.keyFor( )有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。
1234var s1 &#x3D; Symbol.for(&#39;foo&#39;);var s2 &#x3D; Symbol.for(&#39;foo&#39;);s1 &#x3D;&#x3D;&#x3D; s2 &#x2F;&#x2F; true

Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。
Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。
内置的symbol值除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。
11. set和map数据结构set基本用法ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
Set 本身是一个构造函数，用来生成 Set 数据结构。
Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。
1234567891011121314151617181920&#x2F;&#x2F; 例一const set &#x3D; new Set([1, 2, 3, 4, 4]);[...set]&#x2F;&#x2F; [1, 2, 3, 4]&#x2F;&#x2F; 例二const items &#x3D; new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size &#x2F;&#x2F; 5&#x2F;&#x2F; 例三function divs () {  return [...document.querySelectorAll(&#39;div&#39;)];}const set &#x3D; new Set(divs());set.size &#x2F;&#x2F; 56&#x2F;&#x2F; 类似于divs().forEach(div &#x3D;&gt; set.add(div));set.size &#x2F;&#x2F; 56
向Set加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（&#x3D;&#x3D;&#x3D;），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。
另外，两个对象总是不相等的。
set实例的属性和方法Set 结构的实例有以下属性。

Set.prototype.constructor：构造函数，默认就是Set函数。
Set.prototype.size：返回Set实例的成员总数。

Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。

add(value)：添加某个值，返回Set结构本身。
delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
has(value)：返回一个布尔值，表示该值是否为Set的成员。
clear()：清除所有成员，没有返回值。

遍历操作Set 结构的实例有四个遍历方法，可以用于遍历成员。

keys()：返回键名的遍历器
values()：返回键值的遍历器
entries()：返回键值对的遍历器
forEach()：使用回调函数遍历每个成员

WeakSetWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。
首先，WeakSet 的成员只能是对象，而不能是其他类型的值。
其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。
语法WeakSet 是一个构造函数，可以使用new命令，创建 WeakSet 数据结构。
1const ws &#x3D; new WeakSet();
WeakSet 结构有以下三个方法。

WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。
WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。
WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。

WeakSet没有size属性，没有办法遍历它的成员。
Map基本含义和用法它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。
事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。
实例的属性和操作方法
size属性 size属性返回 Map 结构的成员总数。
set(key, value) set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。
get(key) get方法读取key对应的键值，如果找不到key，返回undefined。
has(key) has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。
delete(key) delete方法删除某个键，返回true。如果删除失败，返回false。
clear() clear方法清除所有成员，没有返回值。

遍历方法Map 结构原生提供三个遍历器生成函数和一个遍历方法。

keys()：返回键名的遍历器。
values()：返回键值的遍历器。
entries()：返回所有成员的遍历器。
forEach()：遍历 Map 的所有成员。

结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。
与其他数据结构的相互转换
map转换为数组
数组转换为map
map转换为对象
对象转换为map
map转换为json
JSON转换为map

WeakMapWeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
WeakMap的键名所指向的对象，不计入垃圾回收机制。
12. Proxy概述Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。
Proxy可以拦截的操作
get() get方法用于拦截某个属性的读取操作。
set() set方法用来拦截某个属性的赋值操作。
apply() apply方法拦截函数的调用、call和apply操作。
has() has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。
construct() construct方法用于拦截new命令
deleteProperty() deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。
defineProperty() defineProperty方法拦截了Object.defineProperty操作。
getOwnPropertyDescriptors() getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。
getPrototypeOf() getPrototypeOf方法主要用来拦截获取对象原型。
isExtensible()isExtensible方法拦截Object.isExtensible操作。
ownKeys()ownKeys方法用来拦截对象自身属性的读取操作。
preventExtensions()preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。
setProrypeOf()setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。

Proxy.revocable()Proxy.revocable方法返回一个可取消的 Proxy 实例。
13. Reflect概述Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。
（1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。
（2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。
（3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。
（4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。
2. 静态方法
Reflect.apply(target,thisArg,args)
Reflect.construct(target,args)
Reflect.get(target,name,receiver)
Reflect.set(target,name,value,receiver)
Reflect.defineProperty(target,name,desc)
Reflect.deleteProperty(target,name)
Reflect.has(target,name)
Reflect.ownKeys(target)
Reflect.isExtensible(target)
Reflect.preventExtensions(target)
Reflect.getOwnPropertyDescriptor(target, name)
Reflect.getPrototypeOf(target)
Reflect.setPrototypeOf(target, prototype)

14. Promise对象Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。
所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。
Promise对象有以下两个特点。
（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。
（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。
Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
基本用法ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。
123456789var promise &#x3D; new Promise(function(resolve, reject) {  &#x2F;&#x2F; ... some code  if (&#x2F;* 异步操作成功 *&#x2F;){    resolve(value);  } else {    reject(error);  }});

Promise.prototype.then()Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。
then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。
12345getJSON(&quot;&#x2F;posts.json&quot;).then(function(json) {  return json.post;}).then(function(post) {  &#x2F;&#x2F; ...});
上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。
Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。
123456getJSON(&#39;&#x2F;posts.json&#39;).then(function(posts) {  &#x2F;&#x2F; ...}).catch(function(error) {  &#x2F;&#x2F; 处理 getJSON 和 前一个回调函数运行时发生的错误  console.log(&#39;发生错误！&#39;, error);});

Promise.all()Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。
1var p &#x3D; Promise.all([p1, p2, p3]);
上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）
Promise.race()Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。
Promise.resolve()有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。
1var jsPromise &#x3D; Promise.resolve($.ajax(&#39;&#x2F;whatever.json&#39;));
上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。
Promise.reject()Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。
两个有用的附加方法done()Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。
finally()finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。
15. Iterator 和 for…of循环Iterator的概念遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。
Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。
默认Iterator接口一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是”可遍历的“（iterable）。
ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。
原生具备 Iterator 接口的数据结构如下。

Array
Map
Set
String
TypedArray
函数的 arguments 对象

调用Iterator的场合有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for…of循环，还有几个别的场合。

解构赋值
扩展运算符
yield yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。
数组作为参数的场合
for…of
Array.from()
Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])）
Promise.all()
Promise.race()



字符串的Iterator接口字符串是一个类似数组的对象，也原生具有 Iterator 接口。
Iterator接口和Generator函数Symbol.iterator方法的最简单实现，还是使用下一章要介绍的Generator函数。
1234567891011121314151617181920212223var myIterable &#x3D; {};myIterable[Symbol.iterator] &#x3D; function* () {  yield 1;  yield 2;  yield 3;};[...myIterable] &#x2F;&#x2F; [1, 2, 3]&#x2F;&#x2F; 或者采用下面的简洁写法let obj &#x3D; {  * [Symbol.iterator]() {    yield &#39;hello&#39;;    yield &#39;world&#39;;  }};for (let x of obj) {  console.log(x);}&#x2F;&#x2F; hello&#x2F;&#x2F; world

遍历器对象的return(),throw()遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。
return方法的使用场合是，如果for…of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。
for…of循环ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。
一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。
for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。
16. Generator函数的语法简介Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。
形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。
yield表达式由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。
18. async函数含义async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。（1）内置执行器。
Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。
var result &#x3D; asyncReadFile();上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。
（2）更好的语义。
async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。
（3）更广的适用性。
co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。
（4）返回值是 Promise。
async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。
进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。
基本用法async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。
19. Class基本语法简介ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。
基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。
20. class的继承简介Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。
Object.getPrototypeOf()Object.getPrototypeOf方法可以用来从子类上获取父类。
super 关键字第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。
第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
类的prototype属性和__proto__属性大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。
（1）子类的__proto__属性，表示构造函数的继承，总是指向父类。
（2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。
21. 修饰器类的修饰修饰器（Decorator）是一个函数，用来修改类的行为。
22. Module语法概述ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。
1import { stat, exists, readFile } from &#39;fs&#39;;

严格模式ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。
export命令模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。
一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。
import命令使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。
123456&#x2F;&#x2F; main.jsimport {firstName, lastName, year} from &#39;.&#x2F;profile&#39;;function setName(element) {  element.textContent &#x3D; firstName + &#39; &#39; + lastName;}

模块的整体加载除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。
export default命令为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。
23. Module的加载实现浏览器加载如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。
12&lt;script src&#x3D;&quot;path&#x2F;to&#x2F;myModule.js&quot; defer&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;path&#x2F;to&#x2F;myModule.js&quot; async&gt;&lt;&#x2F;script&gt;
defer是“渲染完再执行”，async是“下载完就执行”。
加载规则浏览器加载 ES6 模块，也使用&lt;script&gt;标签，但是要加入type&#x3D;”module”属性。
1&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;foo.js&quot;&gt;&lt;&#x2F;script&gt;
ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。
12345&lt;script type&#x3D;&quot;module&quot;&gt;  import utils from &quot;.&#x2F;utils.js&quot;;  &#x2F;&#x2F; other code&lt;&#x2F;script&gt;

24. 编程风格块级作用域
let取代var
全局常量和线程安全 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。

字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。
解构赋值
使用数组成员对变量赋值时，优先使用解构赋值。
函数的参数如果是对象的成员，优先使用解构赋值。

对象单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。
对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。
数组使用扩展运算符（…）拷贝数组。
1const itemsCopy &#x3D; [...items];

使用Array.from方法，将类似数组的对象转为数组。
函数
立即执行函数可以写成箭头函数的形式。123(() &#x3D;&gt; {  console.log(&#39;Welcome to the Internet.&#39;);})();
箭头函数取代Function.prototype.bind，不应再用self&#x2F;_this&#x2F;that绑定 this。
不要在函数体内使用arguments变量，使用rest运算符（…）代替。
使用默认值语法设置函数参数的默认值。

map结构注意区分Object和Map，只有模拟现实世界的实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制。
Class总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。
使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。
模块首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。






输入法
















</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">

1. ECMAScirpt 6 简介ESMAScript 6 是javascript 2016年发布的新标准。
2. let和const命令2.1 let命令基本用法let 声明的变量只在代码块中有效。
123{  let a &#x3D; 10;}
for 循环的计数器，就很适合使用let命令。此时计数器i只在循环体内有效。
另外，循环语句部分的变量和循环体内部的变量是分离的。
不存在变量提升let 声明的变量不可以在声明之前被使用。否则会抛出错误。
暂时性死区只要一个代码块中使用了let声明一个变量，则它的全局同名变量在该代码块中不可用。
总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。
1234567891011if (true) {  &#x2F;&#x2F; TDZ开始  tmp &#x3D; &#39;abc&#39;; &#x2F;&#x2F; ReferenceError  console.log(tmp); &#x2F;&#x2F; ReferenceError  let tmp; &#x2F;&#x2F; TDZ结束  console.log(tmp); &#x2F;&#x2F; undefined  tmp &#x3D; 123;  console.log(tmp); &#x2F;&#x2F; 123}
不允许重复声明let不允许在相同作用域内，重复声明同一个变量。
2.2块级作用域为什么需要块级作用域？
内层变量可能会覆盖外层变量。
用来计数的循环变量泄露为全局变量。

ES6 的块级作用域let实际上为 JavaScript 新增了块级作用域。
ES6 允许块级作用域的任意嵌套。
内层作用域可以定义外层作用域的同名变量。
块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。
1234567891011&#x2F;&#x2F; IIFE 写法(function () {  var tmp &#x3D; ...;  ...}());&#x2F;&#x2F; 块级作用域写法{  let tmp &#x3D; ...;  ...}
块级作用域与函数声明ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。
123456789101112131415&#x2F;&#x2F; 函数声明语句{  let a &#x3D; &#39;secret&#39;;  function f() {    return a;  }}&#x2F;&#x2F; 函数表达式{  let a &#x3D; &#39;secret&#39;;  let f &#x3D; function () {    return a;  };}
const命令const声明一个只读的常量。一旦声明，常量的值就不能改变。
const的作用域与let命令相同：只在声明所在的块级作用域内有效。
顶层对象的属性顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。
ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。
global对象垫片库system.global模拟了这个提案，可以在所有环境拿到global。
3.变量的解构赋值3.1数组的结构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。
1let [a, b, c] &#x3D; [1, 2, 3];
解构赋值允许指定默认值
12345let [foo &#x3D; true] &#x3D; [];foo &#x2F;&#x2F; truelet [x, y &#x3D; &#39;b&#39;] &#x3D; [&#39;a&#39;]; &#x2F;&#x2F; x&#x3D;&#39;a&#39;, y&#x3D;&#39;b&#39;let [x, y &#x3D; &#39;b&#39;] &#x3D; [&#39;a&#39;, undefined]; &#x2F;&#x2F; x&#x3D;&#39;a&#39;, y&#x3D;&#39;b&#39;
3.2对象的解构赋值解构不仅可以用于数组，还可以用于对象。
123let { foo, bar } &#x3D; { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };foo &#x2F;&#x2F; &quot;aaa&quot;bar &#x2F;&#x2F; &quot;bbb&quot;
3.3 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。
123456const [a, b, c, d, e] &#x3D; &#39;hello&#39;;a &#x2F;&#x2F; &quot;h&quot;b &#x2F;&#x2F; &quot;e&quot;c &#x2F;&#x2F; &quot;l&quot;d &#x2F;&#x2F; &quot;l&quot;e &#x2F;&#x2F; &quot;o&quot;
3.4 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
12345let {toString: s} &#x3D; 123;s &#x3D;&#x3D;&#x3D; Number.prototype.toString &#x2F;&#x2F; truelet {toString: s} &#x3D; true;s &#x3D;&#x3D;&#x3D; Boolean.prototype.toString &#x2F;&#x2F; true
3.5 函数参数的解构赋值函数的参数也可以使用解构赋值。
12345function add([x, y]){  return x + y;}add([1, 2]); &#x2F;&#x2F; 3
3.6 用途
交换变量的值1234let x &#x3D; 1;let y &#x3D; 2;[x, y] &#x3D; [y, x];
2.从函数返回多个值12345678910111213141516&#x2F;&#x2F; 返回一个数组function example() {  return [1, 2, 3];}let [a, b, c] &#x3D; example();&#x2F;&#x2F; 返回一个对象function example() {  return {    foo: 1,    bar: 2  };}let { foo, bar } &#x3D; example();
3.函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来。1234567&#x2F;&#x2F; 参数是一组有次序的值function f([x, y, z]) { ... }f([1, 2, 3]);&#x2F;&#x2F; 参数是一组无次序的值function f({x, y, z}) { ... }f({z: 3, y: 2, x: 1});
提取JSON数据12345678910let jsonData &#x3D; {  id: 42,  status: &quot;OK&quot;,  data: [867, 5309]};let { id, status, data: number } &#x3D; jsonData;console.log(id, status, number);&#x2F;&#x2F; 42, &quot;OK&quot;, [867, 5309]
函数参数的默认值1234567891011jQuery.ajax &#x3D; function (url, {  async &#x3D; true,  beforeSend &#x3D; function () {},  cache &#x3D; true,  complete &#x3D; function () {},  crossDomain &#x3D; false,  global &#x3D; true,  &#x2F;&#x2F; ... more config}) {  &#x2F;&#x2F; ... do stuff};
6.遍历map结构123456789var map &#x3D; new Map();map.set(&#39;first&#39;, &#39;hello&#39;);map.set(&#39;second&#39;, &#39;world&#39;);for (let [key, value] of map) {  console.log(key + &quot; is &quot; + value);}&#x2F;&#x2F; first is hello&#x2F;&#x2F; second is world
输入模块的指定方法加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。1const { SourceMapConsumer, SourceNode } &#x3D; require(&quot;source-map&quot;);

4. 字符串的扩展4.1字符的Unicode表示法ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。
1234567891011&quot;\u{20BB7}&quot;&#x2F;&#x2F; &quot;𠮷&quot;&quot;\u{41}\u{42}\u{43}&quot;&#x2F;&#x2F; &quot;ABC&quot;let hello &#x3D; 123;hell\u{6F} &#x2F;&#x2F; 123&#39;\u{1F680}&#39; &#x3D;&#x3D;&#x3D; &#39;\uD83D\uDE80&#39;&#x2F;&#x2F; true
4.2 codePointAt()ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。
12345var s &#x3D; &#39;𠮷a&#39;;s.codePointAt(0) &#x2F;&#x2F; 134071s.codePointAt(1) &#x2F;&#x2F; 57271s.codePointAt(2) &#x2F;&#x2F; 97
4.3 String.fromCodePoint()ES5提供String.fromCharCode方法，用于从码点返回对应字符。
4.4 字符串的遍历器接口ES6为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历。
123for (let codePoint of &#39;foo&#39;) {  console.log(codePoint)}

4.5 at()ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。
4.7 includes(), startsWith(), endsWith()
includes()：返回布尔值，表示是否找到了参数字符串。
startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。
endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。

4.8 repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。
4.9 padStart()，padEnd()ES2017引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。
4.10 模板字符串模板字符串（template string）是增强版的字符串，用反引号（&#96;）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。
12345678910111213&#x2F;&#x2F; 普通字符串&#96;In JavaScript &#39;\n&#39; is a line-feed.&#96;&#x2F;&#x2F; 多行字符串&#96;In JavaScript this is not legal.&#96;console.log(&#96;string text line 1string text line 2&#96;);&#x2F;&#x2F; 字符串中嵌入变量var name &#x3D; &quot;Bob&quot;, time &#x3D; &quot;today&quot;;&#96;Hello ${name}, how are you ${time}?&#96;

上面代码中，所有模板字符串的空格和换行，都是被保留的，比如标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。
模板字符串中嵌入变量，需要将变量名写在${}之中。模板字符串之中还能调用函数。
12345function fn() {  return &quot;Hello World&quot;;}&#96;foo ${fn()} bar&#96;

4.12 标签模板4.13 String.raw()String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。
5. 正则的扩展（跳过）6. 数值的扩展6.1 二进制和八进制表示法ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。
6.2 Number.isFinite(), Number.isNaN()Number.isFinite()用来检查一个数值是否为有限的（finite）。Number.isNaN()用来检查一个值是否为NaN。
7. 函数的扩展函数参数的默认值ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。
123function log(x, y &#x3D; &#39;World&#39;) {  console.log(x, y);}
参数变量是默认声明的，所以不能用let或const再次声明。
与解构赋值默认值结合使用参数默认值可以与解构赋值的默认值，结合起来使用。
123function foo({x, y &#x3D; 5}) {  console.log(x, y);}

参数默认值的位置通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。
函数的length属性指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest 参数也不会计入length属性。
如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。
作用域一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。
应用利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。
1234567function throwIfMissing() {  throw new Error(&#39;Missing parameter&#39;);}function foo(mustBeProvided &#x3D; throwIfMissing()) {  return mustBeProvided;}

rest参数ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。
1234567891011function add(...values) {  let sum &#x3D; 0;  for (var val of values) {    sum +&#x3D; val;  }  return sum;}add(2, 5, 3) &#x2F;&#x2F; 10

严格模式ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。
name属性函数的name属性，返回该函数的函数名。
箭头函数ES6 允许使用“箭头”（&#x3D;&gt;）定义函数。
1var f &#x3D; v &#x3D;&gt; v;
第一个v为参数，第二个v为返回值。
箭头函数的一个用处是简化回调函数。
1234567&#x2F;&#x2F; 正常函数写法[1,2,3].map(function (x) {  return x * x;});&#x2F;&#x2F; 箭头函数写法[1,2,3].map(x &#x3D;&gt; x * x);
尾调用优化尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。
123function f(x){  return g(x);}
尾调用之所以与其他调用不同，就在于它的特殊的调用位置。
我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。
尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。
尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。
递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。
由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。
函数参数的尾逗号ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。
8. 数组的扩展扩展运算符扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
扩展运算符与正常的函数参数可以结合使用，非常灵活。
123function f(v, w, x, y, z) { }var args &#x3D; [0, 1];f(-1, ...args, 2, ...[3]);

替代数组的apply方法由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。
12345678910111213&#x2F;&#x2F; ES5 的写法function f(x, y, z) {  &#x2F;&#x2F; ...}var args &#x3D; [0, 1, 2];f.apply(null, args);&#x2F;&#x2F; ES6的写法function f(x, y, z) {  &#x2F;&#x2F; ...}var args &#x3D; [0, 1, 2];f(...args);

扩展运算符的应用1. 合并数组1234567&#x2F;&#x2F; ES5的合并数组arr1.concat(arr2, arr3);&#x2F;&#x2F; [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]&#x2F;&#x2F; ES6的合并数组[...arr1, ...arr2, ...arr3]&#x2F;&#x2F; [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]

2. 与结构赋值结合123const [first, ...rest] &#x3D; [1, 2, 3, 4, 5];first &#x2F;&#x2F; 1rest  &#x2F;&#x2F; [2, 3, 4, 5]

3. 函数的返回值JavaScript 的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。
4. 字符串扩展运算符还可以将字符串转为真正的数组。
12[...&#39;hello&#39;]&#x2F;&#x2F; [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]

5. 实现了Iterator接口的对象任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。
12var nodeList &#x3D; document.querySelectorAll(&#39;div&#39;);var array &#x3D; [...nodeList];
上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。
Array.form()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。
123456789101112let arrayLike &#x3D; {    &#39;0&#39;: &#39;a&#39;,    &#39;1&#39;: &#39;b&#39;,    &#39;2&#39;: &#39;c&#39;,    length: 3};&#x2F;&#x2F; ES5的写法var arr1 &#x3D; [].slice.call(arrayLike); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&#x2F;&#x2F; ES6的写法let arr2 &#x3D; Array.from(arrayLike); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于\uFFFF的Unicode字符，算作两个字符的bug。
Array.of( )Array.of方法用于将一组值，转换为数组。
123Array.of(3, 11, 8) &#x2F;&#x2F; [3,11,8]Array.of(3) &#x2F;&#x2F; [3]Array.of(3).length &#x2F;&#x2F; 1

数组示例的copyWithin()数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。
1Array.prototype.copyWithin(target, start &#x3D; 0, end &#x3D; this.length)
它接受三个参数。

target（必需）：从该位置开始替换数据。
start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。
end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。

这三个参数都应该是数值，如果不是，会自动转为数值。
数组实例的find()和findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。
12[1, 4, -5, 10].find((n) &#x3D;&gt; n &lt; 0)&#x2F;&#x2F; -5
上面代码找出数组中第一个小于0的成员。
数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。
数组实例的fill()fill方法使用给定值，填充一个数组。
12[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)&#x2F;&#x2F; [7, 7, 7]
数组实例的entries(),keys(),values()ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。
1234567891011121314151617for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) {  console.log(index);}&#x2F;&#x2F; 0&#x2F;&#x2F; 1for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) {  console.log(elem);}&#x2F;&#x2F; &#39;a&#39;&#x2F;&#x2F; &#39;b&#39;for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) {  console.log(index, elem);}&#x2F;&#x2F; 0 &quot;a&quot;&#x2F;&#x2F; 1 &quot;b&quot;

数组实例的includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。
123[1, 2, 3].includes(2)     &#x2F;&#x2F; true[1, 2, 3].includes(4)     &#x2F;&#x2F; false[1, 2, NaN].includes(NaN) &#x2F;&#x2F; true

数组的空位数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。
ES6 则是明确将空位转为undefined。
由于空位的处理规则非常不统一，所以建议避免出现空位。
9. 对象的扩展属性的简洁表示法ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。
123456var foo &#x3D; &#39;bar&#39;;var baz &#x3D; {foo};baz &#x2F;&#x2F; {foo: &quot;bar&quot;}&#x2F;&#x2F; 等同于var baz &#x3D; {foo: foo};

属性名表达式ES6 允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。
123456let propKey &#x3D; &#39;foo&#39;;let obj &#x3D; {  [propKey]: true,  [&#39;a&#39; + &#39;bc&#39;]: 123};

方法的name属性函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。
1234567const person &#x3D; {  sayName() {    console.log(&#39;hello!&#39;);  },};person.sayName.name   &#x2F;&#x2F; &quot;sayName&quot;
如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。
Object.is()ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致。
不同之处只有两个：一是+0不等于-0，二是NaN等于自身。
Object.assign()Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。
1234567var target &#x3D; { a: 1 };var source1 &#x3D; { b: 2 };var source2 &#x3D; { c: 3 };Object.assign(target, source1, source2);target &#x2F;&#x2F; {a:1, b:2, c:3}
Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。
Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。
Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。
Object.assign()的用途
为对象添加属性12345class Point {  constructor(x, y) {    Object.assign(this, {x, y});  }}
为对象添加方法
克隆对象
合并多个对象
为属性制定默认值

属性的可枚举性对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。
描述对象的enumerable属性，称为”可枚举性“，如果该属性为false，就表示某些操作会忽略当前属性。
ES5 有三个操作会忽略enumerable为false的属性。

for…in循环：只遍历对象自身的和继承的可枚举的属性
Object.keys()：返回对象自身的所有可枚举的属性的键名
JSON.stringify()：只串行化对象自身的可枚举的属性

ES6 新增了一个操作Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。
属性的遍历ES6 一共有5种方法可以遍历对象的属性。

for in
Object.keys(obj)
Object.getOwnPropertyNames(obj)
Object.getOwnPropertySymbols(obj)
Reflect.ownKeys(obj)

__proto__属性，__proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。
123456789&#x2F;&#x2F; es6的写法var obj &#x3D; {  method: function() { ... }};obj.__proto__ &#x3D; someOtherObj;&#x2F;&#x2F; es5的写法var obj &#x3D; Object.create(someOtherObj);obj.method &#x3D; function() { ... };
无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。
Object.keys(),Object.values(),Object.entries()ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for…of循环使用。
1234567891011121314let {keys, values, entries} &#x3D; Object;let obj &#x3D; { a: 1, b: 2, c: 3 };for (let key of keys(obj)) {    console.log(key); &#x2F;&#x2F; &#39;a&#39;, &#39;b&#39;, &#39;c&#39;}for (let value of values(obj)) {    console.log(value); &#x2F;&#x2F; 1, 2, 3}for (let [key, value] of entries(obj)) {    console.log([key, value]); &#x2F;&#x2F; [&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]}
Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。
Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。
对象的扩展运算符1. 解构赋值对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。
1234let { x, y, ...z } &#x3D; { x: 1, y: 2, a: 3, b: 4 };x &#x2F;&#x2F; 1y &#x2F;&#x2F; 2z &#x2F;&#x2F; { a: 3, b: 4 }
注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。
2. 扩展运算符扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。
123let z &#x3D; { a: 3, b: 4 };let n &#x3D; { ...z };n &#x2F;&#x2F; { a: 3, b: 4 }

Object.getOwnPropertyDescriptors()ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。
12345678910111213141516const obj &#x3D; {  foo: 123,  get bar() { return &#39;abc&#39; }};Object.getOwnPropertyDescriptors(obj)&#x2F;&#x2F; { foo:&#x2F;&#x2F;    { value: 123,&#x2F;&#x2F;      writable: true,&#x2F;&#x2F;      enumerable: true,&#x2F;&#x2F;      configurable: true },&#x2F;&#x2F;   bar:&#x2F;&#x2F;    { get: [Function: bar],&#x2F;&#x2F;      set: undefined,&#x2F;&#x2F;      enumerable: true,&#x2F;&#x2F;      configurable: true } }

Null传导运算符1const firstName &#x3D; message?.body?.user?.firstName || &#39;default&#39;;

上面代码有三个?.运算符，只要其中一个返回null或undefined，就不再往下运算，而是返回undefined。
10. Symbol概述ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。
Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。
1234let s &#x3D; Symbol();typeof s&#x2F;&#x2F; &quot;symbol&quot;

注意，Symbol函数前不能使用new命令，否则会报错。
作为属性名的Symbol由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。
1234567891011121314151617var mySymbol &#x3D; Symbol();&#x2F;&#x2F; 第一种写法var a &#x3D; {};a[mySymbol] &#x3D; &#39;Hello!&#39;;&#x2F;&#x2F; 第二种写法var a &#x3D; {  [mySymbol]: &#39;Hello!&#39;};&#x2F;&#x2F; 第三种写法var a &#x3D; {};Object.defineProperty(a, mySymbol, { value: &#39;Hello!&#39; });&#x2F;&#x2F; 以上写法都得到同样结果a[mySymbol] &#x2F;&#x2F; &quot;Hello!&quot;
注意，Symbol 值作为对象属性名时，不能用点运算符。
同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。
还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。
属性名的遍历Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。
Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。
1234567891011var obj &#x3D; {};var a &#x3D; Symbol(&#39;a&#39;);var b &#x3D; Symbol(&#39;b&#39;);obj[a] &#x3D; &#39;Hello&#39;;obj[b] &#x3D; &#39;World&#39;;var objectSymbols &#x3D; Object.getOwnPropertySymbols(obj);objectSymbols&#x2F;&#x2F; [Symbol(a), Symbol(b)]

Symbol.for( ),Symbol.keyFor( )有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。
1234var s1 &#x3D; Symbol.for(&#39;foo&#39;);var s2 &#x3D; Symbol.for(&#39;foo&#39;);s1 &#x3D;&#x3D;&#x3D; s2 &#x2F;&#x2F; true

Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。
Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。
内置的symbol值除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。
11. set和map数据结构set基本用法ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
Set 本身是一个构造函数，用来生成 Set 数据结构。
Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。
1234567891011121314151617181920&#x2F;&#x2F; 例一const set &#x3D; new Set([1, 2, 3, 4, 4]);[...set]&#x2F;&#x2F; [1, 2, 3, 4]&#x2F;&#x2F; 例二const items &#x3D; new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size &#x2F;&#x2F; 5&#x2F;&#x2F; 例三function divs () {  return [...document.querySelectorAll(&#39;div&#39;)];}const set &#x3D; new Set(divs());set.size &#x2F;&#x2F; 56&#x2F;&#x2F; 类似于divs().forEach(div &#x3D;&gt; set.add(div));set.size &#x2F;&#x2F; 56
向Set加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（&#x3D;&#x3D;&#x3D;），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。
另外，两个对象总是不相等的。
set实例的属性和方法Set 结构的实例有以下属性。

Set.prototype.constructor：构造函数，默认就是Set函数。
Set.prototype.size：返回Set实例的成员总数。

Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。

add(value)：添加某个值，返回Set结构本身。
delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
has(value)：返回一个布尔值，表示该值是否为Set的成员。
clear()：清除所有成员，没有返回值。

遍历操作Set 结构的实例有四个遍历方法，可以用于遍历成员。

keys()：返回键名的遍历器
values()：返回键值的遍历器
entries()：返回键值对的遍历器
forEach()：使用回调函数遍历每个成员

WeakSetWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。
首先，WeakSet 的成员只能是对象，而不能是其他类型的值。
其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。
语法WeakSet 是一个构造函数，可以使用new命令，创建 WeakSet 数据结构。
1const ws &#x3D; new WeakSet();
WeakSet 结构有以下三个方法。

WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。
WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。
WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。

WeakSet没有size属性，没有办法遍历它的成员。
Map基本含义和用法它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。
事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。
实例的属性和操作方法
size属性 size属性返回 Map 结构的成员总数。
set(key, value) set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。
get(key) get方法读取key对应的键值，如果找不到key，返回undefined。
has(key) has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。
delete(key) delete方法删除某个键，返回true。如果删除失败，返回false。
clear() clear方法清除所有成员，没有返回值。

遍历方法Map 结构原生提供三个遍历器生成函数和一个遍历方法。

keys()：返回键名的遍历器。
values()：返回键值的遍历器。
entries()：返回所有成员的遍历器。
forEach()：遍历 Map 的所有成员。

结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。
与其他数据结构的相互转换
map转换为数组
数组转换为map
map转换为对象
对象转换为map
map转换为json
JSON转换为map

WeakMapWeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
WeakMap的键名所指向的对象，不计入垃圾回收机制。
12. Proxy概述Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。
Proxy可以拦截的操作
get() get方法用于拦截某个属性的读取操作。
set() set方法用来拦截某个属性的赋值操作。
apply() apply方法拦截函数的调用、call和apply操作。
has() has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。
construct() construct方法用于拦截new命令
deleteProperty() deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。
defineProperty() defineProperty方法拦截了Object.defineProperty操作。
getOwnPropertyDescriptors() getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。
getPrototypeOf() getPrototypeOf方法主要用来拦截获取对象原型。
isExtensible()isExtensible方法拦截Object.isExtensible操作。
ownKeys()ownKeys方法用来拦截对象自身属性的读取操作。
preventExtensions()preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。
setProrypeOf()setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。

Proxy.revocable()Proxy.revocable方法返回一个可取消的 Proxy 实例。
13. Reflect概述Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。
（1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。
（2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。
（3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。
（4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。
2. 静态方法
Reflect.apply(target,thisArg,args)
Reflect.construct(target,args)
Reflect.get(target,name,receiver)
Reflect.set(target,name,value,receiver)
Reflect.defineProperty(target,name,desc)
Reflect.deleteProperty(target,name)
Reflect.has(target,name)
Reflect.ownKeys(target)
Reflect.isExtensible(target)
Reflect.preventExtensions(target)
Reflect.getOwnPropertyDescriptor(target, name)
Reflect.getPrototypeOf(target)
Reflect.setPrototypeOf(target, prototype)

14. Promise对象Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。
所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。
Promise对象有以下两个特点。
（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。
（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。
Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
基本用法ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。
123456789var promise &#x3D; new Promise(function(resolve, reject) {  &#x2F;&#x2F; ... some code  if (&#x2F;* 异步操作成功 *&#x2F;){    resolve(value);  } else {    reject(error);  }});

Promise.prototype.then()Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。
then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。
12345getJSON(&quot;&#x2F;posts.json&quot;).then(function(json) {  return json.post;}).then(function(post) {  &#x2F;&#x2F; ...});
上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。
Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。
123456getJSON(&#39;&#x2F;posts.json&#39;).then(function(posts) {  &#x2F;&#x2F; ...}).catch(function(error) {  &#x2F;&#x2F; 处理 getJSON 和 前一个回调函数运行时发生的错误  console.log(&#39;发生错误！&#39;, error);});

Promise.all()Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。
1var p &#x3D; Promise.all([p1, p2, p3]);
上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）
Promise.race()Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。
Promise.resolve()有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。
1var jsPromise &#x3D; Promise.resolve($.ajax(&#39;&#x2F;whatever.json&#39;));
上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。
Promise.reject()Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。
两个有用的附加方法done()Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。
finally()finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。
15. Iterator 和 for…of循环Iterator的概念遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。
Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。
默认Iterator接口一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是”可遍历的“（iterable）。
ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。
原生具备 Iterator 接口的数据结构如下。

Array
Map
Set
String
TypedArray
函数的 arguments 对象

调用Iterator的场合有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for…of循环，还有几个别的场合。

解构赋值
扩展运算符
yield yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。
数组作为参数的场合
for…of
Array.from()
Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])）
Promise.all()
Promise.race()



字符串的Iterator接口字符串是一个类似数组的对象，也原生具有 Iterator 接口。
Iterator接口和Generator函数Symbol.iterator方法的最简单实现，还是使用下一章要介绍的Generator函数。
1234567891011121314151617181920212223var myIterable &#x3D; {};myIterable[Symbol.iterator] &#x3D; function* () {  yield 1;  yield 2;  yield 3;};[...myIterable] &#x2F;&#x2F; [1, 2, 3]&#x2F;&#x2F; 或者采用下面的简洁写法let obj &#x3D; {  * [Symbol.iterator]() {    yield &#39;hello&#39;;    yield &#39;world&#39;;  }};for (let x of obj) {  console.log(x);}&#x2F;&#x2F; hello&#x2F;&#x2F; world

遍历器对象的return(),throw()遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。
return方法的使用场合是，如果for…of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。
for…of循环ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。
一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。
for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。
16. Generator函数的语法简介Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。
形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。
yield表达式由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。
18. async函数含义async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。（1）内置执行器。
Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。
var result &#x3D; asyncReadFile();上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。
（2）更好的语义。
async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。
（3）更广的适用性。
co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。
（4）返回值是 Promise。
async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。
进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。
基本用法async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。
19. Class基本语法简介ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。
基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。
20. class的继承简介Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。
Object.getPrototypeOf()Object.getPrototypeOf方法可以用来从子类上获取父类。
super 关键字第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。
第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
类的prototype属性和__proto__属性大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。
（1）子类的__proto__属性，表示构造函数的继承，总是指向父类。
（2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。
21. 修饰器类的修饰修饰器（Decorator）是一个函数，用来修改类的行为。
22. Module语法概述ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。
1import { stat, exists, readFile } from &#39;fs&#39;;

严格模式ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。
export命令模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。
一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。
import命令使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。
123456&#x2F;&#x2F; main.jsimport {firstName, lastName, year} from &#39;.&#x2F;profile&#39;;function setName(element) {  element.textContent &#x3D; firstName + &#39; &#39; + lastName;}

模块的整体加载除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。
export default命令为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。
23. Module的加载实现浏览器加载如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。
12&lt;script src&#x3D;&quot;path&#x2F;to&#x2F;myModule.js&quot; defer&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;path&#x2F;to&#x2F;myModule.js&quot; async&gt;&lt;&#x2F;script&gt;
defer是“渲染完再执行”，async是“下载完就执行”。
加载规则浏览器加载 ES6 模块，也使用&lt;script&gt;标签，但是要加入type&#x3D;”module”属性。
1&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;foo.js&quot;&gt;&lt;&#x2F;script&gt;
ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。
12345&lt;script type&#x3D;&quot;module&quot;&gt;  import utils from &quot;.&#x2F;utils.js&quot;;  &#x2F;&#x2F; other code&lt;&#x2F;script&gt;

24. 编程风格块级作用域
let取代var
全局常量和线程安全 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。

字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。
解构赋值
使用数组成员对变量赋值时，优先使用解构赋值。
函数的参数如果是对象的成员，优先使用解构赋值。

对象单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。
对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。
数组使用扩展运算符（…）拷贝数组。
1const itemsCopy &#x3D; [...items];

使用Array.from方法，将类似数组的对象转为数组。
函数
立即执行函数可以写成箭头函数的形式。123(() &#x3D;&gt; {  console.log(&#39;Welcome to the Internet.&#39;);})();
箭头函数取代Function.prototype.bind，不应再用self&#x2F;_this&#x2F;that绑定 this。
不要在函数体内使用arguments变量，使用rest运算符（…）代替。
使用默认值语法设置函数参数的默认值。

map结构注意区分Object和Map，只有模拟现实世界的实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制。
Class总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。
使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。
模块首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。






输入法
















</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-ECMAScirpt-6-%E7%AE%80%E4%BB%8B"><span class="nav-number"></span> <span class="nav-text">1. ECMAScirpt 6 简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-let%E5%92%8Cconst%E5%91%BD%E4%BB%A4"><span class="nav-number"></span> <span class="nav-text">2. let和const命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-let%E5%91%BD%E4%BB%A4"><span class="nav-number"></span> <span class="nav-text">2.1 let命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="nav-number"></span> <span class="nav-text">不存在变量提升</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"><span class="nav-number"></span> <span class="nav-text">暂时性死区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D%E5%A3%B0%E6%98%8E"><span class="nav-number"></span> <span class="nav-text">不允许重复声明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number"></span> <span class="nav-text">2.2块级作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">为什么需要块级作用域？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6-%E7%9A%84%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number"></span> <span class="nav-text">ES6 的块级作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number"></span> <span class="nav-text">块级作用域与函数声明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const%E5%91%BD%E4%BB%A4"><span class="nav-number"></span> <span class="nav-text">const命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B6%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number"></span> <span class="nav-text">顶层对象的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#global%E5%AF%B9%E8%B1%A1"><span class="nav-number"></span> <span class="nav-text">global对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">3.变量的解构赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E6%95%B0%E7%BB%84%E7%9A%84%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">3.1数组的结构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">3.2对象的解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">3.3 字符串的解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E6%95%B0%E5%80%BC%E5%92%8C%E5%B8%83%E5%B0%94%E5%80%BC%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">3.4 数值和布尔值的解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">3.5 函数参数的解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E7%94%A8%E9%80%94"><span class="nav-number"></span> <span class="nav-text">3.6 用途</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number"></span> <span class="nav-text">4. 字符串的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1%E5%AD%97%E7%AC%A6%E7%9A%84Unicode%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">4.1字符的Unicode表示法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-codePointAt"><span class="nav-number"></span> <span class="nav-text">4.2 codePointAt()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-String-fromCodePoint"><span class="nav-number"></span> <span class="nav-text">4.3 String.fromCodePoint()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%81%8D%E5%8E%86%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="nav-number"></span> <span class="nav-text">4.4 字符串的遍历器接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-at"><span class="nav-number"></span> <span class="nav-text">4.5 at()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-includes-startsWith-endsWith"><span class="nav-number"></span> <span class="nav-text">4.7 includes(), startsWith(), endsWith()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-repeat"><span class="nav-number"></span> <span class="nav-text">4.8 repeat()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-9-padStart-%EF%BC%8CpadEnd"><span class="nav-number"></span> <span class="nav-text">4.9 padStart()，padEnd()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-10-%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number"></span> <span class="nav-text">4.10 模板字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-12-%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF"><span class="nav-number"></span> <span class="nav-text">4.12 标签模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-13-String-raw"><span class="nav-number"></span> <span class="nav-text">4.13 String.raw()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%88%E8%B7%B3%E8%BF%87%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">5. 正则的扩展（跳过）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number"></span> <span class="nav-text">6. 数值的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">6.1 二进制和八进制表示法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-Number-isFinite-Number-isNaN"><span class="nav-number"></span> <span class="nav-text">6.2 Number.isFinite(), Number.isNaN()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number"></span> <span class="nav-text">7. 函数的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">函数参数的默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E9%BB%98%E8%AE%A4%E5%80%BC%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-number"></span> <span class="nav-text">与解构赋值默认值结合使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number"></span> <span class="nav-text">参数默认值的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84length%E5%B1%9E%E6%80%A7"><span class="nav-number"></span> <span class="nav-text">函数的length属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number"></span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-number"></span> <span class="nav-text">应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rest%E5%8F%82%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">rest参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="nav-number"></span> <span class="nav-text">严格模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#name%E5%B1%9E%E6%80%A7"><span class="nav-number"></span> <span class="nav-text">name属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">箭头函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96"><span class="nav-number"></span> <span class="nav-text">尾调用优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%BE%E9%80%92%E5%BD%92"><span class="nav-number"></span> <span class="nav-text">尾递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E5%B0%BE%E9%80%97%E5%8F%B7"><span class="nav-number"></span> <span class="nav-text">函数参数的尾逗号</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number"></span> <span class="nav-text">8. 数组的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number"></span> <span class="nav-text">扩展运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%BF%E4%BB%A3%E6%95%B0%E7%BB%84%E7%9A%84apply%E6%96%B9%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">替代数组的apply方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number"></span> <span class="nav-text">扩展运算符的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%90%88%E5%B9%B6%E6%95%B0%E7%BB%84"><span class="nav-number"></span> <span class="nav-text">1. 合并数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%8E%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC%E7%BB%93%E5%90%88"><span class="nav-number"></span> <span class="nav-text">2. 与结构赋值结合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">3. 函数的返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number"></span> <span class="nav-text">4. 字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%AE%9E%E7%8E%B0%E4%BA%86Iterator%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number"></span> <span class="nav-text">5. 实现了Iterator接口的对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-form"><span class="nav-number"></span> <span class="nav-text">Array.form()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-of"><span class="nav-number"></span> <span class="nav-text">Array.of( )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%A4%BA%E4%BE%8B%E7%9A%84copyWithin"><span class="nav-number"></span> <span class="nav-text">数组示例的copyWithin()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84find-%E5%92%8CfindIndex"><span class="nav-number"></span> <span class="nav-text">数组实例的find()和findIndex()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84fill"><span class="nav-number"></span> <span class="nav-text">数组实例的fill()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84entries-keys-values"><span class="nav-number"></span> <span class="nav-text">数组实例的entries(),keys(),values()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84includes"><span class="nav-number"></span> <span class="nav-text">数组实例的includes()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%A9%BA%E4%BD%8D"><span class="nav-number"></span> <span class="nav-text">数组的空位</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number"></span> <span class="nav-text">9. 对象的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E7%AE%80%E6%B4%81%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">属性的简洁表示法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%90%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number"></span> <span class="nav-text">属性名表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84name%E5%B1%9E%E6%80%A7"><span class="nav-number"></span> <span class="nav-text">方法的name属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-is"><span class="nav-number"></span> <span class="nav-text">Object.is()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-assign"><span class="nav-number"></span> <span class="nav-text">Object.assign()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-assign-%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-number"></span> <span class="nav-text">Object.assign()的用途</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%AF%E6%9E%9A%E4%B8%BE%E6%80%A7"><span class="nav-number"></span> <span class="nav-text">属性的可枚举性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number"></span> <span class="nav-text">属性的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#proto-%E5%B1%9E%E6%80%A7%EF%BC%8C"><span class="nav-number"></span> <span class="nav-text">__proto__属性，</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-keys-Object-values-Object-entries"><span class="nav-number"></span> <span class="nav-text">Object.keys(),Object.values(),Object.entries()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number"></span> <span class="nav-text">对象的扩展运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">1. 解构赋值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number"></span> <span class="nav-text">2. 扩展运算符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-getOwnPropertyDescriptors"><span class="nav-number"></span> <span class="nav-text">Object.getOwnPropertyDescriptors()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Null%E4%BC%A0%E5%AF%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number"></span> <span class="nav-text">Null传导运算符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-Symbol"><span class="nav-number"></span> <span class="nav-text">10. Symbol</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number"></span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84Symbol"><span class="nav-number"></span> <span class="nav-text">作为属性名的Symbol</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number"></span> <span class="nav-text">属性名的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbol-for-Symbol-keyFor"><span class="nav-number"></span> <span class="nav-text">Symbol.for( ),Symbol.keyFor( )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E7%9A%84symbol%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">内置的symbol值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-set%E5%92%8Cmap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number"></span> <span class="nav-text">11. set和map数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#set"><span class="nav-number"></span> <span class="nav-text">set</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-1"><span class="nav-number"></span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#set%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">set实例的属性和方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C"><span class="nav-number"></span> <span class="nav-text">遍历操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WeakSet"><span class="nav-number"></span> <span class="nav-text">WeakSet</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">语法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number"></span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%90%AB%E4%B9%89%E5%92%8C%E7%94%A8%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">基本含义和用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">实例的属性和操作方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">遍历方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="nav-number"></span> <span class="nav-text">与其他数据结构的相互转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WeakMap"><span class="nav-number"></span> <span class="nav-text">WeakMap</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-Proxy"><span class="nav-number"></span> <span class="nav-text">12. Proxy</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-number"></span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy%E5%8F%AF%E4%BB%A5%E6%8B%A6%E6%88%AA%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number"></span> <span class="nav-text">Proxy可以拦截的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy-revocable"><span class="nav-number"></span> <span class="nav-text">Proxy.revocable()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-Reflect"><span class="nav-number"></span> <span class="nav-text">13. Reflect</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="nav-number"></span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">2. 静态方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-Promise%E5%AF%B9%E8%B1%A1"><span class="nav-number"></span> <span class="nav-text">14. Promise对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-2"><span class="nav-number"></span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-prototype-then"><span class="nav-number"></span> <span class="nav-text">Promise.prototype.then()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-prototype-catch"><span class="nav-number"></span> <span class="nav-text">Promise.prototype.catch()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-all"><span class="nav-number"></span> <span class="nav-text">Promise.all()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-race"><span class="nav-number"></span> <span class="nav-text">Promise.race()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-resolve"><span class="nav-number"></span> <span class="nav-text">Promise.resolve()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-reject"><span class="nav-number"></span> <span class="nav-text">Promise.reject()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E6%9C%89%E7%94%A8%E7%9A%84%E9%99%84%E5%8A%A0%E6%96%B9%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">两个有用的附加方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#done"><span class="nav-number"></span> <span class="nav-text">done()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#finally"><span class="nav-number"></span> <span class="nav-text">finally()</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-Iterator-%E5%92%8C-for%E2%80%A6of%E5%BE%AA%E7%8E%AF"><span class="nav-number"></span> <span class="nav-text">15. Iterator 和 for…of循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterator%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number"></span> <span class="nav-text">Iterator的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4Iterator%E6%8E%A5%E5%8F%A3"><span class="nav-number"></span> <span class="nav-text">默认Iterator接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8Iterator%E7%9A%84%E5%9C%BA%E5%90%88"><span class="nav-number"></span> <span class="nav-text">调用Iterator的场合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84Iterator%E6%8E%A5%E5%8F%A3"><span class="nav-number"></span> <span class="nav-text">字符串的Iterator接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterator%E6%8E%A5%E5%8F%A3%E5%92%8CGenerator%E5%87%BD%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">Iterator接口和Generator函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E5%99%A8%E5%AF%B9%E8%B1%A1%E7%9A%84return-throw"><span class="nav-number"></span> <span class="nav-text">遍历器对象的return(),throw()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for%E2%80%A6of%E5%BE%AA%E7%8E%AF"><span class="nav-number"></span> <span class="nav-text">for…of循环</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-Generator%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">16. Generator函数的语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number"></span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#yield%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number"></span> <span class="nav-text">yield表达式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-async%E5%87%BD%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">18. async函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AB%E4%B9%89"><span class="nav-number"></span> <span class="nav-text">含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-3"><span class="nav-number"></span> <span class="nav-text">基本用法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-Class%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">19. Class基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="nav-number"></span> <span class="nav-text">简介</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-class%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number"></span> <span class="nav-text">20. class的继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="nav-number"></span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-getPrototypeOf"><span class="nav-number"></span> <span class="nav-text">Object.getPrototypeOf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">super 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84prototype%E5%B1%9E%E6%80%A7%E5%92%8C-proto-%E5%B1%9E%E6%80%A7"><span class="nav-number"></span> <span class="nav-text">类的prototype属性和__proto__属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-%E4%BF%AE%E9%A5%B0%E5%99%A8"><span class="nav-number"></span> <span class="nav-text">21. 修饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E4%BF%AE%E9%A5%B0"><span class="nav-number"></span> <span class="nav-text">类的修饰</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-Module%E8%AF%AD%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">22. Module语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="nav-number"></span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F-1"><span class="nav-number"></span> <span class="nav-text">严格模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#export%E5%91%BD%E4%BB%A4"><span class="nav-number"></span> <span class="nav-text">export命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#import%E5%91%BD%E4%BB%A4"><span class="nav-number"></span> <span class="nav-text">import命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E6%95%B4%E4%BD%93%E5%8A%A0%E8%BD%BD"><span class="nav-number"></span> <span class="nav-text">模块的整体加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#export-default%E5%91%BD%E4%BB%A4"><span class="nav-number"></span> <span class="nav-text">export default命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-Module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0"><span class="nav-number"></span> <span class="nav-text">23. Module的加载实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD"><span class="nav-number"></span> <span class="nav-text">浏览器加载</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E8%A7%84%E5%88%99"><span class="nav-number"></span> <span class="nav-text">加载规则</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC"><span class="nav-number"></span> <span class="nav-text">24. 编程风格</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number"></span> <span class="nav-text">块级作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number"></span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-number"></span> <span class="nav-text">对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number"></span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map%E7%BB%93%E6%9E%84"><span class="nav-number"></span> <span class="nav-text">map结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class"><span class="nav-number"></span> <span class="nav-text">Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97"><span class="nav-number"></span> <span class="nav-text">模块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">输入法</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Alexander Ezharjan</p>
  <div class="site-description" itemprop="description">This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/Blog/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/Blog/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alexander Ezharjan</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/Blog/lib/anime.min.js"></script>
  <script src="/Blog/lib/velocity/velocity.min.js"></script>
  <script src="/Blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/Blog/js/utils.js"></script>

<script src="/Blog/js/motion.js"></script>


<script src="/Blog/js/schemes/muse.js"></script>


<script src="/Blog/js/next-boot.js"></script>




  




  
<script src="/Blog/js/local-search.js"></script>













  

  

</body>
</html>
