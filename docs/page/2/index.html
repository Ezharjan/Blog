<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/Blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/Blog/css/main.css">


<link rel="stylesheet" href="/Blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ezharjan.github.io","root":"/Blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.">
<meta property="og:type" content="website">
<meta property="og:title">
<meta property="og:url" content="https://ezharjan.github.io/Blog/page/2/index.html">
<meta property="og:site_name">
<meta property="og:description" content="This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Alexander Ezharjan">
<meta property="article:tag" content="Software, Lab, Engineer, Game Engine, Alexander, Ezharjan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ezharjan.github.io/Blog/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title></title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/Blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title"></h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Blog By Alexander</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/Blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/Blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ezharjan.github.io/Blog/2022/05/15/TOEFL-Experience/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Alexander Ezharjan">
      <meta itemprop="description" content="This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2022/05/15/TOEFL-Experience/" class="post-title-link" itemprop="url">TOEFL-Experience</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-15 11:47:59" itemprop="dateCreated datePublished" datetime="2022-05-15T11:47:59+08:00">2022-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-17 10:34:44" itemprop="dateModified" datetime="2022-10-17T10:34:44+08:00">2022-10-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Exams/" itemprop="url" rel="index"><span itemprop="name">Exams</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TOEFL-Experience"><a href="#TOEFL-Experience" class="headerlink" title="TOEFL Experience"></a>TOEFL Experience</h1><p><strong>For My Brother Guang Yang</strong></p>
<br>

<p><em>by Alexander Ezharjan</em></p>
<br>
<br>

<p>The process or result of learning is never a thing that can be calculated through an exact meter, but preparing for the exams has its own way that we can sometime apply to get good grades. Here are some of my experience on how to get decent scores in TOEFOL.</p>
<br>

<ol>
<li><p>Recite 20 to 100 TOEFL words everyday.<br>Remember 2 things:<br>(1) Review of the past words are more important than reciting the new ones;<br>(2) Never ignore those words that looks familiar to you. Try to recite the familiar word’s all meanings and exampled cases.</p>
</li>
<li><p>Try to do a real exam practice first. You can download some applications or directly practice online.<br>Remember 2 things:<br>(1) Use the REAL OLD EXAMS, not the simulations, to measure your current ability, then you will find out your deficiencies and problems so that you’re able to solve them.<br>(2) Always try to make yourself in a real exam situation when you are taking the test. If you can’t, just try to make an atmosphere like that! For example, you can take your simulation test in a noisy classroom with people going in and out. Yeah, the real situation is somewhat noisy and people will go in and out from the exam hall, you have to be fully focused on your own exam and avoid those distractions.</p>
</li>
<li><p>Practice more! Always practice upon the TOEFL exam itself. DO NOT PRACTICE ANY OTHER THINGS THAT CAN SEEMS UNRELATED WITH THE EXAM ITSELF. (For example: listening to English songs, watching English films, speaking with foreigners online etc.) Note that the TOEFL is a test of your comprehensive ability rather than the test of your real foreign communication ability. </p>
</li>
<li><p>Always catch your mistakes and just calm down to think about the reason why you have mistaken, practice more.</p>
</li>
<li><p>Practice your speed! You should be clarified that the exam time is not enough, especially for your reading test. You can’t read thoroughly through all the details of a passage, so you have to view the current question first and then find out the answer for it. Time control is significant while doing the TOEFL reading test.</p>
</li>
<li><p>When it comes to the preparation of the listening test, find some ways to enhance your note-taking ability. Interpretation note taking methods are listed below in <code>Appendix II</code> for a reference from my point of view, but you may find some more suitable methods to enhance your ability.</p>
</li>
<li><p>While practicing your speaking ability, you have to link your speaking ability with the listening practice. Never separate them! Try to speak loudly so that your voice can be recorded by the microphone clearly. You can record your own voice while you are practicing.</p>
</li>
<li><p>Essay is important and you have to read some tutorials related to the TOEFL Essay Test and practice with those guides. Some of the mottos or sayings of the famous people is strongly recommended. Some of them is listed below in <code>Appendix I</code>.</p>
</li>
<li><p>Do at least 5 real-test-based simulation test before entering the exam day.</p>
</li>
<li><p>Sleep well before the exam day.</p>
</li>
<li><p>Eat well in the morning on the exam day.</p>
</li>
</ol>
<br>
<br>
<br>
<br>



<h3 id="Appendix-I"><a href="#Appendix-I" class="headerlink" title="Appendix I"></a>Appendix I</h3><ol>
<li>Misfortunes never come alone&#x2F;single.祸不单行。</li>
<li>Constant dropping wears the stone. 滴水穿石。</li>
<li>Life is a leaf of paper white, thereon each of us may write his word or two. 生活是一张白纸，每个人都在上面写上自己的一两句话。</li>
<li>For man is man and master of his fate. 人就是人，是自己命运的主人。</li>
<li>A good medicine tasks bitter.良药苦口。</li>
<li>Live and let live. 自己生活也让别人生活。</li>
<li>A great ship asks for deep waters.大船要走深水。</li>
<li>From small beginnings comes great things. 伟大始于渺小。</li>
<li>Great works are performed not by strength but by perseverance.没有恒心只有力量是完不成伟业。</li>
<li>Two heads are better than one. 一人不及二人智；三个臭皮匠，胜个过一个诸葛亮。</li>
<li>The voice of one man is the voice of no one. 一个人的声音没有力量。</li>
<li>It is never too late to learn. 活到老，学到老。</li>
<li>Wise men learn by other men’s mistakes; fools by their own. 聪明人从别人的错误中学得教训；笨人则自己付出代价。他山之石可以攻玉。</li>
<li>Good company on the road is the shortest cut. 行路有良伴就是捷径。</li>
<li>It takes all sorts to make a world. 世界是由各种不同的人所组成的。</li>
<li>Money spent on the brain is never spent in vain. 智力投资绝不会白花。</li>
<li>On earth there is nothing at but man; in the man there is nothing at but mind. 地球上唯一伟大的是人，人身上唯一伟大的是心灵。</li>
<li>Wisdom in the mind is better than money in the hand.脑中有知识，胜过手中有金钱。</li>
<li>Misfortunes tell us what fortune is.不经灾难不知福。</li>
<li>While there is life, there is hope.有生命便有希望&#x2F;留得青山在，哪怕没柴烧</li>
<li>Storms make trees take deeper roots.风暴使树木深深扎根。</li>
<li>It is never too late to mend. 亡羊补牢，犹时未晚。</li>
<li>Truth never fears investigation.事实从来不怕调查。</li>
<li>Misfortunes come on wings and depart on foot.遭祸容易脱祸难。</li>
<li>To an optimist every change is a change for the better.对于乐观者总是越变越好。</li>
<li>Every man is his own worst enemy.一个人最大的敌人就是他自己。</li>
<li>The secret of success is constancy of purpose.成功的秘诀在于持之于恒。</li>
<li>Actions speak louder than words. 行动比语言更响亮。</li>
<li>Saying and doing are two different things. 说和做是迥然不同的两回事。</li>
<li>Better late than never. 迟做总比不做好；晚来总比不来强。</li>
<li>Experience is the mother of wisdom. 经验是智慧之母。</li>
<li>Be honest rather clever. 诚实比聪明更要紧。</li>
<li>Being on sea, sail; being on land, settle. 随遇而安。</li>
<li>Be just to all, but trust not all. 要公正对待所有的人，但不要轻信所有的人。</li>
<li>Believe not all that you see nor half what you hear. 眼见的不能全信，耳闻的也不能半信。</li>
<li>Be slow to promise and quick to perform. 不轻诺，诺必果。</li>
<li>Be swift to hear, slow to speak. 多听少说。</li>
<li>Better an empty purse than an empty head. 宁可钱袋瘪，不要脑袋空。</li>
<li>Better an open enemy than a false friend. 明枪易躲，暗箭难防。</li>
<li>Better good neighbors near than relations far away. 远亲不如近邻。</li>
<li>Between the cup and the lip a morsel may slip. 功亏一篑。</li>
<li>Between two stools one falls to the ground. 脚踏两头要落空。</li>
<li>Beware beginnings. 慎始为上。</li>
<li>Big mouthfuls ofter choke. 贪多嚼不烂。</li>
<li>Bind the sack before it be full. 做事应适可而止。</li>
<li>Birds of a feather flock together. 物以类聚，人以群分。</li>
<li>Birth is much, but breeding is more. 出身固然重要，教养更且重要。</li>
<li>Bite off more than one can chew. 贪多咽不下。</li>
<li>Bite the hand that feeds one. 恩将仇报。</li>
<li>Bitter pills may have wholesome effects. 良药苦口利于病。</li>
<li>Blind men can judge no colors. 不宜问道於盲。</li>
<li>Blood is thicker than water. 血浓于水。</li>
<li>Bread is the staff of life. 民以食为天。</li>
<li>Brevity is the soul of wit. 言以简洁为贵。</li>
<li>Bring up a raven and he’ll pick out your eyes. 养虎贻患。</li>
<li>Burn not your house to rid it of the mouse. 投鼠忌器。</li>
<li>Burnt child dreads the fire. 一朝被蛇咬，十年怕井绳。</li>
<li>Business before pleasure. 事业在先，享乐在后。</li>
<li>Business is business. 公事公办。</li>
<li>By doing we learn. 经一事，长一智。</li>
<li>By falling we learn to go safely. 吃一堑，长一智。</li>
<li>By other’s faults, wise men correct their own. 他山之石，可以攻玉。</li>
<li>By reading we enrich the mind; by conversation we polish it. 读书可以使我门的思想充实，谈话使其更臻完美。</li>
<li>pain past is pleasure. 过去的痛苦即快乐。</li>
<li>All things are difficult before they are easy. 凡事必先难后易。</li>
<li>Nothing is impossible to a willing heart. 心之所愿，无事不成。</li>
<li>Where there is life, there is hope. 有生命必有希望。</li>
<li>I feel strongly that I can make it. 我坚信我一定能成功。</li>
<li>Better to light one candle than to curse the darkness. 与其诅咒黑暗，不如燃起蜡烛。</li>
<li>The shortest answer is doing. 最简短的回答就是行动。</li>
<li>Four short words sum up what has lifted most successful individuals above the crowd: a little bit more. 成功的秘诀就是四个简单的字：多一点点。</li>
<li>All things in their being are good for something. 天生我才必有用。</li>
<li>Difficult circumstances serve as a textbook of life for people. 困难坎坷是人们的生活教科书。</li>
<li>Failure is the mother of success. - Thomas Paine 失败乃成功之母。</li>
<li>For man is man and master of his fate. 人就是人，是自己命运的主人。</li>
<li>The unexamined life is not worth living. – Socrates 混混噩噩的生活不值得过。 – 苏格拉底</li>
<li>None is of freedom or of life deserving unless he daily conquers it anew. -Erasmus 只有每天再度战胜生活并夺取自由的人，才配享受生活的自由。</li>
<li>Our destiny offers not the cup of despair, but the chalice of opportunity. So let us seize it, not in fear, but in gladness. – R.M. Nixon 命运给予我们的不是失望之酒，而是机会之杯。因此，梦颐呛廖薹惧，满心愉悦地把握命？- 尼克松</li>
<li>Living without an aim is like sailing without a compass. – John Ruskin 生活没有目标，犹如航海没有罗盘。– 罗斯金</li>
<li>What makes life dreary is the want of motive. – George Eliot 没有了目的，生活便郁闷无光。 – 乔治 埃略特</li>
<li>Towering genius disdains a beaten path. It seeks regions hitherto unexplored.– Lincoln 卓越的天才不屑走旁人走过的路。他寻找迄今未开拓的地区。</li>
<li>There is no such thing as a great talent without great will - power. – Balzac 没有伟大的意志力，便没有雄才大略。 – 巴尔扎克</li>
</ol>
<br>

<h3 id="Appendix-II"><a href="#Appendix-II" class="headerlink" title="Appendix II"></a>Appendix II</h3><p><img src="https://ezharjan.github.io/Blog/2022/05/15/TOEFL-Experience/%E5%8F%A3%E8%AF%91%E7%AC%94%E8%AE%B0%E7%AC%A6%E5%8F%B7%E5%A4%A7%E6%B1%87%E6%80%BB.jpg" alt="TOEFL-Experience"></p>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ezharjan.github.io/Blog/2022/03/12/%E5%A6%82%E4%BD%95%E8%B0%88%E8%96%AA%E8%B5%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Alexander Ezharjan">
      <meta itemprop="description" content="This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2022/03/12/%E5%A6%82%E4%BD%95%E8%B0%88%E8%96%AA%E8%B5%84/" class="post-title-link" itemprop="url">如何谈薪资</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-12 21:51:18" itemprop="dateCreated datePublished" datetime="2022-03-12T21:51:18+08:00">2022-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-17 10:34:44" itemprop="dateModified" datetime="2022-10-17T10:34:44+08:00">2022-10-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Job-Interview/" itemprop="url" rel="index"><span itemprop="name">Job Interview</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h6 align="center">编者：艾孜尔江<h6>



<p><b><details><summary>1、我们先来了解面试官如何评判应聘者的工资，知己知彼才能对症下药啊！</summary></details></b></p>
<p>一些正规的大公司主要是根据以下四个方面进行评判（重要性从上至下）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、掌握的技术（通过笔试、项目经验、工作时间）</span><br><span class="line">2、表达</span><br><span class="line">3、学历</span><br><span class="line">4、其他素质（如英语四六级等）</span><br></pre></td></tr></table></figure>

<p>面试官评判应聘者工资的重要性之所以采取如此的顺序，根本原因在于面试官最最重要的是程序员能不能把工作做好，让公司放心。所以学员技术很重要，表达也很重要（技术牛但不会表达，也会让人怀疑技术实力）</p>


<p><b><details><summary>2、当 HR 问：你对薪资有什么要求？</summary></details></b></p>
<p>大家找工作，都希望找个高薪的，那我们如何和公司去谈薪酬呢？如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。这个问题确实是个比较难于回答的问题，处理不好的话，会影响面试的效果，但又是不可避免的一个现实问题。</p>
<p>对于这个问题，第一首先要知道程序员等级、技能、工资的绑定情况，因为我们前端工程师主要是看技术。技术实力决定了我们的月薪；第二要打探出公司能给出的薪资范围。在这个范围内争取高薪资。</p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步是了解对方可以提供的薪酬幅度是多少，这里的关键是善于发问，让对方多讲，而自己了解足够的信息。当经过几轮面试后，面试官会问应聘者：你还有什么想了解的问题吗？应聘者就可问：像你们这样的大企业都有自己的一套薪酬体系，请问可以简单介绍一下吗？面试官一般就会简单介绍一下，如果介绍得不是太详细，还可以问：贵公司的薪酬水平在同行业中的位置是怎样的？除了工资之外还有哪些奖金、福利和培训机会？试用期后工资的加幅是多少？等问题。从对方的回答中，你再对照一下市场行情心里就有底了。</span><br><span class="line"></span><br><span class="line">第二步是根据以上信息，提出自己的期望薪酬。如果对自己想提的薪资还是把握不准，那也可以把问题抛给对方：我想请教一个问题，以我现在的经历、学历和您对我面试的了解，在公司的薪酬体系中大约能达到怎么样的水平？对方就会透露给你准备开的工资水平。</span><br></pre></td></tr></table></figure>

<h2 id="迂回战术求高薪"><a href="#迂回战术求高薪" class="headerlink" title="迂回战术求高薪"></a>迂回战术求高薪</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果你对该公司开出的薪资标准不太满意，就可以尝试用探讨式、协商式的口气去争取高一些：比如我认为工作最重要的是合作开心，薪酬是其次的，不过我原来的月薪是××元，如果跳槽的话就希望自己能有点进步，如果不是让您太为难的话，您看这个工资是不是可以有一点提高？这时要看对方的口气是否可以松动，松动的话则可以再举出你值更高价的理由。</span><br><span class="line"></span><br><span class="line">如果对方的口气坚决，则可以迂回争取试用期的缩短，比如说：我对自己是比较有自信的，您看能不能一步到位直接拿转正期的工资，或者把３个月的试用期缩短为１个月？额外工资多争取。</span><br><span class="line"></span><br><span class="line">很多企业除了正式的工资以外，都会产生一些奖金、福利等额外工资，在这方面应聘者就要大胆争取了。应聘者要注意察言观色见好就收，不要过度要求，否则让对方破例后，到时你进来后对方也会以更高的要求来考核你，还可能答应了最后也不兑现。为了保险起见，应聘者最好让对方在接收函上写明薪酬、试用期限、上班时间等，这样可免去日后口说无凭的纠纷。</span><br><span class="line"></span><br><span class="line">总之，好的薪水是要靠势力得到的,但多调查和多注意这方面的资讯,使自己在面试前做到对这个职位的大致薪水有个了解,就会使你不至于提太高或太低不切实际的要求,从而失去到手的工作。</span><br></pre></td></tr></table></figure>



<p><b><details><summary>3、HR 指责要薪太高怎么办？</summary></details></b></p>
<p>想象下，当你实事求是的按照以上的方法报出自己的工资为 7000 元的时候，面试官呵呵笑道：“你是应届生，却要求 7000 元的工资，是不是太高了？”此时，你该怎么办？</p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、北京的生活成本高，3000元在北京生存很艰难，在饭店工作也可能不值这个，北京的web前端平均工资我也是有过了解的。同学大都是这个工资（注意：这个同学可以向HR强调是平时一起讨论问题的同学，暗示水平差不多)；</span><br><span class="line">2、上几家都给我6千了，我没有去（觉得自己值多少钱，那就是值多少）；</span><br><span class="line">3、我不是乱要价，我有能力完成完成上级交代的任务，创造出超过7000元价值的能力（强调自己的能力）；</span><br><span class="line">4、对技术狂热，会沿着前端道路一直往前走（强调自己对这份工作的热爱）；</span><br><span class="line">5、再说公司会有试用期，试用期可以低于7000，我会在这个阶段证明我自己的能力，可以如果没有达到，公司也可以开除我。</span><br></pre></td></tr></table></figure>






<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></h6></h6>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ezharjan.github.io/Blog/2022/03/12/%E9%9D%9E%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98100%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Alexander Ezharjan">
      <meta itemprop="description" content="This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2022/03/12/%E9%9D%9E%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98100%E7%AF%87/" class="post-title-link" itemprop="url">非技术问题100篇</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-12 21:44:21" itemprop="dateCreated datePublished" datetime="2022-03-12T21:44:21+08:00">2022-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-17 10:34:44" itemprop="dateModified" datetime="2022-10-17T10:34:44+08:00">2022-10-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Job-Interview/" itemprop="url" rel="index"><span itemprop="name">Job Interview</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h6 align="center">编者：艾孜尔江<h6>



<h5 id="（1）问题：请给我们谈谈你自己的一些情况"><a href="#（1）问题：请给我们谈谈你自己的一些情况" class="headerlink" title="（1）问题：请给我们谈谈你自己的一些情况"></a>（1）问题：请给我们谈谈你自己的一些情况</h5><p>回答：简要的描述你的相关工作经历以及你的一些特征，包括与人相处的能力和个人的性格特征。如果你一下子不能够确定面试者到底需要什么样的内容，你可以这样说：“有没有什么您特别感兴趣的范围？”</p>
<p>点评：企业以此来判断是否应该聘用你。通过你的谈论，可以看出你想的是如何为公司效力还是那些会影响工作的个人问题。当然，还可以知道你的一些背景。</p>
<br>

<h5 id="（2）问题：你是哪年出生的？你是哪所大学毕业的？等等"><a href="#（2）问题：你是哪年出生的？你是哪所大学毕业的？等等" class="headerlink" title="（2）问题：你是哪年出生的？你是哪所大学毕业的？等等"></a>（2）问题：你是哪年出生的？你是哪所大学毕业的？等等</h5><p>回答：我是XXXX年出生的。我是XX大学毕业的。</p>
<p>点评：这类问题至为关键的是要针对每个问题简洁明了的回答，不可拖泥带水，也不必再加什么说明。完全不必再画蛇添足的说“我属X，今年XX岁”之类的话。至于专业等或许主考官接下来的问题就是针对此而言的，故而不必迫不及待和盘托出。</p>
<br>

<h5 id="（3）问题：请谈一下你对公司的看法，为什么你想来公司工作？"><a href="#（3）问题：请谈一下你对公司的看法，为什么你想来公司工作？" class="headerlink" title="（3）问题：请谈一下你对公司的看法，为什么你想来公司工作？"></a>（3）问题：请谈一下你对公司的看法，为什么你想来公司工作？</h5><p>回答：可根据你先前对该公司的情报收集，叙述一下你对公司的了解。适当的对公司的声誉、产品和发展情况予以赞美。还可以提提你为了了解公司的情况所做的努力然后就说你非常喜欢这个工作，而且你的能力也非常适合并能胜任这份工作。</p>
<p>点评：此问目的测试一下你对公司的了解和喜欢的程度，看看你的能力是否符合公司的要求和方向。看看你是真正地愿意为公司效力，还是仅仅冲着公司的福利、声望和工作的稳定。</p>
<br>

<h5 id="（4）问题：你认为对你来说现在找一份工作是不是不太容易，或者你很需要这份工作？"><a href="#（4）问题：你认为对你来说现在找一份工作是不是不太容易，或者你很需要这份工作？" class="headerlink" title="（4）问题：你认为对你来说现在找一份工作是不是不太容易，或者你很需要这份工作？"></a>（4）问题：你认为对你来说现在找一份工作是不是不太容易，或者你很需要这份工作？</h5><p>回答：<br>1.是的。<br>2.我看不见得。</p>
<p>点评：<br>一般按1回答，一切便大功告成。<br>有些同学为了显示自己的“不卑不亢“，强调个人尊严，故按2回答。结果，用人单位打消了录用该生的念头，理由是：“此人比较傲“一句话，断送了该生一次较好的就业机会。</p>
<br>

<h5 id="（5）问题：你是怎么应聘到我们公司的？"><a href="#（5）问题：你是怎么应聘到我们公司的？" class="headerlink" title="（5）问题：你是怎么应聘到我们公司的？"></a>（5）问题：你是怎么应聘到我们公司的？</h5><p>回答：贵公司是国际上有名的汽车工业公司，虽然我学的专业不是汽车专业，但我一直留意、关心贵公司的发展，特别是贵公司注重对员工的培训，更让我心动，另外象贵公司这样大的企业，我想是各种专业人才都需要的，便毅然前来应聘。</p>
<p>点评：该毕业生的专业虽然不是该公司紧缺的专业，但他分析了公司招聘职位的具体要求，认为可以应试该公司的某一种职位要求。<br></p>
<p>（如管理、营销、秘书），如食品工程专业的求职面远不只局限于食品的加工企业，可延伸至饮品、酒类、保健品、调味品甚至酒楼等多个行业。都会有适合自己的职位。</p>
<br>

<h5 id="（6）问题：请你谈谈对我单位的看法"><a href="#（6）问题：请你谈谈对我单位的看法" class="headerlink" title="（6）问题：请你谈谈对我单位的看法"></a>（6）问题：请你谈谈对我单位的看法</h5><p>回答：我对贵单位还没什么了解，故谈不出看法</p>
<p>点评：象这样的回答，一般面试不成功多，如你很想进入该单位，就不妨实地去单位“侦察”一番，或收集有关的资料。如有一位毕业生，他有意去国家进出口银行工作，便通过朋友的关系弄到了一本进出口银行的基本业务材料，从而在面试中对答如流，赢得了招聘单位的赏识。并能以自身的优势来说明为何应聘这工作，做到有的防矢，给主考官留下了深刻的印象。因此，收集资料，了解单位，可以帮助求职者认清主要方向，更精确，更客观地审视主聘单位，选择适合自己发展的单位，避免走弯路。</p>
<br>

<h5 id="（7）问题：以你的资历条件，完全可以到大公司任职，你怎么想到我们小企业？"><a href="#（7）问题：以你的资历条件，完全可以到大公司任职，你怎么想到我们小企业？" class="headerlink" title="（7）问题：以你的资历条件，完全可以到大公司任职，你怎么想到我们小企业？"></a>（7）问题：以你的资历条件，完全可以到大公司任职，你怎么想到我们小企业？</h5><p>回答：<br>1.哎，没办法，一时没有应聘到大企业，况且，毕业时间又到了，否则只能回当地就业，因此先就业再说。<br>2.小企业有他自己的优势，在用人方面非常重视，自己虽然资历条件尚可，我想，在你们这样的企业更能发挥自己的作用。</p>
<p>点评：一个还未工作就想以后跳槽的员工，是无论如何不能指望他尽心尽力的干好工作的，因此，即使有此想法，也不能说出来，说不定工作后受到企业重用，本人的作用也发挥的特别好，而不想再走了呢？</p>
<br>

<h5 id="（8）问题：你为什么希望到我们公司工作？"><a href="#（8）问题：你为什么希望到我们公司工作？" class="headerlink" title="（8）问题：你为什么希望到我们公司工作？"></a>（8）问题：你为什么希望到我们公司工作？</h5><p>回答：我觉得贵公司力量雄厚，领导得力，上下一心，适于一切有才干的人发展。<br>忌：“我是学电子的，我到这里才是专业对口。”看情况而定。<br>“我来这里上班离家近。”<br>“我喜欢你们这儿。”<br>“听说你们公司月薪较高。”</p>
<p>点评：回答问题要从对方入题，引起对方好感，使对方感到你能尊重，关心公司的需要，愿为公司尽微薄之力。</p>
<br>

<h5 id="（9）问题：如果本公司录用你，你最希望在哪个部门工作？"><a href="#（9）问题：如果本公司录用你，你最希望在哪个部门工作？" class="headerlink" title="（9）问题：如果本公司录用你，你最希望在哪个部门工作？"></a>（9）问题：如果本公司录用你，你最希望在哪个部门工作？</h5><p>回答：<br>忌：“到哪个部门都行”<br>应：“本人希望到XX部门，但也很乐意接受公司的其他安排。</p>
<p>点评：不要说得太随意，太肯定。比较稳妥的办法是首先表明自己的志向和兴趣，再表示服从安排。</p>
<br>

<h5 id="（10）问题：你愿意被外派工作吗？你愿意经常出差吗？"><a href="#（10）问题：你愿意被外派工作吗？你愿意经常出差吗？" class="headerlink" title="（10）问题：你愿意被外派工作吗？你愿意经常出差吗？"></a>（10）问题：你愿意被外派工作吗？你愿意经常出差吗？</h5><p>回答：愿意，反正我无牵无挂，到哪儿工作都可以。</p>
<p>点评：这是主试者通过提问来透露他要找的是什么样的人，此信息已经很明白地告诉你，他所期待的回答是什么。对于此类问题应聘者留意倾听。从“话中之话”中找出应试者实际需要的线索。</p>
<br>

<h5 id="（11）问题：我怎样相信对这个职位你是最好的人选呢？"><a href="#（11）问题：我怎样相信对这个职位你是最好的人选呢？" class="headerlink" title="（11）问题：我怎样相信对这个职位你是最好的人选呢？"></a>（11）问题：我怎样相信对这个职位你是最好的人选呢？</h5><p>回答：根据这个职位的性质和我们刚才的谈话，我推断你需要的是工作积极的人，能够设定目标，不惧怕挑战的人。我就具有这些品质，让我再告诉你一些我在校时的经历，它们能说明我确实是你所需要的最好的人选。</p>
<p>点评：设身处地替面试官想一想，考虑一下招聘者需要什么样的人，你又在哪些方面符合他们的要求。根据要求，谈出自己应聘的优势。</p>
<br>

<h5 id="（12）问题：如果我能给你任何你想要的工作，你会选择什么？你真正想做的是什么工作？"><a href="#（12）问题：如果我能给你任何你想要的工作，你会选择什么？你真正想做的是什么工作？" class="headerlink" title="（12）问题：如果我能给你任何你想要的工作，你会选择什么？你真正想做的是什么工作？"></a>（12）问题：如果我能给你任何你想要的工作，你会选择什么？你真正想做的是什么工作？</h5><p>回答：就是这份工作。</p>
<p>点评：你可能觉得这是个怪问题，事实上常有这样的问题。这个问题是假设每个人都有未实现的梦想，都不能做他真正想做的事，亦即或多或少每个人都在妥协。若你真的谈了你的梦想，而他只会为圆你梦想的梦，而不录用你。因此，你确实要这份工作，那么参考答案只有一个。</p>
<br>

<h5 id="（13）问题：为什么你还没有找到工作？"><a href="#（13）问题：为什么你还没有找到工作？" class="headerlink" title="（13）问题：为什么你还没有找到工作？"></a>（13）问题：为什么你还没有找到工作？</h5><p>回答：我正在谨慎选择我的工作，本来我可以选择别的工作的，可是那些工作和现在这一个不同，我实在看不出它们会对我的事业进展有帮助。</p>
<p>点评：如果你真的拒绝了其他人的录取，那是再好不过了，如果其他企业都没有录取你，哪也不一定有问题。别人不能只因为你现在没有工作，就断定都没有人录取你，不要给人这样的错觉。</p>
<br>

<h5 id="（14）问题：你对我们公司有多少了解？"><a href="#（14）问题：你对我们公司有多少了解？" class="headerlink" title="（14）问题：你对我们公司有多少了解？"></a>（14）问题：你对我们公司有多少了解？</h5><p>回答：<br>1.完全不了解。<br>2.因为对贵公司有关方面相当有兴趣,所以才来应聘.</p>
<p>点评：若回答1.那就没有必要再说下去了，但录用的机会也就小了。最好的回答是2，这是公司想测试应聘者对公司的兴趣，关注程度，以后进公司工作的意愿的问题，因此，最好要稍稍记住公司的简介内容和招聘人事广告内容。</p>
<br>

<h5 id="（15）问题：你对公司有何印象？"><a href="#（15）问题：你对公司有何印象？" class="headerlink" title="（15）问题：你对公司有何印象？"></a>（15）问题：你对公司有何印象？</h5><p>回答：感觉很好，在其他公司没有这样的感受。</p>
<p>点评：或者说出面试当天的印象就可以了，因为还没有正式进入公司上班，所以主试者也不会太过刁难。</p>
<br>

<h5 id="（16）问题：你谈谈选择这份工作的动机？"><a href="#（16）问题：你谈谈选择这份工作的动机？" class="headerlink" title="（16）问题：你谈谈选择这份工作的动机？"></a>（16）问题：你谈谈选择这份工作的动机？</h5><p>回答：“这个职位刚好是我的专业对口，能把学的书本知识在实践中更好地应用。”<br>“我虽然学的专业与这职位有区别，但我对这方面的能力较强，相信自己能干好这份工作。</p>
<p>点评：这是测试面试者对这份工作的理解程度及热忱，并筛选因一时兴起而来应聘的人。</p>
<br>

<h5 id="（17）问题：你家在外地，我们单位无住宿，你如何看待呢？"><a href="#（17）问题：你家在外地，我们单位无住宿，你如何看待呢？" class="headerlink" title="（17）问题：你家在外地，我们单位无住宿，你如何看待呢？"></a>（17）问题：你家在外地，我们单位无住宿，你如何看待呢？</h5><p>回答：家在外地，贵单位无住宿条件，这些都不影响我来应聘贵公司，住宿我可以自己解决，无须单位操心，我看重贵公司的发展前途。</p>
<p>点评：不要因为个人生活上的小问题，而错失良机。主试者也想看看你对困难的看法，自信心程度。</p>
<br>

<h5 id="（18）问题：我们不限定固定职位，你认为自己最适合做什么？"><a href="#（18）问题：我们不限定固定职位，你认为自己最适合做什么？" class="headerlink" title="（18）问题：我们不限定固定职位，你认为自己最适合做什么？"></a>（18）问题：我们不限定固定职位，你认为自己最适合做什么？</h5><p>回答：<br>忌：“公司安排我做什么就做什么！”太随意。<br>“理想的职位就是有机会让我一展专长，为公司的发展贡献自己的学识。”太空。<br>应：我学的是XX专业，我认为XX职位比较适合我。</p>
<p>点评：主试者问你问题，就是想要一个明确的参考答案，且明确的回答给人以有思想、有主见、有活力的印象。象上面的回答，是犯了一个错误，然而几乎每个人都会犯同样的错误，他们总是说自己干什么都可以。因此，回答这样的问题，干脆用自己的心里话表白，实事求是，至少让主试者听起来感到舒服些。</p>
<br>

<h5 id="（19）问题：你希望从事什么样的工作？"><a href="#（19）问题：你希望从事什么样的工作？" class="headerlink" title="（19）问题：你希望从事什么样的工作？"></a>（19）问题：你希望从事什么样的工作？</h5><p>回答：根据贵公司的招聘职位，我认为x职位可能比较适合我，有利于我的能力的发挥。当然，其他有些职位也是可做的，人贵在学习。</p>
<p>点评：应试者可以应聘的职位作出大致的设想，让主试人了解自己的抱负与努力方向。由于每个单位都有自己的人事政策，其工作安排未必能完全与求职者的愿望相一致，尤其对一个初出茅庐的大学生来说，从基层做起，从小事做起也是应该的。但是，又不能随便回答：“到哪里工作都可以。”这让人觉得像在“乞讨工作”，被人看轻。所以要掌握分寸。</p>
<br>

<h5 id="（20）问题：你为什么要应聘我们公司？"><a href="#（20）问题：你为什么要应聘我们公司？" class="headerlink" title="（20）问题：你为什么要应聘我们公司？"></a>（20）问题：你为什么要应聘我们公司？</h5><p>回答：看了贵公司的广告及要求，感到自己比较符合公司的招聘条件，另外，对贵公司也有些了解，自己若能有幸成为贵公司的一员，是能有助于自己能力的发挥与发展的。</p>
<p>点评：这样的回答，可显示出自己积极进取的态度。在谈论用人单位时，态度要诚恳、谦和。不论大单位或小单位，都有其优胜和劣势，应试者应视其实际情况，提出自己的见解，不要牵强附会，如果一味往对方脸上贴金，反而会令人反感。</p>
<br>

<h5 id="（21）问题：你在以前实习的公司从事什么样的工作？"><a href="#（21）问题：你在以前实习的公司从事什么样的工作？" class="headerlink" title="（21）问题：你在以前实习的公司从事什么样的工作？"></a>（21）问题：你在以前实习的公司从事什么样的工作？</h5><p>回答：在具体说明对工作的理解程度和熟悉度时，回答要领有三个方面：担任的工作内容、职务、成绩三项。</p>
<p>点评：这个问题可以让公司知道面试者是否符合所要招聘的职位，以前在其他公司的职位是否重要，来判断应聘者的发展可能。</p>
<br>

<h5 id="（22）问题：为何辞去原来的工作？"><a href="#（22）问题：为何辞去原来的工作？" class="headerlink" title="（22）问题：为何辞去原来的工作？"></a>（22）问题：为何辞去原来的工作？</h5><p>回答：工作地点离家较远，路上花费时间多，发生交通问题时，影响工作。贵公司的工作岗位更适合自己专业<br></p>
<p>（个性）的发展。</p>
<p>点评：为了避免应聘者以相同的原因辞职，公司尽量能做到对这方面原因的了解，有助于创造一个良好的工作环境和人际氛围。因此，应聘者最好说出对方能信服的理由。如果自己确有缺点，要说出“将尽量克服自己缺点”，作为有信心改变这类情况的答复。</p>
<br>

<h5 id="（23）问题：你为何选择应聘我们公司？"><a href="#（23）问题：你为何选择应聘我们公司？" class="headerlink" title="（23）问题：你为何选择应聘我们公司？"></a>（23）问题：你为何选择应聘我们公司？</h5><p>回答：我对贵公司有一定的了解，特别对公司的XX经营理念，产品质量及员工培训比较看好。</p>
<p>点评：为了表明应聘原因及工作意愿，应聘者在回答时最好要了解企业状况，不要笼统回答因为自己将来有发展，更不要回答为了安定等参考答案。</p>
<br>

<h5 id="（24）问题：在公司想做什么样的工作？"><a href="#（24）问题：在公司想做什么样的工作？" class="headerlink" title="（24）问题：在公司想做什么样的工作？"></a>（24）问题：在公司想做什么样的工作？</h5><p>回答：现在想在某工作方面冲刺，将来则希望能在某方面努力等。朝自己想要的目标陈述即可。</p>
<p>点评：同时招聘很多职种的公司，最有可能问到这样的问题，这是判断应聘者个人的能力倾向。面试者如果不论职种都回答“可以”的话，反而会让人怀疑工作态度。如果这家公司只招聘一个职种，还是被问到这个问题时，是为了确认应聘者有无犹豫，应聘者只要清楚的叙述自己想做的事就可以了。</p>
<br>

<h5 id="（25）问题：你为何要跳槽？"><a href="#（25）问题：你为何要跳槽？" class="headerlink" title="（25）问题：你为何要跳槽？"></a>（25）问题：你为何要跳槽？</h5><p>回答：虽然在前面公司工作挺顺的，同事间合作也很愉快，但我感到贵公司更适合我的发展。</p>
<p>点评：公司根据你跳槽原因，意在了解你的就业动机。</p>
<br>

<h5 id="（26）问题：请问你有什么样的工作观？"><a href="#（26）问题：请问你有什么样的工作观？" class="headerlink" title="（26）问题：请问你有什么样的工作观？"></a>（26）问题：请问你有什么样的工作观？</h5><p>回答：我认为工作是为了实现自己的人生价值，发挥自己的最大潜能，解决自己的生活问题。</p>
<p>点评：此话是问工作在你的生活中意味着什么？为何而工作？从工作中得到了什么？几年后想变成怎样等。因此，别把它想得太复杂，可根据自己的具体情况回答。</p>
<br>

<h5 id="（27）问题：你是否可以接受加班？"><a href="#（27）问题：你是否可以接受加班？" class="headerlink" title="（27）问题：你是否可以接受加班？"></a>（27）问题：你是否可以接受加班？</h5><p>回答：我愿意接受挑战。在自己责任范围内的工作，不能算是加班。</p>
<p>点评：这是面试者针对应聘者的工作热忱而提的问题，因无理的加班不一定是好的。</p>
<br>

<h5 id="（28）问题：你认为这份工作最重要的是什么？"><a href="#（28）问题：你认为这份工作最重要的是什么？" class="headerlink" title="（28）问题：你认为这份工作最重要的是什么？"></a>（28）问题：你认为这份工作最重要的是什么？</h5><p>回答：最重要的是对自己的挑战和提高。</p>
<p>点评：对工作要加上自己的看法。<br>兴趣、学业、优点、缺点</p>
<br>

<h5 id="（29）问题：你现在最感兴趣的是什么？"><a href="#（29）问题：你现在最感兴趣的是什么？" class="headerlink" title="（29）问题：你现在最感兴趣的是什么？"></a>（29）问题：你现在最感兴趣的是什么？</h5><p>回答：做个人网站，练习口语，但越做越感到自己知识欠缺。</p>
<p>点评：可以简述你的兴趣，及这个兴趣带给你个性或能力的正面效果。</p>
<br>

<h5 id="（30）问题：空闲时喜欢什么消遣？"><a href="#（30）问题：空闲时喜欢什么消遣？" class="headerlink" title="（30）问题：空闲时喜欢什么消遣？"></a>（30）问题：空闲时喜欢什么消遣？</h5><p>回答：看书、集邮、上网。有空与朋友聚聚聊聊也不错。</p>
<p>点评：对工作之外，拥有其他兴趣的应聘者较受欢迎。</p>
<br>

<h5 id="（31）问题：你在自我调节方面做何种努力？"><a href="#（31）问题：你在自我调节方面做何种努力？" class="headerlink" title="（31）问题：你在自我调节方面做何种努力？"></a>（31）问题：你在自我调节方面做何种努力？</h5><p>回答：一般情况下，我会听音乐来放松自己，若能约上几个朋友一起搞搞运动感觉也是很好的。</p>
<p>点评：听到这种提问，你可以舒坦地笑一下。此问是为了了解应聘者自我管理能力、自我调节、自我完善的能力。</p>
<br>

<h5 id="（32）问题：你在学校里学了哪些课程？这些课程对所应聘的工作有些什么帮助？"><a href="#（32）问题：你在学校里学了哪些课程？这些课程对所应聘的工作有些什么帮助？" class="headerlink" title="（32）问题：你在学校里学了哪些课程？这些课程对所应聘的工作有些什么帮助？"></a>（32）问题：你在学校里学了哪些课程？这些课程对所应聘的工作有些什么帮助？</h5><p>回答：回答时只要将所学过的重要课程以及与所应聘的工作岗位有关的课程说出来就行了，不必把每一门课程都罗列出来。可稍为详细地介绍一下与应聘岗位有关的科目。</p>
<p>点评：不要强调所学科目会对今后的工作会有极大的作用，只着重强调打好了理论和技能基础。</p>
<p>问题；你有哪些兴趣爱好或具备什么资格证书？</p>
<p>回答：“书法、乐器、体育、集邮、唱歌、舞蹈等，如钢琴能达到十级水平。我还有打字达到A级，中英文都比较熟练，同时还有一张驾驶执照呢。”</p>
<p>点评：一个人的兴趣爱好，能显示他的多方面的才能和修养，这样的人除比别人多一种技能外，更重要的是，他们往往有进取心，有发散性的思维，比较热爱生活，另外，打字、计算机、口译证书、驾驶证、报关员证书等也可以作为技能，但一般要求有资格证书作证明，如果拥有这类操作性技能证书，则也是一张“硬派司”。在开放度极大的都市里，企业最欣赏的是一专多能的复合型人才。如没有，则说实话，如爱好广泛，但都不太精。</p>
<br>

<h5 id="（33）问题：你的学习成绩如何？"><a href="#（33）问题：你的学习成绩如何？" class="headerlink" title="（33）问题：你的学习成绩如何？"></a>（33）问题：你的学习成绩如何？</h5><p>回答：<br>“较好。”<br>“一般。”我在学校里除课堂上学习的知识外，比较喜欢扩充自己的其他方面的知识，对XX类的书也看了不少。</p>
<p>点评：对自己的学习成绩一定要如实回答。如果成绩优秀，应该用平和的口气，实事求是地介绍，决不可自我炫耀，让人觉得轻浮；如果成绩不好则应说明理由，或者哪门课程不好，隐瞒或欺骗，只会暴露自己的不良品行。总之，应表现出对学习的态度是认真的，努力的，对成绩又看得比较客观。这样即使你的成绩不太理想，主试人的反应也不会太强烈。</p>
<br>

<h5 id="（34）问题：请谈一谈你的弱点。"><a href="#（34）问题：请谈一谈你的弱点。" class="headerlink" title="（34）问题：请谈一谈你的弱点。"></a>（34）问题：请谈一谈你的弱点。</h5><p>回答：<br>我是一个完美主义者，总是追求事物完美无缺。<br>我对准时要求得非常严格。<br>我从不轻易放弃，以至有些固执。<br>我喜欢独立工作，而不喜欢主管领导在我的工作中安排一切。</p>
<p>点评：一般的策略是说出一些表面上是弱点，实际上却是优点的特征。当你在叙述个人弱点时，要能够说出过去的具体相关事例，来说明你的观点。这点非常重要。当然，你也可以说一个你明显的缺点，然后举出例子说明你是怎样克服这个缺点的。此问是主试者看看你是不是由于缺少某种经验、训练，甚至由于某些性格弱点而不能胜任工作。</p>
<br>

<h5 id="（35）问题：请谈谈你的优点。"><a href="#（35）问题：请谈谈你的优点。" class="headerlink" title="（35）问题：请谈谈你的优点。"></a>（35）问题：请谈谈你的优点。</h5><p>回答：我非常喜欢和善于学习新东西，在工作中有责任心，真诚，有热情，有灵活性，能够合理地安排时间使工作有条理、有效率，能够在紧张压力下工作等等。</p>
<p>点评：以上回答要有具体实例来证明你的说法。优点除了你的工作技能、具有的各类证书和实践经验外，主试者要想听的优点不见得是你最突出的优点，而应该是和你应聘的那份工作相关的优点，从中找出雇佣你的理由，同时可以知道你对自己的了解程度，看看你对自己有没有自信，以及你到底适合不适合这份工作。因此，你要精确地描述，不可泛泛说些无意义的话，例如，适应力强，具有幽默感，合群等等。</p>
<br>

<h5 id="（36）问题：你认为自己最大的缺点是什么？"><a href="#（36）问题：你认为自己最大的缺点是什么？" class="headerlink" title="（36）问题：你认为自己最大的缺点是什么？"></a>（36）问题：你认为自己最大的缺点是什么？</h5><p>回答：我认为自己的长处是能够热衷于某件事情，并且始终乐此不疲，能够专心致志直到完成。从某方面来讲，这也是我的短处，有时过分热衷于某件事，有时对一些事的看法可能会有失偏颇。其实我也了解自己的这一点，因此，今后会经常反思和检讨的。</p>
<p>点评：<br>这个问题也是较难回答的，它考察你的应变能力的成分多于问题参考答案的本身。<br>一个人的最大的缺点可能对你的家人和朋友来讲更清楚一些，自己可能有时会意识不到，所谓不识庐山真面目，只缘身在此山中。但是对一个大学生来说，应该能够意识到自己性格中的缺点。聘方知道你的优缺点就可以知道你是否能够适合某个职位。</p>
<br>

<h5 id="（37）问题：你所取得的最大成就是什么？"><a href="#（37）问题：你所取得的最大成就是什么？" class="headerlink" title="（37）问题：你所取得的最大成就是什么？"></a>（37）问题：你所取得的最大成就是什么？</h5><p>回答：从你过去或目前的相关工作中，找出具体的实例来加以说明。如为了举办校园歌手比赛，成功地联系了一家企业作为赞助商，使比赛开展的很成功，或大三开始，自己边学习，边工作，勤工助学，生活不依靠父母，完全自立等等。</p>
<p>点评：进一步了解你的能力和背景，你要有备而去，想些可能成就比较小，但和他们的需求比较相关的一件成就来叙述。</p>
<br>

<h5 id="（38）问题：请你说说在以前的工作上成功与失败的地方？"><a href="#（38）问题：请你说说在以前的工作上成功与失败的地方？" class="headerlink" title="（38）问题：请你说说在以前的工作上成功与失败的地方？"></a>（38）问题：请你说说在以前的工作上成功与失败的地方？</h5><p>回答：<br>在学校里，我成功地组织了一次“创业与知识”的主题讨论会，得到了老师与同学的肯定，在组织中碰到了不少问题，但使我感到做任何事情，只要有信心，困难都会迎刃而解的。<br>在班级里，曾组织过一次活动，原来想活动肯定有意义，但实际上参加的人不多，活动是失败的，事后了解，有些同学对此活动不感兴趣。主观上找了原因，是和同学沟通不够，使我在以后工作中注意了凡事多与同学商量。</p>
<p>点评：成功的地方可举出目前为止的实绩，来强调对经历的自信，也可以叙述工作所带来的乐趣；失败经验可以说曾经遇到的业务或人际障碍，也可以将如何克服失败的经验说出来，并说出由失败中所得到的教训。</p>
<br>

<h5 id="（39）问题：你的好朋友怎样形容你？"><a href="#（39）问题：你的好朋友怎样形容你？" class="headerlink" title="（39）问题：你的好朋友怎样形容你？"></a>（39）问题：你的好朋友怎样形容你？</h5><p>回答：他们说我开朗大方，对朋友的困难会尽力帮助，很有号召力，但有时不拘小节。</p>
<p>点评：这类问题是你表现自己的最好机会，不要错过。因此也最需要预先准备，否则你可能不知道从何说起，往往要想一会儿才答，或者随便回答，这两种情形都不会争取到好印象。</p>
<br>

<h5 id="（40）问题：你在大学里的学习成绩不敢恭维，你如何解释呢？"><a href="#（40）问题：你在大学里的学习成绩不敢恭维，你如何解释呢？" class="headerlink" title="（40）问题：你在大学里的学习成绩不敢恭维，你如何解释呢？"></a>（40）问题：你在大学里的学习成绩不敢恭维，你如何解释呢？</h5><p>回答：是的，我的学习成绩不是很理想，即学习分数不是很高，但我注重实践能力的锻炼，我已经实习过好几家企业，他们对我反映都不错。</p>
<p>点评：这类问题往往是一种“压迫法”的面试技巧，主试者故意提出应试者的弱点，令其尴尬，看他在压力之下怎样反应。故提到的弱点，不是问题关键所在。因此，应试者应沉着应付，想办法扭转劣势，表现出自己的急才与修养。</p>
<br>

<h5 id="（41）问题：你认为你的优势在哪些方面？"><a href="#（41）问题：你认为你的优势在哪些方面？" class="headerlink" title="（41）问题：你认为你的优势在哪些方面？"></a>（41）问题：你认为你的优势在哪些方面？</h5><p>回答：<br>1.我性格开朗活泼，善于与人沟通，有较强的亲和力，营销工作与管理工作比较适合我。<br>2．我和其他同学相比不是很活跃，可能最合适我的工作是财务与行政工作，我有信心做好这样的工作。</p>
<p>点评：回答2.他在面试者前谈了自己的“缺点”，显示了他的诚实和勇敢，他知道什么工作适合自己，显示了很强的自我意识，人家谈优点，他没有人云亦云，而坚持原则是财务与行政人员重要的素质之一。<br>工作经验、工作态度</p>
<br>

<h5 id="（42）问题：你有什么社会实践经验？"><a href="#（42）问题：你有什么社会实践经验？" class="headerlink" title="（42）问题：你有什么社会实践经验？"></a>（42）问题：你有什么社会实践经验？</h5><p>回答：一年级暑假参加过学校的社会实践调查。调查“xxxx”写了一篇《xxxx》小论文。二、三年级时利用暑假<br></p>
<p>（周末）、业余时间做英语家教，受到学生家长的好评。还曾在xxxx公司、xxxx公司打过工，这是企业对我的评价。</p>
<p>点评：现在的就业市场相当重视工作经验。如果应试者曾在假期或业余时间外出打工，积累了一定的社会工作经验，将会令用人单位更加满意，哪怕应试者的打工与求职的工作无关，如果应试者曾在大学里担任过一些学生工作或参加一些社团活动，也应作些介绍，表明自己具有一定的阅历与能力。用人单位都有这样的共识，具有社会经验的人往往比较成熟，能够更快地适应工作环境。</p>
<br>

<h5 id="（43）问题：你为什么选择现在的学校和专业？"><a href="#（43）问题：你为什么选择现在的学校和专业？" class="headerlink" title="（43）问题：你为什么选择现在的学校和专业？"></a>（43）问题：你为什么选择现在的学校和专业？</h5><p>回答：高考填报志愿时，当然有好几个高校是我理想的选择。按高考进入现在的学校，它是我的选择之一，当然这个专业是我喜欢的专业。喜欢的、或感兴趣的专业，也是我学习的动力之一，事实上，通过四年的的学习生活，我对我的学校所学专业感觉很好。</p>
<p>点评：回答这一问题时，要对自己的学校和所学的专业有一种崇高和热爱的心情，并应抱有信心。随意菲薄母校和所学的专业是一种极不负责的态度，会引起别人的反感，甚至让人怀疑应试者是否有真才实学。</p>
<br>

<h5 id="（44）问题：你比较喜欢独立工作还是集体工作？"><a href="#（44）问题：你比较喜欢独立工作还是集体工作？" class="headerlink" title="（44）问题：你比较喜欢独立工作还是集体工作？"></a>（44）问题：你比较喜欢独立工作还是集体工作？</h5><p>回答：我对独立工作或集体工作没有什么偏好，如果工作比较接近团队工作，我会做的很愉快的。如工作需要相当的自主性，我也很喜欢负责那样的工作。</p>
<p>点评：如果你知道应聘的工作性质是自主的或需要依赖集体合作的，那么你可以顺势决定回答这个问题。但是如果你一无所知，不论你怎么回答都可能惹祸上身。因此，不要让自己必须在两者中抉择，你不必非得说出喜欢哪一种不可。</p>
<br>

<h5 id="（45）问题：请你谈一下和本工作有关的工作经验"><a href="#（45）问题：请你谈一下和本工作有关的工作经验" class="headerlink" title="（45）问题：请你谈一下和本工作有关的工作经验"></a>（45）问题：请你谈一下和本工作有关的工作经验</h5><p>回答：如果你做过这一类工作，说出地点，并以具体的实例来说明你的工作成绩，不要用空洞的词语。如果你没有做过这类工作，就应强调你有能力来学做这个工作，你要表明你非常喜欢这个工作，也非常想学习新东西。尽可能把你过去经历中和这个工作有联系的内容提出来，尽可能将你具有的与这个工作有关联的技能提出来。</p>
<p>点评：此问题判断你能不能做这份工作。</p>
<br>

<h5 id="（46）问题：若你到我们公司后，如何看待你本人的地位。"><a href="#（46）问题：若你到我们公司后，如何看待你本人的地位。" class="headerlink" title="（46）问题：若你到我们公司后，如何看待你本人的地位。"></a>（46）问题：若你到我们公司后，如何看待你本人的地位。</h5><p>回答：<br>1.把自己当主人，能极大地发挥个人的潜能，与公司有共同的忧患意识。<br>2.不计较个人暂时得失，做到以公司利益为重，不急功近利或搞短期行为，在工作上任劳任怨、兢兢业业。<br>3.公司以真待我，我以诚回应。</p>
<p>点评：只有把“自己当主人”，才能干劲十足，激发活力，迸发才智，干出业绩，最终凭业绩成为该企业的主人。而如果这山望着那山高，不专心工作岗位，公司稍一陷入困境就辞职走人，只同甘不共苦，把自己当成打工仔，人格上就低人一等。</p>
<br>

<h5 id="（47）问题：你希望在本公司工作多长时间？"><a href="#（47）问题：你希望在本公司工作多长时间？" class="headerlink" title="（47）问题：你希望在本公司工作多长时间？"></a>（47）问题：你希望在本公司工作多长时间？</h5><p>回答：如果我们彼此感到满意的话，我将很乐意一直继续工作下去。</p>
<p>点评：一般情况下，公司都希望所提供的工作和氛围能使未来的雇员才华得到最大程度的发挥，而你也不乐意自己的大好时光耗费在一份自己不喜欢或不适合的工作上。因此这是一个比较好的回答。</p>
<br>

<h5 id="（48）问题：你对本公司"><a href="#（48）问题：你对本公司" class="headerlink" title="（48）问题：你对本公司"></a>（48）问题：你对本公司<br></h5><p>（或这份工作）有什么看法吗？</p>
<p>回答：我对贵公司<br></p>
<p>（或这份工作）很感兴趣，很乐意在公司里发挥自己的潜能，我也相信以自己积极的心态，努力工作，在贵公司我会得以发展的。</p>
<p>点评：考官问这个问题的真正目的想要了解你能做这份工作吗？你在这公司工作安心吗？若你感到没有准备的话，你最好先说：“让我想一下”然后深呼吸放松，再做回答，这有助于增加你在回答问题时的自信。</p>
<br>

<h5 id="（49）问题：你为什么要离开前一家单位？"><a href="#（49）问题：你为什么要离开前一家单位？" class="headerlink" title="（49）问题：你为什么要离开前一家单位？"></a>（49）问题：你为什么要离开前一家单位？</h5><p>回答：事实上，离开原来的单位对我来说是比较痛苦的选择，因为我在那里工作了x年之后<br></p>
<p>（一段时间），与那里的领导和同事相处的非常好，同时，通过我的努力，也取得了大家的信任，大家不愿我离开。但是，我心中一直希望自己在xx领域内有所发展，由于客观原因，在前面的单位里一直没能实现这个愿望，所以我还是做出了这个选择，离开前一个单位。</p>
<p>点评：这个问题看起来较为简单，但回答要注意。你回答的如果不合适，对方就可能产生这样的想法，离开前一个单位是不是你不得已而为之，问题在你个人，你会因为同样或者类似的原因离开我们？因此，要避免过多的抱怨前一雇主。要强调自己个人发展需要的原因，不要归咎于别人。要让聘方相信，你在原单位也是工作出色，人际关系良好，但是为了你个人的某种理想和追求，你愿意到新公司工作。</p>
<br>

<h5 id="（50）问题：你大学刚毕业，在相关工作经验方面较为欠缺你怎么看？"><a href="#（50）问题：你大学刚毕业，在相关工作经验方面较为欠缺你怎么看？" class="headerlink" title="（50）问题：你大学刚毕业，在相关工作经验方面较为欠缺你怎么看？"></a>（50）问题：你大学刚毕业，在相关工作经验方面较为欠缺你怎么看？</h5><p>回答：<br>1.“不见得吧！”“我看未必”“不会！”“完全不是这么回事！”等等。<br>2．“这样的说法未必全对”“这样的看法值得探讨”“这样的说法有一定的道理，但恐怕不能完全接受。”等等。</p>
<p>点评：<br>1.象这样的回答方式虽然求职者也能表达清楚个人的想法并对主考官的设问进行反驳或申诉，但由于语气太过生硬，否定太过直接而会引起主考官的不悦。<br>2.在表达的过程中较为委婉地表示出自己的不同意见，不致会影响到主考官的情绪。</p>
<br>

<h5 id="（51）问题：你如何看自己缺少工作经验这问题？"><a href="#（51）问题：你如何看自己缺少工作经验这问题？" class="headerlink" title="（51）问题：你如何看自己缺少工作经验这问题？"></a>（51）问题：你如何看自己缺少工作经验这问题？</h5><p>回答：<br>忌：“本人想到贵公司，目的也就是为了取得工作经验。”<br>应：“自己确实缺乏工作经验，在读书时，我就注意这个问题，作为学生、只能利用假期进行社会实践，到公司去打工，锻炼，平时勤工助学，曾在.XX公司工作过，这是XX公司对我的评价。”</p>
<p>点评：如何理解，如何解释缺少经验，缺少经验并不是毫无经验。一人在同一职位干了五年的人，并不意味着此人就具备了五年的经验，他极有可能只是将一年经验重复了五次而已。</p>
<br>

<h5 id="（52）问题：你没有营销方面的经验，不是吗？"><a href="#（52）问题：你没有营销方面的经验，不是吗？" class="headerlink" title="（52）问题：你没有营销方面的经验，不是吗？"></a>（52）问题：你没有营销方面的经验，不是吗？</h5><p>回答：<br>1.“我很喜欢营销方面的挑战，我会达到你们的要求，而且我也期望能扩大增长我的经验。营销这一行很吸引我，因为我适应力强，接受新知识能力又较快，我自信会干好营销工作的。”<br>2.“是啊，我是没有这方面的经验。”</p>
<p>点评：记住！如果这真的是一个问题，企业就不会请你来面试了。因此，不要按2.回答，按1.的回答显示了你的热忱和自信，无形中多了一些应征的可能，所以，要懂得化缺点为优点，转劣势为优势。<br>能力表现</p>
<br>

<h5 id="（53）问题：你谈恋爱了吗？你如何看待大学生谈恋爱？"><a href="#（53）问题：你谈恋爱了吗？你如何看待大学生谈恋爱？" class="headerlink" title="（53）问题：你谈恋爱了吗？你如何看待大学生谈恋爱？"></a>（53）问题：你谈恋爱了吗？你如何看待大学生谈恋爱？</h5><p>回答：没有。我个人认为大学生最好不要谈恋爱，因为大学生毕竟不是很成熟，自控力比较差，因恋爱荒废学业、不求上进的大有人在，大学生应集中精力搞好学业、锻炼能力。</p>
<p>点评：通过这个问题来考察应试者的成熟程度和处理生活事务的能力，考察应试者的人生观和价值观。因此，应提高认识的层次，从用人单位领导的角度思考问题。</p>
<br>

<h5 id="（54）问题：你有能力胜任应聘的职位吗？"><a href="#（54）问题：你有能力胜任应聘的职位吗？" class="headerlink" title="（54）问题：你有能力胜任应聘的职位吗？"></a>（54）问题：你有能力胜任应聘的职位吗？</h5><p>回答：没问题！这虽然较难，但是我会想办法做好的！对我来说这是一个新的挑战，我相信能够战胜它。<br>忌:“对不起，我缺乏经验，可能做不好吧？”“一个人做，恐怕我现在不行”<br>如果听到这种毫无生气与活力的话时，自然会在失望之余产生一种想法：“也许他是一个缺乏能力与自信的人吧！“</p>
<p>点评：掌握好谦虚的度，实在是一个大有学问的问题。中国的传统教育总是教导人们处事要谦虚，这方面的古训很多，“满招损，谦受益”；久而久之。一方面想出人头地，一方面又自觉不自觉的受这种思想的左右，不敢大胆的发表自己的意见，礼让过头，贬低自己。这种虚伪的过谦，特别在应聘外企中很不合时宜。往往弊大于利，适得其反。作为一个企业，理所当然的选择自信敬业的人。</p>
<br>

<h5 id="（55）问题：依你现在的水平，恐怕能找到比我们企业更好的公司吧？"><a href="#（55）问题：依你现在的水平，恐怕能找到比我们企业更好的公司吧？" class="headerlink" title="（55）问题：依你现在的水平，恐怕能找到比我们企业更好的公司吧？"></a>（55）问题：依你现在的水平，恐怕能找到比我们企业更好的公司吧？</h5><p>回答：<br>1.“YES”说明你这个人“身在曹营心在汉。”<br>2.“NO”说明你的能力有问题或是对自己自信心不足，总之你会左右为难。而如果你说“不知道”或“不清楚”。则又拒绝回答之嫌。<br>3.“不可一概而论。”<br>“或许我能找到比贵公司更好的企业，但别的企业或许在对人才培养方面不如贵公司重视，机会也不如贵公司多，或许我找不到更好的企业，我想珍惜已有的最为重要的。”</p>
<p>点评：象上面这个问题以3回答最好，可以说把一个“模糊”的参考答案抛给主考官，做到滴水不漏。这类问题的特点是主考官设定了一个特定的背景式条件，让求职者作出回答，有时任何一种条件参考答案都不是很理想，这时就需要用模糊语言表示。</p>
<br>

<h5 id="（56）问题：你的面试通过了，现在我们签约。"><a href="#（56）问题：你的面试通过了，现在我们签约。" class="headerlink" title="（56）问题：你的面试通过了，现在我们签约。"></a>（56）问题：你的面试通过了，现在我们签约。</h5><p>回答：让我考虑一下，我要和父母商量过再决定。</p>
<p>点评：其实这是一种不成熟的回答，在应聘外企时不可取得，设想如果将来让这样的人代表公司和客户谈判，凡事都回公司请示报告，到手的生意也会飞了。该同学是一个条件很不错的人选，应聘的是一家非常出名的跨国公司。她走后，公司马上通知了“替补队员”<br></p>
<p>（为防意外，公司面试人数比正式录取的人数总多1—2名）那位小伙子看完公司聘函立即签了约。他表示，我就想到该公司工作。待女孩子回来。说跟家人商量好了，同意签约，而此时，那个职位已招到新人，就是那位替补队员。所以当机会来临时，千万要抓住，犹豫就会错失良机，后悔也无济于事。</p>
<br>

<h5 id="（57）问题：今天来参加面试的有近十位候选人，而我们只挑选二名，如何证明你是他们中最优秀的呢？"><a href="#（57）问题：今天来参加面试的有近十位候选人，而我们只挑选二名，如何证明你是他们中最优秀的呢？" class="headerlink" title="（57）问题：今天来参加面试的有近十位候选人，而我们只挑选二名，如何证明你是他们中最优秀的呢？"></a>（57）问题：今天来参加面试的有近十位候选人，而我们只挑选二名，如何证明你是他们中最优秀的呢？</h5><p>回答：恐怕不能一下子讲清，得具体情况具体分析，比如贵公司现在所最需要的是行政管理方面的人才，虽然前来应征的都是这方面的对口人才，但我深信我在大学四年中担任过的学生干部及组织过多次大型活动的经验已经为我打下了扎实的基础，我想这一点恐怕也是我自认为比较突出的一点。</p>
<p>点评：这样的回答可以说比较圆滑，以免主考官抓住某一“把柄”，再度发难。此问题是考察求职者随机应变的能力。无论你列举多少优点别人总有比你更多的优点，因此，你从正面去回答这样的问题毫无意义的。</p>
<br>

<h5 id="（58）问题：听说你对XX工作"><a href="#（58）问题：听说你对XX工作" class="headerlink" title="（58）问题：听说你对XX工作"></a>（58）问题：听说你对XX工作<br></h5><p>（业务）很精通，不妨谈些你的看法吧？</p>
<p>回答：谈不上精通，只是略知一二，可以共同探讨一下。</p>
<p>点评：给自己留下一点回旋的余地。对于此类问题，特别要谨慎，这往往是一个“陷阱”，是主考官有意想进一步对求职者有更加深入的了解所设定的“圈套”。因此，求职者要小心回答问题，即使你真的对XX业务很精通，也千万不要自以为是，否则你将面临难度更大的问题。</p>
<br>

<h5 id="（59）问题：如果你被录用，是否马上就可来上班？"><a href="#（59）问题：如果你被录用，是否马上就可来上班？" class="headerlink" title="（59）问题：如果你被录用，是否马上就可来上班？"></a>（59）问题：如果你被录用，是否马上就可来上班？</h5><p>回答：今天听到你的聘用邀请十分感激，但学校里学业还未全部结束，论文撰写正是关键的时候，还在准备论文答辩阶段，容我回去征求导师意见，看能否抽出时间上班，所以允许我明天正式回复。</p>
<p>点评：面对开门见山的质问，如当时无法确定答复，且自己未决定真正意愿应允，应考虑到事后可能还会有更让自己心动的工作机会。在回答时即应巧妙预设一个转弯的空间。同时，避免得罪对方而错失良机，这比“对不起，我还不能回答这个问题，我必须仔细考虑看看。”这种答复圆滑的多。</p>
<br>

<h5 id="（60）问题：你救了我女儿，是我们家的救命恩人，对你的录用我们会优先考虑的。"><a href="#（60）问题：你救了我女儿，是我们家的救命恩人，对你的录用我们会优先考虑的。" class="headerlink" title="（60）问题：你救了我女儿，是我们家的救命恩人，对你的录用我们会优先考虑的。"></a>（60）问题：你救了我女儿，是我们家的救命恩人，对你的录用我们会优先考虑的。</h5><p>回答：不，先生，你弄错了吧，我未曾救过任何人<br>考官：年轻人，你说的很对，是我弄错了，我很欣赏你的诚实，我决定，不是优先，而是你的复试已经通过了</p>
<p>点评：此问题是考官设的一个“陷阱”。一个人的优秀品质会引起他人喜欢的，而诚实是招聘者看重的必备品质。因此大学生虽有良好的资历和优秀的学业成绩，更必备诚实的品格。</p>
<br>

<h5 id="（61）问题：“会打羽毛球吗？”"><a href="#（61）问题：“会打羽毛球吗？”" class="headerlink" title="（61）问题：“会打羽毛球吗？”"></a>（61）问题：“会打羽毛球吗？”</h5><p>“给你们一辆小轿车，有没有把握学会驾驶？”<br>“厨房里有蔬菜，你俩能不能给我做几样拿手的好菜？”</p>
<p>回答：<br>男：会女：打的不好<br>男：有女：不敢保证<br>男：没问题女：做得不好</p>
<p>点评：<br>此应聘面试单位是一家中外合资公司，已经过了几道关卡的面试，此是最后复试，主考经理是外国人，以上是闲聊中随便地问了三个问题。最后，公司录用了男学生，淘汰了女学生。公司对女学生的评价是：有自卑情绪，缺乏自信心，无法胜任本公司职务。其实，该女同学是个不错的羽毛球选手。</p>
<br>

<h5 id="（62）问题：在工作中你怎样看待错误？"><a href="#（62）问题：在工作中你怎样看待错误？" class="headerlink" title="（62）问题：在工作中你怎样看待错误？"></a>（62）问题：在工作中你怎样看待错误？</h5><p>回答：<br>1.我尽量不出错误<br>2.我并不担心自己会出错，但我能做到不重复同样的一个错误。</p>
<p>点评：对回答1的公司没有录用。<br>人非圣贤，熟能无过？错误是必不可少的，但关键是要能很快地吸取经验教训，总结经验。求职也如此，不要害怕失败，你应牢牢记住：“失败乃成功之母！”“失败是成功的踏脚石。”通往成功的路从不平坦，跌倒是难免的，但是，跌倒了并不是失败，真正的失败是跌倒了怕不起来了。”</p>
<br>

<h5 id="（63）问题：我们公司今年计划一般不招女学生"><a href="#（63）问题：我们公司今年计划一般不招女学生" class="headerlink" title="（63）问题：我们公司今年计划一般不招女学生"></a>（63）问题：我们公司今年计划一般不招女学生</h5><p>回答：贵公司的用人计划我了解，但我想性别差异并非是挑选人才的关键，还是要看个人的基本素质，何况我各方面表现都较优秀，有些男同学还赶不上我，而且女生在贵公司的职位更能显示女同学的优势。</p>
<p>点评：女同学碰到此类问题，不要愤怒、憎恨，要靠耐心和韧性，回答问题不要带怒意，要不卑不亢，充满自信，介绍自己的优势，有与男同学一比高低的勇气。</p>
<br>

<h5 id="（64）问题：你可以有三分钟的表现自己的机会，若表现得使我感兴趣，就留下来，否则另请高就。"><a href="#（64）问题：你可以有三分钟的表现自己的机会，若表现得使我感兴趣，就留下来，否则另请高就。" class="headerlink" title="（64）问题：你可以有三分钟的表现自己的机会，若表现得使我感兴趣，就留下来，否则另请高就。"></a>（64）问题：你可以有三分钟的表现自己的机会，若表现得使我感兴趣，就留下来，否则另请高就。</h5><p>回答：这三分钟的表现，可以成为你去留的依据，有的学生充分显示实力，把握了机会，有的学生则不会表现而被淘汰。有的学生为了显得谦虚，尽量少讲自己的优点，少表现自己，结果也失去了这个机会。</p>
<p>点评：此类面试问题一般是企业总经理面试时提的，他们的话简单明了：“你连自己都推销不掉，你帮我推什么？要帮我推销商品，推销企业形象，首先学会推销自己。”因此针对不同的面试对象，自己认真准备好几个三分钟是有必要的。因此，自我表现时要充满自信，落落大方，态度诚恳。</p>
<br>

<h5 id="（65）问题：小姐，假如在将来的工作中，你接待的客人要你陪跳舞，你不想跳，但不跳又不行，你会怎么办？"><a href="#（65）问题：小姐，假如在将来的工作中，你接待的客人要你陪跳舞，你不想跳，但不跳又不行，你会怎么办？" class="headerlink" title="（65）问题：小姐，假如在将来的工作中，你接待的客人要你陪跳舞，你不想跳，但不跳又不行，你会怎么办？"></a>（65）问题：小姐，假如在将来的工作中，你接待的客人要你陪跳舞，你不想跳，但不跳又不行，你会怎么办？</h5><p>回答：<br>1.你们是什么样的鬼单位，在这里摆摊招舞女。”说完头也不回扬长而去。<br>2.若是工作需要，要陪客人跳舞，跳跳也无妨。若是客人另有意思，那可约男同事一起去娱乐。</p>
<p>点评：此是外贸进出口公司在人才会上招聘秘书，单位是很正派很有声望的企业，提出这一问题，考官只是想试试求职者的口头应变能力和处事能力。该小姐只要冷静下来，思考考官提出的问题，把自己的看法如实说出，作机敏的回答，就不至于失去一份很有前途的工作。</p>
<br>

<h5 id="（66）问题：你喜欢和何种人共事？"><a href="#（66）问题：你喜欢和何种人共事？" class="headerlink" title="（66）问题：你喜欢和何种人共事？"></a>（66）问题：你喜欢和何种人共事？</h5><p>回答：总的说来我是一个开朗的人，我喜欢和有相同个性的人打交道。</p>
<p>点评：此句意在了解求职者本身的个性特点，并借此来分析求职者一旦进入新的机构后与现职位的其他人员的相容程度，主考官据此判断此人是否能与其他人融洽相处。按照一句时髦的话来说，就是看看求职者是否具有团队精神。作为求职者，应当注意不要过分对此句话“躲躲闪闪”或是故意回避，回答这个问题时，要先大概介绍一下自己的个性特点，然后再说喜欢同什么样的人相处，总之要言之有理，顺理成章。</p>
<br>

<h5 id="（67）问题：你对大学生就业市场的评价如何？"><a href="#（67）问题：你对大学生就业市场的评价如何？" class="headerlink" title="（67）问题：你对大学生就业市场的评价如何？"></a>（67）问题：你对大学生就业市场的评价如何？</h5><p>回答：这个问题很大，很难用三言两语概括清楚。在双向选择，自主择业的政策下，要就业，找市场已被学生接受，虽然就业市场形势严峻，但我们乐意在市场中参与竞争，选择合适自己的职业。</p>
<p>点评：主试人为测验应试者分析问题与逻辑思维能力，有意提一些很难回答的问题。回答此问题时应边说边想。若想好了再说，主试人会认为你反映迟钝。为了赢得思考的时间，开头可以先说一句开场白，后面边想边说，分条回答。想起一条答一条，在答第一条时就想第二条，依此类推。回答完了的时候，再从中找出一两个重点。这样就容易获得构思敏捷，思路清晰，善于抓住要害的好评。</p>
<br>

<h5 id="（68）问题：你喜欢什么样的上司？"><a href="#（68）问题：你喜欢什么样的上司？" class="headerlink" title="（68）问题：你喜欢什么样的上司？"></a>（68）问题：你喜欢什么样的上司？</h5><p>回答：<br>忌：“谁做我的上司都喜欢。”或“不知道”<br>应：“我本人比较喜欢有真才实学，公正严明的上司。”</p>
<p>点评：大多数应聘者对上司的背景毫不知情，因此，用一些普通适用的公认标准为好</p>
<br>

<h5 id="（69）问题：假如我们聘用你，但有时需要做些倒茶端水的杂务，你会反对吗？"><a href="#（69）问题：假如我们聘用你，但有时需要做些倒茶端水的杂务，你会反对吗？" class="headerlink" title="（69）问题：假如我们聘用你，但有时需要做些倒茶端水的杂务，你会反对吗？"></a>（69）问题：假如我们聘用你，但有时需要做些倒茶端水的杂务，你会反对吗？</h5><p>回答：“只要需要，我不会斤斤计较。”“如果有客人到我所在的那个部门，我会主动倒茶端水，这些杂务只是我的工作内容的一小部分而已。”</p>
<p>点评：这是一个试探性问题，目的是观察应聘者的反应，以判断你对工作的态度。因没有任何一家公司会聘用大学毕业生专门从事杂务工作。若明确拒绝接受这类杂务，则意味着拒绝接受职位，且在面试时与主试者争论差别毫无意义。</p>
<br>

<h5 id="（70）问题：如果公司与另外一家公司同时录用你，你将如何选择？"><a href="#（70）问题：如果公司与另外一家公司同时录用你，你将如何选择？" class="headerlink" title="（70）问题：如果公司与另外一家公司同时录用你，你将如何选择？"></a>（70）问题：如果公司与另外一家公司同时录用你，你将如何选择？</h5><p>回答：<br>1.贵公司是我的第一选择。<br>2.我不敢奢望有两家公司同时看上我，即使有此情况，我还是首选贵公司。</p>
<p>点评：无论你到哪家公司应聘，都应这么回答，在未确定最后的归属前，回答这个问题不能有丝毫犹豫。</p>
<br>

<h5 id="（71）问题：你对营销、管理工作如何看待？"><a href="#（71）问题：你对营销、管理工作如何看待？" class="headerlink" title="（71）问题：你对营销、管理工作如何看待？"></a>（71）问题：你对营销、管理工作如何看待？</h5><p>回答：现在社会竞争非常激烈，营销、管理工作不是光凭热情能干好的，它需要经常做些调查研究，了解社会需求，提出目标、计划，同时，需要各方面的配合，才能把工作做的更好。</p>
<p>点评：应聘者对所应聘的岗位不能仅仅是有热情，同时还要冷静、理智地作出一些工作设想，这既说明了工作的积极主动性，也表明了应聘者是一个聪慧且思考成熟的人。</p>
<br>

<h5 id="（72）问题：你认为对员工的管理严厉的好，还是宽松的好？"><a href="#（72）问题：你认为对员工的管理严厉的好，还是宽松的好？" class="headerlink" title="（72）问题：你认为对员工的管理严厉的好，还是宽松的好？"></a>（72）问题：你认为对员工的管理严厉的好，还是宽松的好？</h5><p>回答：我想这要因时因人而定的，不能千篇一律。有些人对严厉的管理方法反应良好，有些人却需要鼓励才能做得更好。好的管理人员应该知道怎么使他的部属发挥更大的潜力。</p>
<p>点评：你不清楚企业需要的是什么样的管理作风，也是测试你能接受什么样的管理风格，如你确实不能接受他们的管理风格，那等到录取了再抉择。</p>
<br>

<h5 id="（73）问题：你好象不适合到我们公司工作？"><a href="#（73）问题：你好象不适合到我们公司工作？" class="headerlink" title="（73）问题：你好象不适合到我们公司工作？"></a>（73）问题：你好象不适合到我们公司工作？</h5><p>回答：可能在刚才的陈述中没把问题谈清楚，是我引起你的误解。其实我对贵公司非常尊重，对公司业务也有一些了解，我想在贵公司经过培训和工作后，是能够达到贵公司要求的，请务必再次考虑录用的问题。</p>
<p>点评：应答时，千万要注意不可反问对方提出的此问题的理由。此问有时也是主试者考验应试者到企业的决心，和应试者的自信心。</p>
<br>

<h5 id="（74）问题：你的计算机能力如何？"><a href="#（74）问题：你的计算机能力如何？" class="headerlink" title="（74）问题：你的计算机能力如何？"></a>（74）问题：你的计算机能力如何？</h5><p>回答：<br>如果你这方面能力较差的话，你就应该告诉他们你的计算机能力较为欠缺，但是你目前还在继续学习计算机。<br>如果能力强的话，就可直接告诉他们你所得到的高级或中级编程员证书，及计算机的其他能力。</p>
<p>点评：遇到的问题属于自己的长处，也不要洋洋洒洒，滔滔不绝。对方问到自己的短处，不要避而不谈，或者转移话题，其实每一个人即使是非常优秀的人都会有自己的弱点，这种情况下应该正面回答对方的问题，同时如果自己认为这是一个欠缺而又是对方的招聘条件的话，应该积极表示自己现在的或者即将的行动用来克服这方面的缺点。</p>
<br>

<h5 id="（75）问题：你的外语水平如何？"><a href="#（75）问题：你的外语水平如何？" class="headerlink" title="（75）问题：你的外语水平如何？"></a>（75）问题：你的外语水平如何？</h5><p>回答：<br>如果你水平高的话，对方又是懂外语的面试官你可以直接用外语进行回答你外语所具备的能力，得到的证书或托福的考分，以表示你的能力。但表示还不够，还需努力继续学习。<br>若你的水平较低，就应如实回答，讲出低的原因，如笔头翻译不差，口语听力稍差，或专业词汇较熟悉，人文词汇掌握较少等。并表示你目前还在学习。</p>
<p>点评：遇到的问题属于自己的长处，也不要洋洋洒洒，滔滔不绝。对方问到自己的短处，不要避而不谈，或者转移话题，其实每一个人即使是非常优秀的人都会有自己的弱点，这种情况下应该正面回答对方的问题，同时如果自己认为这是一个欠缺而又是对方的招聘条件的话，应该积极表示自己现在的或者即将的行动用来克服这方面的缺点。</p>
<br>

<h5 id="（76）问题：能否介绍一下你的社会活动能力"><a href="#（76）问题：能否介绍一下你的社会活动能力" class="headerlink" title="（76）问题：能否介绍一下你的社会活动能力"></a>（76）问题：能否介绍一下你的社会活动能力</h5><p>回答：<br>1.我的外交能力较强，在校学生会我担任外联部长。<br>2.我在校尽可能多地参加一些能发挥自己特长的活动，使社会活动能力得到了一定的提高。<br>3.我善于组织同学开展活动，如组织演讲赛，辩论赛，知识抢答赛等等，而且活动也较成功，从中可以证实我有一定的社会活动能力。<br>4.在校期间，我曾担任过班长职务。为了把班级基础文明建设搞好，组织全班同学进行校规校纪学习，集思广益，制定了“班规十条”，并要求全班同学严格遵守班级纪律。经过大家的努力，我班评为校先进班级，全班同学学习努力，团结友爱。</p>
<p>点评：<br>1.过于简单，草率，效果不好。<br>2.比较谦虚地说明自己有一定的能力，但言之无物，有些空洞。<br>3.如实的介绍自己曾组织过活动，但不具体。<br>4.通过例举事例，来说明自己的能力，有理有据，效果最佳，使主试者了解其素质和能力。</p>
<br>

<h5 id="（77）问题：你今后打算是什么？"><a href="#（77）问题：你今后打算是什么？" class="headerlink" title="（77）问题：你今后打算是什么？"></a>（77）问题：你今后打算是什么？</h5><p>回答：“我希望我能够在这个公司里长久地工作。根据自己的能力和表现，不断地增加工作中所担负的责任。”</p>
<p>点评：看看你真正想要得到的是什么，以判定你是否会长期在公司工作。明确你的个人目标和公司是否一致。</p>
<br>

<h5 id="（78）问题：你为什么这么长时间没有工作？"><a href="#（78）问题：你为什么这么长时间没有工作？" class="headerlink" title="（78）问题：你为什么这么长时间没有工作？"></a>（78）问题：你为什么这么长时间没有工作？</h5><p>回答：我花了很长一段时间对自己的经历进行了反省和总结，并仔细研究了目前的就业市场，以确定自己的目标和方向，当然我也有过一些工作机会，但我的目的不仅仅是找一份工作，我追求的是有发展前途的未来。今天来应聘贵公司，我觉得贵公司适合我的发展。</p>
<p>点评：判断你对难题的应变能力，以及你对实际生活中问题的判断和处理能力。</p>
<br>

<h5 id="（79）问题：为什么要录用你？"><a href="#（79）问题：为什么要录用你？" class="headerlink" title="（79）问题：为什么要录用你？"></a>（79）问题：为什么要录用你？</h5><p>回答：这是你要回答好的最重要的问题。根据公司目前的需要，强调你的背景优势，根据工作的需求叙述一下你的能力。如果你没有相关工作经验，强调你的其他工作经验和所受的教育，适合这个工作。</p>
<p>点评：确定你是不是最佳人选，看看你有没有自信心。</p>
<br>

<h5 id="（80）问题：你为什么想要换工作？"><a href="#（80）问题：你为什么想要换工作？" class="headerlink" title="（80）问题：你为什么想要换工作？"></a>（80）问题：你为什么想要换工作？</h5><p>回答：“我想进一步发挥我的能力”，或“我目前单位的发展机会非常有限。”</p>
<p>点评：这个问题是判断你的动机，和你处理问题的能力。切记，不要抱怨你过去或目前的雇主。</p>
<br>

<h5 id="（81）问题：谈一谈你在过去工作中生活中遇到的问题，以及如何解决。"><a href="#（81）问题：谈一谈你在过去工作中生活中遇到的问题，以及如何解决。" class="headerlink" title="（81）问题：谈一谈你在过去工作中生活中遇到的问题，以及如何解决。"></a>（81）问题：谈一谈你在过去工作中生活中遇到的问题，以及如何解决。</h5><p>回答：举一个你在过去的工作中或生活中遇到的问题，说明你是如何解决该问题的。</p>
<p>点评：判断你对问题的分析能力，看看你有没有团队精神和克服困难的信心。这也是给你一个表现自我的机会。</p>
<br>

<h5 id="（82）问题：你喜欢你们学校吗？你的老师怎么样？"><a href="#（82）问题：你喜欢你们学校吗？你的老师怎么样？" class="headerlink" title="（82）问题：你喜欢你们学校吗？你的老师怎么样？"></a>（82）问题：你喜欢你们学校吗？你的老师怎么样？</h5><p>回答：我很喜欢学校，那是我学习、生活了四年的地方，也是我成材、成熟的人生车站。四年中也碰到了许多好老师，对我思想上引导、学业上指导、能力上辅导，我从心里感谢他们。特别我们的英语老师，上课非常幽默，回想起来仍感到回味无穷。</p>
<p>点评：每个学生对这个问题一定要持积极肯定的态度。这是主考者考察应试者的个人品格的题目。作为一个具有高度思想觉悟和良好道德品质的现代大学生，尊师爱校是应有的品质。此外，人们普遍认为，一个不热爱母校、不尊敬老师的大学毕业生，也很难谈得上热爱就业单位，尊敬单位领导及老同志。因此，因充满激情地简单说明喜欢自己母校的原因，及老师对自己在学业和能力上的帮助和影响。</p>
<br>

<h5 id="（83）问题：假如你流落荒岛，可以拥有一本书，你会选择哪一本？为什么？"><a href="#（83）问题：假如你流落荒岛，可以拥有一本书，你会选择哪一本？为什么？" class="headerlink" title="（83）问题：假如你流落荒岛，可以拥有一本书，你会选择哪一本？为什么？"></a>（83）问题：假如你流落荒岛，可以拥有一本书，你会选择哪一本？为什么？</h5><p>回答：我选择生活百科全书，因为此时人最基本的问题是解决生存问题。</p>
<p>点评：这是假设性问题，来测试应试者的想象力、解决问题的能力，目的看你有没有急才，思想有没有条理。</p>
<br>

<h5 id="（84）问题：如果你的任务完成了，而同伴尚未完成，你应该怎么办？"><a href="#（84）问题：如果你的任务完成了，而同伴尚未完成，你应该怎么办？" class="headerlink" title="（84）问题：如果你的任务完成了，而同伴尚未完成，你应该怎么办？"></a>（84）问题：如果你的任务完成了，而同伴尚未完成，你应该怎么办？</h5><p>回答；我应该处理好其他事情，主动地去支援同伴。</p>
<p>点评：用人单位希望员工能更好地融入集体，勇于承担个人责任。要求员工在工作中应和睦相处，互相帮助，互相合作。一家外资公司总经理说：“可能这里不一定每个人都是一流的，但他们结合起来，绝对是一流的。”</p>
<p>其他问题</p>
<br>

<h5 id="（85）问题：毕业后为何不马上工作"><a href="#（85）问题：毕业后为何不马上工作" class="headerlink" title="（85）问题：毕业后为何不马上工作"></a>（85）问题：毕业后为何不马上工作<br></h5><p>（为何现在才应聘工作）</p>
<p>回答：<br>为了取得xx资格证书，故一直在复习应考，使应聘时更具实力。<br>参加了xx大学的短训班，使自己的xx水平提高。<br>花了很多时间了解就业市场和有关信息。</p>
<p>点评：要以肯定、积极、正面的活动进行回答为佳。如果没有任何活动，也可讲述这段时间自己的想法。只要有上进性，面试者会满意的。</p>
<br>

<h5 id="（86）问题：你择业考虑的主要问题是什么？"><a href="#（86）问题：你择业考虑的主要问题是什么？" class="headerlink" title="（86）问题：你择业考虑的主要问题是什么？"></a>（86）问题：你择业考虑的主要问题是什么？</h5><p>回答：主要谈考虑应聘的职业对自己将来事业的发展，及发挥自己的专业所长。另外，良好的企业文化<br></p>
<p>（工作氛围）能激发自己的能动性等等。</p>
<p>点评：凡是与物质利益有关的条件，如工资、福利、环境等等，最好少谈，即使问到，也要把握分寸，适可而止。</p>
<br>

<h5 id="（87）问题：你觉得自己干这项工作是大材小用还是小材大用？"><a href="#（87）问题：你觉得自己干这项工作是大材小用还是小材大用？" class="headerlink" title="（87）问题：你觉得自己干这项工作是大材小用还是小材大用？"></a>（87）问题：你觉得自己干这项工作是大材小用还是小材大用？</h5><p>回答：我相信我能干好这项工作。我觉得自己既不是大材小用也不是小材大用，它正好适合我干。</p>
<p>点评：如果你对这项工作确实很感兴趣，那么不管情况怎样，你都应如上面回答。</p>
<br>

<h5 id="（88）问题：你正在和其他公司洽谈吗？"><a href="#（88）问题：你正在和其他公司洽谈吗？" class="headerlink" title="（88）问题：你正在和其他公司洽谈吗？"></a>（88）问题：你正在和其他公司洽谈吗？</h5><p>回答：是的。</p>
<p>点评：<br>如果你的回答是否定的，那么你应征的希望必然削弱不少。<br>如果你没有同时应征其他公司，那么表示你的求职计划出了严重的错误。若确实在谈，你也不必告诉他们你正和谁接洽。只要让他们知道，如果他们想要你，最好得马上采取行动才行，认为你是值得给第二次面试机会的人选。</p>
<br>

<h5 id="（89）问题：薪水和工作，哪个对你更重要？"><a href="#（89）问题：薪水和工作，哪个对你更重要？" class="headerlink" title="（89）问题：薪水和工作，哪个对你更重要？"></a>（89）问题：薪水和工作，哪个对你更重要？</h5><p>回答：两者对我都很重要。因为薪水可以解决个人生存问题，是生活条件基本需要，工作是为了发展自己的能力。点评：此题是非A即B题，如果你希望获得一个既有高薪待遇，又有长期职业发展前途的工作的话，没必要非排除一个选择另一个。</p>
<br>

<h5 id="（90）问题：这份工作起薪点不高，你不会介意吧？"><a href="#（90）问题：这份工作起薪点不高，你不会介意吧？" class="headerlink" title="（90）问题：这份工作起薪点不高，你不会介意吧？"></a>（90）问题：这份工作起薪点不高，你不会介意吧？</h5><p>回答：不介意。</p>
<p>点评：一般碰到这类问题都顺水推舟，照对方的意思回答，如果你有特别理由要说相反的话，也不妨鼓起勇气照说出来，但要言之有理，在对方大感意外之余，说不定会赞赏你有主见。可是一般来说，还是尽可能不要冒险。</p>
<br>

<h5 id="（91）问题：你希望待遇月薪大约是多少金额？"><a href="#（91）问题：你希望待遇月薪大约是多少金额？" class="headerlink" title="（91）问题：你希望待遇月薪大约是多少金额？"></a>（91）问题：你希望待遇月薪大约是多少金额？</h5><p>回答：依贵公司的规定大概是什么样的薪金行情？</p>
<p>点评：若你心里没底的话，感到难回答，那么上面这一反问就行了，因一个有制度的公司不会因为你要求得多就多给，要求得少就少给。</p>
<br>

<h5 id="（92）问题：你如何看待你原来的薪金问题"><a href="#（92）问题：你如何看待你原来的薪金问题" class="headerlink" title="（92）问题：你如何看待你原来的薪金问题"></a>（92）问题：你如何看待你原来的薪金问题</h5><p>回答：我并不是说原来工作的单位不好，但工作几年下来的工资奖金没有增长，可能是他们的企业所决定的，但别人还以为我能力不够，现在，我到贵公司来应聘，薪金有所提高，算是自我价值的认定吧。”</p>
<p>点评：薪金问题一向是单位吸引人才的重要手段，也是求职者的追求目的之一，因此，薪金问题既是个敏感的问题，又是个重要问题，须小心处理。</p>
<br>

<h5 id="（93）问题：请谈一下你期望的月薪要求"><a href="#（93）问题：请谈一下你期望的月薪要求" class="headerlink" title="（93）问题：请谈一下你期望的月薪要求"></a>（93）问题：请谈一下你期望的月薪要求</h5><p>回答：如果我能到贵公司工作，这将是我跨出校门，第一次走上社会工作，我相信我自己的能力，如果能受聘这个职位我一定会非常努力的工作，因此每月xxxx元的工资是我个人的要求，但我更关心的是能找到一份工作来充分发挥我个人的能力。</p>
<p>点评：实际上用人单位决定录用你时，对你的待遇其实已基本确定。特别在一些国企跨国大公司中，对大学生的工资待遇公司都有了相关规定的，但也不是绝对不可更改的。此问也是面试者为了了解你对自己的估价。因此对月薪不能要求过高，但也要合理。如果你觉得单位给你的月薪偏低，可以将你的关注告诉单位。你要让单位觉得你是在同他们商议，而不是要挟。重点放在你关注的原因上。比如，你要租房、车费、生活费等基本开销或探亲等，希望单位算一下你的基本生活开销，那么效果会比简单地说你要多少多少工资要来得好些。</p>
<p>忌问：我不是名牌大学毕业生<br></p>
<p>（研究生），你们要吗？</p>
<p>点评：此问话首先让人感到你缺少自信心，有一种自卑感。有的招聘单位招聘条件很醒目地提出，只招聘名牌大学毕业生<br></p>
<p> （研究生），遇到这种情况，你要调节好自己的心态，以积极自信的态度前往应聘，讲出自己的优点，对应聘岗位的了解，希望公司不要以牌子取人，应注重真才实学，给你面试机会。</p>
<p>忌问：“外地生源要否？”</p>
<p>点评：一些外地学生或出于坦诚，或急于得到“兑现”，一到用人单位招聘摊位前劈头就提这么一个问题，弄得主试人无话可说。因为实际情况是，不是外地生源不要，也不是所有外地生源都要，而是要看应聘者的实际情况能否与招聘者要求相符合。这么简单地提问，很有可能同样简单地得到回绝。</p>
<p>忌问：“你单位招几个？”</p>
<p>点评：这种提问似乎无可厚非，但招聘者对此会从另外的角度认为，招一个也是招，招两个也是招，问题不在于招几个，而是应聘者有没有成为百分之一或二分之一或独一无二的竞争能力和实力。因为一百个名额要竞争，一个名额更要竞争。</p>
<p>忌问：“你们单位招女生吗？”</p>
<p>点评：这样提问的女生，首先自己先打了“折扣”，是一种缺乏自信心的表现。面对已明显表露出“胆怯”的女性，招聘单位若想拒绝，就正好“顺水推舟”。这时，如果这位女生面对主试人来一番非同凡响的慷慨陈词或巧妙的介绍，反倒会使主试人认真“考虑考虑。”</p>
<p>忌问：你们单位有住宿吗？</p>
<p>点评：对于在异地就业的毕业生，住宿问题是一个大问题，但在应聘中，什么问题都没谈，企业根本还没决定录用你，你就提出住宿问题，这是自信心不足的表现。何况，现在社会上租房也是很方便的一件事。</p>
<br>

<h5 id="（94）问题：请问你还有问题要问吗？"><a href="#（94）问题：请问你还有问题要问吗？" class="headerlink" title="（94）问题：请问你还有问题要问吗？"></a>（94）问题：请问你还有问题要问吗？</h5><p>回答：回答这个问题，大有学问。首先，你可以将你在面试中还没有机会提出的相关问题提出来。其次，进一步强调一下你在面试过程中没有机会谈到的个人优势。如果实在没有什么可以说的，也不要说没有问题。你可以问面试者下一次的面试<br></p>
<p>（如果有的话）是什么时间？或者问面试者什么时候可以得到结果，以及什么时候可以打电话给他。如果你确定得到这份工作，这个时候你就应该对面试者这么说：“我很想得到这份工作。我认为我完全能够胜任这份工作。请给我这个机会。”最后，对面试者表示致谢，握手，告别。</p>
<p>点评：此问一般当面试者要结束面试时，常常会问的问题。</p>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></h6></h6>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ezharjan.github.io/Blog/2022/03/12/%E9%9D%9E%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98%E5%9B%9E%E7%AD%94%E6%96%B9%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Alexander Ezharjan">
      <meta itemprop="description" content="This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2022/03/12/%E9%9D%9E%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98%E5%9B%9E%E7%AD%94%E6%96%B9%E7%95%A5/" class="post-title-link" itemprop="url">非技术问题回答方略</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-12 21:31:43" itemprop="dateCreated datePublished" datetime="2022-03-12T21:31:43+08:00">2022-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-17 10:34:44" itemprop="dateModified" datetime="2022-10-17T10:34:44+08:00">2022-10-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Job-Interview/" itemprop="url" rel="index"><span itemprop="name">Job Interview</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h6 align="center">编者：艾孜尔江<h6>


<p><b><details><summary>1、请你自我介绍一下你自己</summary></details></b></p>
<p>回答提示：一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历上都有，其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以和学习无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句“谢谢”。企业喜欢有礼貌的求职者。</p>
<p>回答样本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、我叫xxx,来自于xxx，从网上看得到公司招聘的这个职位，觉得非常适合自己的发展。所以来这里争取下这份工作。</span><br><span class="line">2、接下来可以讲解自己的核心竞争力（最强的技能、最深入研究的知识领域、个性中最积极的部分）和闪光点（做过的最成功的事，主要的成就）。核心就是要体现自己胜任这份工作（介绍时候要自然有底气，合情合理，面试前要充分准备好）。</span><br><span class="line">3、先介绍到这里，面试官看看有什么问题，我可以再补充。</span><br><span class="line">4、最后要说谢谢，任何企业都喜欢有礼貌的人！</span><br></pre></td></tr></table></figure>

<p>注意：自曝其短（说自己的缺点）没有必要，自我介绍的时候千万不要和简历有冲突！</p>


<p><b><details><summary>2、你觉得你个性上最大的优点是什么？</summary></details></b></p>
<p>回答提示：沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱、技术狂热、学习能力强、为人谦和。</p>


<p><b><details><summary>3、说说你最大的缺点？</summary></details></b></p>
<p>回答提示：这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，企业肯定不会录用你。绝对不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌芨可危了。企业喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转回到优点上，突出优点的部分。企业喜欢聪明的求职者。</p>


<p><b><details><summary>4、你对加班的看法？</summary></details></b></p>
<p>回答提示：实际上好多公司问这个问题，并不证明一定要加班。 只是想测试你是否愿意为公司奉献。<br>回答样本：如果是工作需要我会义不容辞加班。我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。</p>


<p><b><details><summary>5、你对薪资的要求？</summary></details></b></p>
<p>回答提示：如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱。他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。</p>
<p>回答样本一：“我对工资没有硬性要求。我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多</p>
<p>回答样本二：我受过系统的软件编程的训练，不需要进行大量的培训。而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。</p>
<p>回答样本三：如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场作了调查，知道像自己这样学历的雇员有什么样的价值。</p>


<p><b><details><summary>6、在五年的时间内，你的职业规划？</summary></details></b></p>
<p>回答提示：这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到。比较多的参考答案是“管理者”。但是近几年来，许多公司都已经建立了专门的技术途径。这些工作地位往往被称作“顾问”、“参议技师”或“高级软件工程师”等等。当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是 “我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。</p>


<p><b><details><summary>7、你朋友对你的评价？</summary></details></b></p>
<p>回答提示： 想从侧面了解一下你的性格及与人相处的问题。<br>回答样本：“我的朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。<br>回答样本：”我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题“</p>


<p><b><details><summary>8、你还有什么问题要问吗？</summary></details></b></p>
<p>回答提示：企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没有问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。</p>


<p><b><details><summary>9、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？</summary></details></b></p>
<p>回答提示：一段时间发现工作不适合我，有两种情况：</p>
<p>1、如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；</p>
<p>2、你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。</p>


<p><b><details><summary>10、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？</summary></details></b></p>
<p>回答提示：①.原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法；<br>② 如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作；<br>③.还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见；如领导仍固执己见，我会毫不犹豫地再向上级领导反映。</p>


<p><b><details><summary>11、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？</summary></details></b></p>
<p>回答提示：<br>① 我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决；<br>② 是责任问题。分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。<br>③ 总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。</p>


<p><b><details><summary>12、如果你在这次考试中没有被录用，你怎么打算？</summary></details></b></p>
<p>回答提示：现在的社会是一个竞争的社会,从这次面试中也可看出这一点,有竞争就必然有优劣,有成功必定就会有失败.往往成功的背后有许多的困难和挫折,如果这次失败了也仅仅是一次而已,只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败.</p>
<p>第一、要敢于面对,面对这次失败不气馁,接受已经失去了这次机会就不会回头这个现实,从心理意志和精神上体现出对这次失败的抵抗力。要有自信,相信自己经历了这次之后经过努力一定能行.能够超越自我.</p>
<p>第二、善于反思,对于这次面试经验要认真总结,思考剖析,能够从自身的角度找差距。正确对待自己,实事求是地评价自己,辩证的看待自己的长短得失,做一个明白人.</p>
<p>第三、走出阴影,要克服这一次失败带给自己的心理压力,时刻牢记自己弱点,防患于未然,加强学习,提高自身素质.</p>
<p>第四、认真工作,回到原单位岗位上后,要实实在在、踏踏实实地工作,三十六行,行行出状元,争取在本岗位上做出一定的成绩.</p>
<p>第五、再接再厉,成为软件工程师或网络工程师一直是我的梦想,以后如果有机会我仍然后再次参加竞争.</p>


<p><b><details><summary>13、如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？</summary></details></b></p>
<p>回答提示：我首先不会找那位上级领导说明这件事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他；2.他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。</p>


<p><b><details><summary>14、谈谈你对跳槽的看法？</summary></details></b></p>
<p>回答提示：（1）正常的”跳槽”能促进人才合理流动，应该支持；<br>（2）频繁的跳槽对单位和个人双方都不利，应该反对。</p>


<p><b><details><summary>15、工作中你难以和同事、上司相处，你该怎么办？</summary></details></b></p>
<p>回答提示：<br>① 我会服从领导的指挥，配合同事的工作。<br>② 我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好。如果是这样的话 我会努力改正。<br>③ 如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足。有问题就及时改正。<br>④ 作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的！</p>


<p><b><details><summary>16、假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？</summary></details></b></p>


<p>回答提示：<br>① 成绩比较突出，得到领导的肯定是件好事情，以后更加努力<br>② 检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。<br>③ 工作中，切勿伤害别人的自尊心<br>④ 不再领导前拨弄是非<br>⑤ 乐于助人对面</p>


<p><b><details><summary>17、你最近是否参加了培训课程？谈谈培训课程的内容。是公司资助还是自费参加？</summary></details></b></p>
<p>回答提示：请自行根据自己情况做回答，这个没有统一标准参考答案。</p>


<p><b><details><summary>18、你对于我们公司了解多少？</summary></details></b></p>
<p>回答提示：在去公司面试前上网查一下该公司主营业务。</p>


<p><b><details><summary>19、请说出你选择这份工作的动机？你为什么选择我们公司？</summary></details></b></p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.面试前，对应聘公司各方面，要了解详尽！至少要了解到行业、企业、岗位这三方面！最好要准备一些具体的数据和实例！</span><br><span class="line">2.面试时候，可以将之前对公司的了解（行业、企业、数据、实例）结合自己的面试岗位，大略的说一遍，然后强调自己“觉得这个工作合适”即可。</span><br><span class="line">3.如果对这个行业确实很喜欢，要说出你对这个行业的认识与热爱。</span><br></pre></td></tr></table></figure>





<p><b><details><summary>20、你最擅长的技术方向是什么？</summary></details></b></p>
<p>回答提示：说和你要应聘的职位相关的技术，表现一下自己的热诚没有什么坏处。</p>


<p><b><details><summary>21、你能为我们公司带来什么呢？</summary></details></b></p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">① 假如你可以的话，试着告诉他们你可以减低他们的费用——“我已经接受过专业的培训或者工作 X 年，立刻就可以上岗工作”。</span><br><span class="line">② 企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。”等等。</span><br></pre></td></tr></table></figure>





<p><b><details><summary>22、最能概括你自己的三个词是什么？</summary></details></b></p>
<p>回答提示：我经常用的三个词是适应能力强，有责任心和做事有始终，结合具体例子向主考官解释。</p>


<p><b><details><summary>23、你的业余爱好是什么？</summary></details></b></p>
<p>回答提示：找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作。</p>


<p><b><details><summary>24、作为被面试者给我打一下分</summary></details></b></p>
<p>回答提示：试着列出四个优点和一个非常非常非常小的缺点，（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。</p>


<p><b><details><summary>25、你怎么理解你应聘的职位？</summary></details></b></p>
<p>回答提示：把岗位职责和任务及工作态度阐述一下</p>


<p><b><details><summary>26、喜欢这份工作的哪一点？</summary></details></b></p>
<p>回答提示：相信其实大家心中一定都有参考答案了吧！每个人的价值观不同，自然评断的标准也会不同，但是，在回答面试官这个问题时可不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的参考答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。</p>


<p><b><details><summary>27、为什么要离职?您在前一家公司的离职原因是什么?</summary></details></b></p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">① 回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言，都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象；建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的参考答案最好是积极正面的。</span><br><span class="line">② 我希望能获得一份更好的工作，如果机会来临，我会抓住；我觉得目前的工作，已经达到顶峰，即沒有升迁机会。</span><br><span class="line">③ 最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”在此家招聘单位里不存在；</span><br><span class="line">④ 避免把“离职原因”说得太详细、太具体；</span><br><span class="line">⑤ 不能掺杂主观的负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥我们某某的员工”等；但也不能躲闪、回避，如“想换换环境”、“个人原因”等；</span><br><span class="line">⑥ 不能涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等；尽量使解释的理由为应聘者个人形象添彩；</span><br></pre></td></tr></table></figure>

<p>回答样本：如“我离职是因为这家公司倒闭；我在公司工作了三年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只有一个参考答案，而同一个参考答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。</p>
<p>分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能准假，所以辞职。这个参考答案一般面试官还能接受。</p>


<p><b><details><summary>28、说说你对行业、技术发展趋势的看法？</summary></details></b></p>
<p>回答提示：企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。</p>


<p><b><details><summary>29、对工作的期望与目标何在？</summary></details></b></p>
<p>回答提示：这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的参考答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。</p>


<p><b><details><summary>30、说说你的家庭。</summary></details></b></p>
<p>回答提示：企业面试时询问家庭问题不是非要知道求职者家庭的情况，探究隐私，企业不喜欢探究个人隐私，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。企业最喜欢听到的是：我很爱我的家庭！我的家庭一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。企业相信，和睦的家庭关系对一个人的成长有潜移默化的影响。</p>


<p><b><details><summary>31、就你申请的这个职位，你认为你还欠缺什么？</summary></details></b></p>
<p>回答提示：企业喜欢问求职者弱点，但精明的求职者一般不直接回答。他们希望看到这样的求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地躲过难题的求职者。</p>


<p><b><details><summary>32、你欣赏哪种性格的人？</summary></details></b></p>
<p>回答提示：诚实、不死板而且容易相处的人、有”实际行动”的人。</p>


<p><b><details><summary>33、你通常如何处理別人的批评？</summary></details></b></p>
<p>回答提示：① 沈默是金。不必说什么，否则情况更糟，不过我会接受建设性的批评；② 我会等大家冷靜下来再讨论。</p>


<p><b><details><summary>34、你怎样对待自己的失敗？</summary></details></b></p>
<p>回答提示：我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。</p>


<p><b><details><summary>35、什么会让你有成就感？</summary></details></b></p>
<p>回答提示：为贵公司竭力效劳；尽我所能，完成一个项目</p>


<p><b><details><summary>36、眼下你生活中最重要的是什么？</summary></details></b></p>
<p>回答提示：对我来说，能在这个领域找到工作是最重要的；望能在贵公司任职对我说最重要。</p>


<p><b><details><summary>37、你为什么愿意到我们公司来工作？</summary></details></b></p>
<p>回答提示：对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”，“我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。”“你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”或者“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。</p>


<p><b><details><summary>38、你和别人发生过争执吗？你是怎样解决的？</summary></details></b></p>
<p>回答提示：这是面试中最险恶的问题。其实是考官布下的一个陷阱。千万不要说任何人的过错。应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的一个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确参考答案。</p>


<p><b><details><summary>39、问题：你做过的哪件事最令自己感到骄傲?</summary></details></b></p>
<p>回答提示：这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去午餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。</p>


<p><b><details><summary>40、你新到一个部门,一天一个客户来找你解决问题,你努力想让他满意，可是始终达不到群众得满意,他投诉你们部门工作效率低,你这个时候怎么作?</summary></details></b></p>
<p>回答提示：</p>
<p>(1)首先，我会保持冷静。作为一名工作人员，在工作中遇到各种各样的问题是正常的，关键是如何认识它，积极应对，妥善处理。</p>
<p>(2)其次，我会反思一下客户不满意的原因。一是看是否是自己在解决问题上的确有考虑的不周到的地方，二是看是否是客户不太了解相关的服务规定而提出超出规定的要求，三是看是否是客户了解相关的规定，但是提出的要求不合理。</p>
<p>(3)再次，根据原因采取相对的对策。如果是自己确有不周到的地方，按照服务规定作出合理的安排，并向客户作出解释；如果是客户不太了解政策规定而造成的误解，我会向他作出进一步的解释，消除他的误会；如果是客户提出的要求不符合政策规定，我会明确地向他指出。</p>
<p>(4)再次，我会把整个事情的处理情况向领导作出说明，希望得到他的理解和支持。</p>
<p>(5)我不会因为客户投诉了我而丧失工作的热情和积极性，而会一如既往地牢记为客户服务的宗旨，争取早日做一名领导信任、公司放心、客户满意的职员。</p>


<p><b><details><summary>41、对这项工作，你有哪些可预见的困难？</summary></details></b></p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">① 不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行；</span><br><span class="line">② 可以尝试迂回战术，说出应聘者对困难所持有的态度——“工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。”</span><br></pre></td></tr></table></figure>

<p>分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节。但常规思路中的回答，又被面试官“骗”了。当面试官询问这个问题的时候，有两个目的。</p>
<p>第一，看看应聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。</p>
<p>第二，是想看一下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难的态度。</p>


<p><b><details><summary>42、如果我录用你，你将怎样开展工作？</summary></details></b></p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">① 如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法；</span><br><span class="line">② 可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。”</span><br></pre></td></tr></table></figure>

<p>分析：这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性，而且重点想要知道细节。如果向思路中所讲的迂回战术，面试官会认为回避问题，如果引导了几次仍然是回避的话。此人绝对不会录用了。</p>


<p><b><details><summary>43、你希望与什么样的上级共事？</summary></details></b></p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">① 通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会；</span><br><span class="line">② 最好回避对上级具体的希望，多谈对自己的要求；</span><br><span class="line">③ 如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了</span><br></pre></td></tr></table></figure>

<p>分析：这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏。</p>


<p><b><details><summary>44、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？</summary></details></b></p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">①.原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法；</span><br><span class="line">② 如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作；</span><br><span class="line">③.还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见；如领导仍固执己见，我会毫不犹豫地再向上级领导反映。</span><br></pre></td></tr></table></figure>





<p><b><details><summary>45、与上级意见不一是，你将怎么办？</summary></details></b></p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">① 一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”</span><br><span class="line">② 如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。”</span><br></pre></td></tr></table></figure>

<p>分析：这个问题的标准参考答案是思路 1，如果用 2 的回答，必死无疑。你没有摸清楚改公司的内部情况，先想打小报告，这样的人没有人敢要。</p>


<p><b><details><summary>46、你工作经验欠缺，如何能胜任这项工作？</summary></details></b></p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">① 如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎“经验”，关键看应聘者怎样回答；</span><br><span class="line">② 对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业；</span><br><span class="line">③ 如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。”</span><br></pre></td></tr></table></figure>

<p>点评：这个问题思路中的参考答案尚可。突出自己的吃苦能力和适应性以及学习能力（不是学习成绩）为好。</p>


<p><b><details><summary>47、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？</summary></details></b></p>
<p>回答提示：每个公司都在不断变化发展的过程中；你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。此外，他们遇到矛盾和问题时，也能泰然处之。下面的问题能够考核应聘者这方面的能力。<br>据说有人能从容避免正面冲突。请讲一下你在这方面的经验和技巧。<br>有些时候，我们得和我们不喜欢的人在一起共事。说说你曾经克服了性格方面的冲突而取得预期工作效果的经历。</p>


<p><b><details><summary>48、项目中遇到困难，你怎么办？怎么回答</summary></details></b></p>
<p>回答提示：自己能搞定的，就自己上网找资料；但如果比如在 2 个小时之内还没有头绪，就考虑问公司技术水平比较高的同事之类的，然后还要及时和项目经理沟通</p>
<p>那不浪费了 2 个小时时间 业务问题的话，谁清楚就问谁啊……即时沟通能够大大提高工作效率。</p>
<p>技术问题查资料，需求问题重新分析</p>
<p>还是写程序的时候有技术难点、技术难点又分普遍的技术难点、还是你个人不会做、</p>
<p>第一种这个要找项目负责人商量、甚至要找产品&#x2F;运行或其他甲方沟通、</p>
<p>第二种普遍技术难点的话、参考资料或者和项目负责人商量看看怎么办、</p>
<p>第三种的话、先自己查资料试着解决、不行就找人其他资讯、、</p>


<p><b><details><summary>49、对前端界面工程师这个职位是怎么样理解的？</summary></details></b></p>
<p>回答提示：</p>
<p>a. 前端是最贴近用户的程序员，前端的能力就是能让产品从 90 分进化到 100 分，甚至更好</p>
<p>b. 参与项目，快速高质量完成实现效果图，精确到 1px；</p>
<p>c. 与团队成员，UI 设计，产品经理的沟通；</p>
<p>d. 做好的页面结构，页面重构和用户体验；</p>
<p>e. 处理 hack，兼容、写出优美的代码格式；</p>
<p>f. 针对服务器的优化、拥抱最新前端技术。</p>


<p><b><details><summary>50、你在现在的团队处于什么样的角色，起到了什么明显的作用？</summary></details></b></p>
<p>回答提示：请自行根据自己情况做回答，这个没有统一标准参考答案。</p>


<p><b><details><summary>51、最近在学什么？能谈谈你未来 3，5 年给自己的规划吗？</summary></details></b></p>
<p>面试时，经常会被面试官问到关于职业规划的问题，比如：你准备在我们公司做多久？你未来几年的职业规划是什么？等等。还没有进入公司，对公司工作环境还不太了解就被面试官问到这些问题，该怎么答才能合情有合理呢？</p>
<p>问：你准备在我们这家单位做多久？</p>
<p>答：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 这不是自己单方面决定的，还要看公司，但是可以肯定的是，如果公司跟自己的职业发展一致，我是会一直干下去的。</span><br><span class="line">2．以我对公司和现有职位的了解，如果能应聘上的话，目前来看至少可以稳定三年。</span><br></pre></td></tr></table></figure>

<p>问：未来五年的规划是怎样的？</p>
<p>答：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.如果应聘成功，我至少会稳定的做两年，踏实的做好自己的本职工作。</span><br><span class="line">2.在工作中，会向高手请教，研究些新技术，提高自己的技术水平。</span><br><span class="line">3.目前的规划是要优先做一名技术高手，如果有可能的话，做管理也是可以考虑的。</span><br></pre></td></tr></table></figure>

<p>当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。</p>
<p>大部分面试官司都会问你是否有职业规划，这个问题的背后是了解你的求职动机和对自己中长期职业发展的思考。在回答这个问题之前，要对自己有个清晰的认识，知道自己想往哪个方向发展以及未来有什么计划，要给面试官一种积极向上，好学上进，有追求，有规划的感觉，面试官喜欢有规划的求职者。</p>


<p><b><details><summary>52、如何向 HR 介绍你做过的项目</summary></details></b></p>
<p>项目经验与工作经验是相辅相成的，但较之于工作经验，项目经验更侧重于表现求职者在某个专业领域内的技能水平（技能水平决定了工资水平）。因而，技术类岗招聘的时候，更注重项目经验。项目介绍是有套路的，面试时，要将简历中的项目准备好！</p>
<p>回答提示：</p>
<p>我们在跟面试官讲解的时候，讲解项目一定要围绕着以下几个方面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、项目名称</span><br><span class="line">2、开发时间（这里有个注意点：时间不要说的太短，而应该把前期的构思、需求分析、准备工作等时间都可以加进去）；</span><br><span class="line">3、项目描述（做什么的）；</span><br><span class="line">4、项目职责（说清楚自己职责，同时为了提高自己的技术形象，可以将项目说大点）；</span><br><span class="line">5、项目使用的技术（除了说现在使用的技术，还可以说项目进行了压力测试、兼容性处理、数据库的3F、未来还要放mysql集群技术、页面静态化技术、以提升自己在对方心目中的技术形象）；</span><br><span class="line">6、项目的亮点；</span><br><span class="line">7、在自己的项目上可以想一些市面上没有但是自己觉得很有创意的点子。实现不实现都是无所谓了，但是你给面试官的印象会再上一个层次。</span><br><span class="line">8、项目体会（可以说说：多人协作、命名规范、模块划分）；</span><br></pre></td></tr></table></figure>





<p><b><details><summary>53、HR 贬低项目时你该怎么办</summary></details></b></p>
<p>我们在上文讲解了如何向 HR 介绍项目。由于项目反映了技术，技术决定了薪资，所以面试官一般会把打压我们的项目变相打压我们技术，以达到打压我们薪资预期的目的，同时观察我们在打压环境中的表现来决定到底打压薪资到何种程度！所以，当 HR 说：“一个月的时间，四五个人的配合就完成了项目，可见你们项目不大、技术含量不高啊”，各位面试者一定要冷静！来学学在 HR 贬低项目时的应对方法！</p>
<p>回答提示：</p>
<p>HR 说：一个月的时间，四五个人的配合就完成了项目，可见你们项目不大、技术含量不高啊！如何应对，别慌，我们应该按下面的方法答：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.项目实现也许花的时间不多，但是前期的构思、需求分析、页面设计等等准备工作是花了很多时间的。</span><br><span class="line">2.项目大小和技术含量并不能够成正比，我们的项目，虽然小，但麻雀虽小，却五脏俱全。接着向面试官介绍你们团队在项目过程中所使用的技术等等。</span><br><span class="line">3.项目大小主要是体现在功能上，有些功能客户并没有提出。如果后期客户有提出，我们也能够快速的实现。</span><br></pre></td></tr></table></figure>





<p><b><details><summary>54、项目经验少该怎么办</summary></details></b></p>
<p>对于前端来说，技术水平是决定我们工资最重要的因素。技术水平是要通过我们的项目体现出来的，但项目经验少该怎么办？</p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、项目经验是拿高工资最重要的一个指标。这反映了程序员的价值，也是用人单位给出薪资报价最重要的因素。所以面试者一定要重视项目。</span><br><span class="line">2、简历中至少要写出3个项目。</span><br><span class="line">3、项目可以适当包装。可以多说一些比较高端大气上档次的技术。</span><br><span class="line">4、面试官问到简历中的项目细节你要能答上来。否则，就算是你做的，面试官因你答不上来也会认为不是你做的。所以要花时间，搞定写在简历上的项目模块。</span><br><span class="line">5、项目抓亮点来说，可以对照企业的需求，将最有竞争力的点说清楚。这种能够加分的亮点一定要说到。</span><br></pre></td></tr></table></figure>





<p><b><details><summary>55、你学历低，为什么要录用你？</summary></details></b></p>
<p>面试一份工作时，学历有时候是一块敲门砖。对于学历不高的面试者，如果 HR 问：你才高中学历，而现在大学生一大把，我们为什么要录用你？你如果学历真的很低，那该怎么回答呢？</p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、通过自信的表现，有效的沟通，让面试官主动忽略这个问题。或者说是你把你最好的展现出来，让面试官信服，觉得你是合适的人选而不提及或忽略掉这个问题。</span><br><span class="line">2、即使面试官提出来了，勇敢面对主动承认，赞同面试官的提问，确实学历较低，自已已经深刻认识此问题，也因为认识到这个事实，你才更加注重能力的培养，同时自己也在工作之余继续课堂学习，增加扎实的理论知识。同时说出你的学历提升打算，提升计划一定要与你现行的工作职位结合。</span><br><span class="line">3、如果面试官对学历一直抓住不放，或作为必要条件，以退为进吧，委婉表达自己想得到职位的态度，并做好了放弃的心理准备。</span><br></pre></td></tr></table></figure>

<p>总的来说，在面试的时候，表现出自信，从谈吐和沟通上，给面试官好印象。如果问到你学历的时候，表现出“学历不代表能力”的自信来就好，一般的企业不会把这个当做决定性因素，还是看综合素质。</p>


<p><b><details><summary>56、你是不是年龄太大了？</summary></details></b></p>
<p>都说 IT 行业是个吃青春饭的行业，你现在已经接近 30 岁了，你是不是年龄太大了？这个问题应该被问到的不多，但是万一真的被问到这个问题，你该如何作答呢？</p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、 能不能做事才是大问题。而不是年龄。是不是有能力，试用期间可以检验。</span><br><span class="line">2、 要表现出自己很喜欢这份工作，要长久的做下去（年龄大的人，工作经历多，接触的东西多，才能够在众多的经历中明确知道自己未来到底要走什么路）。要突出自己年龄大的优势，比如思想更成熟，眼界更开阔等等。</span><br></pre></td></tr></table></figure>





<p><b><details><summary>57、你太小了，你能承担项目吗？</summary></details></b></p>
<p>虽说 IT 行业是个吃青春饭的行业，但是你年纪太小了，让人感觉不踏实。虽然我们最重要拼的是技术，但真的被问到这个问题，你该如何作答呢？</p>
<p>回答提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、虽然我年纪小，但是我技术是没有问题的，也是有担当的。试用期间可以检验。</span><br><span class="line">2、对于前端，我做过很多的项目，也有系统的学习过。并不比年纪大的人差。</span><br><span class="line">3、正因为我年纪小，我对于工作有十足的干劲，我很想在这行好好的发展，也能承受比较强的工作压力。</span><br></pre></td></tr></table></figure>





<p><b><details><summary>58、你对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</summary></details></b></p>
<p>回答提示：<br>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。</p>
<ul>
<li>1、实现界面交互</li>
<li>2、提升用户体验</li>
<li>3、有了 Node.js，前端可以实现服务端的一些事情</li>
</ul>
<ul>
<li>前端是最贴近用户的程序员，前端的能力就是能让产品从 90 分进化到 100 分，甚至更好，</li>
<li>参与项目，快速高质量完成实现效果图，精确到 1px；</li>
<li>与团队成员，UI 设计，产品经理的沟通；</li>
<li>做好的页面结构，页面重构和用户体验；</li>
<li>处理 hack，兼容、写出优美的代码格式；</li>
<li>针对服务器的优化、拥抱最新前端技术。</li>
</ul>
<p>其它相关的加分项：</p>
<ol>
<li>都使用和了解过哪些编辑器?都使用和了解过哪些日常工具?</li>
<li>都知道有哪些浏览器内核?开发过的项目都兼容哪些浏览器?</li>
<li>瀑布流布局或者流式布局是否有了解</li>
<li>HTML5 都有哪些新的 API?</li>
<li>都用过什么代码调试工具?</li>
<li>是否有接触过或者了解过重构。</li>
<li>你遇到过比较难的技术问题是？你是如何解决的？</li>
</ol>


<p><b><details><summary>59.现如今面对如层出不穷的类库，说说你的感受</summary></details></b></p>
<p>参考答案：百花齐放，百家争鸣的感觉。<br>说明社区活跃，这一片欣欣尚荣的风景，蛮好！</p>





<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></h6></h6>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ezharjan.github.io/Blog/2022/03/05/%E6%8A%80%E8%83%BD%E9%9D%A2%E8%AF%95%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Alexander Ezharjan">
      <meta itemprop="description" content="This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2022/03/05/%E6%8A%80%E8%83%BD%E9%9D%A2%E8%AF%95%E8%80%83%E5%89%8D%E5%86%B2%E5%88%BA/" class="post-title-link" itemprop="url">技能面试考前冲刺</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-05 22:53:32" itemprop="dateCreated datePublished" datetime="2022-03-05T22:53:32+08:00">2022-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-17 10:34:44" itemprop="dateModified" datetime="2022-10-17T10:34:44+08:00">2022-10-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Job-Interview/" itemprop="url" rel="index"><span itemprop="name">Job Interview</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h6 align="center">编者：艾孜尔江<h6>


<hr>
<h1 id="一、编程之美"><a href="#一、编程之美" class="headerlink" title="一、编程之美"></a>一、编程之美</h1><h2 id="1-2-中国象棋将帅问题"><a href="#1-2-中国象棋将帅问题" class="headerlink" title="1.2 中国象棋将帅问题"></a>1.2 中国象棋将帅问题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b:<span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i.a = <span class="number">1</span>; i.a &lt;= <span class="number">9</span>; i.a++)</span><br><span class="line">    <span class="keyword">for</span> (i.b = <span class="number">1</span>; i.b &lt;= <span class="number">9</span>; i.b++)</span><br><span class="line">        <span class="keyword">if</span> (i.a % <span class="number">3</span> != i.b % <span class="number">3</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%u:%u&quot;</span>, i.a, i.b);</span><br></pre></td></tr></table></figure>

<h2 id="1-14-连连看"><a href="#1-14-连连看" class="headerlink" title="1.14 连连看"></a>1.14 连连看</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Grid* preClick = <span class="literal">NULL</span>, * curClick = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// listen user event</span></span><br><span class="line">    <span class="keyword">if</span> (点击格子 xy 非空) &#123;</span><br><span class="line">        preClick = curClick;</span><br><span class="line">        curClick.pos = x, y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preClick &amp;&amp; curClick &amp;&amp; findPath(preClick, curClick)) &#123;</span><br><span class="line">        显示路径</span><br><span class="line">        消去</span><br><span class="line">        preClick = curClick = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-2-6-LeetCode"><a href="#2-1-2-6-LeetCode" class="headerlink" title="2.1 - 2.6 LeetCode"></a>2.1 - 2.6 LeetCode</h2><h2 id="2-7-最大公约数"><a href="#2-7-最大公约数" class="headerlink" title="2.7 最大公约数"></a>2.7 最大公约数</h2><p>辗转相除法，如果一个数能够整除x,y，那么他也能够整除x,x%y。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> gcd(y, x % y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// iterative</span><br><span class="line">int gcd(int x, int y) &#123;</span><br><span class="line">    while (y) &#123;</span><br><span class="line">        int t = x;</span><br><span class="line">        x = y</span><br><span class="line">        y = t % y;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">取模运算开销较大，但如下方法在y比较小时，求解次数过多，容易溢出</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">int gcd(int x, int y) &#123;</span><br><span class="line">    if (x &lt; y)</span><br><span class="line">        return gcd(y, x);</span><br><span class="line">    if (y == 0)</span><br><span class="line">        return x;</span><br><span class="line">    return gcd(x - y, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">        <span class="keyword">return</span> gcd(y, x);</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">0x1</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">0x1</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> gcd(x&gt;&gt;<span class="number">1</span>, y&gt;&gt;<span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> gcd(x &gt;&gt;<span class="number">1</span>, y);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">0x1</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> gcd(x, y&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> gcd(y, x-y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="2-8-看下讲解"><a href="#2-8-看下讲解" class="headerlink" title="2.8 看下讲解"></a>2.8 看下讲解</h2><h2 id="2-9-斐波那契数列"><a href="#2-9-斐波那契数列" class="headerlink" title="2.9 斐波那契数列"></a>2.9 斐波那契数列</h2><p>使用动态规划(Memoization)的算法不在赘述O(n)。</p>
<p>O(logn)的解法</p>
<p>通项公式</p>
<pre><code>f(n), f(n-1) = (f(n-1), f(n-2)) * A

A = |1  1|
    |1  0| 

f(n), f(n-1) = (f(n-1), f(n-2)) * A = ... = (f1, f0) * A^(n-1)
</code></pre>
<p>下面我们计算<code>A^n-1</code>，太简单了，使用<code>A^(2n) = A^n * A^n</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// pesudo code</span><br><span class="line">int fib(int n) &#123;</span><br><span class="line">    Matrix factor = matrixPow(A, n-1);</span><br><span class="line">    return f1*factor + f0*factor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Matrix matrixPow(Matrix m, int n) &#123;</span><br><span class="line">    Matrix result = Matrix::Identity;</span><br><span class="line">    while (n) &#123;</span><br><span class="line">        if (n &amp; 1)</span><br><span class="line">            result *= m;</span><br><span class="line">        m *= m;</span><br><span class="line">        n &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展问题，如果是前三项相加的数列呢，依然可以求出转移矩阵</p>
<h2 id="2-11-最近点对问题"><a href="#2-11-最近点对问题" class="headerlink" title="2.11 最近点对问题"></a>2.11 最近点对问题</h2><h2 id="2-12-2-14-LeetCode-2-15-Cracking-2-16-2-17-LeetCode"><a href="#2-12-2-14-LeetCode-2-15-Cracking-2-16-2-17-LeetCode" class="headerlink" title="2.12-2.14 LeetCode 2.15 Cracking 2.16 2.17 LeetCode"></a>2.12-2.14 LeetCode 2.15 Cracking 2.16 2.17 LeetCode</h2><h2 id="2-18-数组分割"><a href="#2-18-数组分割" class="headerlink" title="2.18 数组分割"></a>2.18 数组分割</h2><h2 id="2-19-LeetCode"><a href="#2-19-LeetCode" class="headerlink" title="2.19 LeetCode"></a>2.19 LeetCode</h2><h2 id="3-1-有时间可以尝试写一下"><a href="#3-1-有时间可以尝试写一下" class="headerlink" title="3.1 有时间可以尝试写一下"></a>3.1 有时间可以尝试写一下</h2><h2 id="3-2-电话号码对应英文单词"><a href="#3-2-电话号码对应英文单词" class="headerlink" title="3.2 电话号码对应英文单词"></a>3.2 电话号码对应英文单词</h2><p>递归写法</p>
<h2 id="3-3-Edit-Distance"><a href="#3-3-Edit-Distance" class="headerlink" title="3.3 Edit Distance"></a>3.3 Edit Distance</h2><h2 id="3-4-删除链表节点"><a href="#3-4-删除链表节点" class="headerlink" title="3.4 删除链表节点"></a>3.4 删除链表节点</h2><h2 id="3-5-最短摘要的生成"><a href="#3-5-最短摘要的生成" class="headerlink" title="3.5 最短摘要的生成"></a>3.5 最短摘要的生成</h2><p>问题转化为，在一个单词词组中，找出包含所有给定单词的最短区间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">abstract</span><span class="params">(vector&lt;string&gt; article, unordered_set&lt;string&gt; keywords)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, range = INT_MAX;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; indecies;</span><br><span class="line">    unordered_set&lt;string&gt; having;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">while</span> (end &lt; article.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; article.<span class="built_in">size</span>() &amp;&amp; !<span class="built_in">isContain</span>(keywords, having)) &#123;</span><br><span class="line">            indecies[articel[end]] = end;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isContain</span>(keywords, having)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end - start + <span class="number">1</span> &lt; range) &#123;</span><br><span class="line">                range = end - start + <span class="number">1</span>;</span><br><span class="line">                result.first = start;</span><br><span class="line">                result.second = end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (indecies[aritcle[start]] == start)</span><br><span class="line">                having.erase[article[start]];</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-判断两个链表是否相交"><a href="#3-6-判断两个链表是否相交" class="headerlink" title="3.6 判断两个链表是否相交"></a>3.6 判断两个链表是否相交</h2><p>如果链表中有环呢？</p>
<h2 id="3-7-队列中取最大值"><a href="#3-7-队列中取最大值" class="headerlink" title="3.7 队列中取最大值"></a>3.7 队列中取最大值</h2><p>使用连个minstack模拟队列</p>
<h2 id="3-8-二叉树中两个节点之间的最远距离"><a href="#3-8-二叉树中两个节点之间的最远距离" class="headerlink" title="3.8 二叉树中两个节点之间的最远距离"></a>3.8 二叉树中两个节点之间的最远距离</h2><p>显然，对一个根节点，最远距离有两种情况：</p>
<ol>
<li>左子树或者右子树中的最远距离</li>
<li>左子树最长路径＋有子树最长路径+1</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> max_distance;</span><br><span class="line">    <span class="type">int</span> max_depth;</span><br><span class="line">&#125; <span class="type">result_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get max distance of two nodes in a tree</span></span><br><span class="line"><span class="type">result_t</span> <span class="title function_">get_max</span><span class="params">(<span class="type">tree_node_t</span>* root)</span> &#123;</span><br><span class="line">    <span class="type">result_t</span> result;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        result.max_distance = <span class="number">0</span>;</span><br><span class="line">        result.max_depth = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">result_t</span> left = get_max(root-&gt;left);</span><br><span class="line">    <span class="type">result_t</span> right = get_max(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    result.max_depth = max(left.max_depth, right.max_depth) + <span class="number">1</span>;</span><br><span class="line">    result.max_distance = max(max(left.max_distance, right.max_distance), left.max_depth + right.max_depth + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于递归问题，书上的心得：</p>
<ol>
<li>在递归的实现中，往往假设后续的调用已经完成，在此基础上，才能实现递归的逻辑。</li>
<li>分析清楚递归体的逻辑。</li>
<li>考虑清楚递归退出的边界条件，也就是return的地方。</li>
</ol>
<h2 id="3-9-重建二叉树"><a href="#3-9-重建二叉树" class="headerlink" title="3.9 重建二叉树"></a>3.9 重建二叉树</h2><p>拓展问题，如何判断前序遍历和中序遍历是合理的？</p>
<p>测试用例：<br>非完全二叉树，退化的二叉树，满二叉树，普通二叉树，空树。。。</p>
<h2 id="3-10-层序遍历"><a href="#3-10-层序遍历" class="headerlink" title="3.10 层序遍历"></a>3.10 层序遍历</h2><p>注意把LeetCode上的ZigZag层序都看一遍。</p>
<p>递归的遍历需要先计算level</p>
<h2 id="3-11-注意问题"><a href="#3-11-注意问题" class="headerlink" title="3.11 注意问题"></a>3.11 注意问题</h2><p>对于询问知识点，要答得<em>正确</em>，<em>有条理</em>。最后写出来的程序已定要是<em>没有严重错误</em>，<em>完整</em>，并尝试用一些测试用例。</p>
<h2 id="4-1-金刚"><a href="#4-1-金刚" class="headerlink" title="4.1 金刚"></a>4.1 金刚</h2><p>询问李博士</p>
<h2 id="4-2-瓷砖覆盖地板"><a href="#4-2-瓷砖覆盖地板" class="headerlink" title="4.2 瓷砖覆盖地板"></a>4.2 瓷砖覆盖地板</h2><p>斐波那契额数列</p>
<p>1x2覆盖8x8？从小到大，先找出2x2有多少种，再找出4x4有多少种，再找出8x8有多少种。还有考虑好多种，注意不要有重复<br>pxq覆盖mxn？</p>
<h2 id="4-3-Catalan数"><a href="#4-3-Catalan数" class="headerlink" title="4.3  Catalan数"></a>4.3  Catalan数</h2><h2 id="4-4-点是否在三角形内部"><a href="#4-4-点是否在三角形内部" class="headerlink" title="4.4 点是否在三角形内部"></a>4.4 点是否在三角形内部</h2><p>给定 ABC，逆时针顺序，判断 D 是否在 ABC 内部</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 利用面积，如果 D 和 ABC 分别构成的三角形的面积小于 ABC 的面积，那么 D 在三角形内部</span><br><span class="line">double area(Point A, Point B, Point, C) &#123;</span><br><span class="line">    double a, b, c;</span><br><span class="line">    b = distance(A, C);</span><br><span class="line">    a = distance(B, C);</span><br><span class="line">    c = distance(A, B);</span><br><span class="line"></span><br><span class="line">    double p = (a + b + c) / 2;</span><br><span class="line">    return sqrt((p-a) * (p-b) * (p-c) * p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isInTriangle(A, B, C, D) &#123;</span><br><span class="line">    return area(A, B, D) + area(A, C, D) + area(B, C, D) &lt;= area(A, B, C);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 根据角度考虑，如果两个向量叉积为正，那么 P3 在P1P2的左边，如果一个点同时在 AB，BC，CA 的左边</span><br><span class="line">double cross(Point A, Point B, Point X) &#123;</span><br><span class="line">    return (B.x - A.x) * (X.y - A.y) - (X.x - A.x) * (B.y - A.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isInTriangle(A, B, C, D) &#123;</span><br><span class="line">    return cross(A, B, D) &gt;= 0 &amp;&amp; cross(B, C, D) &gt;= 0 &amp;&amp; cross(C, A, D) &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-磁带文件存储优化"><a href="#4-5-磁带文件存储优化" class="headerlink" title="4.5 磁带文件存储优化"></a>4.5 磁带文件存储优化</h2><p>只考虑长度，按照文件长度由短到长存放。<br>只考虑访问频率，按照访问频率由高到低存放。<br>综合考虑，按照频率&#x2F;长度由高到低</p>
<h2 id="4-6-桶中取黑白球"><a href="#4-6-桶中取黑白球" class="headerlink" title="4.6 桶中取黑白球"></a>4.6 桶中取黑白球</h2><p>相当于使用 XOR，可以解任意问题</p>
<h2 id="4-7-蚂蚁爬杆"><a href="#4-7-蚂蚁爬杆" class="headerlink" title="4.7 蚂蚁爬杆"></a>4.7 蚂蚁爬杆</h2><p>相当于穿越</p>
<h2 id="4-8-三角形测试用例"><a href="#4-8-三角形测试用例" class="headerlink" title="4.8 三角形测试用例"></a>4.8 三角形测试用例</h2><p><code>int isTriangle(int a, int b, int c);</code></p>
<ol>
<li>用一个字节编码各种情况。</li>
</ol>
<p>用不同的位表示不同的结果，注意要正交</p>
<ol start="2">
<li><p>测试用例</p>
<ol>
<li><p>合法输入，各种三角形的形状，以及不是三角形的，还需要考虑交换不同边的顺序；</p>
</li>
<li><p>非法输入，负数，0，类型错误等等；</p>
</li>
<li><p>边界值，一般程序可能在<code>&lt; &lt;= &gt; &gt;=</code>上犯错误；</p>
</li>
<li><p>很大的数，很小的数，等等。</p>
</li>
</ol>
</li>
</ol>
<p>一般需要给出15-20个用例</p>
<h2 id="4-10-数字哑谜"><a href="#4-10-数字哑谜" class="headerlink" title="4.10 数字哑谜"></a>4.10 数字哑谜</h2><p>列出方程，使用深度优先搜索，注意剪枝</p>
<h2 id="4-11-扫雷游戏的概率"><a href="#4-11-扫雷游戏的概率" class="headerlink" title="4.11 扫雷游戏的概率"></a>4.11 扫雷游戏的概率</h2><br>
<br>
<br>

<h1 id="二、C-x2F-C-基本算法考点"><a href="#二、C-x2F-C-基本算法考点" class="headerlink" title="二、C&#x2F;C++基本算法考点"></a>二、C&#x2F;C++基本算法考点</h1><h2 id="1-1-确定一个字符串中所有数字是否完全不同"><a href="#1-1-确定一个字符串中所有数字是否完全不同" class="headerlink" title="1.1 确定一个字符串中所有数字是否完全不同"></a>1.1 确定一个字符串中所有数字是否完全不同</h2><p>首先应该询问面试官字符集的大小，是ASCII还是Unicode还是GBK，对于ASCII和GBK，<br>因为字符集大小有限，而且都不太大，可以使用一个数组统计，而对于Unicode，<br>显然只能使用Hash统计</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isUniqueChars</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">256</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">charSet</span><span class="params">(<span class="number">256</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">        <span class="keyword">if</span> (charSet[s])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            charSet[c] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：还可以使用位向量提高效率，但是C++的vector<bool>本身就是特质化的。</bool></p>
<h2 id="1-2-实现reverse-char-s"><a href="#1-2-实现reverse-char-s" class="headerlink" title="1.2 实现reverse(char* s)"></a>1.2 实现reverse(char* s)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">char</span>* end = s;</span><br><span class="line">    <span class="keyword">while</span> (*end++) ;</span><br><span class="line">    end--; <span class="comment">// back one</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (s &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> t = *s;</span><br><span class="line">        *s++ = *end;</span><br><span class="line">        *end-- = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-判断两个词是否是变位词-Anagram"><a href="#1-3-判断两个词是否是变位词-Anagram" class="headerlink" title="1.3 判断两个词是否是变位词(Anagram)"></a>1.3 判断两个词是否是变位词(Anagram)</h2><h2 id="1-4-编写一个方法，将字符串中的空格全部替换为-20，假设字符串结尾有足够空间"><a href="#1-4-编写一个方法，将字符串中的空格全部替换为-20，假设字符串结尾有足够空间" class="headerlink" title="1.4 编写一个方法，将字符串中的空格全部替换为%20，假设字符串结尾有足够空间"></a>1.4 编写一个方法，将字符串中的空格全部替换为<code>%20</code>，假设字符串结尾有足够空间</h2><p>对于数组操作的好多题目，尝试从尾部做起一下子就简单多了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">replaceSpaces</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> spaceCount = <span class="number">0</span>, newLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(s[i]))</span><br><span class="line">            newLength++;</span><br><span class="line"></span><br><span class="line">    newLength = len + spaceCount * <span class="number">2</span>;</span><br><span class="line">    s[newLength] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(s[i])) &#123;</span><br><span class="line">            s[--newLength] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            s[--newLength] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            s[--newLength] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s[--newLength] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-压缩字符串-aabcccccaaa-gt-a2b1c5a3如果压缩后变短，返回压缩后的字符串"><a href="#1-5-压缩字符串-aabcccccaaa-gt-a2b1c5a3如果压缩后变短，返回压缩后的字符串" class="headerlink" title="1.5 压缩字符串 aabcccccaaa -&gt; a2b1c5a3如果压缩后变短，返回压缩后的字符串"></a>1.5 压缩字符串 <code>aabcccccaaa -&gt; a2b1c5a3</code>如果压缩后变短，返回压缩后的字符串</h2><p>首先要计算出新的长度，然后比较是否变短，如果变短，则执行压缩，否则返回</p>
<h2 id="1-6-给定一幅由N＊N矩阵表示的图像，顺时针旋转90度"><a href="#1-6-给定一幅由N＊N矩阵表示的图像，顺时针旋转90度" class="headerlink" title="1.6 给定一幅由N＊N矩阵表示的图像，顺时针旋转90度"></a>1.6 给定一幅由N＊N矩阵表示的图像，顺时针旋转90度</h2><h2 id="1-7-若m＊n矩阵中某个元素为0，就把这一行和这一列都清零"><a href="#1-7-若m＊n矩阵中某个元素为0，就把这一行和这一列都清零" class="headerlink" title="1.7 若m＊n矩阵中某个元素为0，就把这一行和这一列都清零"></a>1.7 若m＊n矩阵中某个元素为0，就把这一行和这一列都清零</h2><p>LeetCode 73 注意同样可以使用位向量提高效率</p>
<h2 id="1-8-给定方法isSubstring-，判断s1是不是可以由s2旋转组成"><a href="#1-8-给定方法isSubstring-，判断s1是不是可以由s2旋转组成" class="headerlink" title="1.8 给定方法isSubstring()，判断s1是不是可以由s2旋转组成"></a>1.8 给定方法isSubstring()，判断s1是不是可以由s2旋转组成</h2><p>假设s1 &#x3D; xy, s2 &#x3D; yx，yx一定是xyxy的字串，而且是中间部分。注意先判断长度，提高效率</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isRotation</span><span class="params">(string&amp; s1, string&amp; s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.<span class="built_in">size</span>() != s2.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    string s1s1 = s1 + s1;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isSubstring</span>(s1s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-移除未排序列表中的重复节点"><a href="#2-1-移除未排序列表中的重复节点" class="headerlink" title="2.1 移除未排序列表中的重复节点"></a>2.1 移除未排序列表中的重复节点</h2><p>因为是无序的，所以我们还是需要记录重复节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显然第一个节点是不可能被移除的，所以不用返回新的头部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">    ListNode dummy, *p = dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vals.<span class="built_in">find</span>(p-&gt;next-&gt;val) != vals.<span class="built_in">end</span>())</span><br><span class="line">            ListNode* next = p-&gt;next;</span><br><span class="line">            p-&gt;next = next-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vals.<span class="built_in">insert</span>(p-&gt;next-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不允许使用额外空间，那么这个功能至少需要O(N^2)实现</p>
<h2 id="2-2-实现一个算法，找出链表中倒数第K个元素"><a href="#2-2-实现一个算法，找出链表中倒数第K个元素" class="headerlink" title="2.2 实现一个算法，找出链表中倒数第K个元素"></a>2.2 实现一个算法，找出链表中倒数第K个元素</h2><h2 id="2-3-删除单向链表中的某个节点，假设你只有访问该节点的权限"><a href="#2-3-删除单向链表中的某个节点，假设你只有访问该节点的权限" class="headerlink" title="2.3 删除单向链表中的某个节点，假设你只有访问该节点的权限"></a>2.3 删除单向链表中的某个节点，假设你只有访问该节点的权限</h2><h2 id="2-4-以给定的值x分割列表，使得小于x的元素都排在x的前面"><a href="#2-4-以给定的值x分割列表，使得小于x的元素都排在x的前面" class="headerlink" title="2.4 以给定的值x分割列表，使得小于x的元素都排在x的前面"></a>2.4 以给定的值x分割列表，使得小于x的元素都排在x的前面</h2><p>LeetCode 83</p>
<h2 id="2-5-给定一个链表，每个链表节点存放一位数字，并且是反向存放的，求两个链表的和"><a href="#2-5-给定一个链表，每个链表节点存放一位数字，并且是反向存放的，求两个链表的和" class="headerlink" title="2.5 给定一个链表，每个链表节点存放一位数字，并且是反向存放的，求两个链表的和"></a>2.5 给定一个链表，每个链表节点存放一位数字，并且是反向存放的，求两个链表的和</h2><p>LeetCode 2</p>
<p>如果是正向存放的呢？</p>
<p>先求出两个列表的长度，然后用零填充一个较短的链表，然后在从前往后相加。</p>
<h2 id="2-6-给定一个有环链表，找到环的开头"><a href="#2-6-给定一个有环链表，找到环的开头" class="headerlink" title="2.6 给定一个有环链表，找到环的开头"></a>2.6 给定一个有环链表，找到环的开头</h2><p>LeetCode 141 142</p>
<h2 id="2-7-判断链表是否是回文-Palindrome"><a href="#2-7-判断链表是否是回文-Palindrome" class="headerlink" title="2.7 判断链表是否是回文(Palindrome)"></a>2.7 判断链表是否是回文(Palindrome)</h2><p>LeetCode 234</p>
<h2 id="3-1-如何用一个数组实现3个栈"><a href="#3-1-如何用一个数组实现3个栈" class="headerlink" title="3.1 如何用一个数组实现3个栈"></a>3.1 如何用一个数组实现3个栈</h2><p>如果是实现两个堆栈，可以把两头作为栈底，向中间生长。</p>
<p>解法1: 固定分割，显然这样是不能让面试官满意的。。</p>
<p>解法2: 弹性分割，并把数组看成是环状的！</p>
<h2 id="3-2-设计一个栈，支持min方法，返回栈中的最小值"><a href="#3-2-设计一个栈，支持min方法，返回栈中的最小值" class="headerlink" title="3.2 设计一个栈，支持min方法，返回栈中的最小值"></a>3.2 设计一个栈，支持min方法，返回栈中的最小值</h2><p>LeetCode 155</p>
<h2 id="3-3-实现SetOfStacks，由多个栈组成"><a href="#3-3-实现SetOfStacks，由多个栈组成" class="headerlink" title="3.3 实现SetOfStacks，由多个栈组成"></a>3.3 实现SetOfStacks，由多个栈组成</h2><p>这实际上是一道OOD(面向对象设计)的题目</p>
<h2 id="3-4-汉诺塔"><a href="#3-4-汉诺塔" class="headerlink" title="3.4 汉诺塔"></a>3.4 汉诺塔</h2><p>经典问题了，考虑 n＝2的时候，把上面1块放到中间，然后把下面一块移动完成。那么对于n，我们把n-1块移到中间即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void moveDisks(int n, tower_t origin, tower_t dest, tower_t buffer) &#123;</span><br><span class="line">    if (n &lt;= 0) return;</span><br><span class="line"></span><br><span class="line">    moveDisks(n-1, origin, buffer, dest); // 先把上面的n-1块放到中间</span><br><span class="line">    moveBottom(origin, dest) // 把最底下的盘子直接放过去</span><br><span class="line">    moveDisks(n-1, buffer, dest, origin) // 把中间的再放到最后</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-使用两个栈模拟一个队列"><a href="#3-5-使用两个栈模拟一个队列" class="headerlink" title="3.5 使用两个栈模拟一个队列"></a>3.5 使用两个栈模拟一个队列</h2><h2 id="3-6-对栈进行排序，额外的数据只能使用栈"><a href="#3-6-对栈进行排序，额外的数据只能使用栈" class="headerlink" title="3.6 对栈进行排序，额外的数据只能使用栈"></a>3.6 对栈进行排序，额外的数据只能使用栈</h2><p>使用简单插入排序，在一个新的栈中保存排序好的数据，从unsorted中弹出以后，不断弹出sorted为新元素找到正确位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; <span class="title function_">sortStack</span><span class="params">(<span class="type">const</span> <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;&amp; unsorted)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; sorted;</span><br><span class="line">    <span class="keyword">while</span> (!unsorted.empty()) &#123;</span><br><span class="line">        <span class="type">int</span> temp = unsorted.top(); <span class="comment">// 待插入的新元素</span></span><br><span class="line">        unsorted.pop();</span><br><span class="line">        <span class="keyword">while</span> (!sorted.empty() &amp;&amp; sorted.top() &gt; temp) &#123; <span class="comment">// 不断弹出，找到合适位置</span></span><br><span class="line">            <span class="type">int</span> big = sorted.top(); sorted.pop();</span><br><span class="line">            unsorted.push(big);</span><br><span class="line">        &#125;</span><br><span class="line">        sorted.push(temp); <span class="comment">// 插入新元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sorted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="4-1-检查二叉树是否平衡-任意两个节点之间的高度差不超过1"><a href="#4-1-检查二叉树是否平衡-任意两个节点之间的高度差不超过1" class="headerlink" title="4.1 检查二叉树是否平衡: 任意两个节点之间的高度差不超过1"></a>4.1 检查二叉树是否平衡: 任意两个节点之间的高度差不超过1</h2><h2 id="4-2-给定一个有向图，找出两个节点之间是否存在一条路径"><a href="#4-2-给定一个有向图，找出两个节点之间是否存在一条路径" class="headerlink" title="4.2 给定一个有向图，找出两个节点之间是否存在一条路径"></a>4.2 给定一个有向图，找出两个节点之间是否存在一条路径</h2><blockquote>
<p>碰到这类问题，有必要和面试官探讨一下DFS和BFS之间的利弊，例如，DFS实现起来比较简单，只需要简单的递归即可。BFS适合用来查找最短路径。<br>而DFS在访问临近借点之前可能会深度便利其中一个临近节点</p>
</blockquote>
<p>🌲的遍历一定要注意visited数组或者集合，因为树中可能有几个节点指向同一个节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(Graph* graph, Node* start, Node* end)</span> </span>&#123;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    unordered_set&lt;Node*&gt; visited;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> node = q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> adj : q.<span class="built_in">adjs</span>())</span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">find</span>(adj) == visited.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">if</span> (adj == end)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    q.<span class="built_in">push</span>(adj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-给定一个有序数组，元素各不相同且按升序排列，创建一颗高度最小的二叉查找树"><a href="#4-3-给定一个有序数组，元素各不相同且按升序排列，创建一颗高度最小的二叉查找树" class="headerlink" title="4.3 给定一个有序数组，元素各不相同且按升序排列，创建一颗高度最小的二叉查找树"></a>4.3 给定一个有序数组，元素各不相同且按升序排列，创建一颗高度最小的二叉查找树</h2><p>LeetCode 108</p>
<h2 id="4-4-给定一棵二叉树，创建层序访问的链表"><a href="#4-4-给定一棵二叉树，创建层序访问的链表" class="headerlink" title="4.4 给定一棵二叉树，创建层序访问的链表"></a>4.4 给定一棵二叉树，创建层序访问的链表</h2><p>LeetCode 102</p>
<h2 id="4-5-检查一棵二叉树是否为二叉查找树"><a href="#4-5-检查一棵二叉树是否为二叉查找树" class="headerlink" title="4.5 检查一棵二叉树是否为二叉查找树"></a>4.5 检查一棵二叉树是否为二叉查找树</h2><p>LeetCode 98</p>
<h2 id="4-6-找到二叉查找树指定节点的下一个节点-中序后继-，假设每个节点都有指向父节点的指针"><a href="#4-6-找到二叉查找树指定节点的下一个节点-中序后继-，假设每个节点都有指向父节点的指针" class="headerlink" title="4.6 找到二叉查找树指定节点的下一个节点(中序后继)，假设每个节点都有指向父节点的指针"></a>4.6 找到二叉查找树指定节点的下一个节点(中序后继)，假设每个节点都有指向父节点的指针</h2><p>按照中序遍历，左子树，当前节点，右子树，显然下一个节点应该在右边。也就是右子树中最左边的节点。<br>考虑没有右子树的情况，如果当前节点是左子节点，下一个节点应该是父节点。如果是右节点，我们继续向上，如果到达了root，显然没有更多节点了。</p>
<p>对于树这种可以分情况的最好先把各种情况想好了，在写代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">inorderSucc</span><span class="params">(TreeNode* n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (n-&gt;right) &#123;</span><br><span class="line">        TreeNode* right = n-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (right-&gt;left)</span><br><span class="line">            right = right-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode* q = n, * parent = q.parent;</span><br><span class="line">        <span class="keyword">while</span> (parent &amp;&amp; parent-&gt;left != q) &#123; <span class="comment">// 找到当前节点可以作为左子节点的父节点</span></span><br><span class="line">            q = parent;</span><br><span class="line">            parent = parent-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-7-查找二叉树的公共祖先"><a href="#4-7-查找二叉树的公共祖先" class="headerlink" title="4.7 查找二叉树的公共祖先"></a>4.7 查找二叉树的公共祖先</h2><p>LeetCode 236</p>
<h2 id="4-8-又两棵非常大的二叉树：T1-有几百万个节点，T2，有几百个节点。判断T2是否是T1的子树"><a href="#4-8-又两棵非常大的二叉树：T1-有几百万个节点，T2，有几百个节点。判断T2是否是T1的子树" class="headerlink" title="4.8 又两棵非常大的二叉树：T1 有几百万个节点，T2，有几百个节点。判断T2是否是T1的子树"></a>4.8 又两棵非常大的二叉树：T1 有几百万个节点，T2，有几百个节点。判断T2是否是T1的子树</h2><p>这道题并没有标准解法。值得和面试官探讨，详见树上的讲解（161页）。</p>
<h2 id="4-9-打印节点数值总和为给定值的路径，路径可以从任意节点开始，任意节点结束"><a href="#4-9-打印节点数值总和为给定值的路径，路径可以从任意节点开始，任意节点结束" class="headerlink" title="4.9 打印节点数值总和为给定值的路径，路径可以从任意节点开始，任意节点结束"></a>4.9 打印节点数值总和为给定值的路径，路径可以从任意节点开始，任意节点结束</h2><p>对于一个没有见过的问题，可以先简化，然后在推广。假设路径必须从root开始，那很简单。<br>如果路径可以从任意节点开始，那么我们需要向上检查是否得到了相符的总和，而不能假定root是起点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">findSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="type">int</span> depth = depth(root);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">path</span><span class="params">(depth)</span>;</span><br><span class="line">    findSum(root, sum, path, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">depth</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> max(depth(root-&gt;left), depth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">findSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    path[level] = root-&gt;val;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = level, t= <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        t += path[i];</span><br><span class="line">        <span class="keyword">if</span> (t == sum)</span><br><span class="line">            print(path, i ,level); <span class="comment">// printing out path from i to level</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    findSum(root-&gt;left, sum, path, level + <span class="number">1</span>);</span><br><span class="line">    findSum(root-&gt;right, sum, path, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-1-给定一个数n，和另一个数字m，然后给定区间-i-j-，区间保证可以大于m的二进制长度，把m的二进制表示插入到n的区间内"><a href="#5-1-给定一个数n，和另一个数字m，然后给定区间-i-j-，区间保证可以大于m的二进制长度，把m的二进制表示插入到n的区间内" class="headerlink" title="5.1 给定一个数n，和另一个数字m，然后给定区间(i, j)，区间保证可以大于m的二进制长度，把m的二进制表示插入到n的区间内"></a>5.1 给定一个数n，和另一个数字m，然后给定区间(i, j)，区间保证可以大于m的二进制长度，把m的二进制表示插入到n的区间内</h2><p>示例：n&#x3D;100&#x2F;000&#x2F;00, m &#x3D; 101, i &#x3D; 2, j &#x3D; 4 -&gt; 100&#x2F;101&#x2F;00</p>
<ol>
<li>把n中对应位置清零</li>
<li>把m移动到对应的位置</li>
<li>合并</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left_mask = ~<span class="number">0</span> &lt;&lt; (j+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> right_mask = (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span></span><br><span class="line">    <span class="type">int</span> mask = left_mask | right_mask;</span><br><span class="line"></span><br><span class="line">    n &amp;= mask;</span><br><span class="line">    m &lt;&lt;= i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n | m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-给定一个0和1之间的实数，打印他的二进制表示，如果32位以内无法表示，打印error"><a href="#5-2-给定一个0和1之间的实数，打印他的二进制表示，如果32位以内无法表示，打印error" class="headerlink" title="5.2 给定一个0和1之间的实数，打印他的二进制表示，如果32位以内无法表示，打印error"></a>5.2 给定一个0和1之间的实数，打印他的二进制表示，如果32位以内无法表示，打印error</h2><p>我们知道 (0.101)2 &#x3D; 1 * 2^-1 + 0 * 2^-2 + 1 * 2^-3，我们只要让这个数字不断的乘2，然后看它是否大于1，然后就可以得到第一位是不是1了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">printBinary</span><span class="params">(<span class="type">double</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= <span class="number">1</span> || num &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line"></span><br><span class="line">    string result;</span><br><span class="line">    result += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() &gt;= <span class="number">32</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">        num *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            result += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">            num -= <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-给定一个正整数，找出和其二进制表示中一的数字相同的数字，并且最接近，一共两个"><a href="#5-3-给定一个正整数，找出和其二进制表示中一的数字相同的数字，并且最接近，一共两个" class="headerlink" title="5.3 给定一个正整数，找出和其二进制表示中一的数字相同的数字，并且最接近，一共两个"></a>5.3 给定一个正整数，找出和其二进制表示中一的数字相同的数字，并且最接近，一共两个</h2><p>我们需要把某个0反转为1，把某个1反转为0。<br>0 -&gt; 1在1-&gt;0 左边，数字变大，在右边数字变小。<br>如果想变大，反转的0需要在1的左边。</p>
<p>把p位置1；把0到p之间请0；在添加ending1 - 1个1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = n, ending0 = <span class="number">0</span>, ending1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c &amp; <span class="number">1</span> == <span class="number">0</span>) &amp;&amp; c != <span class="number">0</span>) &#123;</span><br><span class="line">        ending0++;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (c &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        ending1++;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n + (<span class="number">1</span> &lt;&lt; ending0) + (<span class="number">1</span> &lt;&lt; (ending1 - <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把位p值0；把位p右边的位值1，再把0到ending0-1置0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getPrev</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = n, ending0 = <span class="number">0</span>, ending1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (c &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        ending1++;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; c != <span class="number">0</span>) &#123;</span><br><span class="line">        ending0++;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - (<span class="number">1</span> &lt;&lt; ending1) - (<span class="number">1</span> &lt;&lt; (ending0 - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-解释n-amp-n-10-0"><a href="#5-4-解释n-amp-n-10-0" class="headerlink" title="5.4 解释n &amp; (n-10) == 0"></a>5.4 解释<code>n &amp; (n-10) == 0</code></h2><p>LeetCode 231</p>
<h2 id="5-5-A和B之间有多少位不相同-x2F-需要改变多少位，才能把A变成B"><a href="#5-5-A和B之间有多少位不相同-x2F-需要改变多少位，才能把A变成B" class="headerlink" title="5.5 A和B之间有多少位不相同&#x2F;需要改变多少位，才能把A变成B"></a>5.5 A和B之间有多少位不相同&#x2F;需要改变多少位，才能把A变成B</h2><p>使用XOR找出不同的位，然后统计1的个位数。需要注意的是不同的题目</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitSwapRequired</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> diff = a ^ b, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (diff) &#123;</span><br><span class="line">        diff &amp;= diff - <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-6-交换一个整数的奇数位和偶数位"><a href="#5-6-交换一个整数的奇数位和偶数位" class="headerlink" title="5.6 交换一个整数的奇数位和偶数位"></a>5.6 交换一个整数的奇数位和偶数位</h2><p>这道题很有趣，选取特殊的掩码即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 考虑32bit int</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">swapBits</span><span class="params">(<span class="type">int32_t</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> odd_bits = x &amp; <span class="number">0xAAAAAAAA</span>; <span class="comment">// 0xAA as 10101010</span></span><br><span class="line">    <span class="type">int32_t</span> even_bits = x &amp; <span class="number">0x55555555</span>; <span class="comment">// 0x55 as 01010101</span></span><br><span class="line">    <span class="keyword">return</span> (odd_bits &gt;&gt; <span class="number">1</span>) | (even_bits &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-8-单色屏幕存贮在一维字节数组中，每个字节存储八个像素，屏幕宽度为w-px，绘制从x1到达x2的水平线"><a href="#5-8-单色屏幕存贮在一维字节数组中，每个字节存储八个像素，屏幕宽度为w-px，绘制从x1到达x2的水平线" class="headerlink" title="5.8 单色屏幕存贮在一维字节数组中，每个字节存储八个像素，屏幕宽度为w px，绘制从x1到达x2的水平线"></a>5.8 单色屏幕存贮在一维字节数组中，每个字节存储八个像素，屏幕宽度为w px，绘制从x1到达x2的水平线</h2><p>显然可以逐bit设定，然而这样是拿不到offer的。更好的做法是逐字节设定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">drawHorizentalLine</span><span class="params">(<span class="type">uint8_t</span> * screen, <span class="type">int</span> width, <span class="type">int</span> x1, <span class="type">int</span> x2, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start_offset = x1 % <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> start_full_byte = x1 / <span class="number">8</span>; <span class="comment">// x1 所在字节</span></span><br><span class="line">    <span class="keyword">if</span> (start_offset != <span class="number">0</span>)</span><br><span class="line">        start_full_byte++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> end_offset = x2 % <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> end_full_byte = x2 / <span class="number">8</span>; <span class="comment">// x2 所在字节</span></span><br><span class="line">    <span class="keyword">if</span> (end_offset != <span class="number">7</span>)</span><br><span class="line">        end_full_byte--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐字节设定</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start_full_byte; i &lt;= end_full_byte; i++)</span><br><span class="line">        screen[width / <span class="number">8</span> * y + i] = (<span class="type">uint8_t</span>)<span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> start_mask = (<span class="type">uint8_t</span>) (<span class="number">0xff</span> &gt;&gt; start_offset);</span><br><span class="line">    <span class="type">uint8_t</span> end_mast = (<span class="type">uint8_t</span>) ~(<span class="number">0xff</span> &gt;&gt; end_offset + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((x1 / <span class="number">8</span>) == (x2 / <span class="number">8</span>)) &#123;</span><br><span class="line">        <span class="type">uint8_t</span> mask = (<span class="type">uint8_t</span>)(start_mask &amp; end_mask);</span><br><span class="line">        screen[(width / <span class="number">8</span>) * y + x1 / <span class="number">8</span>] |= mask;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start_offset != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> byte_number = (width / <span class="number">8</span>) * y + start_full_byte - <span class="number">1</span>;</span><br><span class="line">            screen[byte_number] |= start_mask;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end_offset != <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="type">int</span> byte_number = (width / <span class="number">8</span>) * y + end_full_byte + <span class="number">1</span>;</span><br><span class="line">            screen[byte_number] |= end_mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6-1-给定直角坐标系的两条线，确定他们会不会相交"><a href="#6-1-给定直角坐标系的两条线，确定他们会不会相交" class="headerlink" title="6.1 给定直角坐标系的两条线，确定他们会不会相交"></a>6.1 给定直角坐标系的两条线，确定他们会不会相交</h2><p>我们知道在二维平面上两条线的关系不外乎：平行，相交，重合。问题是两条线重合算不算相交呢，需要问清楚。<br>对于两条线如何表示，这又是面向对象设计的问题，需要讨论。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> EPSILON;</span><br><span class="line">    <span class="type">double</span> m_slope; <span class="comment">// 斜率</span></span><br><span class="line">    <span class="type">double</span> m_y_intercept; <span class="comment">// y轴交点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Line</span>(<span class="type">double</span> s, <span class="type">double</span> y): <span class="built_in">m_slope</span>(s), <span class="built_in">m_y_intercept</span>(y) &#123;&#125;;</span><br><span class="line">    <span class="comment">// 重合视作相交</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">intersect</span><span class="params">(<span class="type">const</span> Line&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="built_in">slope</span>() - other.<span class="built_in">slope</span>()) &gt; EPSILON || <span class="comment">// 斜率不同</span></span><br><span class="line">            <span class="built_in">abs</span>(<span class="built_in">y_intercept</span>() - other.<span class="built_in">y_intercept</span>()) &lt; EPSILON; <span class="comment">// y轴交点相同</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">slope</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_slope;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">y_intercept</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_y_intercept;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Line::EPSILON = <span class="number">0.00001</span>;</span><br></pre></td></tr></table></figure>

<p>遇到这类问题，务必：</p>
<ol>
<li>多问，面试官可能故意模糊问题</li>
<li>仔细设计数据结构，权衡利弊，和面试官讨论</li>
<li>千万不要用＝＝判定浮点数</li>
</ol>
<h2 id="6-2-只使用加号实现减法和乘除法"><a href="#6-2-只使用加号实现减法和乘除法" class="headerlink" title="6.2 只使用加号实现减法和乘除法"></a>6.2 只使用加号实现减法和乘除法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">neg</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> d = a &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (a) &#123;</span><br><span class="line">        result += d;</span><br><span class="line">        a += d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; <span class="number">0</span> ? a : neg(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">minus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + neg(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sign = (a &gt; <span class="number">0</span>) == (b &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    a = <span class="built_in">abs</span>(a);</span><br><span class="line">    b = <span class="built_in">abs</span>(b);</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b--)</span><br><span class="line">        result += a;</span><br><span class="line">    <span class="keyword">return</span> sign == <span class="number">1</span> ? result : neg(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">devide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="comment">// see leetcode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-找出第k个丑数"><a href="#6-3-找出第k个丑数" class="headerlink" title="6.3 找出第k个丑数"></a>6.3 找出第k个丑数</h2><p>LeetCode 264</p>
<h2 id="7-1-小孩上楼梯，楼梯有n阶，小孩可以一次上1，2，3步，请问一共有多少种方法"><a href="#7-1-小孩上楼梯，楼梯有n阶，小孩可以一次上1，2，3步，请问一共有多少种方法" class="headerlink" title="7.1 小孩上楼梯，楼梯有n阶，小孩可以一次上1，2，3步，请问一共有多少种方法"></a>7.1 小孩上楼梯，楼梯有n阶，小孩可以一次上1，2，3步，请问一共有多少种方法</h2><p> 注意如果只能1或2就是斐波那契数列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countSteps</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> vector&lt;<span class="type">int</span>&gt; <span class="title">steps</span><span class="params">(<span class="number">1000</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span> &amp;&amp; steps[n] == <span class="number">1</span>)</span><br><span class="line">        steps[n] = <span class="built_in">countSteps</span>(n <span class="number">-1</span>) + <span class="built_in">countSteps</span>(n - <span class="number">2</span>) + <span class="built_in">countSteps</span>(n - <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> steps[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">countSteps</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n3 = <span class="number">1</span>; <span class="comment">// starts from n = 0</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">1</span>; <span class="comment">// starts from n = 1</span></span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">2</span>; <span class="comment">// starts from n = 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        steps = n3 + n2 + n1;</span><br><span class="line">        n3 = n2;</span><br><span class="line">        n2 = n1;</span><br><span class="line">        n1 = steps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-1-设计一种算法，机器人只能向右向下移动，从-0-0-移动到-x-y-有几种走法"><a href="#8-1-设计一种算法，机器人只能向右向下移动，从-0-0-移动到-x-y-有几种走法" class="headerlink" title="8.1 设计一种算法，机器人只能向右向下移动，从(0, 0)移动到(x, y)有几种走法"></a>8.1 设计一种算法，机器人只能向右向下移动，从(0, 0)移动到(x, y)有几种走法</h2><p>LeetCode 62 63</p>
<h2 id="9-1-在有序数组A-0…n-1-中存在A-i-x3D-x3D-i，找出该数字。如果存在重复值，又该如何做"><a href="#9-1-在有序数组A-0…n-1-中存在A-i-x3D-x3D-i，找出该数字。如果存在重复值，又该如何做" class="headerlink" title="9.1 在有序数组A[0…n-1]中存在A[i] &#x3D;&#x3D; i，找出该数字。如果存在重复值，又该如何做"></a>9.1 在有序数组A[0…n-1]中存在A[i] &#x3D;&#x3D; i，找出该数字。如果存在重复值，又该如何做</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">magic</span><span class="params">(<span class="type">int</span>* A, n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>; right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] == mid)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &lt; mid)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-2-返回一个集合的所有子集"><a href="#9-2-返回一个集合的所有子集" class="headerlink" title="9.2 返回一个集合的所有子集"></a>9.2 返回一个集合的所有子集</h2><p>LeetCode 78</p>
<h2 id="9-3-全排列"><a href="#9-3-全排列" class="headerlink" title="9.3 全排列"></a>9.3 全排列</h2><p>LeetCode</p>
<h2 id="9-4-生成n对括号的全部有效集合"><a href="#9-4-生成n对括号的全部有效集合" class="headerlink" title="9.4 生成n对括号的全部有效集合"></a>9.4 生成n对括号的全部有效集合</h2><p>LeetCode</p>
<h2 id="9-5-实现填充颜色功能"><a href="#9-5-实现填充颜色功能" class="headerlink" title="9.5 实现填充颜色功能"></a>9.5 实现填充颜色功能</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintFill</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; screen, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (screen[y][x] == color)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">paintFill</span>(screen, <span class="type">int</span> x, <span class="type">int</span> y, screen[y][x], <span class="type">int</span> color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintFill</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; screen, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> start, <span class="type">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= screen[<span class="number">0</span>].<span class="built_in">size</span>() || y &lt; <span class="number">0</span> || y &gt;= screen.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (screen[y][x] == start) &#123;</span><br><span class="line">        screen[y][x] == color;</span><br><span class="line">        <span class="built_in">paintFill</span>(screen, <span class="type">int</span> x<span class="number">-1</span>, <span class="type">int</span> y, start, color);</span><br><span class="line">        <span class="built_in">paintFill</span>(screen, x+<span class="number">1</span>, y, start, color);</span><br><span class="line">        <span class="built_in">paintFill</span>(screen, x, y+<span class="number">1</span>, start, color);</span><br><span class="line">        <span class="built_in">paintFill</span>(screen, x, y<span class="number">-1</span>, start, color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-6-给定数量不限的硬币，编写代码计算有几种表示方法"><a href="#9-6-给定数量不限的硬币，编写代码计算有几种表示方法" class="headerlink" title="9.6 给定数量不限的硬币，编写代码计算有几种表示方法"></a>9.6 给定数量不限的硬币，编写代码计算有几种表示方法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">makeChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; coins, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">solution</span><span class="params">(coins.size(), <span class="number">0</span>)</span></span><br><span class="line">    <span class="title function_">make</span><span class="params">(result, coins, solution, <span class="number">0</span>, target)</span>;</span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">make</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; coins, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; solution, <span class="type">int</span> start, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= <span class="number">0</span> || start &gt;= coins.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)</span><br><span class="line">            result.push_back(solution);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i *coins[start] &lt; target ; i++) &#123;</span><br><span class="line">        solution[start] = i;</span><br><span class="line">        make(result, coins, solution, start + <span class="number">1</span>, target - i * coins[start]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9-7-N-Queen问题"><a href="#9-7-N-Queen问题" class="headerlink" title="9.7 N-Queen问题"></a>9.7 N-Queen问题</h2><p>LeetCode</p>
<h2 id="9-8-给你一堆箱子，上面的箱子的长宽高要求小于下面的箱子，实现一个方法，搭出最高的箱子"><a href="#9-8-给你一堆箱子，上面的箱子的长宽高要求小于下面的箱子，实现一个方法，搭出最高的箱子" class="headerlink" title="9.8 给你一堆箱子，上面的箱子的长宽高要求小于下面的箱子，实现一个方法，搭出最高的箱子"></a>9.8 给你一堆箱子，上面的箱子的长宽高要求小于下面的箱子，实现一个方法，搭出最高的箱子</h2><h2 id="10-1-合并两个有序数组"><a href="#10-1-合并两个有序数组" class="headerlink" title="10.1 合并两个有序数组"></a>10.1 合并两个有序数组</h2><p>LeetCode 88</p>
<h2 id="11-1-对一个字符串数组排序，把变位词-Anagram-放在一起"><a href="#11-1-对一个字符串数组排序，把变位词-Anagram-放在一起" class="headerlink" title="11.1 对一个字符串数组排序，把变位词(Anagram)放在一起"></a>11.1 对一个字符串数组排序，把变位词(Anagram)放在一起</h2><p>LeetCode 49</p>
<h2 id="11-2-在已经被旋转过的排序数组中，查找元素"><a href="#11-2-在已经被旋转过的排序数组中，查找元素" class="headerlink" title="11.2 在已经被旋转过的排序数组中，查找元素"></a>11.2 在已经被旋转过的排序数组中，查找元素</h2><p>LeetCode 81</p>
<h2 id="11-3-有一个20GB的文件，每行一个字符串，如何排序"><a href="#11-3-有一个20GB的文件，每行一个字符串，如何排序" class="headerlink" title="11.3 有一个20GB的文件，每行一个字符串，如何排序"></a>11.3 有一个20GB的文件，每行一个字符串，如何排序</h2><p>20GB暗示无法放入内存中，把文件分块后，分别载入内存中，采用归并排序</p>
<h2 id="12-1-使用-C-写个方法，打印输入文件的最后-K-行"><a href="#12-1-使用-C-写个方法，打印输入文件的最后-K-行" class="headerlink" title="12.1 使用 C++ 写个方法，打印输入文件的最后 K 行"></a>12.1 使用 C++ 写个方法，打印输入文件的最后 K 行</h2><p>使用循环数组，容量设为 K，同时记录当前的最早元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printLastKLines</span><span class="params">(<span class="type">char</span>* filename)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> K = <span class="number">10</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">    string lines[K];</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (file.<span class="built_in">good</span>())</span><br><span class="line">        <span class="built_in">getline</span>(file, lines[size++ % K];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start = size &gt; K ? (size % K) : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">min</span>(K, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) </span><br><span class="line">        cout &lt;&lt; lines[(start + i) % K] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="12-2-编写malloc-aligned"><a href="#12-2-编写malloc-aligned" class="headerlink" title="12.2 编写malloc_aligned"></a>12.2 编写malloc_aligned</h2><h2 id="12-3-malloc2d函数，分配二维数组，返回int-可以通过a-i-j-访问，并且尽量少调用malloc"><a href="#12-3-malloc2d函数，分配二维数组，返回int-可以通过a-i-j-访问，并且尽量少调用malloc" class="headerlink" title="12.3 malloc2d函数，分配二维数组，返回int**可以通过a[i][j]访问，并且尽量少调用malloc"></a>12.3 malloc2d函数，分配二维数组，返回int**可以通过a[i][j]访问，并且尽量少调用malloc</h2><p>前面rows大小的区域用作存储指针，后面存储数据。</p>
<pre><code>hhh|ddddd|ddddd|ddddd
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>** <span class="title function_">malloc2d</span><span class="params">(<span class="type">int</span> rows, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line">    <span class="type">int</span> header = rows * <span class="keyword">sizeof</span>(<span class="type">void</span>*);</span><br><span class="line">    <span class="type">void</span>** ptr = (<span class="type">void</span>**)<span class="built_in">malloc</span>(header + rows * cols);</span><br><span class="line">    <span class="keyword">if</span> (!ptr)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">void</span>* buf = (<span class="type">void</span>*)(rawptr + rows);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">         ptr[i] = buf + i * cols;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free2d</span><span class="params">(<span class="type">void</span>** ptr)</span> &#123;</span><br><span class="line">    <span class="type">void</span>* p = <span class="type">void</span>* p;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="12-4-不用中间变量，直接交换两个数字"><a href="#12-4-不用中间变量，直接交换两个数字" class="headerlink" title="12.4 不用中间变量，直接交换两个数字"></a>12.4 不用中间变量，直接交换两个数字</h2><p>想像把 a 和 b 都放在数轴上，假设 a0，b0分别是初值，那么有 diff &#x3D; a - b。我们把<br>diff 保存在 a 中，然后 b &#x3D; b0 + diff 也就是 a0 ，而再另 a &#x3D; b - diff，也就是 b0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    a = a - b;</span><br><span class="line">    b = b + a;</span><br><span class="line">    a = b - a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更巧妙的是，我们还可以使用异或 XOR 在解。假设 a &#x3D; a0 ^ b0，那么 b &#x3D; a ^ b0 &#x3D; a0 ^ b0 ^ b0 &#x3D; a0，然后 a &#x3D; a ^ b &#x3D; a0 ^ b0 ^ a0 &#x3D; b0。完美解决！<br>值得注意的是，因为使用异或不考虑变量的实际类型，只是粗暴地按 bit 位交换，因此适用于各种类型。不过值得注意的是千万不要用这种方法去交换变量的值，当x&#x3D;&#x3D;y的时候会有灾难性后果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="13-1-n-结尾有多少个零"><a href="#13-1-n-结尾有多少个零" class="headerlink" title="13.1 n! 结尾有多少个零"></a>13.1 n! 结尾有多少个零</h2><p>LeetCode 172</p>
<h2 id="13-2-找出两个数字中较大的一个，但不得使用判断语句"><a href="#13-2-找出两个数字中较大的一个，但不得使用判断语句" class="headerlink" title="13.2 找出两个数字中较大的一个，但不得使用判断语句"></a>13.2 找出两个数字中较大的一个，但不得使用判断语句</h2><p>判断a&gt;b就是判断a-b的正负号，显然我们可以使用bit运算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">flip</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="comment">// flip last bit</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ^ a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sign</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">flip</span>((a &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="13-3-把数字转换为英文单词"><a href="#13-3-把数字转换为英文单词" class="headerlink" title="13.3 把数字转换为英文单词"></a>13.3 把数字转换为英文单词</h2><h2 id="13-4-把数字转换为汉语句子"><a href="#13-4-把数字转换为汉语句子" class="headerlink" title="13.4 把数字转换为汉语句子"></a>13.4 把数字转换为汉语句子</h2><h2 id="13-5-数组最大序列和"><a href="#13-5-数组最大序列和" class="headerlink" title="13.5 数组最大序列和"></a>13.5 数组最大序列和</h2><p>LeetCode 53</p>
<h2 id="13-6-给定产生数字概率相同的rand5-，实现一个方法rand7-，要求产生每个数字的概率相同"><a href="#13-6-给定产生数字概率相同的rand5-，实现一个方法rand7-，要求产生每个数字的概率相同" class="headerlink" title="13.6 给定产生数字概率相同的rand5()，实现一个方法rand7()，要求产生每个数字的概率相同"></a>13.6 给定产生数字概率相同的rand5()，实现一个方法rand7()，要求产生每个数字的概率相同</h2><p>扩大rand5产生随机数的范围，然后对舍去一定范围的数字，对剩下的数字取模，虽然这样会导致调用次数不固定，但实现了效果<br>对于randx，扩大范围的方法是 x * randx() + randx()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rand7</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">5</span> * rand5() + rand5();</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">21</span>)</span><br><span class="line">            <span class="keyword">return</span> num % <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该问题可以拓展到对于 x &lt; y，由randx() 构造 randy()</p>
<h2 id="13-7-在数组中找到两个数字，是的他们的和为指定的数字"><a href="#13-7-在数组中找到两个数字，是的他们的和为指定的数字" class="headerlink" title="13.7 在数组中找到两个数字，是的他们的和为指定的数字"></a>13.7 在数组中找到两个数字，是的他们的和为指定的数字</h2><p>LeetCode 1</p>
<h2 id="13-8-把二叉树转化为双向链表"><a href="#13-8-把二叉树转化为双向链表" class="headerlink" title="13.8 把二叉树转化为双向链表"></a>13.8 把二叉树转化为双向链表</h2><p>先把二叉树变成一个环形链表，然后再从头部解开即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">concat</span><span class="params">(<span class="keyword">struct</span> tree_node* x, <span class="keyword">struct</span> tree_node* y)</span> &#123;</span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tree_node* <span class="title function_">convert_circular</span><span class="params">(<span class="keyword">struct</span> tree_node* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span>* <span class="title">left</span> =</span> convert_circular(root-&gt;left);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span>* <span class="title">right</span> =</span> convert_circular(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!left &amp;&amp; !right) &#123;</span><br><span class="line">        root-&gt;left = root;</span><br><span class="line">        root-&gt;right = root;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span>* <span class="title">tail_right</span> =</span> right ? right-&gt;left : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把左边添加到根部</span></span><br><span class="line">    <span class="keyword">if</span> (!left)</span><br><span class="line">        concat(right-&gt;left, root);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        concat(left-&gt;left, root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把右边添加到根部</span></span><br><span class="line">    <span class="keyword">if</span> (!right)</span><br><span class="line">        concat(root, left);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        concat(root, right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把右边和左边链接</span></span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right)</span><br><span class="line">        concat(tail_right, left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left ? left : root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tree_node* <span class="title function_">convert</span><span class="params">(<span class="keyword">struct</span> tree_node* root)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span>* <span class="title">head</span> =</span> convert_circular(root);</span><br><span class="line">    head-&gt;left-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-2-实现加法"><a href="#14-2-实现加法" class="headerlink" title="14.2 实现加法"></a>14.2 实现加法</h2><p>显然是使用位运算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int add(int a, int b) &#123;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        int sum = a ^ b;</span><br><span class="line">        int carry = (a &amp; b) &lt;&lt; 1;</span><br><span class="line">        a = sum, b = carry;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-2-完美洗牌，使得一副牌中任意一种排列出现的概率都相等"><a href="#15-2-完美洗牌，使得一副牌中任意一种排列出现的概率都相等" class="headerlink" title="15.2 完美洗牌，使得一副牌中任意一种排列出现的概率都相等"></a>15.2 完美洗牌，使得一副牌中任意一种排列出现的概率都相等</h2><p>显然全排列是n!个，那么我们保证每一个全排列都可能出现就好了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> k = rand(i);</span><br><span class="line">        swap(A[k], A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-1-从n个数组中选出m个，要求被选中概率一样"><a href="#16-1-从n个数组中选出m个，要求被选中概率一样" class="headerlink" title="16.1 从n个数组中选出m个，要求被选中概率一样"></a>16.1 从n个数组中选出m个，要求被选中概率一样</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">pink_k</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">result</span><span class="params">(k)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-2-小于-n-的数字中出现2的个数"><a href="#16-2-小于-n-的数字中出现2的个数" class="headerlink" title="16.2 小于 n 的数字中出现2的个数"></a>16.2 小于 n 的数字中出现2的个数</h2><h2 id="16-3-矩阵链乘法问题"><a href="#16-3-矩阵链乘法问题" class="headerlink" title="16.3 矩阵链乘法问题"></a>16.3 矩阵链乘法问题</h2><h2 id="16-4-判断是否是合法地出栈序列"><a href="#16-4-判断是否是合法地出栈序列" class="headerlink" title="16.4 判断是否是合法地出栈序列"></a>16.4 判断是否是合法地出栈序列</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/The_star_is_at/article/details/72790961">参考</a></p>
<h2 id="16-5-二叉树的非递归遍历"><a href="#16-5-二叉树的非递归遍历" class="headerlink" title="16.5 二叉树的非递归遍历"></a>16.5 二叉树的非递归遍历</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/archive/2011/08/25/2153720.html">参考</a></p>
<br>
<br>
<br>
<br>
<br>


<h1 id="三、树的遍历"><a href="#三、树的遍历" class="headerlink" title="三、树的遍历"></a>三、树的遍历</h1><p>树的递归遍历都非常简单，但是非递归遍历有时候不是很简单。一般做题的时候直接写递归版就行了，<br>但是对于三个基础的遍历方法，有时候会要求写迭代版本，基本就是花式用栈就行了。</p>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> [root.val, *self.preorderTraversal(root.left), *self.preorderTraversal(root.right)]</span><br></pre></td></tr></table></figure>

<h3 id="非递归版"><a href="#非递归版" class="headerlink" title="非递归版"></a>非递归版</h3><p>使用栈做了一个顺序的反转。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归版-1"><a href="#递归版-1" class="headerlink" title="递归版"></a>递归版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> [*self.inorderTraversal(root.left), root.val, *self.inorderTraversal(root.right)]</span><br></pre></td></tr></table></figure>

<h3 id="非递归版-1"><a href="#非递归版-1" class="headerlink" title="非递归版"></a>非递归版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">            left = stack.pop()</span><br><span class="line">            ans.append(left.val)</span><br><span class="line">            <span class="keyword">if</span> left.right:</span><br><span class="line">                node = left.right</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">LeetCode 145</a></p>
<h3 id="递归版-2"><a href="#递归版-2" class="headerlink" title="递归版"></a>递归版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> [*self.postorderTraversal(root.left), *self.postorderTraversal(root.right), root.val]</span><br></pre></td></tr></table></figure>

<h3 id="非递归版-2"><a href="#非递归版-2" class="headerlink" title="非递归版"></a>非递归版</h3><p>这个方法还是有点 trick 的，类似于前序遍历，但是把左右子树反过来了，最后再翻转一遍，就变成<br>了后序遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br></pre></td></tr></table></figure>

<p>比如：前序遍历是 123, 现在这种遍历方式是 132, 在翻转一次正好是 231, 也就是后续遍历了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">reversed</span>(ans))</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/</a></li>
</ol>
<br>
<br>
<br>
<br>
<br>






<h1 id="四、LeetCode-突击手册"><a href="#四、LeetCode-突击手册" class="headerlink" title="四、LeetCode 突击手册"></a>四、LeetCode 突击手册</h1><p>一共定义了几个标签，可以通过 Ctrl+F&#x2F;Cmd+F 搜索这些标签还快速浏览相同的题目。</p>
<p>标签：#hash #backtracking #slidewindow #stack #queue #pointers</p>
<h2 id="1-从数组中找出两个数字使得他们的和是给定的数字"><a href="#1-从数组中找出两个数字使得他们的和是给定的数字" class="headerlink" title="1 从数组中找出两个数字使得他们的和是给定的数字"></a>1 从数组中找出两个数字使得他们的和是给定的数字</h2><p>tags: #hash</p>
<p>使用一个散列，存储数字和他对应的索引。然后遍历数组，如果另一半在散列当中，那么返回<br>这两个数的索引，程序结束；如果不在，把当前数字加入到散列中。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> reminder = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">find</span>(reminder) != hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            result[<span class="number">0</span>] = hash[reminder] + <span class="number">1</span>;</span><br><span class="line">            result[<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        hash[nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        seen = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> [seen[target-num], i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                seen[num] = i</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">two_sum</span>(nums: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;, target: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">with_capacity</span>(nums.<span class="title function_ invoke__">len</span>());</span><br><span class="line">        <span class="title function_ invoke__">for</span> (idx, num) <span class="keyword">in</span> nums.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">            <span class="keyword">match</span> map.<span class="title function_ invoke__">get</span>(&amp;(target - num)) &#123;</span><br><span class="line">                <span class="literal">None</span> =&gt; &#123;map.<span class="title function_ invoke__">insert</span>(num, idx);&#125;,</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(sub_idx) =&gt; &#123;<span class="keyword">return</span> <span class="built_in">vec!</span>[*sub_idx <span class="keyword">as</span> <span class="type">i32</span>, idx <span class="keyword">as</span> <span class="type">i32</span>]; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vec!</span> []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>go 解答</summary>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> index, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        last_index, ok := m[num]</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;last_index, index&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m[target - num] = index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>Follow up: 如果数组是已经排序的呢？</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()) <span class="comment">// 假设已经排序，只有一个结果</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> s = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (s == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make_pair</span>(left, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; sum)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="2-给两个列表，数字在其中按低位到高位存储，求他们的和"><a href="#2-给两个列表，数字在其中按低位到高位存储，求他们的和" class="headerlink" title="2 给两个列表，数字在其中按低位到高位存储，求他们的和"></a>2 给两个列表，数字在其中按低位到高位存储，求他们的和</h2><p>直接迭代遍历数组，考察细节操作。注意 dummy head 的使用。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 注意最后如果有 carry 的话，需要再生成一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">        <span class="type">int</span> v1 = l1 ? l1-&gt;val: <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> v2 = l2 ? l2-&gt;val: <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> v = v1 + v2 + carry;</span><br><span class="line">        p-&gt;next = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        p-&gt;val = v % <span class="number">10</span>;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        carry = v / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        l1 = l1 ? l1-&gt;next: <span class="literal">NULL</span>;</span><br><span class="line">        l2 = l2 ? l2-&gt;next: <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">ListNode *<span class="title">addTwoNumbers</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">            <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">            <span class="type">int</span> shift = <span class="number">0</span>;</span><br><span class="line">            ListNode* result = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">            ListNode* p = result;</span><br><span class="line">            <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> || l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="type">int</span> v1 = l1 != <span class="literal">NULL</span> ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> v2 = l2 != <span class="literal">NULL</span> ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">                newNode-&gt;val = v1 + v2 + shift;</span><br><span class="line">                <span class="keyword">if</span> (newNode-&gt;val &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                    newNode-&gt;val -= <span class="number">10</span>;</span><br><span class="line">                    shift = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    shift = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">                    l1 = l1-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">                    l2 = l2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;next = newNode;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意最后多余的一个进位处理</span></span><br><span class="line">            <span class="keyword">if</span> (shift == <span class="number">1</span>) &#123;</span><br><span class="line">                p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two_numbers</span>(l1: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;ListNode&gt;&gt;, l2: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;ListNode&gt;&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;ListNode&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> l1, <span class="keyword">mut</span> l2) = (l1, l2);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">dummy</span> = <span class="type">Box</span>&lt;ListNode::<span class="title function_ invoke__">new</span>(<span class="number">0</span>)&gt;;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">carry</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">p</span> = dummy;</span><br><span class="line">        <span class="keyword">while</span> l1.<span class="title function_ invoke__">is_some</span>() || l2.<span class="title function_ invoke__">is_some</span>() || carry != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> l1, l2&#123;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(a), <span class="title function_ invoke__">Some</span>(b) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = a + b + carry;</span><br><span class="line">                    l1 = l1.<span class="title function_ invoke__">next</span>();</span><br><span class="line">                    l2 = l2.<span class="title function_ invoke__">next</span>();</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(a), <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = a + carry;</span><br><span class="line">                    l1 = l1.<span class="title function_ invoke__">next</span>();</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="literal">None</span>, <span class="title function_ invoke__">Some</span>(b) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = b + carry;</span><br><span class="line">                    l2 = l2.<span class="title function_ invoke__">next</span>();</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="literal">None</span>, <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p.next = <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>&lt;ListNode::<span class="title function_ invoke__">new</span>(v)&gt;);</span><br><span class="line">            p = p.next;</span><br><span class="line">            p.val = v % <span class="number">10</span>;</span><br><span class="line">            carry = v / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> carry:</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                v1 = l1.val</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                v1 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                v2 = l2.val</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                v2 = <span class="number">0</span></span><br><span class="line">            v = v1 + v2 + carry  <span class="comment"># 别忘了这里</span></span><br><span class="line">            <span class="keyword">if</span> v &gt;= <span class="number">10</span>:</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">                v -= <span class="number">10</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            p.<span class="built_in">next</span> = ListNode(v)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="3-最长不重复子串"><a href="#3-最长不重复子串" class="headerlink" title="3 最长不重复子串"></a>3 最长不重复子串</h2><p>tags: #slidewindow</p>
<p>滑动窗口解决</p>
<p>注意，当字符有限的时候，比如限定为 ASCII 字符，可以使用一个数组代替 Hash。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> indices[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  <span class="comment">// init the array, memset can only be used for char</span></span><br><span class="line">        indices[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> longest = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; s[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        left = max(left, indices[s[i]] + <span class="number">1</span>);   <span class="comment">// 考虑新加入字符后对左边界的影响</span></span><br><span class="line">        indices[s[i]] = i;                     <span class="comment">// 更新元素上次出现位置</span></span><br><span class="line">        longest = max(longest, i - left + <span class="number">1</span>);  <span class="comment">// 应用动态规划</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        last_seen = &#123;&#125;</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            lo = <span class="built_in">max</span>(lo, last_seen.get(c, -<span class="number">1</span>) + <span class="number">1</span>)  <span class="comment"># 更新下边界</span></span><br><span class="line">            last_seen[c] = i</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - lo + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<h2 id="4-找到两个排序数组的中位数"><a href="#4-找到两个排序数组的中位数" class="headerlink" title="4 找到两个排序数组的中位数"></a>4 找到两个排序数组的中位数</h2><p>解法参见<a target="_blank" rel="noopener" href="https://leetcode.com/discuss/15790/share-my-o-log-min-m-n-solution-with-explanation">这里</a></p>
<p>使用两个数字 i 和 j, 分别作为 AB 的分隔元素，把 AB 分成两份，比如<br><code>A[0..i]</code>, <code>B[0..j]</code> 和 <code>A[i, m]</code>, <code>B[j, n]</code>，这样我们只需要下面两个条件就可以了：</p>
<ul>
<li><code>i+j = m-i + n-j</code>, 也就是 <code>i+j = (m+n)/2</code></li>
<li><code>B[j-1] &lt;= A[i] &amp;&amp; A[i-1] &lt;= B[j]</code>,  B 的前一半元素小于 A 的分隔符，A 的前一半元素小于 B 的分隔符</li>
</ul>
<p>这时候我们就得到了 A[i] 就是我们的中位数，或者之一。 i 的初始值在 0 到 m 之间，<br>然后我们二分搜索 <code>i = (imin + imax) / 2, j = mid - i</code>。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> m, <span class="type">int</span>* B, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> findMedianSortedArrays(B, n, A, m);</span><br><span class="line">    <span class="type">int</span> imin = <span class="number">0</span>, imax = m, i, j, num1, mid = (m + n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, num2;</span><br><span class="line">    <span class="keyword">while</span> (imin &lt;= imax) &#123;</span><br><span class="line">        i = (imin + imax) <span class="comment">// 2;</span></span><br><span class="line">        j = mid - i;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; m &amp;&amp; j &gt; <span class="number">0</span> &amp;&amp; B[j<span class="number">-1</span>] &gt; A[i]) &#123;  <span class="comment">// B 中的数字偏大</span></span><br><span class="line">            imin = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; B[j] &lt; A[i<span class="number">-1</span>]) &#123; <span class="comment">// A 中的数字偏大</span></span><br><span class="line">            imax = i - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                num1 = B[j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                num1 = A[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num1 = max(A[i<span class="number">-1</span>],B[j<span class="number">-1</span>]);  <span class="comment">// 普通情况</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((m + n) &amp; <span class="number">0x1</span>) <span class="comment">// odd</span></span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="keyword">if</span> (i == m)</span><br><span class="line">        num2 = B[j];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (j == n)</span><br><span class="line">        num2 = A[i];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        num2 = min(A[i], B[j]); <span class="comment">// 普通情况</span></span><br><span class="line">    <span class="keyword">return</span> (num1 + num2) / <span class="number">2.0</span>; <span class="comment">// 注意整数除法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5 最长回文子串"></a>5 最长回文子串</h2><ol>
<li>以某个元素为中心，向两边展开，注意处理奇数和偶数两种情况</li>
<li>Manacher 算法，参见<a target="_blank" rel="noopener" href="http://taop.marchtea.com/01.05.html">这里</a></li>
</ol>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        ans = <span class="string">&quot;&quot;</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 奇数长度回文子串</span></span><br><span class="line">            <span class="keyword">while</span> i - j &gt;= <span class="number">0</span> <span class="keyword">and</span> i + j &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i-j] == s[i+j]:</span><br><span class="line">                <span class="keyword">if</span> j * <span class="number">2</span> + <span class="number">1</span> &gt; length:</span><br><span class="line">                    length = j * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    ans = s[i-j:i+j+<span class="number">1</span>]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 偶数长度回文子串</span></span><br><span class="line">            <span class="keyword">while</span> i - j &gt;= <span class="number">0</span> <span class="keyword">and</span> i + j + <span class="number">1</span> &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i-j] == s[i+j+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> j * <span class="number">2</span> + <span class="number">2</span> &gt; length:</span><br><span class="line">                    length = j * <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">                    ans = s[i-j:i+j+<span class="number">2</span>]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">longestPalindrome</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>; <span class="comment">// length of the longest palindromic string</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">-1</span>; <span class="comment">// start of the lonest palidromic string</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 奇数长度的回文子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; (i - j &gt;= <span class="number">0</span>) &amp;&amp; (i + j &lt; len); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - j] != s[i + j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (j * <span class="number">2</span> + <span class="number">1</span> &gt; length) &#123;</span><br><span class="line">                length = j * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                start = i - j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偶数长度的回文子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; (i - j &gt;= <span class="number">0</span>) &amp;&amp; (i + j + <span class="number">1</span> &lt; len); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - j] != s[i + j + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (j * <span class="number">2</span> + <span class="number">2</span> &gt; length) &#123;</span><br><span class="line">                length = j * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">                start = i - j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * length + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(result, s + start, length);</span><br><span class="line">    result[length] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="6-ZigZag-字符串，把字符串掰弯，然后再按行输出"><a href="#6-ZigZag-字符串，把字符串掰弯，然后再按行输出" class="headerlink" title="6 ZigZag 字符串，把字符串掰弯，然后再按行输出"></a>6 ZigZag 字符串，把字符串掰弯，然后再按行输出</h2><p>考察数学，找出规律，所以实际上并不是 Z 子形，而是由 V 组成的，然后组合按行号重构后的字符串即可。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法不容易理解，建议看 Python 的</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">convert</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (!s || numRows &lt;= <span class="number">1</span> || len &lt; numRows) <span class="keyword">return</span> s; <span class="comment">// no need to convert</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* zigzag = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; len; j += <span class="number">2</span> * (numRows - <span class="number">1</span>)) &#123; <span class="comment">// 每个 v 字型长度</span></span><br><span class="line">            zigzag[cur++] = s[j];</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != numRows - <span class="number">1</span>) &#123; <span class="comment">// 中间行有斜线</span></span><br><span class="line">                <span class="type">int</span> t = j + <span class="number">2</span> * (numRows - <span class="number">1</span>) - <span class="number">2</span> * i; <span class="comment">// V 的第二笔</span></span><br><span class="line">                <span class="keyword">if</span> (t &lt; len)</span><br><span class="line">                    zigzag[cur++] = s[t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    zigzag[cur] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> zigzag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">self, s: <span class="built_in">str</span>, numRows: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> numRows &lt;= <span class="number">1</span> <span class="keyword">or</span> <span class="built_in">len</span>(s) &lt;= numRows:  <span class="comment"># 没有这个条件会超时</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        interval = <span class="number">2</span> * numRows - <span class="number">2</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># 第一行</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            ans.append(s[j])</span><br><span class="line">            j += interval</span><br><span class="line">        <span class="comment"># 中间行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, numRows-<span class="number">1</span>):</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">if</span> i + j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                    ans.append(s[i+j])</span><br><span class="line">                <span class="keyword">if</span> interval - i + j &lt; <span class="built_in">len</span>(s):  <span class="comment"># 一定要注意这里的索引</span></span><br><span class="line">                    ans.append(s[interval - i + j])</span><br><span class="line">                j += interval</span><br><span class="line">        <span class="comment"># 最后一行</span></span><br><span class="line">        j = numRows - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            ans.append(s[j])</span><br><span class="line">            j += interval</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(ans)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="7-翻转数字，溢出返回-0"><a href="#7-翻转数字，溢出返回-0" class="headerlink" title="7 翻转数字，溢出返回 0"></a>7 翻转数字，溢出返回 0</h2><p>注意溢出</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == INT_MIN) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> -reverse(-x);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        result = result * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result &gt; INT_MAX ? <span class="number">0</span> : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sign = <span class="number">1</span> <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        x *= sign</span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            y = y * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> y &gt; <span class="number">2</span>**<span class="number">31</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> y * sign</span><br></pre></td></tr></table></figure>
</details>


<h2 id="8-实现-atoi"><a href="#8-实现-atoi" class="headerlink" title="8 实现 atoi"></a>8 实现 atoi</h2><p>这道题考察各种细节，注意各种特殊情况：</p>
<ol>
<li>首先过滤空格</li>
<li>判定符号，符号只能出现一次</li>
<li>是否溢出，溢出返回 <code>INT_MAX</code> 或者 <code>INT_MIN</code></li>
</ol>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myAtoi</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = s.lstrip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">            sign = -<span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> s[i] == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i].isdigit():</span><br><span class="line">            ans = ans * <span class="number">10</span> + <span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        ans *= sign</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">min</span>(ans, <span class="number">2</span>**<span class="number">31</span>-<span class="number">1</span>), - <span class="number">2</span> ** <span class="number">31</span>)</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(<span class="type">char</span>* str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// discarding spaces</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isspace</span>(*str))</span><br><span class="line">        str++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// determining sign</span></span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">&#x27;-&#x27;</span> || *str == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">&#x27;-&#x27;</span>) sign = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">&#x27;+&#x27;</span>) sign = <span class="number">1</span>;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructing integer</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(*str)) &#123;</span><br><span class="line">        <span class="comment">// handling overflow</span></span><br><span class="line">        <span class="keyword">if</span> (result &gt; INT_MAX / <span class="number">10</span> || result == INT_MAX / <span class="number">10</span> &amp;&amp; *str - <span class="string">&#x27;0&#x27;</span> &gt; INT_MAX % <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> sign &gt; <span class="number">0</span> ? INT_MAX : INT_MIN;</span><br><span class="line">        result = *str - <span class="string">&#x27;0&#x27;</span> + result * <span class="number">10</span>;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result * sign;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="9-是否是回文数字"><a href="#9-是否是回文数字" class="headerlink" title="9 是否是回文数字"></a>9 是否是回文数字</h2><p>限定不能用额外空间，所以直接把 x 取余得到的数字作为一个反向作为一个新的数字</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> x != <span class="number">0</span> <span class="keyword">and</span> x % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 回文走到一半就行了，没必要完全翻转过来</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; y:</span><br><span class="line">            y = y * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> x == y <span class="keyword">or</span> x == y // <span class="number">10</span></span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tricky here, for x == k * 10^j</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &amp;&amp; (x % <span class="number">10</span> == <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; y) &#123;</span><br><span class="line">        y = y * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x == y || x == y / <span class="number">10</span>; <span class="comment">// 注意 x 可能是奇数长度也可能是偶数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="10-正则表达式"><a href="#10-正则表达式" class="headerlink" title="10 正则表达式"></a>10 正则表达式</h2><p>实现正则表达式，只需要实现<code>.</code>代表任意字符，<code>*</code>代表任意重复。只需要特殊处理<code>*</code>，<br>如果遇到了<code>*</code>，贪婪地向后匹配。和通配符的不同之处在于，正则表达式需要两个字母<br>组成模式，<code>*</code>是对前一个字母的修饰。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isMatch</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* p)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c = *p; c != <span class="number">0</span>; s++, c = *p) &#123;</span><br><span class="line">        <span class="comment">// if next char in pattern is not *</span></span><br><span class="line">        <span class="keyword">if</span> (*(p+<span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            p++;</span><br><span class="line">        <span class="comment">// if we got an *, check if we can skip `.*` or `x*`</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isMatch(s, p + <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s ends or p and s differs</span></span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="number">0</span> || c != <span class="string">&#x27;.&#x27;</span> &amp;&amp; c != *s)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *s == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11 盛最多水的容器"></a>11 盛最多水的容器</h2><p>从左右向中间逼近，如果有更大的就更新。简单的一道双指针题目，别想太多。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        water = <span class="built_in">min</span>(height[left], height[right]) * (right - left)</span><br><span class="line">        result = <span class="built_in">max</span>(result, water);</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right])</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            water = <span class="built_in">min</span>(height[lo], height[hi]) * (hi - lo)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, water)</span><br><span class="line">            <span class="keyword">if</span> height[lo] &lt; height[hi]:</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<h2 id="12-十进制转换为罗马数字"><a href="#12-十进制转换为罗马数字" class="headerlink" title="12 十进制转换为罗马数字"></a>12 十进制转换为罗马数字</h2><p>直接按每位把罗马数字转换出来在拼接就好了，使用 C 的话，拼接字符串很麻烦。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intToRoman</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        thousands = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>]</span><br><span class="line">        hundreds = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>]</span><br><span class="line">        tens = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>]</span><br><span class="line">        ones = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> thousands[x//<span class="number">1000</span>] + hundreds[x%<span class="number">1000</span>//<span class="number">100</span>] + tens[x%<span class="number">100</span>//<span class="number">10</span>] + ones[x%<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// note, the leading empty string is the trick here</span></span><br><span class="line">    string thousands[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>&#125;;</span><br><span class="line">    string handreds[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>&#125;;</span><br><span class="line">    string tens[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>&#125;;</span><br><span class="line">    string ones[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> thousands[num / <span class="number">1000</span>] + handreds[num % <span class="number">1000</span> / <span class="number">100</span>] + tens[num % <span class="number">100</span> / <span class="number">10</span>] + ones[num % <span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> digits[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span>* romans = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="type">char</span>* cursor = romans;</span><br><span class="line">    <span class="comment">// if num = 1234, then</span></span><br><span class="line">    <span class="comment">// digits = &#123;1, 2, 3, 4&#125;;</span></span><br><span class="line">    <span class="type">int</span> base = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        digits[i] = num / base;</span><br><span class="line">        num = num % base;</span><br><span class="line">        base /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    doRoman(digits[<span class="number">0</span>], <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, &amp;cursor); <span class="comment">// &#x27;_&#x27; can be anything</span></span><br><span class="line">    doRoman(digits[<span class="number">1</span>], <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, &amp;cursor);</span><br><span class="line">    doRoman(digits[<span class="number">2</span>], <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, &amp;cursor);</span><br><span class="line">    doRoman(digits[<span class="number">3</span>], <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, &amp;cursor);</span><br><span class="line">    *cursor = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> romans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">doRoman</span><span class="params">(<span class="type">int</span> number, <span class="type">char</span> ten, <span class="type">char</span> five, <span class="type">char</span> one, <span class="type">char</span>** str)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (number) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str)[<span class="number">1</span>] = ten;</span><br><span class="line">            (*str) += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = five;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str)[<span class="number">2</span>] = one;</span><br><span class="line">            (*str)[<span class="number">3</span>] = one;</span><br><span class="line">            (*str) += <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = five;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str)[<span class="number">2</span>] = one;</span><br><span class="line">            (*str) += <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = five;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str) += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = five;</span><br><span class="line">            (*str) += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str)[<span class="number">1</span>] = five;</span><br><span class="line">            (*str) += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str)[<span class="number">2</span>] = one;</span><br><span class="line">            (*str) += <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str)[<span class="number">1</span>] = one;</span><br><span class="line">            (*str) += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            (*str)[<span class="number">0</span>] = one;</span><br><span class="line">            (*str) += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="13-罗马数字转为十进制"><a href="#13-罗马数字转为十进制" class="headerlink" title="13 罗马数字转为十进制"></a>13 罗马数字转为十进制</h2><p>主要是当前一个数字小于后一个数字的时候，需要添加的是后一个数和前一个数字的差。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        vals = &#123;</span><br><span class="line">            <span class="string">&quot;I&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;V&quot;</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">&quot;X&quot;</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">&quot;L&quot;</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="string">&quot;C&quot;</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="string">&quot;D&quot;</span>: <span class="number">500</span>,</span><br><span class="line">            <span class="string">&quot;M&quot;</span>: <span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> i+<span class="number">1</span>&lt;<span class="built_in">len</span>(s) <span class="keyword">and</span> vals[s[i]] &lt; vals[s[i+<span class="number">1</span>]]:</span><br><span class="line">                ans += vals[s[i+<span class="number">1</span>]] - vals[s[i]]</span><br><span class="line">                i += <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += vals[s[i]]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acts like a dict or map</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getVal</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; s[i] != <span class="number">0</span>; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getVal(s[i]) &lt; getVal(s[i+<span class="number">1</span>]))</span><br><span class="line">            result += getVal(s[i+<span class="number">1</span>]) - getVal(s[i]), i += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result += getVal(s[i]), i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14 最长公共前缀"></a>14 最长公共前缀</h2><p>纵向扫描，从头到尾，如果不一致，返回当前子串即可。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">        minlen = <span class="built_in">min</span>([<span class="built_in">len</span>(<span class="built_in">str</span>) <span class="keyword">for</span> <span class="built_in">str</span> <span class="keyword">in</span> strs])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(minlen):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(strs)):</span><br><span class="line">                <span class="keyword">if</span> strs[j][i] != strs[<span class="number">0</span>][i]:</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>][:minlen]</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纵向扫描</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">longestCommonPrefix</span><span class="params">(<span class="type">char</span>** strs, <span class="type">int</span> strsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!strs || !strs[<span class="number">0</span>]) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (strsSize == <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(strs[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; strsSize; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[j][i] != strs[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                strs[<span class="number">0</span>][i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="15-从数组中找出三个数使得他们的和是-0"><a href="#15-从数组中找出三个数使得他们的和是-0" class="headerlink" title="15 从数组中找出三个数使得他们的和是 0"></a>15 从数组中找出三个数使得他们的和是 0</h2><p>首先把数组排序，然后使用类似 two sum 的方法做就好了。做这种数组题的套路就是实在不行排个<br>序。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            k = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                <span class="built_in">sum</span> = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span> &gt; <span class="number">0</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">sum</span> &lt; <span class="number">0</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans.append([nums[i], nums[j], nums[k]])</span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j+<span class="number">1</span>]:</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k-<span class="number">1</span>]:</span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &gt; <span class="number">0</span>)</span><br><span class="line">                k--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span>)</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line">                <span class="comment">// skipping duplicates</span></span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k - <span class="number">1</span>])</span><br><span class="line">                    k--;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j + <span class="number">1</span>])</span><br><span class="line">                    j++;</span><br><span class="line">                k--; <span class="comment">// 别忘了这里，还要继续寻找下一组</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="16-在数组中找到三个数字使得他们得和尽可能的接近给定数字，假设结果唯一"><a href="#16-在数组中找到三个数字使得他们得和尽可能的接近给定数字，假设结果唯一" class="headerlink" title="16 在数组中找到三个数字使得他们得和尽可能的接近给定数字，假设结果唯一"></a>16 在数组中找到三个数字使得他们得和尽可能的接近给定数字，假设结果唯一</h2><p>和上一题解法类似，在 <a target="_blank" rel="noopener" href="http://stackoverflow.com/q/2070359">http://stackoverflow.com/q/2070359</a> 有详尽解释</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            k = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                <span class="built_in">sum</span> = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span> == target:</span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">abs</span>(target-<span class="built_in">sum</span>) &lt; <span class="built_in">abs</span>(target-ans):</span><br><span class="line">                    ans = <span class="built_in">sum</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">sum</span> &gt; target:</span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>





<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *a - *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt;= <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] +nums[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> k = numsSize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            <span class="type">int</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">            <span class="keyword">if</span> (sum == target)</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(target - sum) &lt; <span class="built_in">abs</span>(target - result))</span><br><span class="line">                result = sum;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target)</span><br><span class="line">                k--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="17-生成电话键盘按键数字对应的所有可能的字符串，不限制返回结果的顺序"><a href="#17-生成电话键盘按键数字对应的所有可能的字符串，不限制返回结果的顺序" class="headerlink" title="17 生成电话键盘按键数字对应的所有可能的字符串，不限制返回结果的顺序"></a>17 生成电话键盘按键数字对应的所有可能的字符串，不限制返回结果的顺序</h2><p>tags: #backtracking</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="键盘"></p>
<p>递归：</p>
<p>这道题是一道典型的，最简单的深度优先遍历，生成所有可能解的问题。</p>
<p>迭代：</p>
<p>遍历数字，设当前结果为<code>&#123;a, b, c&#125;</code>, 下一个数字是<code>3</code>, 找出对应的字母<code>&#123;d, e, f&#125;</code>, 则新的结果是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; a + &#123;def&#125;, b + &#123;def&#125;, c + &#123;def&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>然后把新获得的数组作为下一轮的初始数组。最开始时，使用空数组开始。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        c2n = &#123;</span><br><span class="line">            <span class="string">&quot;2&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;3&quot;</span>: <span class="string">&quot;def&quot;</span>,</span><br><span class="line">            <span class="string">&quot;4&quot;</span>: <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">            <span class="string">&quot;5&quot;</span>: <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">            <span class="string">&quot;6&quot;</span>: <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">            <span class="string">&quot;7&quot;</span>: <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">            <span class="string">&quot;8&quot;</span>: <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">            <span class="string">&quot;9&quot;</span>: <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">combination, next_digits</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> next_digits:</span><br><span class="line">                ans.append(combination)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> c2n[next_digits[<span class="number">0</span>]]:</span><br><span class="line">                dfs(combination + char, next_digits[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        dfs(<span class="string">&quot;&quot;</span>, digits)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>




<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iterative</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> vector&lt;string&gt; &#123;&#125;;</span><br><span class="line">    string mapping[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">combinations</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;&quot;</span>)</span></span>; <span class="comment">// 注意使用空字符串作为种子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; digits.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> digit = digits[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (mapping[digit].<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vector&lt;string&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : mapping[digit])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; combination : combinations)</span><br><span class="line">                temp.<span class="built_in">push_back</span>(combination + c);</span><br><span class="line">        <span class="built_in">swap</span>(combinations, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> combinations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>还可以使用深度优先的搜索方法</p>
<p>追问：如何通过用户按的数字来查找是否有对应的单词呢</p>
<ol>
<li>通过把所有的单词计算出来，然后查询哪个是合法的，查询可以使用 Trie</li>
<li>通过把已经有的单词字典转换为数字字典，然后通过数字序列查询可能的单词组合。</li>
</ol>
<h2 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18 4Sum"></a>18 4Sum</h2><p>tags: #backtracking</p>
<p>其实可以用 深度优先搜索的方式直接解答 nSum</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">return</span> self.nSum(nums, target, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nSum</span>(<span class="params">self, nums, target, n</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">pos: <span class="built_in">int</span>, cur: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">                j = pos</span><br><span class="line">                k = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                    <span class="built_in">sum</span> = nums[j] + nums[k]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">sum</span> &lt; target:</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> <span class="built_in">sum</span> &gt; target:</span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        solution = cur[:] + [nums[j], nums[k]]</span><br><span class="line">                        ans.append(solution)</span><br><span class="line">                        <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j+<span class="number">1</span>]:</span><br><span class="line">                            j += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k-<span class="number">1</span>]:</span><br><span class="line">                            k -= <span class="number">1</span></span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            i = pos</span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums) - n + <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 剪枝的一种情况</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] * n &gt; target <span class="keyword">or</span> nums[-<span class="number">1</span>] * n &lt; target:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 排除重复数字</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; pos <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                cur.append(nums[i])</span><br><span class="line">                dfs(i+<span class="number">1</span>, cur, n-<span class="number">1</span>, target-nums[i])</span><br><span class="line">                cur.pop()</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        ans = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        dfs(<span class="number">0</span>, [], n, target)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<p>下面的 C++ 解法是一个传统解法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">4</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; hash;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            hash[nums[i]+nums[j]].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(i,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> re = target - nums[i] - nums[j];</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">find</span>(re) != hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> match : hash[re]) &#123;</span><br><span class="line">                    <span class="type">int</span> k = match.first, l = match.second;</span><br><span class="line">                    <span class="keyword">if</span> (k &gt; j) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!result.<span class="built_in">empty</span>()</span><br><span class="line">                            &amp;&amp; result.<span class="built_in">back</span>()[<span class="number">0</span>] == nums[i] &amp;&amp; result.<span class="built_in">back</span>()[<span class="number">1</span>] == nums[j]</span><br><span class="line">                            &amp;&amp; result.<span class="built_in">back</span>()[<span class="number">2</span>] == nums[k] &amp;&amp; result.<span class="built_in">back</span>()[<span class="number">3</span>] == nums[l])</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                        result.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k], nums[l]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="19-删除链表中倒数第-k-的节点"><a href="#19-删除链表中倒数第-k-的节点" class="headerlink" title="19 删除链表中倒数第 k 的节点"></a>19 删除链表中倒数第 k 的节点</h2><p>tags: #pointers</p>
<p>双指针经典题目，一个快指针先走 k 步，另一个慢指针再出发，注意链表长度小于 k 时。</p>
<p>注意：LeetCode 给定的 n 都是有效地，但要求返回头指针，如果头指针被删除需要额外注意，因此采用 dummy head</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        q = dummy</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        q.<span class="built_in">next</span> = q.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">fast</span>, *<span class="title">slow</span>;</span></span><br><span class="line">    dummy.next = fast = head;</span><br><span class="line">    slow = &amp;dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> slow-&gt;next;</span><br><span class="line">    slow-&gt;next = next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(next); <span class="comment">// remeber to free memory</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="20-判定给定的字符串是否是合法的括号序列，可能包括大中小三类"><a href="#20-判定给定的字符串是否是合法的括号序列，可能包括大中小三类" class="headerlink" title="20 判定给定的字符串是否是合法的括号序列，可能包括大中小三类"></a>20 判定给定的字符串是否是合法的括号序列，可能包括大中小三类</h2><p>tags: #stack</p>
<p>使用栈的基础题，注意逻辑简化</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        valid = <span class="literal">True</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">match</span> = &#123;<span class="string">&quot;)&quot;</span>: <span class="string">&quot;(&quot;</span>, <span class="string">&quot;]&quot;</span>: <span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#125;&quot;</span>: <span class="string">&quot;&#123;&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> (<span class="string">&quot;(&quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#123;&quot;</span>):</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> stack[-<span class="number">1</span>] != <span class="keyword">match</span>[c]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">opposite</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span> : <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span> : <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span> : <span class="keyword">return</span> <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            stk.push(c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!stk.empty() &amp;&amp; stk.top() == opposite(c))</span><br><span class="line">            stk.pop();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stk.empty(); <span class="comment">// 注意为空的条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_valid</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stack</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="comment">// let map =</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">ch</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">            <span class="keyword">match</span> ch &#123;</span><br><span class="line">                <span class="string">&#x27;(&#x27;</span> | <span class="string">&#x27;&#123;&#x27;</span> | <span class="string">&#x27;[&#x27;</span> =&gt; stack.<span class="title function_ invoke__">push</span>(ch),</span><br><span class="line">                <span class="string">&#x27;)&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="string">&#x27;(&#x27;</span>) = stack.<span class="title function_ invoke__">pop</span>() &#123;&#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;,</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="string">&#x27;&#123;&#x27;</span>) = stack.<span class="title function_ invoke__">pop</span>() &#123;&#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;,</span><br><span class="line">                <span class="string">&#x27;]&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="string">&#x27;[&#x27;</span>) = stack.<span class="title function_ invoke__">pop</span>() &#123;&#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;,</span><br><span class="line">                _ =&gt; <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="title function_ invoke__">len</span>() == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="21-合并两个已经排序的链表"><a href="#21-合并两个已经排序的链表" class="headerlink" title="21 合并两个已经排序的链表"></a>21 合并两个已经排序的链表</h2><p>tags: #pointers</p>
<p>考察链表的基本操作，很简单</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                p.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            p.<span class="built_in">next</span> = l1</span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            p.<span class="built_in">next</span> = l2</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span></span><br><span class="line">    dummy.next == <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1)</span><br><span class="line">        p-&gt;next = l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l2)</span><br><span class="line">        p-&gt;next = l2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="22-给定数字-n-生成所有合法的-n-个括号组成的序列"><a href="#22-给定数字-n-生成所有合法的-n-个括号组成的序列" class="headerlink" title="22 给定数字 n, 生成所有合法的 n 个括号组成的序列"></a>22 给定数字 n, 生成所有合法的 n 个括号组成的序列</h2><p>tags: #backtracking</p>
<p>一道典型的深度优先搜索题目</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">s, lefts, rights</span>):</span><br><span class="line">            <span class="keyword">if</span> lefts == <span class="number">0</span> <span class="keyword">and</span> rights == <span class="number">0</span>:</span><br><span class="line">                ans.append(s)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> lefts &gt; <span class="number">0</span>:</span><br><span class="line">                dfs(s+<span class="string">&quot;(&quot;</span>, lefts-<span class="number">1</span>, rights)</span><br><span class="line">            <span class="keyword">if</span> (lefts &lt; rights):</span><br><span class="line">                dfs(s+<span class="string">&quot;)&quot;</span>, lefts, rights-<span class="number">1</span>)</span><br><span class="line">        ans = []</span><br><span class="line">        dfs(<span class="string">&quot;&quot;</span>, n, n)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="built_in">gen</span>(result, <span class="string">&quot;&quot;</span>, n, n);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// left 剩下的左括号，right 剩下的右括号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gen</span><span class="params">(vector&lt;string&gt;&amp; result, string s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">gen</span>(result, s + <span class="string">&#x27;(&#x27;</span>, left - <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">        <span class="built_in">gen</span>(result, s + <span class="string">&#x27;)&#x27;</span>, left, right - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="23-合并-K-个排序的列表"><a href="#23-合并-K-个排序的列表" class="headerlink" title="23 合并 K 个排序的列表"></a>23 合并 K 个排序的列表</h2><p>使用优先级队列，复杂度最小。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">把列表看做一个队列，每次拿出两个列表，合并他们后放回到列表中，每次遍历列表的一半，这样每次遍历完一遍，</span><br><span class="line">列表的长度都会减半，直到列表的长度为 <span class="number">1</span>,  合并函数使用 <span class="number">21</span> 题中的合并两个列表的函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;C 解答&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) &#123;</span><br><span class="line">    // see above</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct ListNode* mergeKLists(struct ListNode** lists, <span class="built_in">int</span> listsSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!lists || listsSize &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (listsSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        // listsize <span class="keyword">is</span> halfed</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; listsSize / <span class="number">2</span>; i++)</span><br><span class="line">            // merge i <span class="keyword">and</span> last i <span class="built_in">list</span></span><br><span class="line">            lists[i] = mergeTwoLists(lists[i], lists[listsSize-<span class="number">1</span>-i]);</span><br><span class="line">        listsSize = (listsSize + <span class="number">1</span>) / <span class="number">2</span>; // 注意这里！</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="24-给定一个链表，交换两个相邻节点的值"><a href="#24-给定一个链表，交换两个相邻节点的值" class="headerlink" title="24 给定一个链表，交换两个相邻节点的值"></a>24 给定一个链表，交换两个相邻节点的值</h2><p>最简单的做法显然是直接把前后两个节点的值交换，但是 LeetCode 规定不能改变节点的值。<br>主要考察链表的指针操作，注意各种细节，一定要在纸上先把链表画出来。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> <span class="keyword">and</span> p.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            t = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = t.<span class="built_in">next</span></span><br><span class="line">            t.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span>.<span class="built_in">next</span> = t</span><br><span class="line">            p = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">swapPairs</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">temp</span>, *<span class="title">pnext</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;next) &#123;</span><br><span class="line">        temp = p-&gt;next;</span><br><span class="line">        p-&gt;next = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        p-&gt;next-&gt;next = temp;</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="25-给定一个链表，把相邻的-k-个节点反转"><a href="#25-给定一个链表，把相邻的-k-个节点反转" class="headerlink" title="25 给定一个链表，把相邻的 k 个节点反转"></a>25 给定一个链表，把相邻的 k 个节点反转</h2><p>和上题一样，同样禁止改变节点的值。比较简单地解法是浪费一点空间，使用 Stack, 实现<br>逆转 k 个节点，注意如果 k 较大的话，这种方法是不合适的。另一种方法是直接翻转，空间是<br>O(1) 的，但是时间复杂度是 2N。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head</span>):</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="built_in">next</span> = curr.<span class="built_in">next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> prev</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        p = dummy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            n = k</span><br><span class="line">            q = p</span><br><span class="line">            <span class="comment"># 找到下一组接点的头</span></span><br><span class="line">            <span class="keyword">while</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> q.<span class="built_in">next</span>:</span><br><span class="line">                q = q.<span class="built_in">next</span></span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果节点不够了直接退出</span></span><br><span class="line">            <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 把这段链表先截下来</span></span><br><span class="line">            <span class="built_in">next</span> = q.<span class="built_in">next</span></span><br><span class="line">            q.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            tail = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = self.reverseList(p.<span class="built_in">next</span>)</span><br><span class="line">            p = tail</span><br><span class="line">            p.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>


<p>使用 Stack 的 C++ 解法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    stack&lt;ListNode*&gt; stk;</span><br><span class="line">    <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">-1</span>)</span>, *p </span>= &amp;dummy, *pp;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pp = p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pp-&gt;next) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(pp-&gt;next);</span><br><span class="line">                pp = pp-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">size</span>() &lt; k) <span class="comment">// 剩下的节点不够 k 个了</span></span><br><span class="line">            <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">        pp = stk.<span class="built_in">top</span>()-&gt;next; <span class="comment">// 下一组中的第一个</span></span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            p-&gt;next = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p-&gt;next = pp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26 删除排序数组中的重复项"></a>26 删除排序数组中的重复项</h2><p>tags: #naive</p>
<p>in-place 的删除重复元素，使用两个指针，一个遍历，一个指向当前的结尾。</p>
<p>PS：这个基础题竟然做了半个小时才做对，⊙﹏⊙b 汗，要加强基础啊！</p>
<p>这类数组中去除中间元素的题写的时候还是很容易出错，重点是使用一个 length 变量，<br>然后还是要遍历整个数组。不要想什么双指针了。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 处理 i == 0 的情况也是需要注意的</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> nums[i] != nums[length-<span class="number">1</span>]:</span><br><span class="line">                nums[length] = nums[i]</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt;= <span class="number">1</span>) <span class="keyword">return</span> numsSize;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i] != nums[len - <span class="number">1</span>])</span><br><span class="line">            nums[len++] = nums[i];</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="27-删除元素"><a href="#27-删除元素" class="headerlink" title="27 删除元素"></a>27 删除元素</h2><p>和上一题类似，注意细节</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != val:</span><br><span class="line">                nums[length] = nums[i]</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums || numsSize == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != val)</span><br><span class="line">            nums[len++] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="28-实现-strstr-函数，即查找子串"><a href="#28-实现-strstr-函数，即查找子串" class="headerlink" title="28 实现 strstr 函数，即查找子串"></a>28 实现 strstr 函数，即查找子串</h2><p>使用暴力算法，时间复杂度 O(n)。也可以用 kmp 算法。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kmp 算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="built_in">next</span> = [<span class="number">0</span>]</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 特别注意这里的 1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(needle)):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> needle[i] != needle[j]:</span><br><span class="line">                j = <span class="built_in">next</span>[j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> needle[i] == needle[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="built_in">next</span>.append(j)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(haystack)):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> haystack[i] != needle[j]:</span><br><span class="line">                j = <span class="built_in">next</span>[j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(needle):</span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Brute Force</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strStr</span><span class="params">(<span class="type">char</span>* haystack, <span class="type">char</span>* needle)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="built_in">strlen</span>(haystack);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(needle);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// note h - n + 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h - n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (needle[j] != haystack[i+j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (j == n - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="29-给定连个整数，不使用乘法和除法计算除法。"><a href="#29-给定连个整数，不使用乘法和除法计算除法。" class="headerlink" title="29 给定连个整数，不使用乘法和除法计算除法。"></a>29 给定连个整数，不使用乘法和除法计算除法。</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/discuss/38997/detailed-explained-8ms-c-solution">这里</a> 有一个非常好的算法</p>
<p>计算可以从被除数中减去除数的次数</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> &#123;</span><br><span class="line">    <span class="comment">// abs(INT_MIN) == INT_MAX + 1</span></span><br><span class="line">    <span class="keyword">if</span> (divisor == <span class="number">0</span> || (dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    <span class="type">int</span> sign = (dividend &gt; <span class="number">0</span>) == (divisor &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n = <span class="built_in">labs</span>(dividend);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d = <span class="built_in">labs</span>(divisor);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= d) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> temp = d;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> multi = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;= (temp &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            multi &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n -= temp;</span><br><span class="line">        result += multi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sign * result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="30-包串联所有单词的子串"><a href="#30-包串联所有单词的子串" class="headerlink" title="30 包串联所有单词的子串"></a>30 包串联所有单词的子串</h2><p>tags: #slidewindow</p>
<p>一道诡异的滑动窗口的题目，对这类问题还是不很熟啊。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;C++ 解答&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">vector&lt;<span class="built_in">int</span>&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">    unordered_map&lt;string, <span class="built_in">int</span>&gt; counts;</span><br><span class="line">    <span class="keyword">for</span> (string word : words)</span><br><span class="line">        counts[word]++;</span><br><span class="line">    <span class="built_in">int</span> n = s.length(), num = words.size(), <span class="built_in">len</span> = words[<span class="number">0</span>].size();</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; indexes;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n - num * <span class="built_in">len</span> + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        unordered_map&lt;string, <span class="built_in">int</span>&gt; seen;</span><br><span class="line">        <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; num; j++) &#123;</span><br><span class="line">            string word = s.substr(i + j * <span class="built_in">len</span>, <span class="built_in">len</span>);</span><br><span class="line">            <span class="keyword">if</span> (counts.find(word) != counts.end()) &#123;</span><br><span class="line">                seen[word]++;</span><br><span class="line">                <span class="keyword">if</span> (seen[word] &gt; counts[word])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == num)</span><br><span class="line">            indexes.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> indexes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="31-全排列，下一个"><a href="#31-全排列，下一个" class="headerlink" title="31 全排列，下一个"></a>31 全排列，下一个</h2><p>首先，对于所有的组合，最小的一个一定是按照升序排序的，最大的一定是倒过来，因此</p>
<ol>
<li>如果我们发现是完全倒序的，直接翻转就好了；</li>
<li>如果是一般情况，从后向前遍历，找到逆序的数字的边界，假设是 k。那么后边这段已经是完全<br>逆序的，无法变小了，为了保证生成的数字变大，我们再从后向前找到第一个比 k 大的数字，交<br>换这两个数字，再把后续的逆序数组翻转。</li>
</ol>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextPermutation</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 前后都是闭区间</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">nums, lo, hi</span>):</span><br><span class="line">            <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">                nums[lo], nums[hi] = nums[hi], nums[lo]</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        k = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i + <span class="number">1</span>]:</span><br><span class="line">                k = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> k == -<span class="number">1</span>:</span><br><span class="line">            reverse(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        l = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>, k, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[k]:</span><br><span class="line">                l = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        nums[l], nums[k] = nums[k], nums[l]</span><br><span class="line">        reverse(nums, k+<span class="number">1</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>; <span class="comment">// 升序排列的最后一个数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            k = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完全是逆序的，直接返回第一个，也就是升序排列</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">-1</span>; <span class="comment">// 逆序数字中比 k 大的最小的数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; k; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[k]) &#123;</span><br><span class="line">            l = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[k], nums[l]); <span class="comment">// 保证变大</span></span><br><span class="line">    <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k + <span class="number">1</span>, nums.<span class="built_in">end</span>()); <span class="comment">// 保证是下一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="32-从一个括号构成的字符串中找出最长的合法括号序列"><a href="#32-从一个括号构成的字符串中找出最长的合法括号序列" class="headerlink" title="32 从一个括号构成的字符串中找出最长的合法括号序列"></a>32 从一个括号构成的字符串中找出最长的合法括号序列</h2><p>动态规划的基础题目。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestValidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i-<span class="number">1</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span> i &gt;= <span class="number">2</span>:</span><br><span class="line">                        dp[i] = dp[i-<span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i] = <span class="number">2</span></span><br><span class="line">                <span class="keyword">elif</span> i - dp[i-<span class="number">1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> s[i-dp[i-<span class="number">1</span>]-<span class="number">1</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span> i - dp[i-<span class="number">1</span>] &gt;= <span class="number">2</span>:</span><br><span class="line">                        dp[i] = dp[i-<span class="number">1</span>] + dp[i-dp[i-<span class="number">1</span>]-<span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i] = dp[i-<span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<p>也可以使用栈来解。但是这种方法非常 tricky, 因为要考虑到 <code>()()</code> 的情况。</p>
<h2 id="33-在排序后又被反转的数组中搜索"><a href="#33-在排序后又被反转的数组中搜索" class="headerlink" title="33 在排序后又被反转的数组中搜索"></a>33 在排序后又被反转的数组中搜索</h2><p>既然是部分有序的，自然还是使用二分搜索了，注意终止条件。<br>不同于普通二分搜索的两种情况，我们有了四种情况：</p>
<ol>
<li>前半部分有序，并且在前半部分当中，</li>
<li>前半部分有序，但是不在前半部分</li>
<li>后半部分有序，并且在后半部分</li>
<li>后半部分有序，但是不在后半部分</li>
</ol>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            mi = lo + (hi - lo) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mi] == target:</span><br><span class="line">                <span class="keyword">return</span> mi</span><br><span class="line">            <span class="comment"># 这里为什么要包含等于号呢</span></span><br><span class="line">            <span class="keyword">if</span> nums[lo] &lt;= nums[mi]:</span><br><span class="line">                <span class="keyword">if</span> nums[lo] &lt;= target &lt; nums[mi]:</span><br><span class="line">                    hi = mi - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mi] &lt; target &lt;= nums[hi]:</span><br><span class="line">                    lo = mi + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    hi = mi - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// left half is sorted</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// right half is sorted</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34 在排序数组中查找元素的第一个和最后一个位置"></a>34 在排序数组中查找元素的第一个和最后一个位置</h2><p>在 C++ 的标准库中包含了这两个函数，分别是<code>std::lower_bound</code>和<code>std::upper_bound</code>.</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="function">def <span class="title">searchRange</span><span class="params">(self, nums: List[<span class="type">int</span>], target: <span class="type">int</span>)</span> -&gt; List[<span class="type">int</span>]:</span></span><br><span class="line"><span class="function">        if not nums:</span></span><br><span class="line"><span class="function">            return [<span class="number">-1</span>, <span class="number">-1</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        lo =</span> <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums)</span><br><span class="line">        lower = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = lo + (hi - lo) <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mi] &lt; target:</span><br><span class="line">                lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi</span><br><span class="line">        <span class="keyword">if</span> lo &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[lo] == target:</span><br><span class="line">            lower = lo</span><br><span class="line"></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums)</span><br><span class="line">        upper = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = lo + (hi - lo) <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mi] &lt;= target:</span><br><span class="line">                lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi</span><br><span class="line">        <span class="keyword">if</span> nums[lo<span class="number">-1</span>] == target:</span><br><span class="line">            upper = lo - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [lower, upper]</span><br></pre></td></tr></table></figure>
</details>


<h2 id="35-二分查找数字，如果没有找到，返回应该插入的位置"><a href="#35-二分查找数字，如果没有找到，返回应该插入的位置" class="headerlink" title="35 二分查找数字，如果没有找到，返回应该插入的位置"></a>35 二分查找数字，如果没有找到，返回应该插入的位置</h2><p>就是最基础的二分查找</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = lo + (hi - lo) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mi] == target:</span><br><span class="line">                <span class="keyword">return</span> mi</span><br><span class="line">            <span class="keyword">elif</span> nums[mi] &lt; target:</span><br><span class="line">                lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi</span><br><span class="line">        <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="36-合法数独，给定一个数独表，判定当前是否合法"><a href="#36-合法数独，给定一个数独表，判定当前是否合法" class="headerlink" title="36 合法数独，给定一个数独表，判定当前是否合法"></a>36 合法数独，给定一个数独表，判定当前是否合法</h2><details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        这道题的关键就在于小格子也是可以用 i 和 j 来计算的：</span></span><br><span class="line"><span class="string">        box_index = (row / 3) * 3 + columns / 3</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 特别注意浅拷贝的问题</span></span><br><span class="line">        used_i = [[<span class="number">0</span>] * <span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        used_j = [[<span class="number">0</span>] * <span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        used_k = [[<span class="number">0</span>] * <span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                piece = board[i][j]</span><br><span class="line">                <span class="keyword">if</span> piece == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                n = <span class="built_in">int</span>(piece) - <span class="number">1</span></span><br><span class="line">                k = i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span></span><br><span class="line">                <span class="keyword">if</span> used_i[i][n] <span class="keyword">or</span> used_j[j][n] <span class="keyword">or</span> used_k[k][n]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                used_i[i][n] = used_j[j][n] = used_k[k][n] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有点浪费空间</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>** board, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> used_row[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;, used_col[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;, used_box[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> num = board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> k = i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span> (used_row[i][num] || used_col[j][num] || used_box[k][num])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                used_row[i][num] = used_col[j][num] = used_box[k][num] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="37-求解数独"><a href="#37-求解数独" class="headerlink" title="37 求解数独"></a>37 求解数独</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>(board, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> ind)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ind==<span class="number">81</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> i=ind/<span class="number">9</span>, j=ind%<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span>(board[i][j]!=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">solve</span>(board, ind+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> f = <span class="string">&#x27;1&#x27;</span>; f &lt;= <span class="string">&#x27;9&#x27;</span>; f++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValidFill</span>(board, i, j, f)) &#123;</span><br><span class="line">                board[i][j]= f;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">solve</span>(board, ind+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                board[i][j]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidFill</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span> fill)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">9</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i][k]==fill) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//check the row</span></span><br><span class="line">        <span class="keyword">if</span>(board[k][j]==fill) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//check the column</span></span><br><span class="line">        <span class="type">int</span> r= i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>;   <span class="comment">//select the block</span></span><br><span class="line">        <span class="keyword">if</span>(board[r/<span class="number">3</span>*<span class="number">3</span>+k/<span class="number">3</span>][r%<span class="number">3</span>*<span class="number">3</span>+k%<span class="number">3</span>]==fill) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//check the block</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="38-数数并说出来"><a href="#38-数数并说出来" class="headerlink" title="38 数数并说出来"></a>38 数数并说出来</h2><p>不太理解这道题有什么意义，直接暴力做出来了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    string result = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n <span class="number">-1</span>; i++) &#123;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; result.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j + <span class="number">1</span> &lt; result.<span class="built_in">size</span>() &amp;&amp; result[j+<span class="number">1</span>] == result[j]) &#123;</span><br><span class="line">                j++; count++;</span><br><span class="line">            &#125;</span><br><span class="line">            temp += count + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            temp += result[j];</span><br><span class="line">        &#125;</span><br><span class="line">        result = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="39-给定一个集合，在集合中找出和为-target-的数字，数字可以使用多次，集合中没有重复数字"><a href="#39-给定一个集合，在集合中找出和为-target-的数字，数字可以使用多次，集合中没有重复数字" class="headerlink" title="39 给定一个集合，在集合中找出和为 target 的数字，数字可以使用多次，集合中没有重复数字"></a>39 给定一个集合，在集合中找出和为 target 的数字，数字可以使用多次，集合中没有重复数字</h2><p>典型的深度优先搜索</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">dfs</span>(result, candidates, &#123;&#125;, target);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt;&amp; candidates, vector&lt;<span class="type">int</span>&gt; comb, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(comb);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : candidates) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; target) <span class="keyword">continue</span>; <span class="comment">// 数字太大了</span></span><br><span class="line">        <span class="keyword">if</span> (!comb.<span class="built_in">empty</span>() &amp;&amp; c &lt; comb.<span class="built_in">back</span>()) <span class="keyword">continue</span>; <span class="comment">// 保证不重复且升序</span></span><br><span class="line">        comb.<span class="built_in">push_back</span>(c);</span><br><span class="line">        <span class="built_in">dfs</span>(result, candidates, comb, target - c);</span><br><span class="line">        comb.<span class="built_in">pop_back</span>(); <span class="comment">// 注意此处还需要弹出，因为需要循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="40-同上题一样，但是集合中的数字只能使用一次，并且集合中有重复数字"><a href="#40-同上题一样，但是集合中的数字只能使用一次，并且集合中有重复数字" class="headerlink" title="40 同上题一样，但是集合中的数字只能使用一次，并且集合中有重复数字"></a>40 同上题一样，但是集合中的数字只能使用一次，并且集合中有重复数字</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">dfs</span>(result, candidates, &#123;&#125;, target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt;&amp; candidates, vector&lt;<span class="type">int</span>&gt; comb, <span class="type">int</span> target, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(comb);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidates[i] &gt; target)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i != start &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        comb.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">        <span class="built_in">dfs</span>(result, candidates, comb, target - candidates[i], i + <span class="number">1</span>);</span><br><span class="line">        comb.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="41-给定一个数组，找到第一个缺失的正数"><a href="#41-给定一个数组，找到第一个缺失的正数" class="headerlink" title="41 给定一个数组，找到第一个缺失的正数"></a>41 给定一个数组，找到第一个缺失的正数</h2><p>显然，结果的范围是 [1..n+1]. 而数组的长度为 n 我们把每个位置都放上 i+1,<br>这样如果有位置不是 i+1, 则找到了结果，如果都相等则是 n+1.</p>
<details>
    <summary>c 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *a; *a = *b; *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        <span class="comment">// 注意此处的 while</span></span><br><span class="line">        <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= numsSize &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>])</span><br><span class="line">            swap(&amp;nums[i], &amp;nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numsSize + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="42-给定一个数组表示柱子的高度，求能存贮的雨水的总量"><a href="#42-给定一个数组表示柱子的高度，求能存贮的雨水的总量" class="headerlink" title="42 给定一个数组表示柱子的高度，求能存贮的雨水的总量"></a>42 给定一个数组表示柱子的高度，求能存贮的雨水的总量</h2><p>从两边向中间收拢</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>* height, <span class="type">int</span> heightSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = heightSize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_left = <span class="number">0</span>, max_right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从两侧向中间缩小，可以算作是两个指针吧</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt;= height[right]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[left] &gt;= max_left)</span><br><span class="line">                max_left = height[left];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                water += max_left - height[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[right] &gt;= max_right)</span><br><span class="line">                max_right = height[right];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                water += max_right - height[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> water;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trap</span>(height: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> height.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">left</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">right</span> = height.<span class="title function_ invoke__">len</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">water</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max_left</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max_right</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right &#123;</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt;= height[right] &#123;</span><br><span class="line">                <span class="keyword">if</span> height[left] &gt;= max_left &#123;</span><br><span class="line">                    max_left = height[left];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    water += max_left - height[left];</span><br><span class="line">                &#125;</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> height[right] &gt;= max_right &#123;</span><br><span class="line">                    max_right = height[right];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    water += max_right - height[right];</span><br><span class="line">                &#125;</span><br><span class="line">                right -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        water</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
t

<h2 id="43-给定两个任意长的字符串，返回一个字符串，代表他们相乘的结果"><a href="#43-给定两个任意长的字符串，返回一个字符串，代表他们相乘的结果" class="headerlink" title="43 给定两个任意长的字符串，返回一个字符串，代表他们相乘的结果"></a>43 给定两个任意长的字符串，返回一个字符串，代表他们相乘的结果</h2><p>按整数除法运算即可，重点是下标的表示</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> tonum(c) (c - <span class="string">&#x27;0&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tochar(i) (i + <span class="string">&#x27;0&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">multiply</span><span class="params">(<span class="type">char</span>* num1, <span class="type">char</span>* num2)</span> &#123;</span><br><span class="line">    <span class="comment">// 结果的长度不会超过 m+n,</span></span><br><span class="line">    <span class="comment">// 假设某个数是 n 位的 9, 则结果比另一个数结尾加上 n 个 0 还小</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(num1), m = <span class="built_in">strlen</span>(num2);</span><br><span class="line">    <span class="type">int</span> len = m+n;</span><br><span class="line">    <span class="type">char</span>* result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        result[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    result[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> v = tonum(result[i+j+<span class="number">1</span>]) +  tonum(num1[i]) * tonum(num2[j]) + carry;</span><br><span class="line">            result[i+j+<span class="number">1</span>] = tochar(v % <span class="number">10</span>);</span><br><span class="line">            carry = v / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result[i] += carry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (result[i] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> result+i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="44-通配符匹配，-代表任意一个字符，-代表任意一个或多个字符"><a href="#44-通配符匹配，-代表任意一个字符，-代表任意一个或多个字符" class="headerlink" title="44 通配符匹配，? 代表任意一个字符，*代表任意一个或多个字符"></a>44 通配符匹配，<code>?</code> 代表任意一个字符，<code>*</code>代表任意一个或多个字符</h2><p>注意和正则表达式的区别，要求完全匹配。这道题的关键在于对星号的处理，如果出现星号的时候，我们记录当时的 p 和 s 的值，如果发生了不匹配的话，我们尝试回到该位置的下一个位置开始匹配</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isMatch</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* p)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* star = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>* revert = s;</span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s == *p || *p == <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            s++, p++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            star = p++, revert = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (star)</span><br><span class="line">            p = star + <span class="number">1</span>, s = ++revert;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果剩下了 p, 那应该全都是*才对</span></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p++ != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="45-跳跃游戏，给定一个数组，每个数字是在该位置可以向前移动的距离，返回最少需要多少次才能到达终点"><a href="#45-跳跃游戏，给定一个数组，每个数字是在该位置可以向前移动的距离，返回最少需要多少次才能到达终点" class="headerlink" title="45 跳跃游戏，给定一个数组，每个数字是在该位置可以向前移动的距离，返回最少需要多少次才能到达终点"></a>45 跳跃游戏，给定一个数组，每个数字是在该位置可以向前移动的距离，返回最少需要多少次才能到达终点</h2><p>比较简单，看注释吧</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> last = <span class="number">0</span>; <span class="comment">// last range</span></span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>; <span class="comment">// current range</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="comment">// beyond range, make another jump</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; last)</span><br><span class="line">            last = cur, steps++;</span><br><span class="line">        <span class="comment">// if we could reach longer?</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] + i &gt; cur)</span><br><span class="line">            cur = nums[i] + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="46-生成全排列"><a href="#46-生成全排列" class="headerlink" title="46 生成全排列"></a>46 生成全排列</h2><p>Cracking 上给出了一种解法，通过不断的添加下一个元素到上一组元素的不同位置来生成全排列，这样固然可以，但是大规模的拼接数组或者字符串是很耗费资源的。</p>
<p>在已经有了字符串（或者数组）的初始排列以后，可以通过不断交换的方法生成每一组全排列。<br>比如对于 xyz，我们有全排列为</p>
<pre><code>x + per(yx)
y + per(xz)
z + per(xy)
</code></pre>
<p>那么我们通过把每个元素交换到第一个位置，就把问题规模缩小了，知道把问题规模缩小为 1.</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">per</span>(result, nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">per</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> begin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意是从 begin 开始，这样未改变的才能加入进来</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[begin], nums[i]);</span><br><span class="line">        <span class="built_in">per</span>(result, nums, begin + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">swap</span>(nums[begin], nums[i]); <span class="comment">// 注意因为参数中是传引用，这里需要复原</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">permute</span>(nums: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt; = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">per</span>(&amp;<span class="keyword">mut</span> result, nums, <span class="number">0</span>);</span><br><span class="line">        result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">per</span>(result: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt;, nums: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;, begin: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> begin &gt;= nums.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">            result.<span class="title function_ invoke__">push</span>(nums);</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> begin..nums.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = nums.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">            nums.<span class="title function_ invoke__">swap</span>(begin, i);</span><br><span class="line">            <span class="keyword">Self</span>::<span class="title function_ invoke__">per</span>(result, nums, begin + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="47-全排列，数组中有重复元素"><a href="#47-全排列，数组中有重复元素" class="headerlink" title="47 全排列，数组中有重复元素"></a>47 全排列，数组中有重复元素</h2><p>和上一题基本是一样的，注意跳过重复元素就好了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">per</span>(result, nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">per</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start != i &amp;&amp; nums[start] == nums[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">swap</span>(nums[start], nums[i]);</span><br><span class="line">        <span class="built_in">per</span>(result, nums, start + <span class="number">1</span>); <span class="comment">// 事实证明，传引用反倒会超时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="48-给定一个n-n的图像旋转图像，顺时针旋转-90-度"><a href="#48-给定一个n-n的图像旋转图像，顺时针旋转-90-度" class="headerlink" title="48 给定一个n*n的图像旋转图像，顺时针旋转 90 度"></a>48 给定一个<code>n*n</code>的图像旋转图像，顺时针旋转 90 度</h2><p>做法显然是从里到外，一层一层的旋转，这道题主要考察下标的操作</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> layer = <span class="number">0</span>; layer &lt; n / <span class="number">2</span>; layer++) &#123;</span><br><span class="line">        <span class="type">int</span> first  = layer;</span><br><span class="line">        <span class="type">int</span> last = n - <span class="number">1</span> - layer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = first; i &lt; last; i++) &#123;</span><br><span class="line">            <span class="type">int</span> offset = i - first;</span><br><span class="line">            <span class="type">int</span> top = matrix[first][i];</span><br><span class="line">            <span class="comment">// up &lt;- left</span></span><br><span class="line">            matrix[first][i] = matrix[last-offset][first];</span><br><span class="line">            <span class="comment">// left &lt;- down</span></span><br><span class="line">            matrix[last-offset][first] = matrix[last][last-offset];</span><br><span class="line">            <span class="comment">// down &lt;- right</span></span><br><span class="line">            matrix[last][last-offset] = matrix[i][last];</span><br><span class="line">            <span class="comment">// right &lt;- up</span></span><br><span class="line">            matrix[i][last] = top;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="49-给定字符数组，把他们按照-Anagram-分组"><a href="#49-给定字符数组，把他们按照-Anagram-分组" class="headerlink" title="49 给定字符数组，把他们按照 Anagram 分组"></a>49 给定字符数组，把他们按照 Anagram 分组</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Anagram 分组</span></span><br><span class="line"><span class="comment">// 这道题没什么可做的，只需要统计</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    string temp;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; records;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        temp = strs[i];</span><br><span class="line">        <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">        records[temp].<span class="built_in">push_back</span>(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; record : records) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(record.second.<span class="built_in">begin</span>(), record.second.<span class="built_in">end</span>());</span><br><span class="line">        result.<span class="built_in">push_back</span>(record.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="50-实现-pow-x-n"><a href="#50-实现-pow-x-n" class="headerlink" title="50 实现 pow(x, n)"></a>50 实现 pow(x, n)</h2><p>显然不能直接阶乘过去，分治法</p>
<p>递归做法</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == INT_MIN) <span class="keyword">return</span> myPow(x, n - <span class="number">1</span>) * x;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> / myPow(x, -n);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">double</span> y = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">0x1</span>)</span><br><span class="line">        <span class="keyword">return</span> y * y * x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> y * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>迭代做法</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iteratively</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> p)</span> &#123;</span><br><span class="line">    <span class="type">double</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span> / myPow(x, -p);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            result *= x;</span><br><span class="line">        x *= x;</span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="51-N-皇后问题"><a href="#51-N-皇后问题" class="headerlink" title="51 N 皇后问题"></a>51 N 皇后问题</h2><p>需要大幅度修改</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N 皇后问题，皇后不能再一条直线，一条竖线，一条斜线上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用深度优先求解，对于 dfs 问题，我们首先把算法的框架写下来，然后确定这个问题的限制条件</span></span><br><span class="line"><span class="comment">// 对于这个问题，限制条件当前行的元素不能在以前的列中出现过，也不能在对角线中出现过</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">x</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, x, n);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> t, vector&lt;<span class="type">int</span>&gt;&amp; x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当新添加一个 Q 到当前解的时候</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt;= n) &#123;</span><br><span class="line">        <span class="comment">// result.push_back(make_solution(x));</span></span><br><span class="line">        <span class="comment">// return;</span></span><br><span class="line">        vector&lt;string&gt; solution;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="function">string <span class="title">line</span><span class="params">(n, <span class="string">&#x27;.&#x27;</span>)</span></span>;</span><br><span class="line">            line[x[i]] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            solution.<span class="built_in">push_back</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(solution);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">bool</span> skip = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x[j] == i || <span class="built_in">abs</span>(i - x[j]) == <span class="built_in">abs</span>(t - j)) &#123;</span><br><span class="line">                    skip = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (skip) <span class="keyword">continue</span>;</span><br><span class="line">            x[t] = i;</span><br><span class="line">            <span class="built_in">dfs</span>(t+<span class="number">1</span>, x, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="52-N-皇后一共有多少个解"><a href="#52-N-皇后一共有多少个解" class="headerlink" title="52 N 皇后一共有多少个解"></a>52 N 皇后一共有多少个解</h2><p>不要直接把皇后放好，而是把占用的都记录下来，然后继续深度优先搜索</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; cols, digs1, digs2;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">total</span>(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">total</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> count, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cols.<span class="built_in">find</span>(col) != cols.<span class="built_in">end</span>()</span><br><span class="line">                || digs1.<span class="built_in">find</span>(row - col) != digs1.<span class="built_in">end</span>()</span><br><span class="line">                || digs2.<span class="built_in">find</span>(row + col) != digs2.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (row == n<span class="number">-1</span>)</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cols.<span class="built_in">insert</span>(col);</span><br><span class="line">                digs1.<span class="built_in">insert</span>(row-col);</span><br><span class="line">                digs2.<span class="built_in">insert</span>(row+col);</span><br><span class="line">                count = <span class="built_in">total</span>(row+<span class="number">1</span>, count, n);</span><br><span class="line">                cols.<span class="built_in">erase</span>(col);</span><br><span class="line">                digs1.<span class="built_in">erase</span>(row-col);</span><br><span class="line">                digs2.<span class="built_in">erase</span>(row+col);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="53-最大子序列和"><a href="#53-最大子序列和" class="headerlink" title="53 最大子序列和"></a>53 最大子序列和</h2><p>动态规划经典题目，遍历数组，如果已经当前子序列已经小于 0 了，抛弃并置 sum &#x3D; 0<br>如果比当前和更大，更新。对于一个子序列，要么使得序列和增大，要么减小。</p>
<p><code>dp[n+1] = max(dp[n], dp[n] + A[n+1])</code></p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>; i&lt; numsSize; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; m)</span><br><span class="line">            m = sum;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        current_sum = <span class="number">0</span></span><br><span class="line">        max_value = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            current_sum += i</span><br><span class="line">            max_value = <span class="built_in">max</span>(max_value, current_sum)</span><br><span class="line">            current_sum = <span class="built_in">max</span>(<span class="number">0</span>, current_sum)</span><br><span class="line">        <span class="keyword">return</span> max_value</span><br></pre></td></tr></table></figure>
</details>


<h2 id="54-顺时针螺旋打印矩阵"><a href="#54-顺时针螺旋打印矩阵" class="headerlink" title="54 顺时针螺旋打印矩阵"></a>54 顺时针螺旋打印矩阵</h2><p>一圈一圈地打印就好了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row == <span class="number">0</span> || col == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>, right = col - <span class="number">1</span>, down = row - <span class="number">1</span>, left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * row * col);</span><br><span class="line">    <span class="keyword">while</span> (top &lt;= down &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">            result[index++] = matrix[top][i];</span><br><span class="line">        top++; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = top; i &lt;= down; i++)</span><br><span class="line">            result[index++] = matrix[i][right];</span><br><span class="line">        right--; <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 注意这个 if 语句</span></span><br><span class="line">        <span class="keyword">if</span> (top &lt;= down)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = right; i &gt;= left; i--)</span><br><span class="line">                result[index++] = matrix[down][i];</span><br><span class="line">        down--; <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 注意这个 if 语句</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = down; i &gt;= top; i--)</span><br><span class="line">                result[index++] = matrix[i][left];</span><br><span class="line">        left++; <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="55-给定一个数组，每个数字表示在当前步可以移动的距离，返回是不是能够到达终点"><a href="#55-给定一个数组，每个数字表示在当前步可以移动的距离，返回是不是能够到达终点" class="headerlink" title="55 给定一个数组，每个数字表示在当前步可以移动的距离，返回是不是能够到达终点"></a>55 给定一个数组，每个数字表示在当前步可以移动的距离，返回是不是能够到达终点</h2><p>使用动态规划求解，如果当前距离大于最远距离，更新最远距离，如果已经超过了最远距离，跳出</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> reach = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize &amp;&amp; i &lt;= reach; i++)</span><br><span class="line">            reach = max(reach, nums[i] + i);</span><br><span class="line">    <span class="keyword">return</span> i == numsSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="56-合并序列，给定一组序列，把其中重叠的序列合并"><a href="#56-合并序列，给定一组序列，把其中重叠的序列合并" class="headerlink" title="56 合并序列，给定一组序列，把其中重叠的序列合并"></a>56 合并序列，给定一组序列，把其中重叠的序列合并</h2><p>这道题用 Python 做竟然比用 C++ 还要快</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">class Interval(object):</span></span><br><span class="line"><span class="string">    def __init__(self, start=0, end=0):</span></span><br><span class="line"><span class="string">        self.start = start</span></span><br><span class="line"><span class="string">        self.end= end</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">intervals</span>):</span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x.start)</span><br><span class="line">    combined = []</span><br><span class="line">    <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="keyword">if</span> combined <span class="keyword">and</span> interval.start &lt;= combined[-<span class="number">1</span>].end:</span><br><span class="line">            combined[-<span class="number">1</span>].end = <span class="built_in">max</span>(combined[-<span class="number">1</span>].end, interval.end)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            combined.append(interval)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure>
</details>


<h2 id="57-添加序列，给定一组已经排序的序列，向其中插入一个序列，需要合并的合并"><a href="#57-添加序列，给定一组已经排序的序列，向其中插入一个序列，需要合并的合并" class="headerlink" title="57 添加序列，给定一组已经排序的序列，向其中插入一个序列，需要合并的合并"></a>57 添加序列，给定一组已经排序的序列，向其中插入一个序列，需要合并的合并</h2><p>把剩余的部分都拷贝过来也不失为一种机智的做法。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, intervals, newInterval</span>):</span><br><span class="line">        ans = []</span><br><span class="line">        start, end = newInterval</span><br><span class="line">        remainder = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="comment"># 未重叠</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; y:</span><br><span class="line">                ans.append([x, y])</span><br><span class="line">            <span class="comment"># 进入重叠状态</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> end &lt; x:  <span class="comment"># 当前区间已经不重叠了</span></span><br><span class="line">                    <span class="keyword">break</span>  <span class="comment"># 找到了结尾了</span></span><br><span class="line">                start = <span class="built_in">min</span>(start, x)</span><br><span class="line">                end = <span class="built_in">max</span>(end, y)</span><br><span class="line">            remainder += <span class="number">1</span></span><br><span class="line">        ans.append([start, end])</span><br><span class="line">        ans += intervals[remainder:]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>



<h2 id="58-给定一个字符串，求其中最后一个单词的长度"><a href="#58-给定一个字符串，求其中最后一个单词的长度" class="headerlink" title="58 给定一个字符串，求其中最后一个单词的长度"></a>58 给定一个字符串，求其中最后一个单词的长度</h2><p>显然这道题可以用 strlen 求出长度然后从后往前数，但是，这样相当于多遍历了一次<br>直接从后往前可以保证只遍历一次</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLastWord</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> inWord = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(*s)) &#123;</span><br><span class="line">            inWord = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!inWord) &#123;</span><br><span class="line">                len = <span class="number">1</span>;</span><br><span class="line">                inWord = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="59-给定-n，把-1-2-3-…-螺旋打印到矩阵中"><a href="#59-给定-n，把-1-2-3-…-螺旋打印到矩阵中" class="headerlink" title="59 给定 n，把 1, 2, 3 … 螺旋打印到矩阵中"></a>59 给定 n，把 1, 2, 3 … 螺旋打印到矩阵中</h2><p>和上一个完全一样的思路，只是这次是打印罢了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays.</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>** <span class="title function_">generateMatrix</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>** matrix = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        matrix[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>, left = <span class="number">0</span>, down = n - <span class="number">1</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (top &lt;= down &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;=right; i++)</span><br><span class="line">            matrix[top][i] = a++;</span><br><span class="line">        top++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = top; i &lt;= down; i++) &#123;</span><br><span class="line">            matrix[i][right] = a++;</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="keyword">if</span> (top &lt;= down)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = right; i &gt;= left; i--)</span><br><span class="line">                matrix[down][i] = a++;</span><br><span class="line">        down--;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = down; i &gt;= top; i--)</span><br><span class="line">                matrix[i][left] = a++;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="60-给定-n-个数字，找出第-k-个-Permutation"><a href="#60-给定-n-个数字，找出第-k-个-Permutation" class="headerlink" title="60 给定 n 个数字，找出第 k 个 Permutation"></a>60 给定 n 个数字，找出第 k 个 Permutation</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*The logic is as follows:</span></span><br><span class="line"><span class="comment">    for n numbers the permutations can be divided to (n-1)! groups,</span></span><br><span class="line"><span class="comment">    thus k/(n-1)! indicates the index of current number,</span></span><br><span class="line"><span class="comment">    and k%(n-1)! denotes remaining sequence (to the right).</span></span><br><span class="line"><span class="comment">    We keep doing this until n reaches 0, then we get n numbers permutations that is kth.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">string <span class="title">getPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">        <span class="function">string <span class="title">s</span><span class="params">(n, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            f *= i;</span><br><span class="line">            s[i<span class="number">-1</span>] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 给定 n, 一共有 n! 个序列，f == n!</span></span><br><span class="line"></span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            f /= n - i; <span class="comment">// f /= n, f /= n - 1 ...</span></span><br><span class="line">            <span class="type">int</span> j = i + k / f;</span><br><span class="line">            <span class="type">char</span> c= s[j];</span><br><span class="line">            <span class="keyword">for</span> (;j &gt; i; j--) <span class="comment">// shift space to put `c`, actually we could use swap</span></span><br><span class="line">                s[j] = s[j<span class="number">-1</span>];</span><br><span class="line">            s[i] = c;</span><br><span class="line">            k %= f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="61-把列表旋转到倒数第-k-位"><a href="#61-把列表旋转到倒数第-k-位" class="headerlink" title="61 把列表旋转到倒数第 k 位"></a>61 把列表旋转到倒数第 k 位</h2><p>需要注意的是 k 大于列表长度的情况，这时候需要取余</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">rotateRight</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">n</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (n-&gt;next) &#123;</span><br><span class="line">        n = n-&gt;next;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n is now the tail!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k &gt;= l) k %= l;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="type">int</span> i = l - k;</span><br><span class="line">    <span class="keyword">while</span> (i--)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">    dummy.next = p-&gt;next;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    n-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="62-给定一个m-n的矩阵，有多少种方法从左上角移动到右下角"><a href="#62-给定一个m-n的矩阵，有多少种方法从左上角移动到右下角" class="headerlink" title="62 给定一个m*n的矩阵，有多少种方法从左上角移动到右下角"></a>62 给定一个<code>m*n</code>的矩阵，有多少种方法从左上角移动到右下角</h2><p>显然可以使用组合数学直接求出来解，但是容易溢出。而且这是一道经典的动态规划题目，对于<br>每个格子，可以从他的上部或者左面移动过来。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            grid[i][j] = grid[i - <span class="number">1</span>][j] + grid[i][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="63-同上题，区别是在一些位置是有障碍物的"><a href="#63-同上题，区别是在一些位置是有障碍物的" class="headerlink" title="63 同上题，区别是在一些位置是有障碍物的"></a>63 同上题，区别是在一些位置是有障碍物的</h2><p>经过分析可知，递推关系是一样的，只需要把有障碍格子的到达方法设定为 0。这个主要是实现上的一些技巧，<br>见注释。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>(), n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 注意设定长宽均 +1，但是初始化为 0，边界就成了障碍</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathes</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    pathes[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 给定一个入口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++)</span><br><span class="line">            <span class="comment">// 注意此处的偏移</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="number">1</span>)</span><br><span class="line">                pathes[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pathes[i][j] = pathes[i<span class="number">-1</span>][j] + pathes[i][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> pathes[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="64-给定一个m-n矩阵，每个数字代表经过该处的耗费，找出一条耗费最小的路径"><a href="#64-给定一个m-n矩阵，每个数字代表经过该处的耗费，找出一条耗费最小的路径" class="headerlink" title="64 给定一个m*n矩阵，每个数字代表经过该处的耗费，找出一条耗费最小的路径"></a>64 给定一个<code>m*n</code>矩阵，每个数字代表经过该处的耗费，找出一条耗费最小的路径</h2><p>依然是动态规划</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if modifying the grid is disallowed, copy it</span></span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>)</span><br><span class="line">                grid[i][j] += grid[i][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                grid[i][j] += grid[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                grid[i][j] += <span class="built_in">min</span>(grid[i<span class="number">-1</span>][j], grid[i][j<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> grid[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="65-判定一个字符串是否是合法的数字，包括了正负号，小数点，e等"><a href="#65-判定一个字符串是否是合法的数字，包括了正负号，小数点，e等" class="headerlink" title="65 判定一个字符串是否是合法的数字，包括了正负号，小数点，e等"></a>65 判定一个字符串是否是合法的数字，包括了正负号，小数点，<code>e</code>等</h2><p>一些例子：</p>
<pre><code>&quot;0&quot; =&gt; true
&quot; 0.1 &quot; =&gt; true
&quot;abc&quot; =&gt; false
&quot;1 a&quot; =&gt; false
&quot;2e10&quot; =&gt; true
</code></pre>
<p>这道题就是细节题，用 C 处理字符串太蛋疼了，直接上 Python 了</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isNumber</span>(<span class="params">self, s</span>):</span><br><span class="line">    BEFORE = <span class="number">0</span> <span class="comment"># before dot</span></span><br><span class="line">    AFTER = <span class="number">1</span> <span class="comment"># after dot</span></span><br><span class="line">    EXP = <span class="number">2</span> <span class="comment"># after e</span></span><br><span class="line">    phase = BEFORE</span><br><span class="line">    allow_sign = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    s = s.strip()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">any</span>([c.isdigit() <span class="keyword">for</span> c <span class="keyword">in</span> s]):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> s[-<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> s == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> <span class="keyword">and</span> s[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> <span class="keyword">and</span> s[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">            allow_sign = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">            allow_sign = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> phase == EXP <span class="keyword">or</span> phase == AFTER:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                phase = AFTER</span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> phase == EXP:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            allow_sign = <span class="literal">True</span></span><br><span class="line">            phase = EXP</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;-&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> allow_sign:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            allow_sign = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> phase == EXP:</span><br><span class="line">        <span class="keyword">return</span> s[-<span class="number">1</span>].isdigit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="66-给定一个字符串代表的数字，返回加-1-后的数字"><a href="#66-给定一个字符串代表的数字，返回加-1-后的数字" class="headerlink" title="66 给定一个字符串代表的数字，返回加 1 后的数字"></a>66 给定一个字符串代表的数字，返回加 1 后的数字</h2><p>乍一看如果需要进位的话，可能需要拷贝整个数组。实际上并不需要，我们知道只有当数字是 999…999 的时候，才会使得数字的长度 +1 变为 1000…000。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = digits.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits[i] == <span class="number">9</span>) &#123;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            digits[i]++;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// trick here, we know that the number is 999...999</span></span><br><span class="line">    digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    digits.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">plus_one</span>(<span class="keyword">mut</span> digits: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">0</span>..digits.<span class="title function_ invoke__">len</span>()).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">            <span class="keyword">match</span> digits[i] &#123;</span><br><span class="line">                <span class="number">9</span> =&gt; digits[i] = <span class="number">0</span>,</span><br><span class="line">                _ =&gt; &#123;digits[i] += <span class="number">1</span>; <span class="keyword">return</span> digits&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        digits.<span class="title function_ invoke__">push</span>(<span class="number">0</span>);</span><br><span class="line">        digits</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="67-给定两个字符串代表的二进制数字，返回他们相加的和"><a href="#67-给定两个字符串代表的二进制数字，返回他们相加的和" class="headerlink" title="67 给定两个字符串代表的二进制数字，返回他们相加的和"></a>67 给定两个字符串代表的二进制数字，返回他们相加的和</h2><p>和上一题一样，按照加法定义做就好了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> tonum(c) (c - <span class="string">&#x27;0&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tochar(i) (i + <span class="string">&#x27;0&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">addBinary</span><span class="params">(<span class="type">char</span>* a, <span class="type">char</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(a), n = <span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="type">int</span> len = (m &gt; n ? m : n) + <span class="number">1</span>; <span class="comment">// strlen(c)</span></span><br><span class="line">    <span class="type">char</span>* c = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * len + <span class="number">1</span>); <span class="comment">// with ending null</span></span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="string">&#x27;0&#x27;</span>, len+<span class="number">1</span>);</span><br><span class="line">    c[len] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">         c[len-i] = tochar((i &lt;= m ? tonum(a[m-i]) : <span class="number">0</span>) ^ (i &lt;= n ? tonum(b[n-i]) : <span class="number">0</span>) ^ carry);</span><br><span class="line">         carry = ((i &lt;= m ? tonum(a[m-i]) : <span class="number">0</span>) + (i &lt;= n ? tonum(b[n-i]) : <span class="number">0</span>) + carry) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> ? c+<span class="number">1</span> : c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="68-文字对齐"><a href="#68-文字对齐" class="headerlink" title="68 文字对齐"></a>68 文字对齐</h2><p>待研究</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">fullJustify</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="type">int</span> L)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, k, l; i &lt; words.<span class="built_in">size</span>(); i += k) &#123;</span><br><span class="line">        <span class="keyword">for</span>(k = l = <span class="number">0</span>; i + k &lt; words.<span class="built_in">size</span>() <span class="keyword">and</span> l + words[i+k].<span class="built_in">size</span>() &lt;= L - k; k++) &#123;</span><br><span class="line">            l += words[i+k].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        string tmp = words[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i + k &gt;= words.<span class="built_in">size</span>()) tmp += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> tmp += <span class="built_in">string</span>((L - l) / (k - <span class="number">1</span>) + (j &lt; (L - l) % (k - <span class="number">1</span>)), <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            tmp += words[i+j+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        tmp += <span class="built_in">string</span>(L - tmp.<span class="built_in">size</span>(), <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="69-给定整数-x，求-sqrt-x"><a href="#69-给定整数-x，求-sqrt-x" class="headerlink" title="69 给定整数 x，求 sqrt(x)"></a>69 给定整数 x，求 sqrt(x)</h2><p>比较坑的是 LeetCode 要求的是 <code>y*y &lt; x</code> 的最大整数</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> EPS = x * <span class="number">0.0001</span>;</span><br><span class="line">    <span class="type">double</span> y = x / <span class="number">2</span>; <span class="comment">// initial guess</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(y * y - x) &gt; EPS) &#123;</span><br><span class="line">        y = (y + x / y) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> z = (<span class="type">long</span>) y;</span><br><span class="line">    <span class="keyword">while</span> (z * z &gt; x) z--;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="70-爬梯子，一次可以爬一步或者两步，有几种方法爬完梯子"><a href="#70-爬梯子，一次可以爬一步或者两步，有几种方法爬完梯子" class="headerlink" title="70 爬梯子，一次可以爬一步或者两步，有几种方法爬完梯子"></a>70 爬梯子，一次可以爬一步或者两步，有几种方法爬完梯子</h2><p>斐波那契数列，也可以理解为动态规划</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        t = b, b += a, a = t;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="71-简化-Unix-路径，需要处理-和多个斜杠等情况"><a href="#71-简化-Unix-路径，需要处理-和多个斜杠等情况" class="headerlink" title="71 简化 Unix 路径，需要处理., .. 和多个斜杠等情况"></a>71 简化 Unix 路径，需要处理<code>.</code>, <code>..</code> 和多个斜杠等情况</h2><p>没有什么需要注意的，主要是使用 stringstream 用作 string.split</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">simplifyPath</span><span class="params">(string&amp; path)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; dirs;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(path)</span></span>;</span><br><span class="line">    string dir;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, dir, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dir == <span class="string">&quot;.&quot;</span> || dir == <span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dir == <span class="string">&quot;..&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dirs.<span class="built_in">empty</span>())</span><br><span class="line">            dirs.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            dirs.<span class="built_in">push_back</span>(dir);</span><br><span class="line">    &#125;</span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; dir : dirs)</span><br><span class="line">        <span class="keyword">if</span> (!dir.<span class="built_in">empty</span>())</span><br><span class="line">            result += <span class="string">&quot;/&quot;</span> + dir;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">size</span>() ? result : <span class="string">&quot;/&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="72-编辑距离，允许替换，删除，插入三种操作"><a href="#72-编辑距离，允许替换，删除，插入三种操作" class="headerlink" title="72 编辑距离，允许替换，删除，插入三种操作"></a>72 编辑距离，允许替换，删除，插入三种操作</h2><p>对于两个字符串比较，往往要使用二维的动态规划。<br>使用 f[i][j] 表示 word1[1..i] 和 word2[1..j] 之间的距离。<br>see <a target="_blank" rel="noopener" href="https://leetcode.com/discuss/43398/20ms-detailed-explained-c-solutions-o-n-space">here</a></p>
<p>那么：</p>
<ol>
<li><p>相等 f[i][j] &#x3D; f[i-1][j-1];</p>
</li>
<li><p>不相等</p>
<ol>
<li>替换：f[i][j] &#x3D; f[i-1][j-1] + 1;  都向前一步</li>
<li>添加：f[i][j] &#x3D; f[i][j-1] + 1; word2 向前一步</li>
<li>删除：f[i][j] &#x3D; f[i-1][j] + 1; word1 向前一步</li>
</ol>
</li>
</ol>
<p>另外使用一维数组表示二维数组还需要了解</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// unoptimized code</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = word1.<span class="built_in">length</span>(), n = word2.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>, <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j] + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// optimized</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = word1.<span class="built_in">length</span>(), n = word2.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cur</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 把剩余的字符删掉的距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        cur[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="type">int</span> pre = cur[<span class="number">0</span>];</span><br><span class="line">        cur[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = cur[i];</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                cur[i] = pre;</span><br><span class="line">            <span class="keyword">else</span> cur[i] = <span class="built_in">min</span>(pre + <span class="number">1</span>, <span class="built_in">min</span>(cur[i] + <span class="number">1</span>, cur[i - <span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive code from beauty of programming</span></span><br><span class="line"><span class="comment">// TLE on LeetCode</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">minDistance</span>(&amp;word1.<span class="built_in">front</span>(), &amp;word1.<span class="built_in">back</span>(), &amp;word2.<span class="built_in">front</span>(), &amp;word2.<span class="built_in">back</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">minDistance</span>(<span class="type">char</span>* start1, <span class="type">char</span>* end1, <span class="type">char</span>* start2, <span class="type">char</span>* end2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (start1 &gt; end1)</span><br><span class="line">        <span class="keyword">return</span> start2 &gt; end2 ? <span class="number">0</span> : end2 - start2 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start2 &gt; end2)</span><br><span class="line">        <span class="keyword">return</span> start1 &gt; end1 ? <span class="number">0</span> : end1 - start1 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*start1 == *start2)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">minDistance</span>(start1 + <span class="number">1</span>, end1, start2 + <span class="number">1</span>, end2);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> t1 = <span class="built_in">minDistance</span>(start1 + <span class="number">1</span>, end1, start2 + <span class="number">1</span>, end2);</span><br><span class="line">        <span class="type">int</span> t2 = <span class="built_in">minDistance</span>(start1 + <span class="number">1</span>, end1, start2, end2);</span><br><span class="line">        <span class="type">int</span> t3 = <span class="built_in">minDistance</span>(start1, end1, start2 + <span class="number">1</span>, end2);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(t1, <span class="built_in">min</span>(t2, t3)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="73-给定一个矩阵，如果某个元素为零，把所在的行和所在的列都设为零"><a href="#73-给定一个矩阵，如果某个元素为零，把所在的行和所在的列都设为零" class="headerlink" title="73 给定一个矩阵，如果某个元素为零，把所在的行和所在的列都设为零"></a>73 给定一个矩阵，如果某个元素为零，把所在的行和所在的列都设为零</h2><p>一种可以接受的方法是使用 O(m+n) 的空间，记录哪行哪列需要设为零</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">row</span><span class="params">(m)</span>, <span class="title">column</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                row[i] = <span class="literal">true</span>, column[j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (row[i] || column[j])</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="74-搜索矩阵，矩阵每行从左到右依次增大，每行都比上一行大"><a href="#74-搜索矩阵，矩阵每行从左到右依次增大，每行都比上一行大" class="headerlink" title="74 搜索矩阵，矩阵每行从左到右依次增大，每行都比上一行大"></a>74 搜索矩阵，矩阵每行从左到右依次增大，每行都比上一行大</h2><p>当做数组直接二分搜索就可以了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = row * col - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix[mid/col][mid%col] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[mid/col][mid%col] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="75-颜色排序，每个物体有颜色属性，把他们按照-RGB-的顺序排序-🇳🇱国旗问题）"><a href="#75-颜色排序，每个物体有颜色属性，把他们按照-RGB-的顺序排序-🇳🇱国旗问题）" class="headerlink" title="75 颜色排序，每个物体有颜色属性，把他们按照 RGB 的顺序排序 (🇳🇱国旗问题）"></a>75 颜色排序，每个物体有颜色属性，把他们按照 RGB 的顺序排序 (🇳🇱国旗问题）</h2><p>一种方法是简单地 2 pass 解法，遍历一遍计数再输出。另一种方法是把红色往前交换，蓝色往后交换</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *a; *a = *b; *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> RED = <span class="number">0</span>, GREEN = <span class="number">1</span>, BLUE = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> reds = <span class="number">0</span>,  blues = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= blues; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] == BLUE &amp;&amp; i &lt; blues) swap(&amp;nums[i], &amp;nums[blues--]);</span><br><span class="line">        <span class="keyword">while</span> (nums[i] == RED &amp;&amp; i &gt; reds) swap(&amp;nums[i], &amp;nums[reds++]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>76 跳过</p>
<h2 id="77-给定数字-n-和-k，生成从-n-中取出-k-个数字的所有情况"><a href="#77-给定数字-n-和-k，生成从-n-中取出-k-个数字的所有情况" class="headerlink" title="77 给定数字 n 和 k，生成从 n 中取出 k 个数字的所有情况"></a>77 给定数字 n 和 k，生成从 n 中取出 k 个数字的所有情况</h2><p>数学上的组合，使用回溯来做，对状态空间进行深度搜索。</p>
<p>回溯方法通常适合对状态空间树的深度优先搜索相结合的，当一个解已经不满足条件时，剪枝；<br>如果满足条件，直到找到完全解未知。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合是不要求顺序的</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; k)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">0</span>, k)</span></span>;</span><br><span class="line">    <span class="built_in">combine</span>(result, temp, <span class="number">0</span>, <span class="number">0</span>, n, k);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">combine</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt;&amp; temp, <span class="type">int</span> start, <span class="type">int</span> count, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 回溯条件，找到了一个解</span></span><br><span class="line">    <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 深度优先搜索</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; n; i++) &#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 只搜索比 i 大的即可</span></span><br><span class="line">        <span class="built_in">combine</span>(result, temp, i+ <span class="number">1</span>, count+<span class="number">1</span>, n, k);</span><br><span class="line">        temp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="78-给定一个集合，找到它的所有子集"><a href="#78-给定一个集合，找到它的所有子集" class="headerlink" title="78 给定一个集合，找到它的所有子集"></a>78 给定一个集合，找到它的所有子集</h2><p>这道题至少有 3 种解法：</p>
<ol>
<li>DFS，我们知道对于 n 个元素的集合，有 2^n 个子集，通过每个元素在不在子集中构造一个状态空间树</li>
<li>类似于电话键盘生成字母，迭代</li>
<li>巧妙的利用 1..2^n 对应</li>
</ol>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use backtracking and do a dfs search</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="built_in">subsets</span>(nums, result, temp, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for each solution, the can be divided into two sub solutions: in or out</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">subsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt; temp, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t = temp;</span><br><span class="line">    <span class="built_in">subsets</span>(nums, result, temp, i + <span class="number">1</span>);</span><br><span class="line">    temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">    <span class="built_in">subsets</span>(nums, result, temp, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iterative</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    result.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, nums[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> size = result.<span class="built_in">size</span>(); <span class="comment">// notice the cached size</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> new_subset = result[j];</span><br><span class="line">            new_subset.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">sort</span>(new_subset.<span class="built_in">begin</span>(), new_subset.<span class="built_in">end</span>());</span><br><span class="line">            result.<span class="built_in">push_back</span>(new_subset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tricky</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="type">int</span> size = (<span class="number">1</span> &lt;&lt; nums.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; subset;</span><br><span class="line">        <span class="type">int</span> k = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &amp; <span class="number">0x1</span>)</span><br><span class="line">                subset.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(subset.<span class="built_in">begin</span>(), subset.<span class="built_in">end</span>());</span><br><span class="line">        result.<span class="built_in">push_back</span>(subset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="79-给定一个二维字符数组，查找一个单词是否能够有连续的字母构成，不能交叉"><a href="#79-给定一个二维字符数组，查找一个单词是否能够有连续的字母构成，不能交叉" class="headerlink" title="79 给定一个二维字符数组，查找一个单词是否能够有连续的字母构成，不能交叉"></a>79 给定一个二维字符数组，查找一个单词是否能够有连续的字母构成，不能交叉</h2><p>也是深度优先的做法，首先找到开始的字母，然后依次向上下左右查找，注意还需要统计有没有访问过</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> row = board.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> col = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(row, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; (col, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">findNext</span>(board, word, visited, i, j, <span class="number">0</span>))</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">findNext</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string&amp; word, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == word.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (m &gt;= board.<span class="built_in">size</span>() || n &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || m &lt; <span class="number">0</span> || n &lt; <span class="number">0</span>|| visited[m][n] || board[m][n] != word[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">char</span> temp = board[m][n];</span><br><span class="line">    board[m][n] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> exist = <span class="built_in">findNext</span>(board, word, visited, m + <span class="number">1</span>, n, i+<span class="number">1</span>) ||</span><br><span class="line">        <span class="built_in">findNext</span>(board, word, visited, m - <span class="number">1</span>, n, i+<span class="number">1</span>) ||</span><br><span class="line">        <span class="built_in">findNext</span>(board, word, visited, m, n+<span class="number">1</span>, i+<span class="number">1</span>) ||</span><br><span class="line">        <span class="built_in">findNext</span>(board, word, visited, m, n<span class="number">-1</span>, i+<span class="number">1</span>);</span><br><span class="line">    board[m][n] = temp;</span><br><span class="line">    <span class="keyword">return</span> exist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="80-从排序数组中删除重复元素，但是允许一个元素重复出现两次"><a href="#80-从排序数组中删除重复元素，但是允许一个元素重复出现两次" class="headerlink" title="80 从排序数组中删除重复元素，但是允许一个元素重复出现两次"></a>80 从排序数组中删除重复元素，但是允许一个元素重复出现两次</h2><p>巧妙地解法，和<code>i-2</code>的元素对比</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums || numsSize &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>, counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span> || nums[i] != nums[len<span class="number">-2</span>])</span><br><span class="line">            nums[len++] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="81-在被翻转的数组中查找元素，可能包含重复元素"><a href="#81-在被翻转的数组中查找元素，可能包含重复元素" class="headerlink" title="81 在被翻转的数组中查找元素，可能包含重复元素"></a>81 在被翻转的数组中查找元素，可能包含重复元素</h2><p>经典题目，还是一个二分查找问题，只是要分很多种情况</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//return m in Search in Rotated Array I</span></span><br><span class="line">        <span class="keyword">if</span> (A[left] &lt; A[mid]) &#123; <span class="comment">//left half is sorted</span></span><br><span class="line">            <span class="keyword">if</span> (A[left] &lt;= key &amp;&amp; key &lt; A[mid])</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[left] &gt; A[mid]) &#123; <span class="comment">//right half is sorted</span></span><br><span class="line">            <span class="keyword">if</span> (A[mid] &lt; key &amp;&amp; key &lt;= A[right])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// A[left] == A[mid]</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="82-从已经排序的链表中删除所有重复过的元素，只留下只出现一次的元素"><a href="#82-从已经排序的链表中删除所有重复过的元素，只留下只出现一次的元素" class="headerlink" title="82 从已经排序的链表中删除所有重复过的元素，只留下只出现一次的元素"></a>82 从已经排序的链表中删除所有重复过的元素，只留下只出现一次的元素</h2><p>考察链表操作</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;next &amp;&amp; p-&gt;next-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next-&gt;val == p-&gt;next-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">distinct</span> =</span> p-&gt;next;</span><br><span class="line">            <span class="type">int</span> dup = p-&gt;next-&gt;val;</span><br><span class="line">            <span class="keyword">while</span> (distinct &amp;&amp; distinct-&gt;val == dup) &#123;</span><br><span class="line">                distinct = distinct-&gt;next; <span class="comment">// <span class="doctag">TODO:</span> fix mem leak</span></span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;next = distinct;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="83-从已经排序的链表中删除所有重复过的元素，但是重复过的也留下一个，即，使新链表不重复"><a href="#83-从已经排序的链表中删除所有重复过的元素，但是重复过的也留下一个，即，使新链表不重复" class="headerlink" title="83 从已经排序的链表中删除所有重复过的元素，但是重复过的也留下一个，即，使新链表不重复"></a>83 从已经排序的链表中删除所有重复过的元素，但是重复过的也留下一个，即，使新链表不重复</h2><p>同样是考察链表基本操作</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy; dummy.next = head; dummy.val = head-&gt;val + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val == p-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="type">int</span> dup = p-&gt;val;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;val == dup)</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next; <span class="comment">// <span class="doctag">TODO:</span> fix mem leak</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="84-在柱状图中查找最大的矩形"><a href="#84-在柱状图中查找最大的矩形" class="headerlink" title="84 在柱状图中查找最大的矩形"></a>84 在柱状图中查找最大的矩形</h2><p>见注释</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    height.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="comment">// dummy end</span></span><br><span class="line">    <span class="type">int</span> result  =<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 总结，对于需要查找上一次最大元素的问题，可以考虑使用栈存储</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); ) &#123;</span><br><span class="line">        <span class="comment">// 当遇到更高的柱子时候，先存入堆栈</span></span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() || height[i] &gt; height[stk.<span class="built_in">top</span>()]) <span class="comment">// meet higher</span></span><br><span class="line">            stk.<span class="built_in">push</span>(i++);</span><br><span class="line">        <span class="comment">// 当遇到低一些的柱子时候，计算这些柱子到上一个更矮的柱子之间的最大举行，如果已经清空，说明之前所有柱子都更低</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// lower</span></span><br><span class="line">            <span class="type">int</span> h = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            result = <span class="built_in">max</span>(result, height[h] * (stk.<span class="built_in">empty</span>() ? i : i - stk.<span class="built_in">top</span>() <span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="85-最大的长方形"><a href="#85-最大的长方形" class="headerlink" title="85 最大的长方形"></a>85 最大的长方形</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>** matrix, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!matrix) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left[col], right[col], height[col];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; col; i++)</span><br><span class="line">        left[i] = <span class="number">0</span>, right[i] = col, height[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="type">int</span> cur_left = <span class="number">0</span>, cur_right = col;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)  <span class="comment">// 在第 j 列的高度</span></span><br><span class="line">                height[j]++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                height[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                left[j] = max(left[j], cur_left);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left[j] = <span class="number">0</span>, cur_left = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = col - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                right[j] = min(right[j], cur_right);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right[j] = col, cur_right = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            area = max(area, (right[j] - left[j]) * height[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="86-链表分区，要求把小于某个值得元素全都放到前面"><a href="#86-链表分区，要求把小于某个值得元素全都放到前面" class="headerlink" title="86 链表分区，要求把小于某个值得元素全都放到前面"></a>86 链表分区，要求把小于某个值得元素全都放到前面</h2><p>对于链表这道题很简单，分两个列表在合并就好了，问题是当我们处理类似的数组问题时，也有一种巧妙地 O(n) 的解法</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">partition</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">small</span>, *<span class="title">psmall</span> =</span> &amp;small; <span class="comment">// double dummy head</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">big</span>, *<span class="title">pbig</span> =</span> &amp;big;</span><br><span class="line">    psmall-&gt;next = pbig-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val &lt; x) &#123;</span><br><span class="line">            psmall-&gt;next = head;</span><br><span class="line">            psmall = psmall-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pbig-&gt;next = head;</span><br><span class="line">            pbig = pbig-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    psmall-&gt;next = big.next;</span><br><span class="line">    pbig-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> small.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="87-把字符串分区后，交换得到的字符串"><a href="#87-把字符串分区后，交换得到的字符串" class="headerlink" title="87 把字符串分区后，交换得到的字符串"></a>87 把字符串分区后，交换得到的字符串</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isScramble</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s1==s2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先判断字符是否一致</span></span><br><span class="line">    <span class="type">int</span> len = s1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> count[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">        count[s1[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        count[s2[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(count[i]!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(<span class="number">0</span>,i), s2.<span class="built_in">substr</span>(<span class="number">0</span>,i)) &amp;&amp; <span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(i), s2.<span class="built_in">substr</span>(i)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(<span class="number">0</span>,i), s2.<span class="built_in">substr</span>(len-i)) &amp;&amp; <span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(i), s2.<span class="built_in">substr</span>(<span class="number">0</span>,len-i)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="88-合并已排序数组，要求合并到其中一个空间较大的数组中"><a href="#88-合并已排序数组，要求合并到其中一个空间较大的数组中" class="headerlink" title="88 合并已排序数组，要求合并到其中一个空间较大的数组中"></a>88 合并已排序数组，要求合并到其中一个空间较大的数组中</h2><p>对于这种要求 in-place 的算法，从后往前往往可以解决</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* nums1, <span class="type">int</span> m, <span class="type">int</span>* nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = m + n - <span class="number">1</span>;</span><br><span class="line">    m--, n--;</span><br><span class="line">    <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[m] &gt; nums2[n]) &#123;</span><br><span class="line">            nums1[len--] = nums1[m--];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[len--] = nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[n] = nums2[n];</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="89-生成格雷码-Gray-Code"><a href="#89-生成格雷码-Gray-Code" class="headerlink" title="89 生成格雷码 (Gray Code)"></a>89 生成格雷码 (Gray Code)</h2><p>记住格雷码的生成规则</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>((i &gt;&gt; <span class="number">1</span>) ^ i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="90-由给定元素生成子集，可能包含重复元素"><a href="#90-由给定元素生成子集，可能包含重复元素" class="headerlink" title="90 由给定元素生成子集，可能包含重复元素"></a>90 由给定元素生成子集，可能包含重复元素</h2><p>使用了和手机键盘生成字符串号码类似的迭代算法，注意其中对重复元素的处理，当然也可以用 DFS 来做</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; sets;</span><br><span class="line">    sets.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 处理包含重复元素的一半需要预排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ) &#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// dup count</span></span><br><span class="line">        <span class="keyword">while</span> (count + i &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[count+i] == nums[i])</span><br><span class="line">            count++;</span><br><span class="line">        <span class="type">int</span> prev_n = sets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; prev_n; j++) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; instance = sets[j];</span><br><span class="line">            <span class="comment">// put dup element `count` times</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; count; k++) &#123;</span><br><span class="line">                instance.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                sets.<span class="built_in">push_back</span>(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i += count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="91-给定一个数组只包含-1-9，可以用-1-26-代表字母，求出从其中能都得到多少字符串"><a href="#91-给定一个数组只包含-1-9，可以用-1-26-代表字母，求出从其中能都得到多少字符串" class="headerlink" title="91 给定一个数组只包含 1-9，可以用 1-26 代表字母，求出从其中能都得到多少字符串"></a>91 给定一个数组只包含 1-9，可以用 1-26 代表字母，求出从其中能都得到多少字符串</h2><p>使用动态规划，但是注意其中 0 的处理，很玄妙</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s || <span class="built_in">strlen</span>(s) == <span class="number">0</span> || s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r1 = <span class="number">1</span>, r2 = <span class="number">1</span>; <span class="comment">// r1: 前一个字符， r2：前两个字符</span></span><br><span class="line">    <span class="type">char</span>* p = s++; <span class="comment">// 上一个字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">             r1 = <span class="number">0</span>; <span class="comment">// 0 不能单独构成字母</span></span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="string">&#x27;1&#x27;</span> || *p == <span class="string">&#x27;2&#x27;</span> &amp;&amp; *s &lt; <span class="string">&#x27;7&#x27;</span>) &#123; <span class="comment">// 形成两种可能</span></span><br><span class="line">            <span class="type">int</span> t = r1;</span><br><span class="line">            r1 = r2 + r1;</span><br><span class="line">            r2 = t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r2 = r1; <span class="comment">// 新加入的数字只能单独构成字母</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="92-在给定区间上翻转数组"><a href="#92-在给定区间上翻转数组" class="headerlink" title="92 在给定区间上翻转数组"></a>92 在给定区间上翻转数组</h2><p>同样是数组操作细节题</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseBetween</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m == n) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy, * small_node, * big_node; <span class="comment">// actually the prev ones</span></span><br><span class="line">    dummy.next = head;</span><br><span class="line">    n -= m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--m) <span class="comment">// m starts from 1, so not m--</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">start</span> =</span> p-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> start-&gt;next;</span><br><span class="line">        start-&gt;next = next-&gt;next;</span><br><span class="line">        next-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="93-恢复-IP-地址，给定一个字符串，适当插入点，一共有多少种方式构成-IP-地址"><a href="#93-恢复-IP-地址，给定一个字符串，适当插入点，一共有多少种方式构成-IP-地址" class="headerlink" title="93 恢复 IP 地址，给定一个字符串，适当插入点，一共有多少种方式构成 IP 地址"></a>93 恢复 IP 地址，给定一个字符串，适当插入点，一共有多少种方式构成 IP 地址</h2><p>又是一道 DFS 的题，注意对于字符串问题如何处理</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="built_in">restore</span>(result, s, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">restore</span><span class="params">(vector&lt;string&gt;&amp; result, string&amp; s, string restored, <span class="type">int</span> start, <span class="type">int</span> dots)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dots &gt; <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (dots == <span class="number">4</span> &amp;&amp; start == s.<span class="built_in">size</span>())</span><br><span class="line">        result.<span class="built_in">push_back</span>(restored);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start + i &gt; s.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        string part = s.<span class="built_in">substr</span>(start, i);</span><br><span class="line">        <span class="keyword">if</span> (part[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; part.<span class="built_in">size</span>() &gt; <span class="number">1</span> || i == <span class="number">3</span> &amp;&amp; <span class="built_in">stoi</span>(part) &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">restore</span>(result, s, restored + part + (dots==<span class="number">3</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;.&quot;</span>), start + i, dots + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="94-中序遍历二叉树"><a href="#94-中序遍历二叉树" class="headerlink" title="94 中序遍历二叉树"></a>94 中序遍历二叉树</h2><p>当然是使用栈了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    TreeNode* current = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() || current) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(current);</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(current-&gt;val);</span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>递归解法</p>
<details>
    <summary>go 解答</summary>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    left := inorderTraversal(root.Left)</span><br><span class="line">    right := inorderTraversal(root.Right)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(<span class="built_in">append</span>(left, root.Val), right...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="95-生成二叉树，同下题一样"><a href="#95-生成二叉树，同下题一样" class="headerlink" title="95 生成二叉树，同下题一样"></a>95 生成二叉树，同下题一样</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gen</span>(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">gen</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    vector&lt;TreeNode*&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> leftTrees = <span class="built_in">gen</span>(start, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> rightTrees = <span class="built_in">gen</span>(i + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; l : leftTrees) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : rightTrees) &#123;</span><br><span class="line">                <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                root-&gt;left = l;</span><br><span class="line">                root-&gt;right = r;</span><br><span class="line">                result.<span class="built_in">push_back</span>(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="96-给定数字-n，从-1-到-n-作为节点有多少种方式生成二叉树"><a href="#96-给定数字-n，从-1-到-n-作为节点有多少种方式生成二叉树" class="headerlink" title="96 给定数字 n，从 1 到 n 作为节点有多少种方式生成二叉树"></a>96 给定数字 n，从 1 到 n 作为节点有多少种方式生成二叉树</h2><p>这道题看似是树，实际上是一个动态规划问题。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* dp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) <span class="comment">// 依次选取第 k 个点作为根</span></span><br><span class="line">            num += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">        dp[i] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="97-给定两个字符串交叉是否能够构成第三个字符串"><a href="#97-给定两个字符串交叉是否能够构成第三个字符串" class="headerlink" title="97 给定两个字符串交叉是否能够构成第三个字符串"></a>97 给定两个字符串交叉是否能够构成第三个字符串</h2><p>这道题是一道二维的 DP 问题，因为需要对于每个字符串的每个位置用另一个字符串尝试匹配</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isInterleave</span><span class="params">(<span class="type">char</span>* s1, <span class="type">char</span>* s2, <span class="type">char</span>* s3)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l1 = <span class="built_in">strlen</span>(s1), l2 = <span class="built_in">strlen</span>(s2), l3 = <span class="built_in">strlen</span>(s3);</span><br><span class="line">    <span class="keyword">if</span> (l1 + l2 != l3) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 在 i+j 位置 s1[i] s2[j] 是否能够构成 s[i+j]</span></span><br><span class="line">    <span class="type">bool</span>** dp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>*) * (l1 + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= l1; i++)</span><br><span class="line">        dp[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * (l2 + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= l1; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= l2; j++)</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = (dp[i][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>]); <span class="comment">// 注意：赋值的优先级更高</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = (dp[i<span class="number">-1</span>][j] &amp;&amp; s1[i<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = (dp[i<span class="number">-1</span>][j] &amp;&amp; s1[i<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>] || dp[i][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[l1][l2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="98-验证二叉搜索树是否合法"><a href="#98-验证二叉搜索树是否合法" class="headerlink" title="98 验证二叉搜索树是否合法"></a>98 验证二叉搜索树是否合法</h2><p>先序遍历即可</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">valid</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">long</span> left, <span class="type">long</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="literal">NULL</span> || root-&gt;val &gt; left &amp;&amp; root-&gt;val &lt; right &amp;&amp;</span><br><span class="line">        valid(root-&gt;left, left, root-&gt;val) &amp;&amp;</span><br><span class="line">        valid(root-&gt;right, root-&gt;val, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValidBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> valid(root, INT_MIN - <span class="number">1l</span>, INT_MAX + <span class="number">1l</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="99-在二叉搜索树中有两个节点被调换了，找出这两个节点，并恢复该二叉树"><a href="#99-在二叉搜索树中有两个节点被调换了，找出这两个节点，并恢复该二叉树" class="headerlink" title="99 在二叉搜索树中有两个节点被调换了，找出这两个节点，并恢复该二叉树"></a>99 在二叉搜索树中有两个节点被调换了，找出这两个节点，并恢复该二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">first</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">second</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    traverse(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (prev &amp;&amp; prev-&gt;val &gt; root-&gt;val) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!first) first = prev;</span><br><span class="line">         second = root;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = root;</span><br><span class="line">    traverse(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recoverTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    prev = first = second = <span class="literal">NULL</span>;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">if</span> (!first) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> temp = first-&gt;val;</span><br><span class="line">    first-&gt;val = second-&gt;val;</span><br><span class="line">    second-&gt;val = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="100-判断是否是相同的树"><a href="#100-判断是否是相同的树" class="headerlink" title="100 判断是否是相同的树"></a>100 判断是否是相同的树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isSameTree</span><span class="params">(<span class="keyword">struct</span> TreeNode *p, <span class="keyword">struct</span> TreeNode *q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p == q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val</span><br><span class="line">            &amp;&amp; isSameTree(p-&gt;left, q-&gt;left)</span><br><span class="line">            &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="101-判断是不是左右对称的树"><a href="#101-判断是不是左右对称的树" class="headerlink" title="101 判断是不是左右对称的树"></a>101 判断是不是左右对称的树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">sym</span><span class="params">(<span class="keyword">struct</span> TreeNode* left, <span class="keyword">struct</span> TreeNode* right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; !right || !left &amp;&amp; right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> !left &amp;&amp; !right ||</span><br><span class="line">        left-&gt;val == right-&gt;val &amp;&amp;</span><br><span class="line">        sym(left-&gt;left, right-&gt;right) &amp;&amp;</span><br><span class="line">        sym(right-&gt;left, left-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSymmetric</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> sym(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="102-二叉树层序遍历"><a href="#102-二叉树层序遍历" class="headerlink" title="102 二叉树层序遍历"></a>102 二叉树层序遍历</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    vector&lt;TreeNode*&gt; current, next;</span><br><span class="line">    current.<span class="built_in">push_back</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!current.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        next.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; current.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;left)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;right)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;right);</span><br><span class="line">            vals.<span class="built_in">push_back</span>(current[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(vals);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="103-二叉树-ZigZag-层序遍历"><a href="#103-二叉树-ZigZag-层序遍历" class="headerlink" title="103 二叉树 ZigZag 层序遍历"></a>103 二叉树 ZigZag 层序遍历</h2><p>这道题更好的做法是使用一个栈，从而使得每行的顺序都是上一行的翻转</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    vector&lt;TreeNode*&gt; current, next;</span><br><span class="line">    current.<span class="built_in">push_back</span>(root);</span><br><span class="line">    <span class="type">bool</span> odd = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!current.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        next.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; current.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;left)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;right)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;right);</span><br><span class="line">            vals.<span class="built_in">push_back</span>(current[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!odd) <span class="built_in">reverse</span>(vals.<span class="built_in">begin</span>(), vals.<span class="built_in">end</span>());</span><br><span class="line">        odd = !odd;</span><br><span class="line">        result.<span class="built_in">push_back</span>(vals);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="104-树的最大深度"><a href="#104-树的最大深度" class="headerlink" title="104 树的最大深度"></a>104 树的最大深度</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = maxDepth(root-&gt;left), right = maxDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> (left &gt; right ?left : right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="105-从前序遍历和中序遍历生成生二叉树"><a href="#105-从前序遍历和中序遍历生成生二叉树" class="headerlink" title="105 从前序遍历和中序遍历生成生二叉树"></a>105 从前序遍历和中序遍历生成生二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">build</span><span class="params">(<span class="type">int</span>* prestart, <span class="type">int</span>* preend, <span class="type">int</span>* instart, <span class="type">int</span>* inend)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    root-&gt;val = *prestart;</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prestart == preend)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* root_inorder = instart;</span><br><span class="line">    <span class="keyword">while</span> (root_inorder &lt;= inend &amp;&amp; *root_inorder != *prestart)</span><br><span class="line">        root_inorder++;</span><br><span class="line">    <span class="type">int</span> left_len = root_inorder - instart;</span><br><span class="line">    <span class="type">int</span> right_len = inend - root_inorder;</span><br><span class="line">    <span class="keyword">if</span> (left_len &gt; <span class="number">0</span>)</span><br><span class="line">        root-&gt;left = build(prestart + <span class="number">1</span>, prestart + left_len, instart, root_inorder - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (right_len &gt; <span class="number">0</span>)</span><br><span class="line">        root-&gt;right = build(prestart + left_len + <span class="number">1</span>, preend, root_inorder + <span class="number">1</span>, inend);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// m always equals n, otherwise it&#x27;s bad input</span></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>* preorder, <span class="type">int</span> m, <span class="type">int</span>* inorder, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> build(preorder, preorder + n - <span class="number">1</span>, inorder, inorder + n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="106-从中序遍历和后序遍历生成二叉树"><a href="#106-从中序遍历和后序遍历生成二叉树" class="headerlink" title="106 从中序遍历和后序遍历生成二叉树"></a>106 从中序遍历和后序遍历生成二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">build</span><span class="params">(<span class="type">int</span>* instart, <span class="type">int</span>* inend, <span class="type">int</span>* poststart, <span class="type">int</span>* postend)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    root-&gt;val = *postend;</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (poststart == postend)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* root_inorder = instart;</span><br><span class="line">    <span class="keyword">while</span> (root_inorder &lt;= inend &amp;&amp; *root_inorder != *postend)</span><br><span class="line">        root_inorder++;</span><br><span class="line">    <span class="type">int</span> left_len = root_inorder - instart;</span><br><span class="line">    <span class="type">int</span> right_len = inend - root_inorder;</span><br><span class="line">    <span class="keyword">if</span> (left_len &gt; <span class="number">0</span>)</span><br><span class="line">        root-&gt;left = build(instart, root_inorder - <span class="number">1</span>, poststart, poststart + left_len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (right_len &gt; <span class="number">0</span>)</span><br><span class="line">        root-&gt;right = build(root_inorder + <span class="number">1</span>, inend, poststart + left_len, postend - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>* inorder, <span class="type">int</span> m, <span class="type">int</span>* postorder, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> build(inorder, inorder + n - <span class="number">1</span>, postorder, postorder +n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="107-二叉树层序遍历，但要生成翻转的遍历序列"><a href="#107-二叉树层序遍历，但要生成翻转的遍历序列" class="headerlink" title="107 二叉树层序遍历，但要生成翻转的遍历序列"></a>107 二叉树层序遍历，但要生成翻转的遍历序列</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    vector&lt;TreeNode*&gt; current, next;</span><br><span class="line">    current.<span class="built_in">push_back</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!current.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        next.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; current.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;left)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (current[i]-&gt;right)</span><br><span class="line">                next.<span class="built_in">push_back</span>(current[i]-&gt;right);</span><br><span class="line">            vals.<span class="built_in">push_back</span>(current[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(vals);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="108-把排序数组转化为二叉树"><a href="#108-把排序数组转化为二叉树" class="headerlink" title="108 把排序数组转化为二叉树"></a>108 把排序数组转化为二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> TreeNode* <span class="title function_">bst</span><span class="params">(<span class="type">int</span>* left, <span class="type">int</span>* right)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    root-&gt;val = *mid;</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; mid)</span><br><span class="line">        root-&gt;left = bst(left, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; right)</span><br><span class="line">        root-&gt;right = bst(mid+<span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> bst(nums, nums + n <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="109-把排序列表转化为二叉树"><a href="#109-把排序列表转化为二叉树" class="headerlink" title="109 把排序列表转化为二叉树"></a>109 把排序列表转化为二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">list</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">len</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head)</span><br><span class="line">        head = head-&gt;next, l++;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">bst</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    root-&gt;left = bst(n/<span class="number">2</span>);</span><br><span class="line">    root-&gt;val = <span class="built_in">list</span>-&gt;val;</span><br><span class="line">    <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    root-&gt;right = bst(n - n / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">sortedListToBST</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span> = head;</span><br><span class="line">    <span class="keyword">return</span> bst(len(head));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110 平衡二叉树"></a>110 平衡二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">height</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = height(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> right = height(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right + <span class="number">1</span> || right &gt; left + <span class="number">1</span> || left == <span class="number">-1</span> || right == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (left &gt; right ? left : right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isBalanced</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> height(root) != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="111-二叉树最小高度"><a href="#111-二叉树最小高度" class="headerlink" title="111 二叉树最小高度"></a>111 二叉树最小高度</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = minDepth(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> right = minDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (!right) <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!left) <span class="keyword">return</span> right + <span class="number">1</span>; <span class="comment">// tricky here, 当有空节点时，不能返回 0，而是返回另一个值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (left &lt; right ? left : right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="112-二叉树中是否存在和为某个数的路径"><a href="#112-二叉树中是否存在和为某个数的路径" class="headerlink" title="112 二叉树中是否存在和为某个数的路径"></a>112 二叉树中是否存在和为某个数的路径</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">hasPathSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> sum == root-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val) ||</span><br><span class="line">        hasPathSum(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="113-接上题，把这个路径找出来"><a href="#113-接上题，把这个路径找出来" class="headerlink" title="113 接上题，把这个路径找出来"></a>113 接上题，把这个路径找出来</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> sum) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">getPaths</span>(result, path, root, sum);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPaths</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt; path, TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == root-&gt;val) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getPaths</span>(result, path, root-&gt;left, sum - root-&gt;val);</span><br><span class="line">    <span class="built_in">getPaths</span>(result, path, root-&gt;right, sum - root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="114-把二叉树扁平成列表"><a href="#114-把二叉树扁平成列表" class="headerlink" title="114 把二叉树扁平成列表"></a>114 把二叉树扁平成列表</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* prev;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">flatten</span>(root-&gt;right);</span><br><span class="line">    <span class="built_in">flatten</span>(root-&gt;left);</span><br><span class="line">    root-&gt;right = prev;</span><br><span class="line">    root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    prev = root; <span class="comment">// last flattened element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="115-通过删掉一些字母得到子序列，问有多少种方法能够得到子序列呢"><a href="#115-通过删掉一些字母得到子序列，问有多少种方法能够得到子序列呢" class="headerlink" title="115 通过删掉一些字母得到子序列，问有多少种方法能够得到子序列呢"></a>115 通过删掉一些字母得到子序列，问有多少种方法能够得到子序列呢</h2><p>使用 DP，</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Solution (DP):</span></span><br><span class="line"><span class="comment"> * 我们扫描字符串 s</span></span><br><span class="line"><span class="comment"> * Path[i][j] 代表 T.substr(1...i) 在 S(1...j) 不同的子序列的数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Path[i][j] = Path[i][j-1]            (discard S[j])</span></span><br><span class="line"><span class="comment"> *              +     Path[i-1][j-1]    (S[j] == T[i] and we are going to use S[j])</span></span><br><span class="line"><span class="comment"> *                 or 0                 (S[j] != T[i] so we could not use S[j])</span></span><br><span class="line"><span class="comment"> * while Path[0][j] = 1 and Path[i][0] = 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">path</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            path[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="comment">// S</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="comment">// T</span></span><br><span class="line">                path[i][j] = path[i][j<span class="number">-1</span>] + (t[i<span class="number">-1</span>] == s[j<span class="number">-1</span>] ? path[i<span class="number">-1</span>][j<span class="number">-1</span>] : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> path[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="116-完全二叉树中把每个节点指向他这一层的右面的节点"><a href="#116-完全二叉树中把每个节点指向他这一层的右面的节点" class="headerlink" title="116 完全二叉树中把每个节点指向他这一层的右面的节点"></a>116 完全二叉树中把每个节点指向他这一层的右面的节点</h2><p>显然左节点的下一个节点是父节点的右节点，右节点的下一个节点是父节点下一个节点的左节点。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">connect</span><span class="params">(<span class="keyword">struct</span> TreeLinkNode *root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        root-&gt;right-&gt;next = root-&gt;next ? root-&gt;next-&gt;left : <span class="literal">NULL</span>;</span><br><span class="line">    connect(root-&gt;left);</span><br><span class="line">    connect(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="117-同上题，但是是任意的🌲"><a href="#117-同上题，但是是任意的🌲" class="headerlink" title="117 同上题，但是是任意的🌲"></a>117 同上题，但是是任意的🌲</h2><p>通过上一层已经被连接的 next 指针，顺序层序访问，从而连接下一层。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">connect</span><span class="params">(<span class="keyword">struct</span> TreeLinkNode *root)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span>* <span class="title">head</span> =</span> root, * prev = <span class="literal">NULL</span>, *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123; <span class="comment">// head 是每层的开始</span></span><br><span class="line">        p = head;</span><br><span class="line">        prev = head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev)</span><br><span class="line">                    prev-&gt;next = p-&gt;left;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    head = p-&gt;left;</span><br><span class="line">                prev = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev)</span><br><span class="line">                    prev-&gt;next = p-&gt;right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    head = p-&gt;right;</span><br><span class="line">                prev = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118 杨辉三角"></a>118 杨辉三角</h2><p>注意坐标关系，不要被骗了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">result</span>(n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result[i].<span class="built_in">resize</span>(i+<span class="number">1</span>);</span><br><span class="line">        result[i][<span class="number">0</span>] = result[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            result[i][j] = result[i<span class="number">-1</span>][j<span class="number">-1</span>] + result[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="119-返回杨辉三角的第-k-行"><a href="#119-返回杨辉三角的第-k-行" class="headerlink" title="119 返回杨辉三角的第 k 行"></a>119 返回杨辉三角的第 k 行</h2><p>要求只能使用 O(k) 的额外空间，比较蛋疼的是这里的 k 是从 0 计数的。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">    rowIndex++;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; row;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rowIndex; i++) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newRow</span><span class="params">(i+<span class="number">1</span>)</span></span>;</span><br><span class="line">        newRow[<span class="number">0</span>] = newRow[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            newRow[j] = row[j<span class="number">-1</span>] + row[j];</span><br><span class="line">        <span class="built_in">swap</span>(row, newRow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="120-给定一个类似杨辉三角形状的数组，求从顶部到底部的最短路径"><a href="#120-给定一个类似杨辉三角形状的数组，求从顶部到底部的最短路径" class="headerlink" title="120 给定一个类似杨辉三角形状的数组，求从顶部到底部的最短路径"></a>120 给定一个类似杨辉三角形状的数组，求从顶部到底部的最短路径</h2><p>显然是使用 DP，但是有一个问题，如果是 top down 的话，最后还需要遍历一下，而如果是 bottom up 就只需要返回 dp[0] 就好了。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(triangle.back())</span></span>; <span class="comment">// 复制最后一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> layer = triangle.<span class="built_in">size</span>() - <span class="number">2</span>; layer &gt;= <span class="number">0</span>; layer--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= layer; i++)</span><br><span class="line">            dp[i] = triangle[layer][i] + <span class="built_in">min</span>(dp[i], dp[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="121-买卖股票最佳时机，只能交易一次"><a href="#121-买卖股票最佳时机，只能交易一次" class="headerlink" title="121 买卖股票最佳时机，只能交易一次"></a>121 买卖股票最佳时机，只能交易一次</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pricesSize &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> profit = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 从前到后依次遍历，如果有更好的收益更新，或者更新 min，限制条件是先出现最小值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pricesSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; min) &#123;</span><br><span class="line">                profit = max(profit, prices[i] - min);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            min = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="122-买卖股票的最佳时机，可以做任意多比交易"><a href="#122-买卖股票的最佳时机，可以做任意多比交易" class="headerlink" title="122 买卖股票的最佳时机，可以做任意多比交易"></a>122 买卖股票的最佳时机，可以做任意多比交易</h2><p>有两种解法，一种是不断做交易，完全不考虑交易次数，这种做法不符合实际情况。<br>另一种做法是模拟交易，这样会生成最少的交易次数，结果也是对的。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span></span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; pricesSize<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (prices[i+<span class="number">1</span>]&gt;prices[i])</span><br><span class="line">            total += prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!prices) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> profit = <span class="number">0</span>;<span class="type">bool</span> buy = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> min = prices[<span class="number">0</span>], max = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pricesSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; min &amp;&amp; buy) &#123;</span><br><span class="line">            min = prices[i];</span><br><span class="line">            max = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; min &amp;&amp; buy)</span><br><span class="line">            buy = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; max &amp;&amp; !buy)</span><br><span class="line">            max = prices[i];</span><br><span class="line">        <span class="keyword">if</span> ((prices[i] &lt; max || i == pricesSize - <span class="number">1</span>) &amp;&amp; !buy)&#123;</span><br><span class="line">            profit += max - min;</span><br><span class="line">            min = prices[i];</span><br><span class="line">            max = prices[i];</span><br><span class="line">            buy = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="123-股票交易，限制只能交易两股"><a href="#123-股票交易，限制只能交易两股" class="headerlink" title="123 股票交易，限制只能交易两股"></a>123 股票交易，限制只能交易两股</h2><p>每次求解的是：卖出两股以后的最大值，刚刚买入第二股的最大值，卖出第一股时候的最大值，买入第一股时候的最大值。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> hold1 = INT_MIN, hold2 = INT_MIN;</span><br><span class="line">    <span class="type">int</span> release1 = <span class="number">0</span>, release2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : prices) &#123;</span><br><span class="line">        release2 = <span class="built_in">max</span>(release2, hold2 + i);</span><br><span class="line">        hold2 = <span class="built_in">max</span>(hold2, release1 - i);</span><br><span class="line">        release1 = <span class="built_in">max</span>(release1, hold1 + i);</span><br><span class="line">        hold1 = <span class="built_in">max</span>(hold1, -i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> release2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="124-二叉树路径最大和，路径可以从任意一个节点开始到任意一个节点结束"><a href="#124-二叉树路径最大和，路径可以从任意一个节点开始到任意一个节点结束" class="headerlink" title="124 二叉树路径最大和，路径可以从任意一个节点开始到任意一个节点结束"></a>124 二叉树路径最大和，路径可以从任意一个节点开始到任意一个节点结束</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">doSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* sum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = max(<span class="number">0</span>, doSum(root-&gt;left, sum));</span><br><span class="line">    <span class="type">int</span> right = max(<span class="number">0</span>, doSum(root-&gt;right, sum));</span><br><span class="line">    *sum = max(*sum, left+right+root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> max(left, right) + root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = INT_MIN;</span><br><span class="line">    doSum(root, &amp;sum);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>这道题是把最终答案放在了全局变量中，并采用了辅助函数的方法。全局变量中存储两条路径的和，<br>而返回值中存储当前子树中最长的单边。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.ans = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_maxPathSum</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 注意这里要取 max，以防添加了负路径</span></span><br><span class="line">        left = <span class="built_in">max</span>(<span class="number">0</span>, self._maxPathSum(root.left))</span><br><span class="line">        right = <span class="built_in">max</span>(<span class="number">0</span>, self._maxPathSum(root.right))</span><br><span class="line">        self.ans = <span class="built_in">max</span>(self.ans, left + right + root.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + root.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPathSum</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        self._maxPathSum(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
</details>



<h2 id="125-给定一个字符串，只考虑字母和数字，忽略大小写，判断是否是回文字符串"><a href="#125-给定一个字符串，只考虑字母和数字，忽略大小写，判断是否是回文字符串" class="headerlink" title="125 给定一个字符串，只考虑字母和数字，忽略大小写，判断是否是回文字符串"></a>125 给定一个字符串，只考虑字母和数字，忽略大小写，判断是否是回文字符串</h2><p>太简单了，没啥可说的</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">char</span> l = s[left], r = s[right];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalnum</span>(l) &amp;&amp; <span class="built_in">isalnum</span>(r)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(l) != <span class="built_in">tolower</span>(r))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            left++, right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(l))</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(r))</span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="127-单词梯子"><a href="#127-单词梯子" class="headerlink" title="127 单词梯子"></a>127 单词梯子</h2><p>给定梯子，和开始单词和结束单词，最少需要多少个中间单词，才能变化过去，每次只能变化一个字母</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, unordered_set&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;string&gt; beginSet, endSet, *set1, * set2;</span><br><span class="line">    beginSet.<span class="built_in">insert</span>(beginWord);</span><br><span class="line">    endSet.<span class="built_in">insert</span>(endWord);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dist = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (!beginSet.<span class="built_in">empty</span>() &amp;&amp; !endSet.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beginSet.<span class="built_in">size</span>() &lt; endSet.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            set1 = &amp;beginSet;</span><br><span class="line">            set2 = &amp;endSet;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set1 = &amp;endSet;</span><br><span class="line">            set2 = &amp;beginSet;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;string&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word : *set1) &#123; <span class="comment">// notice word in not ref</span></span><br><span class="line">            wordList.<span class="built_in">erase</span>(word);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; letter : word) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                    <span class="type">char</span> oldLetter = letter;</span><br><span class="line">                    letter = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">                    <span class="keyword">if</span> (set2-&gt;<span class="built_in">find</span>(word) != set2-&gt;<span class="built_in">end</span>())</span><br><span class="line">                        <span class="keyword">return</span> dist;</span><br><span class="line">                    <span class="keyword">if</span> (wordList.<span class="built_in">find</span>(word) != wordList.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        temp.<span class="built_in">insert</span>(word);</span><br><span class="line">                        wordList.<span class="built_in">erase</span>(word);</span><br><span class="line">                    &#125;</span><br><span class="line">                    letter = oldLetter;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dist++;</span><br><span class="line">        <span class="built_in">swap</span>(*set1, temp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="128-最长递增子序列"><a href="#128-最长递增子序列" class="headerlink" title="128 最长递增子序列"></a>128 最长递增子序列</h2><p>使用动态规划</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash; <span class="comment">// 每个元素和它们所在序列的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">find</span>(n) == hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 查找两边的元素，如果找到，把新元素合并进去</span></span><br><span class="line">            <span class="type">int</span> left = hash.<span class="built_in">find</span>(n<span class="number">-1</span>) != hash.<span class="built_in">end</span>() ? hash[n<span class="number">-1</span>] : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> right = hash.<span class="built_in">find</span>(n+<span class="number">1</span>) != hash.<span class="built_in">end</span>() ? hash[n+<span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = left + right + <span class="number">1</span>;</span><br><span class="line">            hash[n] = hash[n-left] = hash[n+right] = sum; <span class="comment">// 注意此处的更新，并不需要更新区间内的每个值，只需要更新边界即可</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="129-二叉树中只有-0-9-找出所有根节点到子节点的和"><a href="#129-二叉树中只有-0-9-找出所有根节点到子节点的和" class="headerlink" title="129 二叉树中只有 0-9 找出所有根节点到子节点的和"></a>129 二叉树中只有 0-9 找出所有根节点到子节点的和</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">10</span> + root-&gt;val;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        val += sum(root-&gt;left, x * <span class="number">10</span> + root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        val += sum(root-&gt;right, x * <span class="number">10</span> + root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> sum(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="130-把所有被包围的-O-置为-X"><a href="#130-把所有被包围的-O-置为-X" class="headerlink" title="130 把所有被包围的 O 置为 X"></a>130 把所有被包围的 O 置为 X</h2><p>使用并查集</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; m_father, m_rank;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n): <span class="built_in">m_father</span>(n), <span class="built_in">m_rank</span>(n, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_father.<span class="built_in">size</span>(); i++)</span><br><span class="line">            m_father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != m_father[x])</span><br><span class="line">            m_father[x] = <span class="built_in">find</span>(m_father[x]);</span><br><span class="line">        <span class="keyword">return</span> m_father[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_rank[x] &gt; m_rank[y]) &#123;</span><br><span class="line">            m_father[y] = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_rank[x] == m_rank[y])</span><br><span class="line">                m_rank[y]++;</span><br><span class="line">            m_father[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(n*m+<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i == <span class="number">0</span> || j == <span class="number">0</span> || i == n<span class="number">-1</span> || j == m<span class="number">-1</span>) &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                    uf.<span class="built_in">unionify</span>(i * m + j, n * m);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (board[i<span class="number">-1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.<span class="built_in">unionify</span>(i * m + j, (i - <span class="number">1</span>) * m + j);</span><br><span class="line">                    <span class="keyword">if</span> (board[i+<span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.<span class="built_in">unionify</span>(i*m+j, (i+<span class="number">1</span>)*m+j);</span><br><span class="line">                    <span class="keyword">if</span> (board[i][j<span class="number">-1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.<span class="built_in">unionify</span>(i*m+j, i*m+j<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (board[i][j+<span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.<span class="built_in">unionify</span>(i*m+j, i*m+j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (uf.<span class="built_in">find</span>(i*m+j) != uf.<span class="built_in">find</span>(n*m))</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="131-对字符串分组，是的每个字串都是回文，返回所有可能的分组"><a href="#131-对字符串分组，是的每个字串都是回文，返回所有可能的分组" class="headerlink" title="131 对字符串分组，是的每个字串都是回文，返回所有可能的分组"></a>131 对字符串分组，是的每个字串都是回文，返回所有可能的分组</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    vector&lt;string&gt; group;</span><br><span class="line">    <span class="built_in">dfs</span>(result, s, group, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; result, <span class="type">const</span> string&amp; s, vector&lt;string&gt;&amp; group, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(group);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, start, i)) &#123;</span><br><span class="line">            group.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(start, i - start + <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">dfs</span>(result, s, group, i + <span class="number">1</span>);</span><br><span class="line">            group.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[left++] != s[right--])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="132-如上题，找出最少需要分组几次"><a href="#132-如上题，找出最少需要分组几次" class="headerlink" title="132 如上题，找出最少需要分组几次"></a>132 如上题，找出最少需要分组几次</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCut</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cut</span><span class="params">(s.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>() + <span class="number">1</span>; i++)</span><br><span class="line">        cut[i] = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; i - j &gt;= <span class="number">0</span> &amp;&amp; i + j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i+j] == s[i-j]; j++)</span><br><span class="line">            cut[i+j+<span class="number">1</span>] = <span class="built_in">min</span>(cut[i+j+<span class="number">1</span>], cut[i-j] + <span class="number">1</span>); <span class="comment">// i-j -&gt; i+j 是 palindrome，所以只需要 cut[i-j] 在加上这一段就好了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; i - j + <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i + j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i+j] == s[i-j+<span class="number">1</span>]; j++)</span><br><span class="line">            cut[i+j+<span class="number">1</span>] = <span class="built_in">min</span>(cut[i+j+<span class="number">1</span>], cut[i - j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cut[s.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="133-复制有向图"><a href="#133-复制有向图" class="headerlink" title="133 复制有向图"></a>133 复制有向图</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; hash; <span class="comment">// old -&gt; new pair</span></span><br><span class="line"><span class="function">UndirectedGraphNode *<span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (hash.<span class="built_in">find</span>(node) == hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        hash[node] = <span class="keyword">new</span> <span class="built_in">UndirectedGraphNode</span>(node-&gt;label);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : node-&gt;neighbors)</span><br><span class="line">            hash[node]-&gt;neighbors.<span class="built_in">push_back</span>(<span class="built_in">cloneGraph</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134 加油站"></a>134 加油站</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>* gas, <span class="type">int</span> gasSize, <span class="type">int</span>* cost, <span class="type">int</span> costSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; gasSize; ++i) &#123;</span><br><span class="line">        sum += gas[i] - cost[i]; <span class="comment">// 从此处经过能够净增多少汽油</span></span><br><span class="line">        total += gas[i] - cost[i]; <span class="comment">// 记录总的汽油量是否是正的</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123; <span class="comment">// 如果当前汽油量已经小于 0，说明之前的节点都是不行的，到下一个节点</span></span><br><span class="line">            j = i;</span><br><span class="line">            sum = <span class="number">0</span>; <span class="comment">// 同时重新开始计数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total &gt;= <span class="number">0</span> ? j + <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="135-糖块，成绩高的需要比他身边成绩低的获得更多的糖"><a href="#135-糖块，成绩高的需要比他身边成绩低的获得更多的糖" class="headerlink" title="135 糖块，成绩高的需要比他身边成绩低的获得更多的糖"></a>135 糖块，成绩高的需要比他身边成绩低的获得更多的糖</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = ratings.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candies</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i<span class="number">-1</span>])</span><br><span class="line">            candies[i] = candies[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (ratings[i<span class="number">-1</span>] &gt; ratings[i])</span><br><span class="line">            candies[i<span class="number">-1</span>] = <span class="built_in">max</span>(candies[i] + <span class="number">1</span>, candies[i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : candies)</span><br><span class="line">        result += i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="136-找出数组中只出现一次的数字"><a href="#136-找出数组中只出现一次的数字" class="headerlink" title="136 找出数组中只出现一次的数字"></a>136 找出数组中只出现一次的数字</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++)</span><br><span class="line">        result ^= nums[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="137-一个数组中，所有数字都出现三次，除了一个数字以外，找出这个数字"><a href="#137-一个数组中，所有数字都出现三次，除了一个数字以外，找出这个数字" class="headerlink" title="137 一个数组中，所有数字都出现三次，除了一个数字以外，找出这个数字"></a>137 一个数组中，所有数字都出现三次，除了一个数字以外，找出这个数字</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用二进制计算</span></span><br><span class="line"><span class="comment">// 00-&gt;10-&gt;01-&gt;00(0-&gt;1-&gt;2-&gt;3/0)</span></span><br><span class="line"><span class="comment">// ones = ones ^ A[i]; if (twos == 1) then ones = 0</span></span><br><span class="line"><span class="comment">// twos = twos ^ A[i]; if (ones* == 1) then twos = 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        ones = (ones ^ nums[i]) &amp; ~twos;</span><br><span class="line">        twos = (twos ^ nums[i]) &amp; ~ones;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="138-复制复杂结构链表"><a href="#138-复制复杂结构链表" class="headerlink" title="138 复制复杂结构链表"></a>138 复制复杂结构链表</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     struct RandomListNode *next;</span></span><br><span class="line"><span class="comment"> *     struct RandomListNode *random;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> RandomListNode *<span class="title function_">copyRandomList</span><span class="params">(<span class="keyword">struct</span> RandomListNode *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RandomListNode</span>* <span class="title">p</span>;</span></span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">RandomListNode</span>* <span class="title">node</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> RandomListNode));</span><br><span class="line">        node-&gt;next = node-&gt;random = <span class="literal">NULL</span>; <span class="comment">// spicial notice to struct initialization in c</span></span><br><span class="line">        node-&gt;label = p-&gt;label;</span><br><span class="line">        node-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = node;</span><br><span class="line">        p = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;random)</span><br><span class="line">            p-&gt;next-&gt;random = p-&gt;random-&gt;next;</span><br><span class="line">        p = p-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RandomListNode</span> <span class="title">dummy</span>, *<span class="title">q</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = dummy.random = <span class="literal">NULL</span>;</span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        q-&gt;next = p-&gt;next;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="139-查找单词是否能组成句子"><a href="#139-查找单词是否能组成句子" class="headerlink" title="139 查找单词是否能组成句子"></a>139 查找单词是否能组成句子</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, unordered_set&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wordDict.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 动态规划，假设前 i 个字符已经匹配到了，尝试匹配 i 到 i+j，如果找到了，就匹配到了 i+j</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j]) &#123;</span><br><span class="line">                string word = s.<span class="built_in">substr</span>(j, i-j);</span><br><span class="line">                <span class="keyword">if</span> (wordDict.<span class="built_in">find</span>(word) != wordDict.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="141-列表是否有环"><a href="#141-列表是否有环" class="headerlink" title="141 列表是否有环"></a>141 列表是否有环</h2><p>slow 每次走一步，而 fast 每次走两步，因此在进入环之后，两者一定会相遇</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">hasCycle</span><span class="params">(<span class="keyword">struct</span> ListNode *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head, * fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="142-列表是否有环？如果有找到环的开始"><a href="#142-列表是否有环？如果有找到环的开始" class="headerlink" title="142 列表是否有环？如果有找到环的开始"></a>142 列表是否有环？如果有找到环的开始</h2><p>从两者出发，到两者相遇，slow 指针走了 p 步，而 fast 指针走了 2p 步，显然 fast 多走了一圈（或者多圈）。<br>设 p &#x3D; k + x, 2p &#x3D; k + x + loop -&gt; 2k + 2x &#x3D; k + x + loop -&gt; k + x &#x3D; loop -&gt; k &#x3D; loop - x，剩下的长度正好也是 k。<br>假设入口处距离起点的距离是 k，那么发生碰撞的点距离环的入口处距离也是 k，所以两个指针分别从开始和碰撞点出发匀速一定会在环的入口相遇。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">detectCycle</span><span class="params">(<span class="keyword">struct</span> ListNode *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head, * fast = head, *entry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!found &amp;&amp; fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!found) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="144-前序遍历"><a href="#144-前序遍历" class="headerlink" title="144 前序遍历"></a>144 前序遍历</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    stk.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node  = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145 二叉树的后序遍历"></a>145 二叉树的后序遍历</h2><p>参见<a href="tree.md">树的遍历</a></p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    stack&lt;TreeNode*&gt; stk, output;</span><br><span class="line">    stk.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> node = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        output.<span class="built_in">push</span>(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!output.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(output.<span class="built_in">top</span>()-&gt;val);</span><br><span class="line">        output.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146 LRU 缓存"></a>146 LRU 缓存</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> unordered_map&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;::iterator&gt;&gt; <span class="type">cache_t</span>; <span class="comment">// k: v, iter</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : <span class="built_in">m_capacity</span>(capacity) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m_cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == m_cache.<span class="built_in">end</span>())</span><br><span class="line">             <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">touch</span>(it);</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second.first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m_cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it != m_cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="built_in">touch</span>(it);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_cache.<span class="built_in">size</span>() == m_capacity) &#123;</span><br><span class="line">                m_cache.<span class="built_in">erase</span>(m_used.<span class="built_in">back</span>());</span><br><span class="line">                m_used.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            m_used.<span class="built_in">push_front</span>(key);</span><br><span class="line">        &#125;</span><br><span class="line">        m_cache[key] = &#123;value, m_used.<span class="built_in">begin</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">touch</span><span class="params">(<span class="type">cache_t</span>::iterator it)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> key = it-&gt;first;</span><br><span class="line">        m_used.<span class="built_in">erase</span>(it-&gt;second.second);</span><br><span class="line">        m_used.<span class="built_in">push_front</span>(key);</span><br><span class="line">        it-&gt;second.second = m_used.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">cache_t</span> m_cache;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; m_used;</span><br><span class="line">    <span class="type">int</span> m_capacity;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="147-链表插入排序"><a href="#147-链表插入排序" class="headerlink" title="147 链表插入排序"></a>147 链表插入排序</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">insertionSortList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> head;</span><br><span class="line">    dummy.val = INT_MIN;</span><br><span class="line">    dummy.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">iter</span> =</span> &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span> (iter-&gt;next &amp;&amp; iter-&gt;next-&gt;val &lt; p-&gt;val)</span><br><span class="line">            iter = iter-&gt;next;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pnext</span> =</span> p-&gt;next;</span><br><span class="line">        p-&gt;next = iter-&gt;next;</span><br><span class="line">        iter-&gt;next = p;</span><br><span class="line">        p = pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="148-排序链表，要求达到-O-nlogn-时间复杂度"><a href="#148-排序链表，要求达到-O-nlogn-时间复杂度" class="headerlink" title="148 排序链表，要求达到 O(nlogn) 时间复杂度"></a>148 排序链表，要求达到 O(nlogn) 时间复杂度</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">split</span><span class="params">(<span class="keyword">struct</span> ListNode* source, <span class="keyword">struct</span> ListNode** frontptr, <span class="keyword">struct</span> ListNode** backptr)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span>, * <span class="title">slow</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!source || !source-&gt;next)</span><br><span class="line">        *backptr = source;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        slow = source;</span><br><span class="line">        fast = source-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *backptr = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *frontptr = source;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">merge</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span></span><br><span class="line">    dummy.next == <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1)</span><br><span class="line">        p-&gt;next = l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l2)</span><br><span class="line">        p-&gt;next = l2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge sort</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">sortList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">front</span>, * <span class="title">back</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">    split(head, &amp;front, &amp;back);</span><br><span class="line">    front = sortList(front);</span><br><span class="line">    back = sortList(back);</span><br><span class="line">    head = merge(front, back);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="149-在同一条线上的点最多的线"><a href="#149-在同一条线上的点最多的线" class="headerlink" title="149 在同一条线上的点最多的线"></a>149 在同一条线上的点最多的线</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxPoints</span><span class="params">(vector&lt;Point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于每一个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 经过该点的直线，使用分数作为斜率，避免使用浮点数</span></span><br><span class="line">        map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; lines;</span><br><span class="line">        <span class="type">int</span> localMax = <span class="number">0</span>, overlap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; points.<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 避免重复计算</span></span><br><span class="line">            <span class="keyword">if</span> (points[j].x == points[i].x &amp;&amp; points[j].y == points[i].y) &#123;</span><br><span class="line">                overlap++; <span class="comment">// 同一个点</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> x = points[j].x - points[i].x;</span><br><span class="line">                <span class="type">int</span> y = points[j].y - points[i].y;</span><br><span class="line">                <span class="type">int</span> g = <span class="built_in">gcd</span>(x, y);</span><br><span class="line">                x /= g, y /= g; <span class="comment">// verticle case: x == 0 -&gt; (0, 1)</span></span><br><span class="line">                lines[<span class="built_in">make_pair</span>(x, y)]++;</span><br><span class="line">                localMax = <span class="built_in">max</span>(localMax, lines[<span class="built_in">make_pair</span>(x, y)]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// overlap 算在任意条线上</span></span><br><span class="line">        result = <span class="built_in">max</span>(result, localMax + overlap + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="150-后缀表达式求值"><a href="#150-后缀表达式求值" class="headerlink" title="150 后缀表达式求值"></a>150 后缀表达式求值</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_operator</span><span class="params">(<span class="type">char</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t == <span class="string">&#x27;+&#x27;</span> || t == <span class="string">&#x27;-&#x27;</span> || t == <span class="string">&#x27;*&#x27;</span> || t == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> left, <span class="type">char</span> op, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> left + right;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> left - right;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> left * right;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> left / right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; token : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_operator</span>(token[<span class="number">0</span>]) &amp;&amp; token.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> op = token[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> right_num = nums.<span class="built_in">top</span>();</span><br><span class="line">            nums.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> left_num = nums.<span class="built_in">top</span>();</span><br><span class="line">            nums.<span class="built_in">pop</span>();</span><br><span class="line">            nums.<span class="built_in">push</span>(<span class="built_in">calc</span>(left_num, op, right_num));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums.<span class="built_in">push</span>(<span class="built_in">stoi</span>(token));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="151-反转句子中的单词顺序"><a href="#151-反转句子中的单词顺序" class="headerlink" title="151 反转句子中的单词顺序"></a>151 反转句子中的单词顺序</h2><p>一般面试的时候会假定没有多余字符的，解法是</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LeetCode 需要处理多余空格：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;C 解答&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">char</span> tmp = *a; *a = *b; *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>* start, <span class="type">char</span>* end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end)</span><br><span class="line">        swap(start++, end--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trim</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* fast, *slow;</span><br><span class="line">    <span class="keyword">for</span> (fast = s; *fast !=<span class="string">&#x27;\0&#x27;</span>; fast++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(*fast)) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isspace</span>(*(fast + <span class="number">1</span>)) &amp;&amp; *(fast + <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                fast++;</span><br><span class="line">            <span class="keyword">if</span>(*(fast+<span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(slow == s)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(fast, slow++);</span><br><span class="line">    &#125;</span><br><span class="line">    *slow = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseWords</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    trim(s);</span><br><span class="line">    len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    reverse(s, s + len - <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span>* head = s, * tail =s ;</span><br><span class="line">    <span class="keyword">while</span> (*(tail + <span class="number">1</span>) != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        tail = head;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isspace</span>(*(tail + <span class="number">1</span>)) &amp;&amp; *(tail + <span class="number">1</span>) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            tail++;</span><br><span class="line">        reverse(head, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="152-最大子序列乘积"><a href="#152-最大子序列乘积" class="headerlink" title="152 最大子序列乘积"></a>152 最大子序列乘积</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; A)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = A.size();</span><br><span class="line">    <span class="type">int</span> r = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, imax = r, imin = r; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; <span class="number">0</span>)</span><br><span class="line">            swap(imax, imin);</span><br><span class="line"></span><br><span class="line">        imax = max(A[i], imax * A[i]);</span><br><span class="line">        imin = min(A[i], imin * A[i]);</span><br><span class="line"></span><br><span class="line">        r = max(r, imax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="153-在旋转数组中查找最小值"><a href="#153-在旋转数组中查找最小值" class="headerlink" title="153 在旋转数组中查找最小值"></a>153 在旋转数组中查找最小值</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>; <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[left] &gt; A[mid])</span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[right] &lt; A[mid])</span><br><span class="line">            left = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[left] &lt; A[right] ? A[left] : A[right];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="154-在旋转数组中查找最小值，可能有重复"><a href="#154-在旋转数组中查找最小值，可能有重复" class="headerlink" title="154 在旋转数组中查找最小值，可能有重复"></a>154 在旋转数组中查找最小值，可能有重复</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] &gt; A[right]) &#123; <span class="comment">// 当需要找的是 left，也就是较小的数字，使用 right 比较不需要等于号</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[right] &lt; A[mid]) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="155-设计一个栈，在普通栈的基础上支持-getmin-操作"><a href="#155-设计一个栈，在普通栈的基础上支持-getmin-操作" class="headerlink" title="155 设计一个栈，在普通栈的基础上支持 getmin 操作"></a>155 设计一个栈，在普通栈的基础上支持 getmin 操作</h2><p>解法 1: 使用额外的栈，每个值都记录一个当前最小值，浪费空间</p>
<p>解法 2: 也是使用额外的栈，但是惰性记录，只有当需要更新的时候才去记录</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; m_stk;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; m_min;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="built_in">getMin</span>())</span><br><span class="line">            m_min.<span class="built_in">push</span>(x);</span><br><span class="line">        m_stk.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_stk.<span class="built_in">top</span>() == <span class="built_in">getMin</span>())</span><br><span class="line">            m_min.<span class="built_in">pop</span>();</span><br><span class="line">        m_stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_min.<span class="built_in">empty</span>() ? INT_MAX : m_min.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<p>156-159 Locked</p>
<h2 id="160-求两个链表的交叉点"><a href="#160-求两个链表的交叉点" class="headerlink" title="160 求两个链表的交叉点"></a>160 求两个链表的交叉点</h2><p>分析题目可知，如果有一个交叉点，那么在这之后的所有点都是交叉的。这里有一个非常巧妙<br>的做法。使用两个指针，如果到达结尾就指向另一个链表，会产生一下三种情况：</p>
<ol>
<li>如果交叉点前面的节点数目相同，显然会返回正确节点。</li>
<li>如果不同假设 A 的节点为 a + c，B 的节点为 b + c，则在下一次遍历时：<br> a + c + b &#x3D;&#x3D; b + c + a，恰好到达相同部分的第一个顶点 C1</li>
<li>如果两个列表不相交，那么经过 a + b, b + a 距离后，恰好都等于 NULL</li>
</ol>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">getIntersectionNode</span><span class="params">(<span class="keyword">struct</span> ListNode *headA, <span class="keyword">struct</span> ListNode *headB)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!headA || !headB) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p1</span> =</span> headA, *p2=headB;</span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        <span class="comment">// 两个列表手尾相接，如果有一个点相同，一定会返回</span></span><br><span class="line">        <span class="comment">// a + c + b == b + c + a   --&gt; C1</span></span><br><span class="line">        <span class="comment">// a + b == b + a    --&gt; NULL</span></span><br><span class="line">        p1 = p1 ? p1-&gt;next : headB;</span><br><span class="line">        p2 = p2 ? p2-&gt;next : headA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>161 Locked</p>
<h2 id="162-找到极大值，给定一个数组，可能有多个极大值，找到任意一个即可，给定数组中-A-i-x3D-A-i-1"><a href="#162-找到极大值，给定一个数组，可能有多个极大值，找到任意一个即可，给定数组中-A-i-x3D-A-i-1" class="headerlink" title="162  找到极大值，给定一个数组，可能有多个极大值，找到任意一个即可，给定数组中 A[i] !&#x3D; A[i+1]"></a>162  找到极大值，给定一个数组，可能有多个极大值，找到任意一个即可，给定数组中 A[i] !&#x3D; A[i+1]</h2><p>题目要求在对数时间内做出来，二分搜索，如果中间的数在左半部分，就向右找。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; nums[mid + <span class="number">1</span>]) <span class="comment">// mid in left part of summit</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>                           <span class="comment">// mid in right part of summit</span></span><br><span class="line">            right= mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>163 Locked</p>
<h2 id="164-未排序数组中相差最大的两个数之间的差"><a href="#164-未排序数组中相差最大的两个数之间的差" class="headerlink" title="164 未排序数组中相差最大的两个数之间的差"></a>164 未排序数组中相差最大的两个数之间的差</h2><p>根据抽屉原理，最大差不可能小于 (max - min) &#x2F; (n - 1)。证明：如果小于，那么整个数组的大小就会小于 max - min。<br>因此我们把</p>
<h2 id="165-比较版本号大小"><a href="#165-比较版本号大小" class="headerlink" title="165 比较版本号大小"></a>165 比较版本号大小</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ver</span><span class="params">(<span class="type">const</span> string&amp; version)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : version) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(num);</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于所有这种分割符中读取数字的都需要注意最后一个</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(num); <span class="comment">// notice here</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> v1 = <span class="built_in">ver</span>(version1);</span><br><span class="line">    <span class="keyword">auto</span> v2 = <span class="built_in">ver</span>(version2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>() || i &lt; v2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> a = i &lt; v1.<span class="built_in">size</span>() ? v1[i] : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b = i &lt; v2.<span class="built_in">size</span>() ? v2[i] : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">            <span class="keyword">return</span> a &gt; b ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="166-分数生成小数"><a href="#166-分数生成小数" class="headerlink" title="166 分数生成小数"></a>166 分数生成小数</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">fractionToDecimal</span><span class="params">(<span class="type">long</span> numerator, <span class="type">long</span> denominator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numerator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    string result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 符号</span></span><br><span class="line">    <span class="keyword">if</span> (numerator &lt; <span class="number">0</span> ^ denominator &lt; <span class="number">0</span>)</span><br><span class="line">        result += <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    <span class="type">long</span> n = <span class="built_in">abs</span>(numerator), d = <span class="built_in">abs</span>(denominator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数部分</span></span><br><span class="line">    result += <span class="built_in">to_string</span>(n / d);</span><br><span class="line">    <span class="keyword">if</span> (n % d == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小数部分</span></span><br><span class="line">    result+= <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> r = n % d; r != <span class="number">0</span>; r %= d) &#123; <span class="comment">// 模拟手工除法</span></span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">count</span>(r) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.<span class="built_in">insert</span>(map[r], <span class="number">1</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            result += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map[r] = result.<span class="built_in">size</span>(); <span class="comment">// 记录对应的位置，以便插入括号</span></span><br><span class="line">        r *= <span class="number">10</span>; <span class="comment">// 从上借位</span></span><br><span class="line">        result += <span class="built_in">to_string</span>(r / d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>167 Locked</p>
<h2 id="168-生成-Excel-表格标题"><a href="#168-生成-Excel-表格标题" class="headerlink" title="168 生成 Excel 表格标题"></a>168 生成 Excel 表格标题</h2><p>注意 A 对应的是 1 而不是 0，而且数字也是从 1 开始的</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    string title;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="type">char</span> c = (n<span class="number">-1</span>) % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        n = (n<span class="number">-1</span>) / <span class="number">26</span>;</span><br><span class="line">        title = c + title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="169-给定一个数组，有一个数字的出现频率超过了一半，找出这个数字"><a href="#169-给定一个数组，有一个数字的出现频率超过了一半，找出这个数字" class="headerlink" title="169 给定一个数组，有一个数字的出现频率超过了一半，找出这个数字"></a>169 给定一个数组，有一个数字的出现频率超过了一半，找出这个数字</h2><p>非常经典的一道题，首先我们假设拿到的数字就是目标，并记录他出现的次数，如果下一个<br>数字和他不一样，那么我们减一，当次数为 0 的时候，我们知道这个数字在已经遍历过的数字<br>中出现小于一半了，这时候我们换下一个数字，最后剩下的一定是超过一半的数字。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> candidate, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span> || candidate == i) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            candidate = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>170 Locked</p>
<h2 id="171-Excel-标题转换为数字"><a href="#171-Excel-标题转换为数字" class="headerlink" title="171 Excel 标题转换为数字"></a>171 Excel 标题转换为数字</h2><p>同样，我们需要注意 A 对应的是 1，而不是 0</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">titleToNumber</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*s)</span><br><span class="line">        result = result * <span class="number">26</span> + *s++ - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="172-阶乘中能有几个-0"><a href="#172-阶乘中能有几个-0" class="headerlink" title="172 阶乘中能有几个 0"></a>172 阶乘中能有几个 0</h2><p>显然先算出阶乘数字是会溢出的，而有 0 的话，就是需要 10，也就是就需要 2 和 5，<br>显然 2 是比 5 多的。那么我们只要考虑 5 的个数就行了， 这时候需要注意，5&#x2F;15 等是算一个 5，<br>而 25&#x2F;75 包含了两个 5，所以我们计算的时候，数一遍包含 5 的（这时 25 等也被计算了），<br>然后再数一遍包含 25 的就像当于数了两次了。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> fives = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; n / i &gt; <span class="number">0</span>; i *= <span class="number">5</span>)</span><br><span class="line">        fives += n / i;</span><br><span class="line">    <span class="keyword">return</span> fives;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="173-二叉树中序遍历迭代器"><a href="#173-二叉树中序遍历迭代器" class="headerlink" title="173 二叉树中序遍历迭代器"></a>173 二叉树中序遍历迭代器</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    BSTIterator(TreeNode *root) &#123;</span><br><span class="line">        pushAll(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !m_stack.empty();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        TreeNode* temp = m_stack.top();</span><br><span class="line">        m_stack.pop();</span><br><span class="line">        pushAll(temp-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> temp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; m_stack;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">pushAll</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            m_stack.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator will be called like this:</span></span><br><span class="line"><span class="comment"> * BSTIterator i = BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174 地下城游戏"></a>174 地下城游戏</h2><p>王子在格子的左上角，需要到右下角去救公主，在过程中王子不能死掉，和机器人走路一样，使用动态规划</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculateMinimumHP</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dungeon)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> row = dungeon.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> col = dungeon[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">bloods</span>(row + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (col + <span class="number">1</span>, INT_MAX));</span><br><span class="line">    bloods[row][col<span class="number">-1</span>] = bloods[row<span class="number">-1</span>][col] = <span class="number">1</span>; <span class="comment">// 公主的两边</span></span><br><span class="line">    <span class="comment">// 从公主那里逆向推</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = col<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">             <span class="type">int</span> need = <span class="built_in">min</span>(bloods[i+<span class="number">1</span>][j], bloods[i][j+<span class="number">1</span>]) - dungeon[i][j]; <span class="comment">// 缺乏的血量 = 到达下一步最少的血量 - 这一步消耗的血量</span></span><br><span class="line">             bloods[i][j] = need &gt; <span class="number">0</span> ? need : <span class="number">1</span>; <span class="comment">// 王子的血量至少为 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bloods[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="175-178-Missing"><a href="#175-178-Missing" class="headerlink" title="175-178 Missing"></a>175-178 Missing</h2><h2 id="179-最大的数字"><a href="#179-最大的数字" class="headerlink" title="179 最大的数字"></a>179 最大的数字</h2><p>神奇的排序方法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">largestNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">num_strings</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        num_strings[i] = <span class="built_in">to_string</span>(nums[i]);</span><br><span class="line">    <span class="keyword">auto</span> comparator = [] (string&amp; s1, string&amp; s2) &#123;</span><br><span class="line">        <span class="keyword">return</span> s1 + s2 &gt; s2 + s1;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(num_strings.<span class="built_in">begin</span>(), num_strings.<span class="built_in">end</span>(), comparator);</span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num_string: num_strings)</span><br><span class="line">        result += num_string;</span><br><span class="line">    <span class="type">int</span> start = result.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (start == string::npos) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">substr</span>(start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="180-185-Missing"><a href="#180-185-Missing" class="headerlink" title="180-185 Missing"></a>180-185 Missing</h2><p>186 Locked</p>
<h2 id="187-找到所有-10-个字母唱的重复-DNA-序列"><a href="#187-找到所有-10-个字母唱的重复-DNA-序列" class="headerlink" title="187 找到所有 10 个字母唱的重复 DNA 序列"></a>187 找到所有 10 个字母唱的重复 DNA 序列</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// naive 的做法从前往后，记录字符串</span></span><br><span class="line"><span class="comment">// 观察 ATCG 四个字符的特征，并把他们编码为一个 int</span></span><br><span class="line"><span class="comment">// 十个字符正好编码在 32bit 的 int 中</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="comment">// 左移弹出老元素，求交为了只使用 30bit，求或添加新元素。</span></span><br><span class="line">        <span class="keyword">if</span> (hash[t = t &lt;&lt; <span class="number">3</span> &amp; <span class="number">0x3FFFFFFF</span> | s[i] &amp; <span class="number">0b111</span>]++ == <span class="number">1</span>) <span class="comment">// 等于 1 为了避免重复</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i - <span class="number">9</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="189-翻转树组"><a href="#189-翻转树组" class="headerlink" title="189 翻转树组"></a>189 翻转树组</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> temp = nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= numsSize) k %= numsSize;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    reverse(nums, <span class="number">0</span>, numsSize - k - <span class="number">1</span>);</span><br><span class="line">    reverse(nums, numsSize - k, numsSize - <span class="number">1</span>);</span><br><span class="line">    reverse(nums, <span class="number">0</span>, numsSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="190-翻转二进制表示"><a href="#190-翻转二进制表示" class="headerlink" title="190 翻转二进制表示"></a>190 翻转二进制表示</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(n) * <span class="number">8</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123; <span class="comment">// 31 times shift</span></span><br><span class="line">        r |= n &amp; <span class="number">0x1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        r &lt;&lt;= <span class="number">1</span>; <span class="comment">// only shift 31 times</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r |= n &amp; <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="191-数字二进制表示中-1-的个数"><a href="#191-数字二进制表示中-1-的个数" class="headerlink" title="191 数字二进制表示中 1 的个数"></a>191 数字二进制表示中 1 的个数</h2><p>我们知道 n&amp;(n-1) 会把 n 中的最后一个 1 去掉，所以循环直到 n 为 0 即可</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        n &amp;= n - <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>还可以采用查表法，对于表我们可以预先构造，或者利用上一个方法生成，对于长度过大的，我们可以分块查表。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> counts[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _get_count(n) &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        n &amp;= n<span class="number">-1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_counts</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        counts[i] = _get_count(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_count</span><span class="params">(n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="type">int</span> index = n &amp; <span class="number">0xF</span>;</span><br><span class="line">        count += counts[index];</span><br><span class="line">        n &gt;&gt;= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    init_counts();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>, _get_count(i), get_count(i));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>192-197 Missing</p>
<h2 id="198-有一排房子，每个房子中都有一定财产，但是不能偷相邻的两个房子，求能偷到的最大值"><a href="#198-有一排房子，每个房子中都有一定财产，但是不能偷相邻的两个房子，求能偷到的最大值" class="headerlink" title="198  有一排房子，每个房子中都有一定财产，但是不能偷相邻的两个房子，求能偷到的最大值"></a>198  有一排房子，每个房子中都有一定财产，但是不能偷相邻的两个房子，求能偷到的最大值</h2><p>使用 DP，对于每个房子，可以选择不偷或者前 i-1 个房子加上偷当前房子，即<code>dp[i+1] = max(dp[i], dp[i-1] + A[i])</code></p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 因为不能相邻，所以可以从相隔一个的取值</span></span><br><span class="line">    <span class="comment">// dp[n] = max(dp[n-1], dp[n-2] + A[n])</span></span><br><span class="line">    <span class="type">int</span> temp, m = <span class="number">0</span>, n = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        temp = n;</span><br><span class="line">        <span class="keyword">if</span> (m + nums[i] &gt; n)</span><br><span class="line">            n = m + nums[i];</span><br><span class="line">        m = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="199-从右边看二叉树的效果"><a href="#199-从右边看二叉树的效果" class="headerlink" title="199 从右边看二叉树的效果"></a>199 从右边看二叉树的效果</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// level order 遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node;</span><br><span class="line">        <span class="type">int</span> len = q.<span class="built_in">size</span>(); <span class="comment">// 保存为了获得最后一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">// 当前数组的最后一个元素就是最右边的元素</span></span><br><span class="line">            node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="200-找出小岛的数量"><a href="#200-找出小岛的数量" class="headerlink" title="200 找出小岛的数量"></a>200 找出小岛的数量</h2><p>采用并查集，找到最后集合的数量</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; m_father, m_rank;</span><br><span class="line">    <span class="type">int</span> m_count; <span class="comment">// sets count</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n): <span class="built_in">m_father</span>(n), <span class="built_in">m_rank</span>(n, <span class="number">0</span>), <span class="built_in">m_count</span>(n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_father.<span class="built_in">size</span>(); i++)</span><br><span class="line">            m_father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != m_father[x])</span><br><span class="line">            m_father[x] = <span class="built_in">find</span>(m_father[x]);</span><br><span class="line">        <span class="keyword">return</span> m_father[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_rank[x] &gt; m_rank[y]) &#123;</span><br><span class="line">            m_father[y] = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_rank[x] == m_rank[y])</span><br><span class="line">                m_rank[y]++;</span><br><span class="line">            m_father[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">        m_count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">char</span> LAND = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">char</span> WATER = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.<span class="built_in">empty</span>() || grid[<span class="number">0</span>].<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = grid.<span class="built_in">size</span>(), c = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(r * c + <span class="number">1</span>)</span></span>; <span class="comment">// extra element is for water</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == LAND) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != r - <span class="number">1</span> &amp;&amp; grid[i+<span class="number">1</span>][j] == LAND)</span><br><span class="line">                         uf.<span class="built_in">unionify</span>(i*c+j, (i+<span class="number">1</span>)*c+j);</span><br><span class="line">                    <span class="keyword">if</span> (j != c - <span class="number">1</span> &amp;&amp; grid[i][j+<span class="number">1</span>] == LAND)</span><br><span class="line">                         uf .<span class="built_in">unionify</span>(i*c+j, i*c+j+<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    uf.<span class="built_in">unionify</span>(i*c+j, c*r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.<span class="built_in">getCount</span>() - <span class="number">1</span>; <span class="comment">// islands + water - 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, count</span>):</span><br><span class="line">        self.count = count</span><br><span class="line">        self.parents = <span class="built_in">list</span>(<span class="built_in">range</span>(count))  <span class="comment"># 初始化时 parent 指针指向自己</span></span><br><span class="line">        self.ranks = [<span class="number">1</span>] * count  <span class="comment"># 记录每棵树的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;把 p, q 两个节点连通起来&quot;&quot;&quot;</span></span><br><span class="line">        p_root = self.find(p)</span><br><span class="line">        q_root = self.find(q)</span><br><span class="line">        <span class="keyword">if</span> p_root == q_root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.ranks[p_root] &gt; self.ranks[q_root]:</span><br><span class="line">            self.parents[q_root] = p_root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.ranks[p_root] == self.ranks[q_root]:</span><br><span class="line">                self.ranks[q_root] += <span class="number">1</span></span><br><span class="line">            self.parents[p_root] = q_root</span><br><span class="line">        self.count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;找到 p 节点的根节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> self.parents[p] != p:</span><br><span class="line">            <span class="comment"># 神奇的路径压缩</span></span><br><span class="line">            self.parents[p] = self.parents[self.parents[p]]</span><br><span class="line">            p = self.parents[p]</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_connected</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        p_root = self.find(p)</span><br><span class="line">        q_root = self.find(q)</span><br><span class="line">        <span class="keyword">return</span> p_root == q_root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        uf = UnionFind(m * n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    up = <span class="built_in">max</span>(i - <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">if</span> grid[up][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                        uf.union(i * n + j, up * n + j)</span><br><span class="line">                    left = <span class="built_in">max</span>(j - <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">if</span> grid[i][j - <span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                        uf.union(i * n + j, i * n + left)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    uf.union(i * n + j, m * n)</span><br><span class="line">        <span class="keyword">return</span> uf.count - <span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="201-给定区间内，所有数字-AND-的结果"><a href="#201-给定区间内，所有数字-AND-的结果" class="headerlink" title="201 给定区间内，所有数字 AND 的结果"></a>201 给定区间内，所有数字 AND 的结果</h2><p>显然直接过一遍是会超时的，那么分析可知</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果两个数不相等，一定是有不同的位，那么这一位一定为 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m != n) &#123;</span><br><span class="line">        t++;</span><br><span class="line">        m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m &lt;&lt; t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="202-快乐数字，各位数字平方相加得到下一个数字，如果最后等于-1"><a href="#202-快乐数字，各位数字平方相加得到下一个数字，如果最后等于-1" class="headerlink" title="202 快乐数字，各位数字平方相加得到下一个数字，如果最后等于 1"></a>202 快乐数字，各位数字平方相加得到下一个数字，如果最后等于 1</h2><p>没啥，一直算就可以了。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="type">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            next += (n%<span class="number">10</span>) * (n%<span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="203-删除链表中给定的值"><a href="#203-删除链表中给定的值" class="headerlink" title="203 删除链表中给定的值"></a>203 删除链表中给定的值</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>, *<span class="title">p</span> =</span> &amp;dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;val == val) &#123; <span class="comment">// not forward here</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> p-&gt;next;</span><br><span class="line">            p-&gt;next = next-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="204-找出素数"><a href="#204-找出素数" class="headerlink" title="204 找出素数"></a>204 找出素数</h2><p>什么筛子，忘了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">primes</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    primes[<span class="number">0</span>] = primes[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt; n; i++) <span class="comment">// 注意，只到 sqrt(n)</span></span><br><span class="line">        <span class="keyword">if</span> (primes[i])</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt; n; j += i) <span class="comment">// 从 i * i 开始，因为 i* i-- 已经被杀过了</span></span><br><span class="line">                primes[j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (primes[i])</span><br><span class="line">            count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="205-同构字符串，可以看作-word-pattern-的简化"><a href="#205-同构字符串，可以看作-word-pattern-的简化" class="headerlink" title="205 同构字符串，可以看作 word pattern 的简化"></a>205 同构字符串，可以看作 word pattern 的简化</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isIsomorphic</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ss[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> ts[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(s) != <span class="built_in">strlen</span>(t))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ss[s[i]] != ts[t[i]])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ss[s[i]] = ts[t[i]] = i + <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206 反转链表"></a>206 反转链表</h2><p>tags: #pointers</p>
<p>最最基础的指针操作题目了</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="built_in">next</span> = curr.<span class="built_in">next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> prev  <span class="comment"># 关键在这里</span></span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>, *cur = head, *next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        next = cur-&gt;next; <span class="comment">// cache</span></span><br><span class="line">        cur-&gt;next = p; <span class="comment">// reverse pointing</span></span><br><span class="line">        p = cur; <span class="comment">// moves forwards</span></span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="207-标准的拓扑排序"><a href="#207-标准的拓扑排序" class="headerlink" title="207 标准的拓扑排序"></a>207 标准的拓扑排序</h2><p>给定边这种方法表示图也是醉了</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123; <span class="comment">// next -&gt; before</span></span><br><span class="line">    vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses); <span class="comment">// 每条边和他的下一步，临接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : prerequisites)</span><br><span class="line">        graph[p.second].<span class="built_in">insert</span>(p.first);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">// in degree</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; nexts : graph)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> next : nexts)</span><br><span class="line">            d[next]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nondep; <span class="comment">// in degree == 0</span></span><br><span class="line">        <span class="keyword">for</span> (nondep = <span class="number">0</span>; nondep &lt; numCourses &amp;&amp; d[nondep] != <span class="number">0</span>; nondep++)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">if</span> (nondep == numCourses)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        d[nondep] = <span class="number">-1</span>; <span class="comment">// remove</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> next : graph[nondep]) <span class="comment">// 所有下一步都 －1</span></span><br><span class="line">            d[next]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="208-实现前缀树"><a href="#208-实现前缀树" class="headerlink" title="208 实现前缀树"></a>208 实现前缀树</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> branchCount = <span class="number">26</span>;</span><br><span class="line">    <span class="type">bool</span> isWord;</span><br><span class="line">    TrieNode* next[branchCount];</span><br><span class="line">    <span class="comment">// Initialize your data structure here.</span></span><br><span class="line">    <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; branchCount; i++)</span><br><span class="line">            next[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        location-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!location)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> location-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : prefix) &#123;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!location)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Trie trie;</span></span><br><span class="line"><span class="comment">// trie.insert(&quot;somestring&quot;);</span></span><br><span class="line"><span class="comment">// trie.search(&quot;key&quot;);</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="209-最短子数组使得和大于某个数"><a href="#209-最短子数组使得和大于某个数" class="headerlink" title="209 最短子数组使得和大于某个数"></a>209 最短子数组使得和大于某个数</h2><p>双指针，超过和之后再尝试从开始处减去元素</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, sum = <span class="number">0</span>, len = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">            len = <span class="built_in">min</span>(len, i - start + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[start++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len == INT_MAX? <span class="number">0</span> : len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="210-Course-Schedule-II"><a href="#210-Course-Schedule-II" class="headerlink" title="210 Course Schedule II"></a>210 Course Schedule II</h2><p>BFS</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; graph = <span class="built_in">make_graph</span>(numCourses, prerequisites);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; degrees = <span class="built_in">compute_indegree</span>(graph);</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; zeros;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">            <span class="keyword">if</span> (!degrees[i]) zeros.<span class="built_in">push</span>(i);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; toposort;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (zeros.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            <span class="type">int</span> zero = zeros.<span class="built_in">front</span>();</span><br><span class="line">            zeros.<span class="built_in">pop</span>();</span><br><span class="line">            toposort.<span class="built_in">push_back</span>(zero);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neigh : graph[zero]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!--degrees[neigh])</span><br><span class="line">                    zeros.<span class="built_in">push</span>(neigh);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toposort;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">make_graph</span>(<span class="type">int</span> numCourses, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> pre : prerequisites)</span><br><span class="line">            graph[pre.second].<span class="built_in">insert</span>(pre.first);</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">compute_indegree</span><span class="params">(vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degrees</span><span class="params">(graph.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> neighbors : graph)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neigh : neighbors)</span><br><span class="line">                degrees[neigh]++;</span><br><span class="line">        <span class="keyword">return</span> degrees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="211-添加和搜索字符串"><a href="#211-添加和搜索字符串" class="headerlink" title="211 添加和搜索字符串"></a>211 添加和搜索字符串</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> branchCount = <span class="number">26</span>;</span><br><span class="line">    <span class="type">bool</span> isWord;</span><br><span class="line">    TrieNode* next[branchCount];</span><br><span class="line">    <span class="comment">// Initialize your data structure here.</span></span><br><span class="line">    <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; branchCount; i++)</span><br><span class="line">            next[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        location-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!location)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> location-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* location = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : prefix) &#123;</span><br><span class="line">            location = location-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!location)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TrieNode* <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> : <span class="keyword">public</span> Trie&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WordDictionary</span>() : <span class="built_in">Trie</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adds a word into the data structure.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the data structure. A word could</span></span><br><span class="line">    <span class="comment">// contain the dot character &#x27;.&#x27; to represent any one letter.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(word.<span class="built_in">c_str</span>(), <span class="built_in">getRoot</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* word, TrieNode* root)</span> </span>&#123;</span><br><span class="line">        TrieNode* run = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (run &amp;&amp; word[i] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                run = run-&gt;next[word[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (run &amp;&amp; word[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// skip checking this char</span></span><br><span class="line">                TrieNode* tmp = run;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                    run = tmp-&gt;next[j];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">search</span>(word + i + <span class="number">1</span>, run))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> run &amp;&amp; run-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// WordDictionary wordDictionary;</span></span><br><span class="line"><span class="comment">// wordDictionary.addWord(&quot;word&quot;);</span></span><br><span class="line"><span class="comment">// wordDictionary.search(&quot;pattern&quot;);</span></span><br></pre></td></tr></table></figure>
</details>


<h2 id="212-单词搜索"><a href="#212-单词搜索" class="headerlink" title="212 单词搜索"></a>212 单词搜索</h2><p>Trie 结构见前面，注意要记录 visited，还有边界的问题，另外集合的使用</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie m_trie;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; word : words)</span><br><span class="line">            m_trie.<span class="built_in">insert</span>(word);</span><br><span class="line">        <span class="type">int</span> row = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> col = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;string&gt; result_set;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(row, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(col, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">                <span class="built_in">find</span>(result_set, board, visited, <span class="string">&quot;&quot;</span>, i, j);</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : result_set)</span><br><span class="line">            result.<span class="built_in">push_back</span>(r);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(unordered_set&lt;string&gt;&amp; r, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, string word, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || visited[i][j])</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        word += board[i][j];</span><br><span class="line">        <span class="keyword">if</span> (!m_trie.<span class="built_in">startsWith</span>(word))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (m_trie.<span class="built_in">search</span>(word))</span><br><span class="line">            r.<span class="built_in">insert</span>(word);</span><br><span class="line"></span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">find</span>(r, board, visited, word, i<span class="number">-1</span>, j);</span><br><span class="line">        <span class="built_in">find</span>(r, board, visited, word, i+<span class="number">1</span>, j);</span><br><span class="line">        <span class="built_in">find</span>(r, board, visited, word, i, j<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">find</span>(r, board, visited, word, i, j+<span class="number">1</span>);</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="213-小偷偷环状数组"><a href="#213-小偷偷环状数组" class="headerlink" title="213 小偷偷环状数组"></a>213 小偷偷环状数组</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">robNonCyclic</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 因为不能相邻，所以可以从相隔一个的取值</span></span><br><span class="line">    <span class="comment">// dp[n] = max(dp[n-1], dp[n-2] + A[n])</span></span><br><span class="line">    <span class="type">int</span> temp, m = <span class="number">0</span>, n = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        temp = n;</span><br><span class="line">        <span class="keyword">if</span> (m + nums[i] &gt; n)</span><br><span class="line">            n = m + nums[i];</span><br><span class="line">        m = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> max(robNonCyclic(nums, numsSize - <span class="number">1</span>), robNonCyclic(nums + <span class="number">1</span>, numsSize - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="214-最短回文字符串，给指定的字符串添加字母获得回文"><a href="#214-最短回文字符串，给指定的字符串添加字母获得回文" class="headerlink" title="214 最短回文字符串，给指定的字符串添加字母获得回文"></a>214 最短回文字符串，给指定的字符串添加字母获得回文</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// based on kmp next array</span></span><br><span class="line"><span class="function">string <span class="title">shortestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string rev_s = s;</span><br><span class="line">    <span class="built_in">reverse</span>(rev_s.<span class="built_in">begin</span>(), rev_s.<span class="built_in">end</span>());</span><br><span class="line">    string l = s + <span class="string">&quot;#&quot;</span> + rev_s;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(l.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; l.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = p[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; l[i] != l[j])</span><br><span class="line">            j = p[j - <span class="number">1</span>];</span><br><span class="line">        p[i] = (j += l[i] == l[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rev_s.<span class="built_in">substr</span>(<span class="number">0</span>, s.<span class="built_in">size</span>() - p[l.<span class="built_in">size</span>() - <span class="number">1</span>]) + s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="215-数组中第-k-大的数字"><a href="#215-数组中第-k-大的数字" class="headerlink" title="215 数组中第 k 大的数字"></a>215 数组中第 k 大的数字</h2><p>实际上这道题更可能的题目是找到前 k 大的所有数字。<br>首先，设计到数组排序的问题一定向面试官要问清楚数据量的大小，这影响到接下来的实现，<br>同时和面试官探讨数据量大小对实现的影响，有助于更好的把握局面。</p>
<p>我们先假设数据量是比较小的，也就是能够放到内存中。</p>
<ol start="0">
<li>使用排序就实在是 naive 了，不过面试官非要问的话，当然是使用选择排序更好了。</li>
<li>使用快排中的 partition 算法，时间复杂度 O(n*logk)。</li>
<li>使用 size 为 k 的堆，时间复杂度也是 O(n*logk)，不管数字多大，都只需要遍历一遍。</li>
<li>使用类似插入排序的方法，保持数组大小不变，这样的时间复杂度是 O(n*k)。</li>
<li>数据的范围有限时候，使用计数排序。</li>
</ol>
<p>当数据过大的时候，我们可以想通过哈希取模之后把文件分组，找出每个文件中最大的 k 个数字</p>
<p>如果数字中有重复呢？使用计数排序，计数强制按一算<br>如果既有重复又是浮点数呢？</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> small = start - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pivot = nums[end];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; end; i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; pivot)</span><br><span class="line">            swap(&amp;nums[++small], &amp;nums[i]);</span><br><span class="line">    swap(&amp;nums[++small], &amp;nums[end]);</span><br><span class="line">    <span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> index = partition(nums, left, right);</span><br><span class="line">        <span class="keyword">if</span> (index == numsSize - k)</span><br><span class="line">            <span class="keyword">return</span> nums[index];</span><br><span class="line">        <span class="keyword">if</span> (index &gt; numsSize - k)</span><br><span class="line">            right = index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="216-找到-k-个数字-1…9-，使得他们的和是-n"><a href="#216-找到-k-个数字-1…9-，使得他们的和是-n" class="headerlink" title="216 找到 k 个数字 [1…9]，使得他们的和是 n"></a>216 找到 k 个数字 [1…9]，使得他们的和是 n</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">dfs</span>(result, &#123;&#125;, n, k);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="type">int</span>&gt; combination, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (combination.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            result.<span class="built_in">push_back</span>(combination);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = combination.<span class="built_in">empty</span>() ? <span class="number">1</span> : combination.<span class="built_in">back</span>() + <span class="number">1</span>; <span class="comment">// 保证不重复切实递增序列</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n &amp;&amp; i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        combination.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">dfs</span>(result, combination, n-i, k);</span><br><span class="line">        combination.<span class="built_in">pop_back</span>();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="217-包含重复数字"><a href="#217-包含重复数字" class="headerlink" title="217 包含重复数字"></a>217 包含重复数字</h2><p>这道题太简单了，也没有什么精妙的解法，可以使用排序，Hash 等多种解法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; n : nums)</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">find</span>(n) != s.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s.<span class="built_in">insert</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="218-获得矩形重合部分的拐点"><a href="#218-获得矩形重合部分的拐点" class="headerlink" title="218 获得矩形重合部分的拐点"></a>218 获得矩形重合部分的拐点</h2><p>抄过来的，还没仔细研究</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">getSkyline</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; buildings) &#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">0</span>, cur_X, cur_H =<span class="number">-1</span>,  len = buildings.<span class="built_in">size</span>();</span><br><span class="line">    priority_queue&lt; pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; liveBlg; <span class="comment">// first: height, second, end time</span></span><br><span class="line">    <span class="keyword">while</span>(cur&lt;len || !liveBlg.<span class="built_in">empty</span>()) &#123; <span class="comment">// if either some new building is not processed or live building queue is not empty</span></span><br><span class="line">        cur_X = liveBlg.<span class="built_in">empty</span>()? buildings[cur][<span class="number">0</span>]:liveBlg.<span class="built_in">top</span>().second; <span class="comment">// next timing point to process</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur&gt;=len || buildings[cur][<span class="number">0</span>] &gt; cur_X) &#123; <span class="comment">//first check if the current tallest building will end before the next timing point</span></span><br><span class="line">              <span class="comment">// pop up the processed buildings, i.e. those  have height no larger than cur_H and end before the top one</span></span><br><span class="line">            <span class="keyword">while</span>(!liveBlg.<span class="built_in">empty</span>() &amp;&amp; ( liveBlg.<span class="built_in">top</span>().second &lt;= cur_X) ) liveBlg.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// if the next new building starts before the top one ends, process the new building in the vector</span></span><br><span class="line">            cur_X = buildings[cur][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">while</span>(cur&lt;len &amp;&amp; buildings[cur][<span class="number">0</span>]== cur_X)  <span class="comment">// go through all the new buildings that starts at the same point</span></span><br><span class="line">            &#123;  <span class="comment">// just push them in the queue</span></span><br><span class="line">                liveBlg.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(buildings[cur][<span class="number">2</span>], buildings[cur][<span class="number">1</span>]));</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_H = liveBlg.<span class="built_in">empty</span>()?<span class="number">0</span>:liveBlg.<span class="built_in">top</span>().first; <span class="comment">// outut the top one</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">empty</span>() || (res.<span class="built_in">back</span>().second != cur_H) ) res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(cur_X, cur_H));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="219-包含重复数字，并且两个的坐标不超过-k"><a href="#219-包含重复数字，并且两个的坐标不超过-k" class="headerlink" title="219 包含重复数字，并且两个的坐标不超过 k"></a>219 包含重复数字，并且两个的坐标不超过 k</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口保存前 k 个值，如果有重复的就返回</span></span><br><span class="line"><span class="comment">// num[i-k] num[i-1]，如果滑过了，就删除该元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= nums.<span class="built_in">size</span>()) <span class="comment">// notice here</span></span><br><span class="line">        k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k)</span><br><span class="line">            s.<span class="built_in">erase</span>(nums[i - k - <span class="number">1</span>]); <span class="comment">// delete first note</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">find</span>(nums[i]) != s.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        s.<span class="built_in">insert</span>(nums[i]); <span class="comment">// insert</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="220-同上一题，同时保证两个数字之间小于-t"><a href="#220-同上一题，同时保证两个数字之间小于-t" class="headerlink" title="220 同上一题，同时保证两个数字之间小于 t"></a>220 同上一题，同时保证两个数字之间小于 t</h2><p>保证两个数字之差小于 t</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; window; <span class="comment">// 注意不能使用 unordered</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= nums.<span class="built_in">size</span>()) <span class="comment">// notice here</span></span><br><span class="line">        k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k)</span><br><span class="line">            window.<span class="built_in">erase</span>(nums[i - k - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">auto</span> pos = window.<span class="built_in">lower_bound</span>(nums[i] - t); <span class="comment">// notice set.lower_bound</span></span><br><span class="line">        <span class="keyword">if</span> (pos != window.<span class="built_in">end</span>() &amp;&amp; *pos - nums[i] &lt;= t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        window.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="221-找到最大的正方形"><a href="#221-找到最大的正方形" class="headerlink" title="221 找到最大的正方形"></a>221 找到最大的正方形</h2><p>使用动态规划 <a target="_blank" rel="noopener" href="https://leetcode.com/discuss/38489/easy-solution-with-detailed-explanations-8ms-time-and-space">https://leetcode.com/discuss/38489/easy-solution-with-detailed-explanations-8ms-time-and-space</a></p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> maxsize = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// 每一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123; <span class="comment">// notice i range</span></span><br><span class="line">            <span class="type">int</span> temp = dp[i];</span><br><span class="line">            <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], <span class="built_in">min</span>(dp[i - <span class="number">1</span>], pre)) + <span class="number">1</span>;</span><br><span class="line">                maxsize = <span class="built_in">max</span>(maxsize, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dp[i] = <span class="number">0</span>;</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsize * maxsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="222-给定一个完全树，计算节点的数量。"><a href="#222-给定一个完全树，计算节点的数量。" class="headerlink" title="222 给定一个完全树，计算节点的数量。"></a>222 给定一个完全树，计算节点的数量。</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left_height = <span class="number">0</span>, right_height = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* left = root, *right = root;</span><br><span class="line">    <span class="keyword">while</span> (left) &#123;</span><br><span class="line">        left = left-&gt;left;</span><br><span class="line">        left_height++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right) &#123;</span><br><span class="line">        right = right-&gt;right;</span><br><span class="line">        right_height++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left_height == right_height) <span class="comment">// 满树 2^h - 1</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; left_height) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="223-找出两个长方形覆盖的面积"><a href="#223-找出两个长方形覆盖的面积" class="headerlink" title="223 找出两个长方形覆盖的面积"></a>223 找出两个长方形覆盖的面积</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">computeArea</span><span class="params">(<span class="type">int</span> left1, <span class="type">int</span> down1, <span class="type">int</span> right1, <span class="type">int</span> up1, <span class="type">int</span> left2, <span class="type">int</span> down2, <span class="type">int</span> right2, <span class="type">int</span> up2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = max(left1, left2); <span class="comment">// 靠右的</span></span><br><span class="line">    <span class="type">int</span> right = max(min(right1, right2), left);<span class="comment">// 靠左的，但是比左边大</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> down = max(down1, down2);</span><br><span class="line">    <span class="type">int</span> up = max(min(up1, up2), down);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不小心写反了。</span></span><br><span class="line">    <span class="keyword">return</span> -((left1 - right1) * (up1 - down1) + (left2 - right2) * (up2 - down2) - (left - right) * (up - down));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="224-给定一个字符串，包含加减和括号，计算值"><a href="#224-给定一个字符串，包含加减和括号，计算值" class="headerlink" title="224 给定一个字符串，包含加减和括号，计算值"></a>224 给定一个字符串，包含加减和括号，计算值</h2><p>难点是对括号的处理，注意每次都要和 signs.top() 相乘</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; signs; <span class="comment">// signs before braces</span></span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    signs.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">            num = <span class="number">10</span> * num + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            result += signs.<span class="built_in">top</span>() * sign * num;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            signs.<span class="built_in">push</span>(sign * signs.<span class="built_in">top</span>()); <span class="comment">// tricky</span></span><br><span class="line">            sign = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            result += signs.<span class="built_in">top</span>() * sign * num;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            signs.<span class="built_in">pop</span>();</span><br><span class="line">            sign = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result += signs.<span class="built_in">top</span>() * sign * num; <span class="comment">// tricky</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="225-使用队列模拟栈"><a href="#225-使用队列模拟栈" class="headerlink" title="225 使用队列模拟栈"></a>225 使用队列模拟栈</h2><p>其实有两种做法，一种是在 push 的时候，把队列清空，把 x 放到最底下。<br>另一种是在 pop 的时候，把队列清空到 1，然后弹出。应当询问面试官究竟是 push 居多还是 pop 居多</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Push element x onto stack.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!nums.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            temp.<span class="built_in">push</span>(nums.<span class="built_in">front</span>());</span><br><span class="line">            nums.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        nums.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (!temp.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            nums.<span class="built_in">push</span>(temp.<span class="built_in">front</span>());</span><br><span class="line">            temp.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes the element on top of the stack.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nums.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the top element.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return whether the stack is empty.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="226-反转二叉树"><a href="#226-反转二叉树" class="headerlink" title="226 反转二叉树"></a>226 反转二叉树</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">invertTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">temp</span> =</span> root-&gt;left;</span><br><span class="line">    root-&gt;left = invertTree(root-&gt;right);</span><br><span class="line">    root-&gt;right = invertTree(temp);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="227-给定一个字符串包含-计算他的值"><a href="#227-给定一个字符串包含-计算他的值" class="headerlink" title="227 给定一个字符串包含 +-*/ 计算他的值"></a>227 给定一个字符串包含 <code>+-*/</code> 计算他的值</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; stk; <span class="comment">// 使用 vector 便于统计最后的值</span></span><br><span class="line">    <span class="type">char</span> token = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">            num = num * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 这里不是 else if</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;*&#x27;</span> || s[i] == <span class="string">&#x27;/&#x27;</span> || i == s.<span class="built_in">size</span>() - <span class="number">1</span>) &#123; <span class="comment">// 注意最后一步还需要把最后的值计算</span></span><br><span class="line">            <span class="type">int</span> a;</span><br><span class="line">            <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                stk.<span class="built_in">push_back</span>(num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                stk.<span class="built_in">push_back</span>(-num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                a = stk.<span class="built_in">back</span>();</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                stk.<span class="built_in">push_back</span>(a * num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                a = stk.<span class="built_in">back</span>();</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                stk.<span class="built_in">push_back</span>(a / num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            token = s[i];</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : stk)</span><br><span class="line">        result += i;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="228-聚合区间，给定一排序数组，把相邻的数字用区间表示"><a href="#228-聚合区间，给定一排序数组，把相邻的数字用区间表示" class="headerlink" title="228 聚合区间，给定一排序数组，把相邻的数字用区间表示"></a>228 聚合区间，给定一排序数组，把相邻的数字用区间表示</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">        <span class="type">int</span> start = i, end = i;</span><br><span class="line">        <span class="keyword">while</span> (end + <span class="number">1</span> &lt; n &amp;&amp; nums[end + <span class="number">1</span>] == nums[end] + <span class="number">1</span>)</span><br><span class="line">            end++;</span><br><span class="line">        <span class="keyword">if</span> (end &gt; start)</span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[start]) + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(nums[end]));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[start]));</span><br><span class="line">        i = end + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="229-找出超过三分之一的元素"><a href="#229-找出超过三分之一的元素" class="headerlink" title="229 找出超过三分之一的元素"></a>229 找出超过三分之一的元素</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count1 == <span class="number">0</span> || n == a) &#123;</span><br><span class="line">            count1++;</span><br><span class="line">            a = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count2 == <span class="number">0</span> || n == b) &#123;</span><br><span class="line">            count2++;</span><br><span class="line">            b = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count1--;</span><br><span class="line">            count2--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count1 = count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == a) count1++;</span><br><span class="line">        <span class="keyword">if</span> (n == b) count2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count1 &gt; nums.<span class="built_in">size</span>() / <span class="number">3</span>) <span class="comment">// verify a</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(a);</span><br><span class="line">    <span class="keyword">if</span> (count2 &gt; nums.<span class="built_in">size</span>() / <span class="number">3</span> &amp;&amp; a != b) <span class="comment">// verify b</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(b);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="230-二叉树中第-k-小的数字"><a href="#230-二叉树中第-k-小的数字" class="headerlink" title="230 二叉树中第 k 小的数字"></a>230 二叉树中第 k 小的数字</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递指针</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* k, <span class="type">int</span>* number)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inorder(root-&gt;left, k, number);</span><br><span class="line">    (*k)--;</span><br><span class="line">    <span class="keyword">if</span> (*k == <span class="number">0</span>) &#123;</span><br><span class="line">        *number = root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root-&gt;right, k, number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    inorder(root, &amp;k, &amp;number);</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="231-2-的次方"><a href="#231-2-的次方" class="headerlink" title="231 2 的次方"></a>231 2 的次方</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<details>
    <summary>Rust 解答</summary>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_power_of_two</span>(n: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        (n &amp; (n-<span class="number">1</span>)) == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="232-使用栈模拟队列"><a href="#232-使用栈模拟队列" class="headerlink" title="232 使用栈模拟队列"></a>232 使用栈模拟队列</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Push element x to the back of queue.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        in.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes the element from in front of queue.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (out.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="built_in">transfer</span>();</span><br><span class="line">        out.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the front element.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">if</span> (out.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="built_in">transfer</span>();</span><br><span class="line">        <span class="keyword">return</span> out.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return whether the queue is empty.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.<span class="built_in">empty</span>() &amp;&amp; out.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!in.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            out.<span class="built_in">push</span>(in.<span class="built_in">top</span>());</span><br><span class="line">            in.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; in;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; out;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="233-小于-n-的数字中-1-的个数"><a href="#233-小于-n-的数字中-1-的个数" class="headerlink" title="233 小于 n 的数字中 1 的个数"></a>233 小于 n 的数字中 1 的个数</h2><p>对于每一位，有三种情况：</p>
<ol>
<li>当是数字 0 的时候，可能出先 1 的情况完全由高位出现决定，因为这一位不能贡献 1</li>
<li>当是数字 1 的时候，同上，但是这一位和低位一起可以贡献一个 1</li>
<li>当时数字 2-9 的时候，相当于这一位的 1 可以任意出现，因此高位＋1</li>
</ol>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ones = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">1</span>; m &lt;= n; m *= <span class="number">10</span>) &#123; <span class="comment">// m is the factor</span></span><br><span class="line">        <span class="type">int</span> a = n/m, b = n%m;  <span class="comment">// a is left half, b is right half</span></span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">10</span> &gt;= <span class="number">2</span>)</span><br><span class="line">            ones += (a / <span class="number">10</span> + <span class="number">1</span>) * m;</span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">10</span> == <span class="number">1</span>)</span><br><span class="line">            ones += (a / <span class="number">10</span>) * m + b + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">            ones += (a / <span class="number">10</span>) * m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>二进制呢</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countDigitOneBinary</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ones = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">1</span>; m &lt;= n; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> a = n / m, b = n % m;</span><br><span class="line">        <span class="keyword">if</span> (a &amp; <span class="number">0x01</span>)</span><br><span class="line">            ones += (a &gt;&gt; <span class="number">1</span>) * m + b + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ones += (a &gt;&gt; <span class="number">1</span>) * m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>求最大的 countDigitOne(n) &#x3D;&#x3D; n</p>
<pre><code>9    1
99   20
999  300
...
99999999  10000000
</code></pre>
<h2 id="234-判断一个链表是否是回文"><a href="#234-判断一个链表是否是回文" class="headerlink" title="234 判断一个链表是否是回文"></a>234 判断一个链表是否是回文</h2><p>解法 1: 如果链表是可以改变的，不妨反转它的前半部分，然后再与后半部分比较</p>
<p>解法 2: 如果是只读的，复制一份也可以，但是不如使用堆栈</p>
<p>注意对奇数偶数的处理</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode* temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    temp = head;</span><br><span class="line">    <span class="type">int</span> mid = len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (mid--) &#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(temp-&gt;val);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &amp; <span class="number">0x01</span>)</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> a = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b = temp-&gt;val;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="235-二叉搜索树公共祖先"><a href="#235-二叉搜索树公共祖先" class="headerlink" title="235 二叉搜索树公共祖先"></a>235 二叉搜索树公共祖先</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">lowestCommonAncestor</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="236-二叉树公共祖先"><a href="#236-二叉树公共祖先" class="headerlink" title="236 二叉树公共祖先"></a>236 二叉树公共祖先</h2><p>如果二叉树的根就是其中一个节点，那显然是这个。<br>在两颗子树中分别查找，如果找到了，返回一个非 NULL 值，如果都找到了，则这个节点就是 LCA</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">lowestCommonAncestor</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || root == p || root == q)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span> =</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span> =</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!left) <span class="comment">// not in left subtree</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">if</span> (!right)</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// both left and right are found!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="237-删除链表中的元素"><a href="#237-删除链表中的元素" class="headerlink" title="237 删除链表中的元素"></a>237 删除链表中的元素</h2><p>直接将后继节点的值复制到当前节点</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(<span class="keyword">struct</span> ListNode* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node || !node-&gt;next)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span> node-&gt;next;</span><br><span class="line">    node-&gt;val = next-&gt;val;</span><br><span class="line">    node-&gt;next = next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="238-数组除了自己以外的乘积，规定不能用除法"><a href="#238-数组除了自己以外的乘积，规定不能用除法" class="headerlink" title="238 数组除了自己以外的乘积，规定不能用除法"></a>238 数组除了自己以外的乘积，规定不能用除法</h2><p>首先从前往后乘，错开一位元素，这样每个元素都乘到了他之前的所有元素，最后一个元素已经是结果了。<br>然后从后往前乘，同样错开一位，这样每个元素又把他之后的元素都得到了。</p>
<h2 id="239-滑动窗口最大值，给定一个滑动窗口，返回它移动过程中的最大值"><a href="#239-滑动窗口最大值，给定一个滑动窗口，返回它移动过程中的最大值" class="headerlink" title="239 滑动窗口最大值，给定一个滑动窗口，返回它移动过程中的最大值"></a>239 滑动窗口最大值，给定一个滑动窗口，返回它移动过程中的最大值</h2><p>单调队列的应用，复杂度是 O(n) 的。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonoQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.q = deque()  <span class="comment"># 实际储存数据</span></span><br><span class="line">        self.m = deque()  <span class="comment"># 维护单调关系，队首元素总是最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.q.append(x)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.m) &gt; <span class="number">0</span> <span class="keyword">and</span> self.m[-<span class="number">1</span>] &lt; x:</span><br><span class="line">            self.m.pop()</span><br><span class="line">        self.m.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        x = self.q.popleft()</span><br><span class="line">        <span class="keyword">if</span> self.m[<span class="number">0</span>] == x:</span><br><span class="line">            self.m.popleft()</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.q)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.m[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        q = MonoQueue()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            q.push(nums[i])</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">            ans.append(q.top())</span><br><span class="line">            q.pop()</span><br><span class="line">            q.push(nums[i])</span><br><span class="line">        ans.append(q.top())</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<p>另一种现在我已经看不懂的做法</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 题目给定 k 一定是有效地</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>() || k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; dq; <span class="comment">// 存储的是索引，front 存储最大值，保证递减</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() &lt; i - k + <span class="number">1</span>) <span class="comment">// 弹出滑过的窗口</span></span><br><span class="line">            dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; nums[dq.<span class="built_in">back</span>()] &lt; nums[i]) <span class="comment">// 弹出小的</span></span><br><span class="line">            dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>)</span><br><span class="line">            result.<span class="built_in">push_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="240-给定一个矩阵，每行从左到右都是增大的，每一列从上到下都是增大的，找出给定数字是否存在"><a href="#240-给定一个矩阵，每行从左到右都是增大的，每一列从上到下都是增大的，找出给定数字是否存在" class="headerlink" title="240 给定一个矩阵，每行从左到右都是增大的，每一列从上到下都是增大的，找出给定数字是否存在"></a>240 给定一个矩阵，每行从左到右都是增大的，每一列从上到下都是增大的，找出给定数字是否存在</h2><p>我们考虑右上角的元素</p>
<ol>
<li>如果这个元素比 taget 大，那么整列都比 target 大，我们可以 c–</li>
<li>如果这个元素比 target 小，那么正行都比 target 小，我们可以 r++</li>
</ol>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>, c = col - <span class="number">1</span>; <span class="comment">// 右上角</span></span><br><span class="line">    <span class="keyword">while</span> (r &lt; row &amp;&amp; c &gt; <span class="number">-1</span>) <span class="comment">// 向左下角</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[r][c] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[r][c] &gt; target)</span><br><span class="line">            c--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="241-添加括号得到不同的结果"><a href="#241-添加括号得到不同的结果" class="headerlink" title="241 添加括号得到不同的结果"></a>241 添加括号得到不同的结果</h2><p>对每一个符号，在他的两边添加括号的好的不同结果再计算。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; output;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> token = input[i];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(token)) <span class="comment">// not digit</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> a : <span class="built_in">diffWaysToCompute</span>(input.<span class="built_in">substr</span>(<span class="number">0</span>, i))) <span class="comment">// 左半部分</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> b : <span class="built_in">diffWaysToCompute</span>(input.<span class="built_in">substr</span>(i+<span class="number">1</span>))) <span class="comment">// 右半部分</span></span><br><span class="line">                    output.<span class="built_in">push_back</span>(token == <span class="string">&#x27;+&#x27;</span> ? a + b : token == <span class="string">&#x27;-&#x27;</span>? a - b: a *b); <span class="comment">// 两半部分之和</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (output.<span class="built_in">empty</span>())</span><br><span class="line">        output.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input));</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="242-一个单词是否能由另一个变幻而来"><a href="#242-一个单词是否能由另一个变幻而来" class="headerlink" title="242 一个单词是否能由另一个变幻而来"></a>242 一个单词是否能由另一个变幻而来</h2><p>还是，对于 ASCII 字符，直接用数组代替字典</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isAnagram</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> &#123;</span><br><span class="line">    <span class="type">char</span> ss[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> ts[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        ss[*s - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        s++;</span><br><span class="line">        ts[*t - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memcmp</span>(ss, ts, <span class="keyword">sizeof</span>(ss)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>243-256 Locked</p>
<h2 id="257-二叉树左右路径"><a href="#257-二叉树左右路径" class="headerlink" title="257 二叉树左右路径"></a>257 二叉树左右路径</h2><p>典型的 DFS，发挥所有从根节点到叶节点的路径</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="built_in">paths</span>(result, <span class="string">&quot;&quot;</span>, root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paths</span><span class="params">(vector&lt;string&gt;&amp; result, string path, TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">empty</span>())</span><br><span class="line">        path += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        path += <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        <span class="built_in">paths</span>(result, path, root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        <span class="built_in">paths</span>(result, path, root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="258-把数字的每一位加起来，直到变成一个一位的数字"><a href="#258-把数字的每一位加起来，直到变成一个一位的数字" class="headerlink" title="258 把数字的每一位加起来，直到变成一个一位的数字"></a>258 把数字的每一位加起来，直到变成一个一位的数字</h2><p>这完全是一道数学题，对于每个进制的数字都有规律 <code>(n - 1) % (x - 1) + 1</code>。实际上是把 10 进制的转化为 9 进制数字</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">addDigits</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>259 Locked</p>
<h2 id="260-给定一个数组，每个数字都是重复的，只有两个数字不是，找出这两个数字"><a href="#260-给定一个数组，每个数字都是重复的，只有两个数字不是，找出这两个数字" class="headerlink" title="260 给定一个数组，每个数字都是重复的，只有两个数字不是，找出这两个数字"></a>260 给定一个数组，每个数字都是重复的，只有两个数字不是，找出这两个数字</h2><p>这道题很奇妙，依然可以使用 XOR 来解，首先遍历一遍，这时候由于有两个数字是不同的，那么一定结果不为 0，那么其中一个 bit 位一定是一个数字有，另一个数字没有。<br>在遍历一遍，同时把数字分两组，一组是有这个 bit 位，一组没有。就得出了结果。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; n : nums)</span><br><span class="line">        r ^= n;</span><br><span class="line">    <span class="type">int</span> bit = r &amp; -r; <span class="comment">// last sig bit</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; n : nums)</span><br><span class="line">        <span class="keyword">if</span> (n &amp; bit)</span><br><span class="line">            result[<span class="number">0</span>] ^= n;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result[<span class="number">1</span>] ^= n;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>261 262 Locked</p>
<h2 id="263-丑陋的数字，质数因子只含有-2-3-5-的数字"><a href="#263-丑陋的数字，质数因子只含有-2-3-5-的数字" class="headerlink" title="263 丑陋的数字，质数因子只含有 2,3,5 的数字"></a>263 丑陋的数字，质数因子只含有 2,3,5 的数字</h2><p>按定义做就好了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isUgly</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="264-找出第-n-个丑陋数字"><a href="#264-找出第-n-个丑陋数字" class="headerlink" title="264 找出第 n 个丑陋数字"></a>264 找出第 n 个丑陋数字</h2><p>使用数列记录 n 个丑陋数字，每一个丑陋数字肯定是之前数字乘以 235 得到的，然后用三个指针分别指向上一个做乘法的数字，每次找出最小的一个</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">6</span>) <span class="comment">// 1..6 恰好都是</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> s2 = <span class="number">0</span>, s3 = <span class="number">0</span>, s5 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* uglies[n];</span><br><span class="line">    uglies[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> c2 = uglies[s2] * <span class="number">2</span>, c3 = uglies[s3] * <span class="number">3</span>, c5 = uglies[s5] * <span class="number">5</span>;</span><br><span class="line">        uglies[i] = MIN(c2, MIN(c3, c5));</span><br><span class="line">        <span class="keyword">if</span> (uglies[i] == c2) s2++;</span><br><span class="line">        <span class="keyword">if</span> (uglies[i] == c3) s3++;</span><br><span class="line">        <span class="keyword">if</span> (uglies[i] == c5) s5++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uglies[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="268-丢失的数字，给定-0…n，丢失了一个，然后放在长度为-n-的数组之中，找出这个数字"><a href="#268-丢失的数字，给定-0…n，丢失了一个，然后放在长度为-n-的数组之中，找出这个数字" class="headerlink" title="268 丢失的数字，给定 0…n，丢失了一个，然后放在长度为 n 的数组之中，找出这个数字"></a>268 丢失的数字，给定 0…n，丢失了一个，然后放在长度为 n 的数组之中，找出这个数字</h2><p>显然还是使用异或，注意 0 ^ x &#x3D;&#x3D; x，所以直接把 0 忽略就行了。把每个数字都和 i 异或，丢失的数字就出来了</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        result = result ^ (i + <span class="number">1</span>) ^ nums[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>269-272 Locked</p>
<h2 id="273-数字转换为英语单词"><a href="#273-数字转换为英语单词" class="headerlink" title="273 数字转换为英语单词"></a>273 数字转换为英语单词</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; digits = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Four&quot;</span>, <span class="string">&quot;Five&quot;</span>, <span class="string">&quot;Six&quot;</span>, <span class="string">&quot;Seven&quot;</span>, <span class="string">&quot;Eight&quot;</span>, <span class="string">&quot;Nine&quot;</span>, <span class="string">&quot;Ten&quot;</span>, <span class="string">&quot;Eleven&quot;</span>, <span class="string">&quot;Twelve&quot;</span>, <span class="string">&quot;Thirteen&quot;</span>, <span class="string">&quot;Fourteen&quot;</span>, <span class="string">&quot;Fifteen&quot;</span>, <span class="string">&quot;Sixteen&quot;</span>, <span class="string">&quot;Seventeen&quot;</span>, <span class="string">&quot;Eighteen&quot;</span>, <span class="string">&quot;Nineteen&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; tens = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Twenty&quot;</span>, <span class="string">&quot;Thirty&quot;</span>, <span class="string">&quot;Forty&quot;</span>, <span class="string">&quot;Fifty&quot;</span>, <span class="string">&quot;Sixty&quot;</span>, <span class="string">&quot;Seventy&quot;</span>, <span class="string">&quot;Eighty&quot;</span>, <span class="string">&quot;Ninety&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; seps = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot; Thousand &quot;</span>, <span class="string">&quot; Million &quot;</span>, <span class="string">&quot; Billion &quot;</span>&#125;; <span class="comment">// notice the trailing spaces</span></span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">numberToWords</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Zero&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Negative &quot;</span> + <span class="built_in">numberToWords</span>(-num);</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        string result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">1000</span> != <span class="number">0</span>)</span><br><span class="line">                result = <span class="built_in">s2word</span>(num % <span class="number">1000</span>) + seps[count] + result;</span><br><span class="line">            num /= <span class="number">1000</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// removw unnecessary tailing space</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(result.<span class="built_in">back</span>()))</span><br><span class="line">            result.<span class="built_in">resize</span>(result.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">s2word</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string result;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">            result += digits[num/<span class="number">100</span>] + <span class="string">&quot; Hundred &quot;</span>;</span><br><span class="line">            num %= <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">20</span>) &#123;</span><br><span class="line">            result += tens[num / <span class="number">10</span>] + <span class="string">&quot; &quot;</span>;</span><br><span class="line">            num %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">1</span> &amp;&amp; num &lt;= <span class="number">19</span>)</span><br><span class="line">            result += digits[num];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remove tailing spaces</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(result.<span class="built_in">back</span>()))</span><br><span class="line">            result.<span class="built_in">resize</span>(result.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="274-H-Index"><a href="#274-H-Index" class="headerlink" title="274 H-Index"></a>274 H-Index</h2><p>H-Index 的定义：一个科学家的 N 篇论文 h 个至少有 h 个引用，而且剩下的 N-h 篇论文都没有超过 h 个引用。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>* cites, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> hs[n+<span class="number">1</span>]; <span class="comment">// Hindex 不可能大于 N</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        hs[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cites[i] &gt; n)</span><br><span class="line">            hs[n]++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hs[cites[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n, papers = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 从后往前，如果有符合条件的，那么就是 Hindex</span></span><br><span class="line">        papers += hs[i];</span><br><span class="line">        <span class="keyword">if</span> (papers &gt;= i)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="275-H-index-II，论文已经按照引用数量排序"><a href="#275-H-index-II，论文已经按照引用数量排序" class="headerlink" title="275 H-index II，论文已经按照引用数量排序"></a>275 H-index II，论文已经按照引用数量排序</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>* citations, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 二分查找是小于等于</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (citations[mid] == n - mid)</span><br><span class="line">            <span class="keyword">return</span> citations[mid];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (citations[mid] &lt; n - mid)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - right - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>276-277 Locked</p>
<h2 id="278-第一个坏版本"><a href="#278-第一个坏版本" class="headerlink" title="278 第一个坏版本"></a>278 第一个坏版本</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际上是 lower_bound 函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n; <span class="comment">// 记住 lower_bound 的 right 是 n</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;   <span class="comment">// 使用小于号</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isBadVersion(mid))</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="279-分解为平方数的和"><a href="#279-分解为平方数的和" class="headerlink" title="279 分解为平方数的和"></a>279 分解为平方数的和</h2><p>最多 4 个即可，尝试在三个以内是否可以。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ub = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a=<span class="number">0</span>; a&lt;=ub; ++a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b=a; b&lt;=ub; ++b) &#123;</span><br><span class="line">            <span class="type">int</span> c = <span class="built_in">sqrt</span>(n - a*a - b*b);</span><br><span class="line">            <span class="keyword">if</span> (a*a + b*b + c*c == n)</span><br><span class="line">                <span class="keyword">return</span> !!a + !!b + !!c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="282-添加运算符使得算式成立"><a href="#282-添加运算符使得算式成立" class="headerlink" title="282 添加运算符使得算式成立"></a>282 添加运算符使得算式成立</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">addOperators</span><span class="params">(string num, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (num.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="built_in">dfs</span>(num, target, result, num[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>, num.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string num, <span class="type">int</span> target, vector&lt;string&gt; &amp; v, <span class="type">long</span> <span class="type">long</span> last, string s, <span class="type">int</span> idx, <span class="type">int</span> left)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == num.<span class="built_in">length</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == last*left)</span><br><span class="line">            v.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(last!=<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(num, target,         v, last * <span class="number">10</span> + num[idx] - <span class="string">&#x27;0&#x27;</span>, s + num.<span class="built_in">substr</span>(idx, <span class="number">1</span>), idx + <span class="number">1</span>, left); <span class="comment">// 尝试拼成 10</span></span><br><span class="line">        <span class="built_in">dfs</span>(num, target,             v, num[idx] - <span class="string">&#x27;0&#x27;</span>, s + <span class="string">&#x27;*&#x27;</span> + num.<span class="built_in">substr</span>(idx, <span class="number">1</span>), idx + <span class="number">1</span>, last*left);</span><br><span class="line">        <span class="built_in">dfs</span>(num, target - left*last, v, num[idx] - <span class="string">&#x27;0&#x27;</span>, s + <span class="string">&#x27;+&#x27;</span> + num.<span class="built_in">substr</span>(idx, <span class="number">1</span>), idx + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(num, target - left*last, v, num[idx] - <span class="string">&#x27;0&#x27;</span>, s + <span class="string">&#x27;-&#x27;</span> + num.<span class="built_in">substr</span>(idx, <span class="number">1</span>), idx + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="283-移动-0"><a href="#283-移动-0" class="headerlink" title="283 移动 0"></a>283 移动 0</h2><p>注意 swap 的使用</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">swap</span>(nums[n++], nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="284-Peek-Iterator"><a href="#284-Peek-Iterator" class="headerlink" title="284 Peek Iterator"></a>284 Peek Iterator</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Below is the interface for Iterator, which is already defined for you.</span></span><br><span class="line"><span class="comment">// **DO NOT** modify the interface for Iterator.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Data</span>;</span><br><span class="line">    Data* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Iterator</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums);</span><br><span class="line">    <span class="built_in">Iterator</span>(<span class="type">const</span> Iterator&amp; iter);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Iterator</span>();</span><br><span class="line">    <span class="comment">// Returns the next element in the iteration.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Returns true if the iteration has more elements.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PeekingIterator</span> : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PeekingIterator</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums) : <span class="built_in">Iterator</span>(nums) &#123;</span><br><span class="line">        <span class="comment">// Initialize any member here.</span></span><br><span class="line">        <span class="comment">// **DO NOT** save a copy of nums and manipulate it directly.</span></span><br><span class="line">        <span class="comment">// You should only use the Iterator interface methods.</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the next element in the iteration without advancing the iterator.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Iterator</span>(*<span class="keyword">this</span>).<span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hasNext() and next() should behave the same as in the Iterator interface.</span></span><br><span class="line">    <span class="comment">// Override them if needed.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Iterator::<span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Iterator::<span class="built_in">hasNext</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="285-286-Locked"><a href="#285-286-Locked" class="headerlink" title="285 ~ 286 Locked"></a>285 ~ 286 Locked</h2><h2 id="287-一个-n-的数组包含了-1…n-1-中的这些数字，证明一定存在重复，并找出这个重复"><a href="#287-一个-n-的数组包含了-1…n-1-中的这些数字，证明一定存在重复，并找出这个重复" class="headerlink" title="287 一个 n 的数组包含了 1…n-1 中的这些数字，证明一定存在重复，并找出这个重复"></a>287 一个 n 的数组包含了 1…n-1 中的这些数字，证明一定存在重复，并找出这个重复</h2><p>使用抽屉原理可以证明一定存在重复。据说高纳德解这个问题花了四个小时。</p>
<p>我们把这个数组看做一个变幻方程 <code>f(i) = A[i]</code>，把一些数字变幻到另一些，那么存在一个 <code>i != j s.t. f(i) == f(j)</code>.<br>那么这个问题变成了链表求环的问题。对于链表，我们有 n &#x3D; n-&gt;next 遍历列表，对于这个序列，则是<code> n = f(n)</code></p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 从 n-1 开始</span></span><br><span class="line">    <span class="type">int</span> fast = n - <span class="number">1</span>, slow = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        slow = nums[slow] - <span class="number">1</span>; <span class="comment">// 减一是为了转化为坐标</span></span><br><span class="line">        fast = nums[nums[fast] - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line">    fast = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        slow = nums[slow] - <span class="number">1</span>;</span><br><span class="line">        fast = nums[fast] - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>; <span class="comment">// 从坐标到数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="288-Locked"><a href="#288-Locked" class="headerlink" title="288 Locked"></a>288 Locked</h2><h2 id="289-Conway’s-Game-of-Life"><a href="#289-Conway’s-Game-of-Life" class="headerlink" title="289 Conway’s Game of Life"></a>289 Conway’s Game of Life</h2><p>哈哈，机智，使用没有使用的第二个位存储下一代</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;<span class="keyword">return</span> a &gt; b ? a :b;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;<span class="keyword">return</span> a &lt; b ? a :b;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gameOfLife</span><span class="params">(<span class="type">int</span>** board, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m=max(i<span class="number">-1</span>, <span class="number">0</span>); m&lt;min(i+<span class="number">2</span>, row); m++) <span class="comment">// 这里的 min，max 使用的太屌了</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> n=max(j<span class="number">-1</span>, <span class="number">0</span>); n&lt;min(j+<span class="number">2</span>, col); n++)</span><br><span class="line">                    count += (board[m][n] &amp; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">3</span> || count - board[i][j] == <span class="number">3</span>) <span class="comment">// 当前为 0，周围为 3；or 当前为 1，周围为 2/3 here</span></span><br><span class="line">                board[i][j] |= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            board[i][j] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="290-单词模式，给定一个模式-abba-等，判断单词是否是这个模式的。"><a href="#290-单词模式，给定一个模式-abba-等，判断单词是否是这个模式的。" class="headerlink" title="290 单词模式，给定一个模式 abba 等，判断单词是否是这个模式的。"></a>290 单词模式，给定一个模式 abba 等，判断单词是否是这个模式的。</h2><details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wordPattern</span><span class="params">(string pattern, string str)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; chars;  <span class="comment">// 使用两个 map 纪录</span></span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; words;</span><br><span class="line">    <span class="function">istringstream <span class="title">in</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, n = pattern.<span class="built_in">size</span>(); <span class="comment">// `i` is word count</span></span><br><span class="line">    <span class="keyword">for</span> (string word; in &gt;&gt; word; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n || chars[pattern[i]] != words[word]) <span class="comment">// 检查是否相等</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        chars[pattern[i]] = words[word] = i + <span class="number">1</span>; <span class="comment">// distinct non zero</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i == n; <span class="comment">// 检查长度是否相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="291-Locked"><a href="#291-Locked" class="headerlink" title="291 Locked"></a>291 Locked</h2><h2 id="292-Nim-游戏，每个人可以选择丢掉-1，2，3，最后一个操作者获胜"><a href="#292-Nim-游戏，每个人可以选择丢掉-1，2，3，最后一个操作者获胜" class="headerlink" title="292 Nim 游戏，每个人可以选择丢掉 1，2，3，最后一个操作者获胜"></a>292 Nim 游戏，每个人可以选择丢掉 1，2，3，最后一个操作者获胜</h2><p>显然，当我们遇到 4 的时候会输，其他情况都可以赢。</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">canWinNim</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300 最长递增子序列"></a>300 最长递增子序列</h2><p>最经典的动态规划题目</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(*dp)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="344-翻转字符串"><a href="#344-翻转字符串" class="headerlink" title="344 翻转字符串"></a>344 翻转字符串</h2><details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* start = s;</span><br><span class="line">    <span class="type">char</span>* e = s;</span><br><span class="line">    <span class="keyword">while</span> (*e) ++e;</span><br><span class="line">    e--;</span><br><span class="line">    <span class="type">char</span> t;</span><br><span class="line">    <span class="keyword">while</span> (s &lt; e) &#123;</span><br><span class="line">        t = *s;</span><br><span class="line">        *s = *e;</span><br><span class="line">        *e = t;</span><br><span class="line">        s++;</span><br><span class="line">        e--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="347-出现最多的几个数字"><a href="#347-出现最多的几个数字" class="headerlink" title="347 出现最多的几个数字"></a>347 出现最多的几个数字</h2><p>C 实在缺乏相关的基础数据结构，这道题用 JS 做了</p>
<details>
    <summary>JavaScript 解答</summary>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> topKFrequent = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num <span class="keyword">in</span> counter) &#123;</span><br><span class="line">            counter[num]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counter[num] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> bucket = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">in</span> counter) &#123;</span><br><span class="line">        <span class="keyword">let</span> rev_freq = nums.<span class="property">length</span> - counter[num] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rev_freq <span class="keyword">in</span> bucket) &#123;</span><br><span class="line">            bucket[rev_freq].<span class="title function_">push</span>(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bucket[rev_freq] = [num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> rv = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> bc <span class="keyword">of</span> bucket) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! <span class="title class_">Array</span>.<span class="title function_">isArray</span>(bc)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> bc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rv.<span class="property">length</span> == k)</span><br><span class="line">                <span class="keyword">return</span> rv;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rv.<span class="title function_">push</span>(<span class="built_in">parseInt</span>(num))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="349-两个数组中都出现的元素"><a href="#349-两个数组中都出现的元素" class="headerlink" title="349 两个数组中都出现的元素"></a>349 两个数组中都出现的元素</h2><p>先排序，降低复杂度</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)a - *(<span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* <span class="title function_">intersection</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> m, <span class="type">int</span>* B, <span class="type">int</span> n, <span class="type">int</span>* k)</span> &#123;</span><br><span class="line">    qsort(A, m, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line">    qsort(B, n, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line">    <span class="type">int</span>* C = <span class="built_in">malloc</span>((m + n) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == B[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*k == <span class="number">0</span>)</span><br><span class="line">                C[(*k)++] = A[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (C[*k - <span class="number">1</span>] != A[i])</span><br><span class="line">                C[(*k)++] = A[i];</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[i] &lt; B[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<h2 id="345-翻转一个字符串里面的元音字母"><a href="#345-翻转一个字符串里面的元音字母" class="headerlink" title="345 翻转一个字符串里面的元音字母"></a>345 翻转一个字符串里面的元音字母</h2><p>使用两个指针，不过需要注意元音字母包括了大小写</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseVowels</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        vowels = <span class="built_in">set</span>(<span class="string">&quot;AEIOUaeiou&quot;</span>)</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> vowels <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> vowels <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            s[i], s[j] = s[j], s[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="371-两个数之和"><a href="#371-两个数之和" class="headerlink" title="371 两个数之和"></a>371 两个数之和</h2><p>这道题要求不用 + 和 - 来计算出两个数之和，显然应该使用位运算，使用异或计算每一位的值，在使用或计算是否需要进位</p>
<details>
    <summary>C 解答</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> last_bit_of_a = a &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> last_bit_of_b = b &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        rv |= (last_bit_of_a ^ last_bit_of_b ^ carry) &lt;&lt; i;</span><br><span class="line">        carry = (carry &amp; last_bit_of_a) | (carry &amp; last_bit_of_b) | (last_bit_of_a &amp; last_bit_of_b);</span><br><span class="line"></span><br><span class="line">        a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="388"><a href="#388" class="headerlink" title="388"></a>388</h2><p>使用栈的一道简单题目, 其实计算长度部分还可以优化</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthLongestPath</span>(<span class="params">self, <span class="built_in">input</span>: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        path = []</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">input</span>.split(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">            l = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> name:</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">&quot;\t&quot;</span>:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; l:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(path) - l):</span><br><span class="line">                    path.pop()</span><br><span class="line">            path.append(name.strip(<span class="string">&quot;\t&quot;</span>))</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;.&quot;</span> <span class="keyword">in</span> name:</span><br><span class="line">                length = <span class="built_in">sum</span>([<span class="built_in">len</span>(p) <span class="keyword">for</span> p <span class="keyword">in</span> path]) + <span class="built_in">len</span>(path) - <span class="number">1</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, length)</span><br><span class="line">                <span class="built_in">print</span>(path)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435 无重叠区间"></a>435 无重叠区间</h2><p>不要被题目迷惑，从反面开始思考，求去除多少个区间其实就是求最多有多少个有效区间</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eraseOverlapIntervals</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">        max_intervals = <span class="number">0</span></span><br><span class="line">        end = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> interval[<span class="number">0</span>] &gt;= end:</span><br><span class="line">                max_intervals += <span class="number">1</span></span><br><span class="line">                end = interval[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(intervals) - max_intervals</span><br></pre></td></tr></table></figure>
</details>


<h2 id="482-注册码格式化"><a href="#482-注册码格式化" class="headerlink" title="482 注册码格式化"></a>482 注册码格式化</h2><p>要求每 K 个字符添加一个 “-“, 如果不够的话，第一个分组可以不全。</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">licenseKeyFormatting</span>(<span class="params">self, S: <span class="built_in">str</span>, K: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        key = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">reversed</span>(S):</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            key.append(c.upper())</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i % K == <span class="number">0</span>:</span><br><span class="line">                key.append(<span class="string">&quot;-&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">and</span> key[-<span class="number">1</span>] == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">            key = key[:-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="built_in">reversed</span>(key))</span><br></pre></td></tr></table></figure>
</details>


<h2 id="547-朋友圈"><a href="#547-朋友圈" class="headerlink" title="547 朋友圈"></a>547 朋友圈</h2><p>UnionFind 的定义见第 200 题</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findCircleNum</span>(<span class="params">self, M: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(M)</span><br><span class="line">        uf = UnionFind(n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> M[i][j] == <span class="number">1</span>:</span><br><span class="line">                    uf.union(i, j)</span><br><span class="line">        <span class="keyword">return</span> uf.count</span><br></pre></td></tr></table></figure>
</details>


<h2 id="739"><a href="#739" class="headerlink" title="739"></a>739</h2><p>单调栈的简单应用</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, T: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = []</span><br><span class="line">        ans = [<span class="number">0</span>] * <span class="built_in">len</span>(T)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(T)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 如果当前温度大于当前最低温度</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> T[i] &gt;= T[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                ans[i] = stack[-<span class="number">1</span>] - i</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<h2 id="864-矩形重叠"><a href="#864-矩形重叠" class="headerlink" title="864 矩形重叠"></a>864 矩形重叠</h2><details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isRectangleOverlap</span>(<span class="params">self, rec1: <span class="type">List</span>[<span class="built_in">int</span>], rec2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 注意要包含等于号</span></span><br><span class="line">        x_overlap = <span class="keyword">not</span>(rec1[<span class="number">0</span>] &gt;= rec2[<span class="number">2</span>] <span class="keyword">or</span> rec1[<span class="number">2</span>] &lt;= rec2[<span class="number">0</span>])</span><br><span class="line">        y_overlap = <span class="keyword">not</span>(rec1[<span class="number">1</span>] &gt;= rec2[<span class="number">3</span>] <span class="keyword">or</span> rec1[<span class="number">3</span>] &lt;= rec2[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> x_overlap <span class="keyword">and</span> y_overlap</span><br></pre></td></tr></table></figure>
</details>



<h2 id="904-找出包含了两个不同数字的最长子序列"><a href="#904-找出包含了两个不同数字的最长子序列" class="headerlink" title="904 找出包含了两个不同数字的最长子序列"></a>904 找出包含了两个不同数字的最长子序列</h2><p>这道题的题目很坑爹，但是翻译过来其实要求很明确。解题思路也很简单，存储一下当前的最长序列<br>就好了。</p>
<details>
    <summary>C++ 解答</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;Rust 解答&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```Rust</span><br><span class="line">use std::collections::HashMap;</span><br><span class="line">use std::cmp::max;</span><br><span class="line"></span><br><span class="line">impl Solution &#123;</span><br><span class="line">    <span class="function">pub fn <span class="title">total_fruit</span><span class="params">(tree: Vec&lt;i32&gt;)</span> -&gt; i32 </span>&#123;</span><br><span class="line">        let mut i = <span class="number">0</span>;</span><br><span class="line">        let mut res = <span class="number">0</span>;</span><br><span class="line">        let mut counter = HashMap::<span class="built_in">new</span>();</span><br><span class="line">        <span class="keyword">for</span> (j, el) in tree.<span class="built_in">iter</span>().<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">            *counter.<span class="built_in">entry</span>(el).<span class="built_in">or_insert</span>(<span class="number">0</span>) += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> counter.<span class="built_in">len</span>() &gt; <span class="number">2</span> &#123;</span><br><span class="line">                *counter.<span class="built_in">get_mut</span>(&amp;tree[i]).<span class="built_in">unwrap</span>() -= <span class="number">1</span>;</span><br><span class="line">                <span class="function"><span class="keyword">if</span> let <span class="title">Some</span><span class="params">(x)</span> </span>= counter.<span class="built_in">get</span>(&amp;tree[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> *x == <span class="number">0</span> &#123;</span><br><span class="line">                        counter.<span class="built_in">remove</span>(&amp;tree[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res as i32</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="986-区间列表的交集"><a href="#986-区间列表的交集" class="headerlink" title="986 区间列表的交集"></a>986 区间列表的交集</h2><p>tags: #interval</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intervalIntersection</span>(<span class="params">self, A: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], B: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(A) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(B):</span><br><span class="line">            lo = <span class="built_in">max</span>(A[i][<span class="number">0</span>], B[j][<span class="number">0</span>])</span><br><span class="line">            hi = <span class="built_in">min</span>(A[i][<span class="number">1</span>], B[j][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> lo &lt;= hi:</span><br><span class="line">                ans.append((lo, hi))</span><br><span class="line">            <span class="keyword">if</span> A[i][<span class="number">1</span>] &lt; B[j][<span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<h2 id="929-唯一邮件地址"><a href="#929-唯一邮件地址" class="headerlink" title="929 唯一邮件地址"></a>929 唯一邮件地址</h2><p>类似 Gmail 的规则，<code>.</code> 去掉，<code>+</code> 后面的也去掉。但是要注意域名中的 <code>.</code> 不能去掉</p>
<details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">normalize</span>(<span class="params">self, username: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        username = username.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="comment"># 使用 split 更好，懒得改了</span></span><br><span class="line">        username = re.sub(<span class="string">r&quot;\+.*$&quot;</span>, <span class="string">&quot;&quot;</span>, username)</span><br><span class="line">        <span class="keyword">return</span> username</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numUniqueEmails</span>(<span class="params">self, emails: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        unique_emails = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> email <span class="keyword">in</span> emails:</span><br><span class="line">            username, domain = email.split(<span class="string">&quot;@&quot;</span>)</span><br><span class="line">            username = self.normalize(username)</span><br><span class="line">            <span class="comment"># print(username, domain)</span></span><br><span class="line">            unique_emails.add(<span class="string">f&quot;<span class="subst">&#123;username&#125;</span>@<span class="subst">&#123;domain&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(unique_emails)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="970-强力数字"><a href="#970-强力数字" class="headerlink" title="970 强力数字"></a>970 强力数字</h2><p>暴力解法</p>
<details>
    <summary>python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">powerfulIntegers</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span>, bound: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> bound &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = <span class="built_in">set</span>()</span><br><span class="line">        limit = <span class="built_in">int</span>(math.log2(bound)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(limit):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(limit):</span><br><span class="line">                v = x ** i + y ** j</span><br><span class="line">                <span class="keyword">if</span> v &lt;= bound:</span><br><span class="line">                    ans.add(v)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(ans)</span><br></pre></td></tr></table></figure>
</details>


<h2 id="1272-删除区间"><a href="#1272-删除区间" class="headerlink" title="1272 删除区间"></a>1272 删除区间</h2><details>
    <summary>python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeInterval</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], toBeRemoved: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        lo, hi = toBeRemoved</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> y &lt; lo <span class="keyword">or</span> x &gt; hi:</span><br><span class="line">                ans.append([x, y])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> lo &gt; x:</span><br><span class="line">                    ans.append([x, lo])</span><br><span class="line">                <span class="keyword">if</span> hi &lt; y:</span><br><span class="line">                    ans.append([hi, y])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>


<h2 id="1317-将整数转换为两个无零整数的和"><a href="#1317-将整数转换为两个无零整数的和" class="headerlink" title="1317 将整数转换为两个无零整数的和"></a>1317 将整数转换为两个无零整数的和</h2><details>
    <summary>python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNoZeroIntegers</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            b = n - a</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;0&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(a) <span class="keyword">and</span> <span class="string">&quot;0&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(b):</span><br><span class="line">                <span class="keyword">return</span> [a, b]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
</details>


<h2 id="1389-按既定顺序创建目标数组"><a href="#1389-按既定顺序创建目标数组" class="headerlink" title="1389 按既定顺序创建目标数组"></a>1389 按既定顺序创建目标数组</h2><details>
    <summary>Python 解答</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createTargetArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], index: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        target = []</span><br><span class="line">        <span class="keyword">for</span> n, i <span class="keyword">in</span> <span class="built_in">zip</span>(nums, index):</span><br><span class="line">            target = target[:i] + [n] + target[i:]</span><br><span class="line">        <span class="keyword">return</span> target</span><br></pre></td></tr></table></figure>
</details>


<h2 id="1390-四因数"><a href="#1390-四因数" class="headerlink" title="1390 四因数"></a>1390 四因数</h2><p>解释见注释，这道题还是很坑的。不过其实也很简单，四个因数就是能够分解成两个质数乘积或者是立方数。</p>
<p>比如：</p>
<ol>
<li>21 &#x3D; 3 * 7</li>
<li>8 &#x3D; 2 * 4</li>
</ol>
<details>
    <summary>py 解答</summary>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumFourDivisors</span>(<span class="params">self, nums</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            upper = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            upper = <span class="built_in">max</span>(*nums)</span><br><span class="line">        <span class="comment"># 首先在这里筛选素数</span></span><br><span class="line">        isPrim = [<span class="literal">True</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(upper)]</span><br><span class="line">        i = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> i * i &lt; upper:</span><br><span class="line">            <span class="keyword">if</span> isPrim[i]:</span><br><span class="line">                j = i * i</span><br><span class="line">                <span class="keyword">while</span> j &lt; upper:</span><br><span class="line">                    isPrim[j] = <span class="literal">False</span></span><br><span class="line">                    j += i</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 把素数都提取出来</span></span><br><span class="line">        prims = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, upper) <span class="keyword">if</span> isPrim[i]]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> prim <span class="keyword">in</span> prims:</span><br><span class="line">                <span class="comment"># 已经不可能了，后续不算了</span></span><br><span class="line">                <span class="keyword">if</span> prim * prim &gt; num:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 立方数是符合的，这个比较坑，开始没想到，比如 8</span></span><br><span class="line">                <span class="keyword">if</span> prim * prim * prim == num:</span><br><span class="line">                    ans += (<span class="number">1</span> + num + prim + prim * prim)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 可以分解成两个质数乘积</span></span><br><span class="line">                <span class="keyword">if</span> num % prim == <span class="number">0</span> <span class="keyword">and</span> isPrim[num // prim] <span class="keyword">and</span> prim * prim != num:</span><br><span class="line">                    ans += (<span class="number">1</span> + num + prim + num // prim)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>




<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></h6></h6>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ezharjan.github.io/Blog/2022/03/05/Reverse-Interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Alexander Ezharjan">
      <meta itemprop="description" content="This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2022/03/05/Reverse-Interview/" class="post-title-link" itemprop="url">Reverse Interview</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-05 22:34:30" itemprop="dateCreated datePublished" datetime="2022-03-05T22:34:30+08:00">2022-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-17 10:34:44" itemprop="dateModified" datetime="2022-10-17T10:34:44+08:00">2022-10-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Job-Interview/" itemprop="url" rel="index"><span itemprop="name">Job Interview</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h6 align="center">编者：艾孜尔江<h6>


<h1 id="反向面试指南"><a href="#反向面试指南" class="headerlink" title="反向面试指南"></a>反向面试指南</h1><p>下面列表里的问题对于参加技术面试的人来说可能有些用。<br>列表里的问题并不一定适用于某个特定的职位或者工作类型，也没有排序。最开始的时候这只是我自己的问题列表，但是慢慢地添加了一些我觉得可能让我对这家公司亮红牌的问题。<br>我也注意到被我面试的人提问我的问题太少了，感觉他们挺浪费机会的。</p>
<h2 id="预期使用方式"><a href="#预期使用方式" class="headerlink" title="预期使用方式"></a>预期使用方式</h2><ul>
<li>检查一下哪些问题你感兴趣</li>
<li>检查一下哪些是你可以自己在网上找到答案的</li>
<li>找不到的话就向面试官提问</li>
</ul>
<p>绝对不要想把这个列表里的每个问题都问一遍。（尊重面试官的时间，而且你可以通过查找已经发布的答案来显示你的主动性）</p>
<p>请记住事情总是灵活的，组织的结构调整也会经常发生。拥有一个 bug 追踪系统并不会保证高效处理 bug。<br>CI&#x2F;CD （持续集成系统） 也不一定保证交付时间会很短。</p>
<h1 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h1><ul>
<li>On-call （电话值班）的计划或者规定是什么？值班或者遇到问题加班时候有加班费吗？</li>
<li>我的日常工作是什么？</li>
<li>有给我设定的特定目标吗？</li>
<li>团队里面初级和高级工程师的比例是多少？（有计划改变吗）</li>
<li>入职培训 (onboarding) 会是什么样的？</li>
<li>每个开发者有多大的自由来做出决定？</li>
<li>在你看来，这个工作做到什么程度算成功？</li>
<li>你期望我在最初的一个月 &#x2F; 三个月能够完成什么？</li>
<li>试用期结束的时候，你会怎么样衡量我的绩效？</li>
<li>自己单独的开发活动和按部就班工作的比例大概是怎样的？</li>
<li>一个典型的一天或者一周的工作是怎样安排的？</li>
<li>对我的申请你有什么疑虑么？</li>
<li>在这份工作上，我将会和谁紧密合作？</li>
<li>我的直接上级他们的上级都是什么样的管理风格？（事无巨细还是着眼宏观）</li>
<li>我在这个岗位上应该如何发展？会有哪些机会？</li>
<li>每天预期 &#x2F; 核心工作时间是多少小时？</li>
<li>我入职的岗位是新增还是接替之前离职的同事？（是否有技术债需要还）？(zh)</li>
<li>入职之后在哪个项目组，项目是新成立还是已有的？(zh)</li>
</ul>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><ul>
<li>公司常用的技术栈是什么？</li>
<li>你们怎么使用源码控制系统？</li>
<li>你们怎么测试代码？</li>
<li>你们怎么追踪 bug?</li>
<li>你们怎样监控项目？</li>
<li>你们怎么集成和部署代码改动？是使用持续集成和持续部署吗 (CI&#x2F;CD)？</li>
<li>你们的基础设施搭建在版本管理系统里吗？或者是代码化的吗？</li>
<li>从计划到完成一项任务的工作流是什么样的？</li>
<li>你们如何准备故障恢复？</li>
<li>有标准的开发环境吗？是强制的吗？</li>
<li>你们需要花费多长时间来给产品搭建一个本地测试环境？（分钟 &#x2F; 小时 &#x2F; 天）</li>
<li>你们需要花费多长时间来响应代码或者依赖中的安全问题？</li>
<li>所有的开发者都可以使用他们电脑的本地管理员权限吗？</li>
<li>介绍一下你们的技术原则或者展望。</li>
<li>你们的代码有开发文档吗？有没有单独的供消费者阅读的文档？</li>
<li>你们有更高层次的文档吗？比如说 ER 图，数据库范式</li>
<li>你们使用静态代码分析吗？</li>
<li>你们如何管理内部和外部的数字资产？</li>
<li>你们如何管理依赖？</li>
<li>公司是否有技术分享交流活动？有的话，多久一次呢？(zh)</li>
<li>你们的数据库是怎么进行版本控制的？(zh)</li>
<li>业务需求有没有文档记录？是如何记录的？(zh)</li>
</ul>
<h1 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h1><ul>
<li>工作是怎么组织的？</li>
<li>团队内 &#x2F; 团队间的交流通常是怎样的？</li>
<li>你们使用什么工具来做项目组织？你的实际体会是什么？</li>
<li>如果遇到不同的意见怎样处理？</li>
<li>谁来设定优先级 &#x2F; 计划？</li>
<li>如果团队没能赶上预期发布日期怎么办？</li>
<li>每周都会开什么类型的会议？</li>
<li>会有定期的和上级的一对一谈话吗？</li>
<li>产品 &#x2F; 服务的规划是什么样的？（n 周一发布 &#x2F; 持续部署 &#x2F; 多个发布流 &#x2F; …)</li>
<li>生产环境发生事故了怎么办？是否有不批评人而分析问题的文化？</li>
<li>有没有一些团队正在经历还尚待解决的挑战？</li>
<li>你们如何跟踪进度？</li>
<li>预期和目标是如何设定的？谁来设定？</li>
<li>Code Review 如何实施？</li>
<li>给我介绍下团队里一个典型的 sprint</li>
<li>你们如何平衡技术和商业目标？</li>
<li>你们如何共享知识？</li>
<li>团队有多大？</li>
<li>公司技术团队的架构和人员组成？(zh)</li>
<li>团队内开发、产品、运营哪一方是需求的主要提出方？哪一方更强势？(zh)</li>
</ul>
<h1 id="问未来的同事"><a href="#问未来的同事" class="headerlink" title="问未来的同事"></a>问未来的同事</h1><ul>
<li>开发者倾向于从哪里学习？</li>
<li>你对在这里工作最满意的地方是？</li>
<li>最不满意的呢？</li>
<li>如果可以的话，你想改变哪里？</li>
<li>团队最老的成员在这里多久了？</li>
<li>在小团队中，有没有出现成员性格互相冲突的情况？最后是如何解决的？</li>
</ul>
<h1 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h1><ul>
<li>公司为什么在招人？（产品发展 &#x2F; 新产品 &#x2F; 波动…)</li>
<li>有没有会议 &#x2F; 旅行预算？使用的规定是什么？</li>
<li>晋升流程是怎样的？要求 &#x2F; 预期是怎样沟通的？</li>
<li>绩效评估流程是怎样的？</li>
<li>技术和管理两条职业路径是分开的吗？</li>
<li>对于多元化招聘的现状或者观点是什么？</li>
<li>有公司级别的学习资源吗？比如电子书订阅或者在线课程？</li>
<li>有获取证书的预算吗？</li>
<li>公司的成熟度如何？（早期寻找方向 &#x2F; 有内容的工作 &#x2F; 维护中 &#x2F; …)</li>
<li>我可以为开源项目做贡献吗？是否需要审批？</li>
<li>你认为公司未来五年或者十年会发展成什么样子？</li>
<li>公司的大多数员工是如何看待整洁代码的？</li>
<li>你上次注意到有人成长是什么时候？他们在哪方面成长了？</li>
<li>在这里成功的定义是什么？如何衡量成功？</li>
<li>有体育活动或者团建么？</li>
<li>有内部的黑客马拉松活动吗？</li>
<li>公司支持开源项目吗？</li>
<li>有竞业限制或者保密协议需要签吗？</li>
<li>你们认为公司文化中的空白是什么？</li>
<li>能够跟我说一公司处于不良情况，以及如何处理的故事吗？</li>
<li>您在这工作了多久了？您觉得体验如何？(zh)</li>
<li>大家为什么会喜欢这里？(zh)</li>
<li>公司的调薪制度是如何的？(zh)</li>
</ul>
<h1 id="社会问题"><a href="#社会问题" class="headerlink" title="社会问题"></a>社会问题</h1><ul>
<li>你们关于多元化招聘什么看法？</li>
<li>你们的公司文化如何？你认为有什么空白么？</li>
<li>这里的工作生活平衡地怎么样？</li>
<li>公司对气候变化有什么态度吗？</li>
</ul>
<h1 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h1><ul>
<li>不同的意见如何处理？</li>
<li>如果被退回了会怎样？（“这个在预计的时间内做不完”）</li>
<li>当团队有压力并且在超负荷工作的时候怎么处理？</li>
<li>如果有人注意到了在流程或者技术等其他方面又改进的地方，怎么办？</li>
<li>当管理层的预期和工程师的绩效之间有差距的时候如何处理？</li>
<li>能给我讲一个公司深处有毒环境以及如何处理的故事吗？</li>
<li>如果在公司内你的同事因涉嫌性侵犯他人而被调查，请问你会如何处理？</li>
<li>假设我自己很不幸是在公司内被性侵的受害者，在公司内部有没有争取合法权益的渠道？</li>
</ul>
<h1 id="商业"><a href="#商业" class="headerlink" title="商业"></a>商业</h1><ul>
<li>你们现在盈利吗？</li>
<li>如果没有的话，还需要多久？</li>
<li>公司的资金来源是什么？谁影响或者制定高层计划或方向？</li>
<li>你们如何挣钱？</li>
<li>什么阻止了你们挣更多的钱？</li>
<li>公司未来一年的增长计划怎样？五年呢？</li>
<li>你们认为什么是你们的竞争优势？</li>
<li>你们的竞争优势是什么？</li>
<li>公司未来的商业规划是怎样的？有上市的计划吗？(zh)</li>
</ul>
<h1 id="远程工作"><a href="#远程工作" class="headerlink" title="远程工作"></a>远程工作</h1><ul>
<li>远程工作和办公室工作的比例是多少？</li>
<li>公司提供硬件吗？更新计划如何？</li>
<li>使用自己的硬件办公可以吗？现在有政策吗？</li>
<li>额外的附件和家具可以通过公司购买吗？这方面是否有预算？</li>
<li>有共享办公或者上网的预算吗？</li>
<li>多久需要去一次办公室？</li>
<li>公司的会议室是否一直是视频会议就绪的？</li>
</ul>
<h1 id="办公室布局"><a href="#办公室布局" class="headerlink" title="办公室布局"></a>办公室布局</h1><ul>
<li>办公室的布局如何？（开放的 &#x2F; 小隔间 &#x2F; 独立办公室）</li>
<li>有没有支持 &#x2F; 市场 &#x2F; 或者其他需要大量打电话的团队在我的团队旁边办公？</li>
</ul>
<h1 id="终极问题"><a href="#终极问题" class="headerlink" title="终极问题"></a>终极问题</h1><ul>
<li>该职位为何会空缺？</li>
<li>公司如何保证人才不流失？</li>
<li>这份工作 &#x2F; 团队 &#x2F; 公司最好和最坏的方面是？</li>
<li>你最开始为什么选择了这家公司？</li>
<li>你为什么留在这家公司？</li>
</ul>
<h1 id="待遇"><a href="#待遇" class="headerlink" title="待遇"></a>待遇</h1><ul>
<li>如果有奖金计划的话，奖金如何分配？</li>
<li>如果有奖金计划的话，过去的几年里通常会发百分之多少的奖金？</li>
<li>有五险一金(zh)&#x2F;401k(us)或者其他退休养老金等福利吗？</li>
<li>五险一金中，补充公积金一般交多少比例？&#x2F;401k一般交多少比例？我可以自己选择这一比例吗？</li>
<li>有什么医疗保险吗？如果有的话何时开始？</li>
<li>有额外商业保险吗？例如人寿保险和额外的养老&#x2F;医疗保险？</li>
<li>更换工作地点，公司付费吗？</li>
</ul>
<h1 id="休假"><a href="#休假" class="headerlink" title="休假"></a>休假</h1><ul>
<li>带薪休假时间有多久？</li>
<li>病假和事假是分开的还是一起算？</li>
<li>我可以提前使用假期时间吗？也就是说应休假期是负的？</li>
<li>假期的更新策略是什么样的？也就是说未休的假期能否滚入下一周期</li>
<li>照顾小孩的政策如何？</li>
<li>无薪休假政策是什么样的？</li>
<li>学术性休假政策是怎么样的？</li>
</ul>
<h1 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h1><p>Find more inspiration for questions in:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/">The Joel Test: 12 Steps to Better Code</a> by Joel Spolsky</li>
<li><a target="_blank" rel="noopener" href="https://jvns.ca/blog/2013/12/30/questions-im-asking-in-interviews/">Questions I’m asking in interviews</a> by Julia Evans</li>
</ul>
<br>
<br>
<br>
<br>
<br>

<hr>
<br>

<h1 id="Reverse-interview"><a href="#Reverse-interview" class="headerlink" title="Reverse interview"></a>Reverse interview</h1><p>This is a list of questions which may be interesting to a tech job applicant.<br>The points are not ordered and many may not apply to a given position, or work type.<br>It was started as my personal list of questions, which grew over time to include both things I’d like to see more of and red flags which I’d like to avoid.<br>I’ve also noticed how few questions were asked by people I interviewed and I think those were missed opportunities.</p>
<h2 id="Expected-usage"><a href="#Expected-usage" class="headerlink" title="Expected usage"></a>Expected usage</h2><ul>
<li>Check which questions are interesting for you specifically</li>
<li>Check which answers you can find yourself online</li>
<li>Otherwise ask</li>
</ul>
<p>Definitely don’t try to ask everything from the list. (Respect the interviewer’s time and show initiative by finding answers on your own if they’re already published)</p>
<p>Remember that things tend to be fluid, re-organizations happens often.<br>Having a bug tracking system doesn’t make bug handling efficient and CI&#x2F;CD doesn’t mean your time to deliver is necessarily short.</p>
<h1 id="The-Role"><a href="#The-Role" class="headerlink" title="The Role"></a>The Role</h1><ul>
<li>What’s the on-call plan&#x2F;schedule? (what’s the pay for standby and call-out)</li>
<li>What are the tasks I would do on a usual day?</li>
<li>Are there any specific goals for me?</li>
<li>What’s the junior&#x2F;senior balance of the team? (and are there plans to change it)</li>
<li>What does the onboarding look like?</li>
<li>How much freedom for decision making do individual developers have?</li>
<li>What are the expected&#x2F;core work hours?</li>
<li>What is your definition of success for this role?</li>
<li>What do you expect me to accomplish in the first 1 month&#x2F;3 months?</li>
<li>How will you evaluate my performance at the end of the trial period?</li>
<li>What does a typical day&#x2F;week look like in this role?</li>
<li>Do you have any concerns about my application?</li>
<li>Tell me about who I would be working most closely with.</li>
<li>What management style does my immediate manager and their manager have? (from micro- to macro-)</li>
<li>How can I develop in my new role &#x2F; what opportunities are offered?</li>
</ul>
<h1 id="Tech"><a href="#Tech" class="headerlink" title="Tech"></a>Tech</h1><ul>
<li>What are the usual stacks used at the company?</li>
<li>How do you use source control?</li>
<li>How do you test code?</li>
<li>How do you track bugs?</li>
<li>How do you monitor projects?</li>
<li>How do you integrate and deploy changes? Is it CI&#x2F;CD?</li>
<li>Is your infrastructure setup under version control &#x2F; available as code?</li>
<li>What’s the workflow from the planning to the finished task?</li>
<li>How do you prepare for disaster recovery?</li>
<li>Is there a standardised development environment? Is it enforced?</li>
<li>How quickly can you setup a new local test environment for the product? (minutes &#x2F; hours &#x2F; days)</li>
<li>How quickly can you respond to security issues in the code or dependencies?</li>
<li>Are all developers allowed to have local admin access of their computers?</li>
<li>Tell me about your technical principles or vision.</li>
<li>Do you have a developer documentation for your code? Do you have a separate documentation for customers?</li>
<li>Do you have some higher level documentation? (ER diagrams, database schema)</li>
<li>Do you employ static code analysis?</li>
<li>How do you manage internal &#x2F; external artifacts?</li>
<li>How do you manage dependencies?</li>
</ul>
<h1 id="The-Team"><a href="#The-Team" class="headerlink" title="The Team"></a>The Team</h1><ul>
<li>How is the work organised?</li>
<li>How does the intra&#x2F;inter-team communication typically work?</li>
<li>Do you use any tools for project organization? What is your experience with them?</li>
<li>How are differences of opinions resolved?</li>
<li>Who sets the priorities &#x2F; schedule?</li>
<li>What happens after pushback? (“this can’t be done in the projected time”)</li>
<li>What happens when the team misses a release target?</li>
<li>What kind of meetings happen every week?</li>
<li>Would there be a regular 1-on-1 with my manager?</li>
<li>What’s the product&#x2F;service schedule? (n-weekly releases &#x2F; continuous deployment &#x2F; multiple release streams &#x2F; …)</li>
<li>What happens after production incidents? Is there a culture of blameless analysis?</li>
<li>What are some ongoing challenges the team is experiencing that you are yet to resolve?</li>
<li>How do you track progress?</li>
<li>How are expectations and goals set, and who does the setting?</li>
<li>What does a code review look like here?</li>
<li>Walk me through a typical sprint on this team</li>
<li>How do you balance technical vs business goals?</li>
<li>How do you share knowledge?</li>
<li>How big are the teams?</li>
</ul>
<h1 id="Your-Potential-Coworkers"><a href="#Your-Potential-Coworkers" class="headerlink" title="Your Potential Coworkers"></a>Your Potential Coworkers</h1><ul>
<li>Who do developers tend to learn from?</li>
<li>What do you like best about working there?</li>
<li>What do you like least?</li>
<li>What would you change if you could?</li>
<li>How long has the longest team member been there?</li>
<li>If it’s a small team, has there been experiences of conflicting personalities and how was this dealt with?</li>
</ul>
<h1 id="The-Company"><a href="#The-Company" class="headerlink" title="The Company"></a>The Company</h1><ul>
<li>Why is the company hiring? (product growth &#x2F; new product &#x2F; fluctuation &#x2F; …)</li>
<li>Is there a conference&#x2F;travel budget and what are the rules to use it?</li>
<li>What’s the promotion process? How are requirements &#x2F; expectations communicated?</li>
<li>What is the performance review process like?</li>
<li>Is there a separate tech and management career path?</li>
<li>Are there any company-wide resources for learning available, like ebooks subscriptions, or online courses?</li>
<li>Is there a budget for getting certifications?</li>
<li>What’s the maturity stage? (early finding direction &#x2F; feature work &#x2F; maintenance &#x2F; …)</li>
<li>Can I contribute to FOSS projects? Are there any approvals needed?</li>
<li>Are there any non-compete or non-disclosure agreements I’ll be asked to sign?</li>
<li>Where do you see the company in the next 5&#x2F;10 years? </li>
<li>What does clean code mean to the majority of developers here?</li>
<li>When is the last time you noticed someone growing here, and in what way were they growing?</li>
<li>What does it mean to be successful here, and how do you measure success?</li>
<li>Is there a Sports &#x2F; Team building Activity?</li>
<li>Are there any Hackathons conducted internally?</li>
<li>Does the company support open-source projects?</li>
<li>What kind of social events does the team&#x2F;company host and are these attended by everyone?</li>
<li>Why did the company decide to hire an outsider over promoting an internal employee?</li>
</ul>
<h1 id="Social-issues"><a href="#Social-issues" class="headerlink" title="Social issues"></a>Social issues</h1><ul>
<li>What’s the status of &#x2F; view on diverse hiring?</li>
<li>What do you think are the gaps in the company culture? (and what is the company culture?)</li>
<li>What does work-life balance mean here?</li>
<li>Does the company have a stance regarding climate change?</li>
</ul>
<h1 id="Conflict"><a href="#Conflict" class="headerlink" title="Conflict"></a>Conflict</h1><ul>
<li>How are differences of opinions resolved?</li>
<li>What happens after pushback? (“this can’t be done in the projected time”)</li>
<li>What happens when the team is under pressure and commits to work over their capacity &#x2F; velocity?</li>
<li>If someone identifies areas of improvement in process &#x2F; technology &#x2F; etc, what happens?</li>
<li>When there is a gap between expectations from management and performance of an engineer or team, what happens?</li>
<li>Could you tell me a story about a toxic situation and how the company dealt with it?</li>
</ul>
<h1 id="The-Business"><a href="#The-Business" class="headerlink" title="The Business"></a>The Business</h1><ul>
<li>Are you profitable?</li>
<li>If not, how long is your runway?</li>
<li>Where does the funding come from and who influences the high level plan&#x2F;direction?</li>
<li>How do you make money?</li>
<li>What’s preventing you from making more money?</li>
<li>What is the company’s growth plan for the next 1 year? 5 years?</li>
<li>What are the big challenges you see coming up?</li>
<li>What have you identified as your competitive advantage?</li>
</ul>
<h1 id="Remote-Work"><a href="#Remote-Work" class="headerlink" title="Remote Work"></a>Remote Work</h1><ul>
<li>What’s the ratio of remote to office workers?</li>
<li>Does the company provide hardware and what’s the refresh schedule?</li>
<li>How do you feel about <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bring_your_own_device">BYOD</a>? Are there any policies around it already?</li>
<li>Are extra accessories&#x2F;furniture possible to buy through the company? Is there a budget for them?</li>
<li>Is there a budget for co-working space or internet access?</li>
<li>How often are office visits expected?</li>
<li>Are the office meeting rooms always prepared for video conferences?</li>
</ul>
<h1 id="Building-Layout"><a href="#Building-Layout" class="headerlink" title="Building Layout"></a>Building Layout</h1><ul>
<li>What’s the office layout? (open plan &#x2F; cubicles &#x2F; offices)</li>
<li>Is there a support &#x2F; marketing &#x2F; other call-heavy team close to my new team?</li>
</ul>
<h1 id="Catch-all"><a href="#Catch-all" class="headerlink" title="Catch all"></a>Catch all</h1><ul>
<li>What’s the best and what’s the worst aspect of working in this role &#x2F; team &#x2F; company?</li>
<li>What got you to choose to work for the company initially?</li>
<li>What keeps you at the company?</li>
</ul>
<h1 id="Compensation"><a href="#Compensation" class="headerlink" title="Compensation"></a>Compensation</h1><ul>
<li>If you have a bonus scheme, then how are bonuses determined?</li>
<li>If you have a bonus scheme, then what have been the typical bonus percentages over the past few years?</li>
<li>Do you have a 401k or other retirement plan? If so, does the company match additional plan contributions?</li>
<li>Are there medical benefits and if so, when do they start?</li>
<li>Do you pay for relocation?</li>
</ul>
<h1 id="Time-Off"><a href="#Time-Off" class="headerlink" title="Time Off"></a>Time Off</h1><ul>
<li>How much Paid Time Off (PTO) is offered?</li>
<li>Are sick time and vacation time separate or do they come from the same pool?</li>
<li>Can I use vacation time before it’s accrued, effectively going into a negative PTO balance?</li>
<li>What is the roll over policy is there for PTO?</li>
<li>What is the parental leave policy?</li>
<li>What is the policy on unpaid leave?</li>
<li>What is the policy for sabbatical leave?</li>
</ul>
<h1 id="Other-resources"><a href="#Other-resources" class="headerlink" title="Other resources"></a>Other resources</h1><p>Find more inspiration for questions in:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/">The Joel Test: 12 Steps to Better Code</a> by Joel Spolsky</li>
<li><a target="_blank" rel="noopener" href="https://jvns.ca/blog/2013/12/30/questions-im-asking-in-interviews/">Questions I’m asking in interviews</a> by Julia Evans</li>
</ul>
<h1 id="License"><a href="#License" class="headerlink" title="License"></a>License</h1><p><a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" alt="Creative Commons License"></a></p>
<p>This work is licensed under a <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a target="_blank" rel="noopener" href="https://github.com/viraptor/reverse-interview">中文翻译来源</a></p>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></h6></h6>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ezharjan.github.io/Blog/2022/02/13/Test-Asset-Folder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="Alexander Ezharjan">
      <meta itemprop="description" content="This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2022/02/13/Test-Asset-Folder/" class="post-title-link" itemprop="url">Test Asset Folder</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-13 13:52:43" itemprop="dateCreated datePublished" datetime="2022-02-13T13:52:43+08:00">2022-02-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-17 10:34:44" itemprop="dateModified" datetime="2022-10-17T10:34:44+08:00">2022-10-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/Hexo-Intro/" itemprop="url" rel="index"><span itemprop="name">Hexo Intro</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Asset-Folder-Test"><a href="#Asset-Folder-Test" class="headerlink" title="Asset Folder Test"></a>Asset Folder Test</h1><h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><p>The image is placed in the folder with the same name as this document.<br><br></p>
<h4 id="1-Revise-the-code-in-hexo-asset-image-index-js-to-the-code-below"><a href="#1-Revise-the-code-in-hexo-asset-image-index-js-to-the-code-below" class="headerlink" title="1. Revise the code in hexo-asset-image/index.js to the code below:"></a>1. Revise the code in <code>hexo-asset-image/index.js</code> to the code below:</h4><p><em>Pay attention to the codes on 59 line.</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPosition</span>(<span class="params">str, m, i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">split</span>(m, i).<span class="title function_">join</span>(m).<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.<span class="property">config</span>;</span><br><span class="line">  <span class="keyword">if</span>(config.<span class="property">post_asset_folder</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> link = data.<span class="property">permalink</span>;</span><br><span class="line">    <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> appendLink = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">    <span class="comment">// if not with index.html endpos = link.lastIndexOf(&#x27;.&#x27;) + 1 support hexo-abbrlink</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/.*\/index\.html$/</span>.<span class="title function_">test</span>(link)) &#123;</span><br><span class="line">      <span class="comment">// when permalink is end with index.html, for example 2019/02/20/xxtitle/index.html</span></span><br><span class="line">      <span class="comment">// image in xxtitle/ will go to xxtitle/index/</span></span><br><span class="line">      appendLink = <span class="string">&#x27;index/&#x27;</span>;</span><br><span class="line">      <span class="keyword">var</span> endPos = link.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> endPos = link.<span class="property">length</span>-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    link = link.<span class="title function_">substring</span>(beginPos, endPos) + <span class="string">&#x27;/&#x27;</span> + appendLink;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.<span class="title function_">load</span>(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">          <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">          <span class="keyword">var</span> src = $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">          <span class="keyword">if</span>(!(<span class="regexp">/http[s]*.*|\/\/.*/</span>.<span class="title function_">test</span>(src)</span><br><span class="line">            || <span class="regexp">/^\s+\//</span>.<span class="title function_">test</span>(src)</span><br><span class="line">            || <span class="regexp">/^\s*\/uploads|images\//</span>.<span class="title function_">test</span>(src))) &#123;</span><br><span class="line">            <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">            <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">            <span class="keyword">var</span> linkArray = link.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">var</span> srcArray = src.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span>(srcArray.<span class="property">length</span> &gt; <span class="number">1</span>)</span><br><span class="line">            srcArray.<span class="title function_">shift</span>();</span><br><span class="line">            src = srcArray.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// $(this).attr(&#x27;src&#x27;, config.root + link + src); // original code</span></span><br><span class="line">            <span class="comment">// console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span></span><br><span class="line">            $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, data.<span class="property">permalink</span> + src); <span class="comment">// new code</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;update link as:--&gt;&quot;</span> + data.<span class="property">permalink</span> + src);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">          <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>($(<span class="variable language_">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.<span class="title function_">html</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-Place-the-image-you-are-gonna-use-in-your-MD-file-to-the-folder-the-same-as-your-MD-file"><a href="#2-Place-the-image-you-are-gonna-use-in-your-MD-file-to-the-folder-the-same-as-your-MD-file" class="headerlink" title="2. Place the image you are gonna use in your MD file to the folder the same as your MD file."></a>2. Place the image you are gonna use in your MD file to the folder the same as your MD file.</h4><br>

<h4 id="3-Directly-use-the-image-in-your-note-in-MD-file-like-below"><a href="#3-Directly-use-the-image-in-your-note-in-MD-file-like-below" class="headerlink" title="3. Directly use the image in your note in MD file like below."></a>3. Directly use the image in your note in MD file like below.</h4><p><img src="https://ezharjan.github.io/Blog/2022/02/13/Test-Asset-Folder/camel.jpg" alt="Local Image Test"></p>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/Blog/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/Blog/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Alexander Ezharjan</p>
  <div class="site-description" itemprop="description">This blog is maintained by Alexander Ezharjan, in order to record some useful things in life.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/Blog/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/Blog/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alexander Ezharjan</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/Blog/lib/anime.min.js"></script>
  <script src="/Blog/lib/velocity/velocity.min.js"></script>
  <script src="/Blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/Blog/js/utils.js"></script>

<script src="/Blog/js/motion.js"></script>


<script src="/Blog/js/schemes/muse.js"></script>


<script src="/Blog/js/next-boot.js"></script>




  




  
<script src="/Blog/js/local-search.js"></script>













  

  

</body>
</html>
